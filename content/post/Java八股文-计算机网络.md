---
title: "Java八股文 - 计算机网络"
date: 2023-01-25 13:44:16
categories: ["Java八股文"]
tags: ["计算机网络"]
url: computer-network

################################目录################################
toc: true
autoCollapseToc: false
################################公式渲染################################
mathjax: false

################################基本不动################################
# lastmod: {{ .Date }}
draft: false
# keywords: []
# description: ""
# tags: []
author: "Yaxing"

comment: false
postMetaInFooter: false
hiddenFromHomePage: true
contentCopyright: true
---

> 整理的计算机网络相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～	<!--more-->

## 深入理解HTTPS工作原理

> https://juejin.cn/post/6844903830916694030

### 前言

近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的 HTTP 协议，在逐渐的被 HTTPS 协议所取代，在浏览器、搜索引擎、CA 机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS 加密时代”，HTTPS 将在未来的几年内全面取代 HTTP 成为传输协议的主流。

读完本文，希望你能明白：

- HTTP 通信存在什么问题
- HTTPS 如何改进 HTTP 存在那些问题
- HTTPS 工作原理是什么

### 一、什么是HTTPS

HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。

HTTPS 主要作用是：

（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;

（2）对网站服务器进行真实身份认证。

我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用`http://`，而是改用`https://`。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。

### 二、为什么需要HTTPS

在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP 协议存在的哪些问题：

- 通信使用明文（不加密），内容可能被**窃听** 

	信息加密：使用非对称加密（RSA）交换密钥，使用对称加密（AES）传输报文，兼备安全与效率

- 无法证明报文的完整性，所以可能遭**篡改** 

	完整性校验：数字签名

- 不验证通信方的身份，因此有可能遭遇**伪装** 

	身份验证：数字证书

### 三、HTTPS如何解决HTTP上述问题?

**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132445345.png" alt="image-20220422132445345" style="zoom:33%;" />



在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、完整性校验、身份验证这些功能。也就是说**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132508534.png" alt="image-20220422132508534" style="zoom:33%;" />

HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，**其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性**。

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132525551.png" alt="image-20220422132525551" style="zoom:33%;" />



#### 1.解决内容可能被窃听的问题——加密

#### 方法1.对称加密

这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。

以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。

#### 方法2.非对称加密

公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。

使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132541737.png" alt="image-20220422132541737" style="zoom:33%;" />

非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。

这种方式有以下缺点：

- 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；
- 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；
- 使用非对称加密**在数据加密解密过程需要消耗一定时间**，降低了数据传输效率；

#### 方法3.对称加密+非对称加密(HTTPS采用这种方式)

使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。

具体做法是：**发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。

#### 2.解决报文可能遭篡改问题——数字签名

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。

**数字签名有两种功效**：

- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。
- 数字签名能确定消息的完整性,证明数据是否未被篡改过。

**数字签名如何生成:**

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132605229.png" alt="image-20220422132605229" style="zoom:33%;" />

将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。

**校验数字签名流程**：

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132617982.png" alt="image-20220422132617982" style="zoom:33%;" />

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

假设消息传递在 Kobe，James 两人之间发生。James 将消息连同数字签名一起发送给 Kobe，Kobe 接收到消息后，通过校验数字签名，就可以验证接收到的消息就是 James 发送的。当然，这个过程的前提是 Kobe 知道 James 的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Kobe,或者说拿到的公钥如何证明是 James 的。

此时就需要引入了**证书颁发机构**（Certificate Authority，简称 CA），CA 数量并不多，Kobe 客户端内置了所有受信任 CA 的证书。CA 对 James 的公钥（和其他信息）数字签名后生成证书。

#### 3.解决通信方身份可能被伪装的问题——数字证书

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。

我们来介绍一下数字证书认证机构的业务流程：

- 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;
- CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;
- 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;
- 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;
- 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
- 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。

### 四、 HTTPS工作流程

<img src="https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132710862.png" alt="image-20220422132710862" style="zoom:80%;" />

1.Client 发起一个 HTTPS（比如`https://juejin.cn/user/4283353031252967`）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。

2.Server 把事先配置好的公钥证书（public key certificate）返回给客户端。

3.Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。

4.Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。

5.Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。

6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。

7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。

8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。

### 五、HTTP 与 HTTPS 的区别

- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

- HTTPS 比 HTTP 更加安全;
- HTTPS 需要用到 SSL 证书，而 HTTP 不用;
- HTTPS 标准端口 443，HTTP 标准端口 80;
- HTTPS 基于传输层，HTTP 基于应用层;
- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示;

### 六、为何不所有的网站都使用HTTPS

既然 HTTPS 那么安全可靠，那为何不所有的 Web 网站都使用 HTTPS？

首先，很多人还是会觉得 HTTPS 实施有门槛，这个门槛在于需要权威 CA 颁发的 SSL 证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。

其次，HTTPS 普遍认为性能消耗要大于 HTTP，因为**与纯文本通信相比，加密通信会消耗更多的CPU及内存资源**。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。

除此之外，**想要节约购买证书的开销也是原因之一**。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。

最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS 部署趋势是由社会、企业、政府共同去推动的。

## 计算机网络体系结构

### 什么是网络编程

网络编程的本质是多台计算机之间的数据交换。现在的网络编程基本上都是基于请求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻响应连接，则需要一直启动。

### 网络编程中两个主要的问题

**1、**一个是如何准确的定位网络上一台或多台主机，

**2、**另一个就是找到主机后如何可靠高效的进行数据传输。

- 在 TCP/IP 协议中 IP 层网际层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。
- 而 TCP 层传输层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。

### 网络协议是什么

在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。

### 为什么要对网络协议分层

**1、**简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。

**2、**灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。

**3、**易于实现和维护。

**4、**促进标准化工作。分开后，每层功能可以相对简单地被描述

### 体系结构

**TCP/IP参考模型**

OSI 七层协议：应用（HTTP）、表示（SSL/TLS）、会话（RPC）、传输（TCP）、网络（IP）、链路（ARP）、物理

TCP/IP 四层协议（数据链路层、网络层、传输层、应用层）

**1、**应用层 **为用户提供各种网络服务**。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET 等。（HTTP 协议全称 Hyper Text Transfer Protocol 超文本传输协议，在浏览器与服务器间传送文档）

**2、**传输层 **建立了主机端到端的连接**，传输层的作用是**为上层协议提供端到端的可靠和透明的数据传输服务**，包括处理差错控制和流量控制等问题。（TCP、UDP）

**3、**网络层 **通过IP寻址来建立两个节点之间的连接**，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。（IP）

**4、**数据链路层 **通过一些规则来控制这些数据的传输**，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路。

### 什么是TCP和UDP

|          | TCP                              | UDP                                    |
| -------- | -------------------------------- | -------------------------------------- |
| 面向连接 | 面向连接                         | 无连接                                 |
| 可靠性   | 可靠传输，使用拥塞控制和流量控制 | 可靠传输                               |
| 连接个数 | 只能一对一通信                   | 支持一对一、一对多、多对一、多对多通信 |
| 使用场景 | 要求可靠传输的应用（文件传输）   | 实时应用（视频会议、网络直播）         |

### 浏览器中输入：网址后都发生了什么？请详细阐述。

**1、**域名解析，域名→IP 地址，解析过程依次经过了浏览器本地缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。

**2、**建立 TCP/IP 连接（三次握手具体过程）

**3、**由浏览器发送一个 HTTP 请求

**4、**经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器

**5、**服务器处理该 HTTP 请求，返回一个 HTML 文件

**6、**浏览器解析该 HTML 文件，并且显示在浏览器端

![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640.webp)

### TCP 协议如何来保证传输的可靠性

**对于可靠性，TCP通过以下方式进行保证：**

> 接收方对数据包进行检查，是否**失序**，失序的话要重排序，是否**重复**，重复的话将重复的数据丢弃，是否**出错**，出错的话将该报文段丢弃。否则的话，接收方会给发送方一个发送一个确认。发送方发送之后如果没有收到这个确认在一定时间后会重发这个报文段。

- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；
- **对失序数据包重排序**：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；
- **丢弃重复数据**：对于重复数据，能够丢弃重复数据；
- **应答机制**：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- **超时重发**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。
	TCP 使用的流量控制协议是**可变大小的滑动窗口协议**。

### TCP 的拥塞避免机制

https://www.cnblogs.com/hongdada/p/11206679.html

拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。

拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。

拥塞控制的方法：

**1、 慢开始 + 拥塞避免：**

![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718131944933-703202720.png)

**慢开始**：拥塞窗口从 1、2、4 以指数规律增长；

**拥塞避免**：到达慢开始阈值后，开始拥塞避免“加法增大”

**2、快重传 + 快恢复：**
![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718132020300-1269239957.png)

**快重传**： **快重传要求接收方在收到一个失序的报文段后就立即发出 重复确认 **（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定， **发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段**，而不必继续等待设置的重传计时器时间到期。

**快恢复**：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行**“乘法减小”算法，把 ssthresh 门限减半**，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将拥塞窗口设置为慢开始阈值的大小，**然后执行拥塞避免算法让拥塞窗口线性加1**。

### 什么是Http协议？

- Http 协议属于应用层，是在浏览器与服务器间传送文档的规范，简称为“超文本传输协议”

![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210326001352.png)

### 说说HTTP常用的状态码及其含义？

![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518889206.webp)

不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义：

![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518894201.webp)



### Http和Https的区别？

Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：

- 端口不同：Http 与 Https 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；
- 资源消耗：和 HTTP 通信相比，Https 通信会由于加密解密处理消耗更多的 CPU 和内存资源；
- 开销：Https 通信需要证书，而证书一般需要向认证机构购买；

Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

### 什么是http的请求体？

**1、**HTTP 请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器拿数据，先要表明我要什么吧

**2、**HTTP 请求体由：**请求行、请求头、请求体** 组成的

> 请求行：请求方法（POST）、URL（character/use.html） 和 HTTP 协议版本（HTTP/1.1）
>
> 请求头：
>
> * User-Agent：发送请求的浏览器类型;
> * Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ */* ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型;
> * Accept-Language：客户端可接受的自然语言;
> * Accept-Encoding：客户端可接受的编码格式;
> * Accept-Charset：可接受的应答的字符集;
> * Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;
> * Connection：连接方式(close 或 keepalive);
> * Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;

**3、**注意：GET 请求是没有请求体的

### HTTP的响应报文有哪些？

**1、**http 的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文

**2、**响应报文包含三部分 **状态行、响应头、响应体**

### Http中常见的header字段有哪些？

cookie，请求时传递给服务端的 cookie 信息 
set-cookie，响应报文首部设置要传递给客户端的 cookie 信息 
allow，支持什么 HTTP 方法 
last-modified，资源的最后修改时间 
expires,设置资源缓存的失败日期 
content-language，实体的资源语言 
content-encoding，实体的编码格式 
content-length，实体主体部分的大小单位是字节 
content-range，返回的实体的哪些范围 
content-type，哪些类型 
accept-ranges，处理的范围请求 
age，告诉客户端服务器在多久前创建了响应 
vary，代理服务器的缓存信息 
location，用于指定重定向后的 URI 
If-Match，值是资源的唯一标识 
User-Agent，将创建请求的浏览器和用户代理名称等信息传递给服务器 
Transfer-Encoding，传输报文的主体编码方式 
connection，管理持久连接 keep-alive , close Cache-Control，控制浏览器的强缓存

### HTTPS工作原理

（AES：非对称加密；RSA：对称加密）

**1、**首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA 加密）等进行校验；

**2、**客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA 加密）；

**3、**消息体产生之后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名；

**4、**发送给服务端，此时只有服务端（RSA 私钥）能解密。

**5、**解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。

### ⭐为什么 TCP 链接需要三次握手，两次不可以么？

“三次握手” 的目的是为了防止**已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

- 正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。
- 假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求（因为那个是已经失效的请求），因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。

### ⭐为什么要四次挥手？

TCP 是全双工模式，这就意味着，
当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；当 B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。

所以想要愉快的结束这次对话就需要四次挥手。

### ⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

MSL（Maximum Segment Lifetime）**报文最大寿命**，TCP 允许不同的实现可以设置不同的 MSL 值。

第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
————————————————
原文链接：https://blog.csdn.net/qzcsu/article/details/72861891

### ⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP 还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个**探测报文段**，以后每隔 75 秒发送一次。若**一连发送10个探测报文仍然没反应**，服务器就认为客户端出了故障，接着就**关闭连接**。
————————————————
原文链接：https://blog.csdn.net/qzcsu/article/details/72861891

### IP地址是怎样分类的，你知道吗？

先说一下 IP 的基本特点：

- IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。
- IP 地址由两部分组成，即**网络地址**和**主机地址**。
	网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。

IP 地址根据网络地址进行分类，主要分为 A、B、C 三类及特殊地址 D、E 这五类

**A类：** (1.0.0.0-126.0.0.0)一般用于大型网络。

**B类：** (128.0.0.0-191.255.0.0)一般用于中等规模网络。

**C类：** (192.0.0.0-223.255.255.0)一般用于小型网络。

**D类：** 是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。

**E类：** 是保留地址。地址的网络号取值于 240~255 之间。

### 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

**(1) DDos 攻击：**

- 客户端向服务端发送请求链接数据包
- 服务端向客户端发送确认数据包
- 客户端却不向服务端发送确认数据包，服务器**一直等待**来自客户端的确认

**(2) DDos 预防：（没有彻底根治的办法，除非不使用TCP）**

- 限制同时打开 SYN 半链接的数目
- 缩短 SYN 半链接的 Time out 时间
- 关闭不必要的服务

### GET 与 POST 的区别？

GET 与 POST 是我们常用的两种 HTTP Method，二者之间的区别主要包括如下五个方面：

**1、** 从功能上讲，GET 一般用来**从服务器上获取资源**，POST 一般用来**更新服务器上的资源**；

**2、**从请求参数形式上看，GET请求的数据会**附在URL上**，以?分割 URL 和传输数据，参数之间以&相连；而 POST 请求会把提交的数据则放置在 HTTP 请求报文的 **请求体** 中。

**3、**就安全性而言，POST的**安全性**要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全。

**4、**从请求的大小看，GET请求的**长度**受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。

### DNS的寻址过程你知道吗？

浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。

### 什么是Socket

**1、**网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。

**2、**但是，Socket 所支持的协议种类也不光 TCP/IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。

**3、**socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的

**4、**Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多，

### Socket属于网络的那个层面

![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210325212441.png)

Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

### Socket通讯的过程

**基于TCP：**

服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。

**基于UDP：**

UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管

### Socket和http的区别和应用场景

**1、**Socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；

**2、**Socket 适用场景：网络游戏，银行持续交互，直播，在线视屏等。

**3、**http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接

**4、**http 适用场景：公司 OA 服务，互联网服务，电商，办公，网站等等等等

### 什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?

HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。服务器无法判断用户身份。

HTTP 的这种特性有优点也有缺点：

- **优点**：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用
- **缺点**：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享

解决方案：

1. 使用参数传递机制：
	将参数拼接在请求的 URL 后面，实现数据的传递（GET 方式），例如：`/param/list?username=wmyskxz`
	**问题**：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有 1kb
2. 使用 Cookie 技术
3. 使用 Session 技术

Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。

### 什么是Cookie

Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie，而客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器，服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。 

### 什么是Session

session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 session。

服务器默认为客户浏览器的 cookie 中设置 sessionid，这个 sessionid 就和 cookie 对应，浏览器在向服务器请求过程中传输的 cookie 包含 sessionid ，服务器根据传输 cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。

### Cookie和Session对于HTTP有什么用？

 HTTP 协议本身是无法判断用户身份。所以需要 cookie 或者 session

### Cookie与Session区别

- **实现机制**：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；
- **大小限制**：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；
- **安全性**：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；
- **服务器资源消耗**：Session 是一定时间内保存在服务器端上，如果 session 过多会增加服务器的压力。

### 什么是Token

Token 的引入：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。

Token 的定义：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。

使用 Token 的目的：Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token **证明自己的合法地位**

### session与token区别

- session 存储在服务器端，token 存储在客户端
- token 提供认证和授权功能，作为身份认证，token 安全性比 session 好；
- ⭐session 这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token 适用于项目级的前后端分离（前后端代码运行在不同的服务器下）

### 常用的HTTP方法有哪些？

- **GET：**用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器
- **POST：**用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。
- **PUT：**传输文件，报文主体中包含文件内容，保存到对应 URI 位置。
- **HEAD：**获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。
- **DELETE：**删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。
- **OPTIONS：**查询相应 URI 支持的 HTTP 方法。

### 网络层的 ARP 协议工作原理？

网络层的 ARP 协议完成了 IP 地址与物理地址的映射

### IP地址与物理地址

物理地址是数据链路层和物理层使用的地址，IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，其中 ARP 协议用于 IP 地址与物理地址的对应。

### 影响网络传输的因素有哪些？

将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。

1、网络带宽
2、传输距离
3、TCP 拥塞控制

### 什是对称加密与非对称加密

对称密钥加密是指**加密和解密使用同一个密钥**的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

而非对称加密是指使用**一对非对称密钥，即公钥和私钥**，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢

### HTTPS采用对称加密+非对称加密

使用对称加密，优点是加密解密速度快，缺点是不安全；
使用非对称加密，优点是保证安全性，缺点是速度慢；

Https 结合两种加密方式的优点，
在**交换密钥环节**使用非对称加密方式，之后的**建立通信交换报文**阶段则使用对称加密方式。

## TCP/IP 协议族

### 应用层

应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。

### 传输层

传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。

运输层主要使用一下两种协议

1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

|              | UDP                                        | TCP                                    |
| ------------ | ------------------------------------------ | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 场景         | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**

运行在`TCP协议`上的协议：

- `HTTP（Hypertext Transfer Protocol，超文本传输协议）`，主要用于普通浏览。
- `HTTPS（HTTP over SSL，安全超文本传输协议）`,`HTTP`协议的安全版本。
- `FTP（File Transfer Protocol，文件传输协议）`，用于文件传输。
- `POP3（Post Office Protocol, version 3，邮局协议）`，收邮件用。
- `SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）`，用来发送电子邮件。
- `TELNET（Teletype over the Network，网络电传）`，通过一个`终端（terminal）`登陆到网络。
- `SSH（Secure Shell，用于替代安全性差的TELNET）`，用于加密安全登陆用。

运行在`UDP协议`上的协议：

- `DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）`，动态配置 IP 地址。

运行在`TCP`和`UDP`协议上：

- `DNS（Domain Name Service，域名服务）`，用于完成地址查找，邮件转发等工作。

### 网络层

网络层的任务就是**选择合适的网间路由和交换结点，确保计算机通信的数据及时传送**。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。

### 数据链路层

数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。

在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。

一般的 web 应用的通信传输流是这样的：

![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzkvMTZhOWM5Y2Q1MjNlMDU5OQ.png)

发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。

### 物理层

在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

### TCP/IP 协议族

在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。

![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS80LzcvMTY5ZjY5NjZjMjRhZjM0NQ.png)



TCP（传输控制协议）和 IP（网际协议）是**最先定义的两个核心协议**，所以才统称为 TCP/IP 协议族

## TCP的三次握手四次挥手

TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。

一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。**通过三次握手建立一个链接，通过四次挥手来关闭一个连接**。

**当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据**。

### TCP报文的头部结构

有几个字段需要重点介绍下：

（1）序号：seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。

（2）确认序号：ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。

（3）标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：

- ACK：确认序号有效。
- FIN：释放一个连接。
- PSH：接收方应该尽快将这个报文交给应用层。
- RST：重置连接。
- SYN：发起一个新连接。
- URG：紧急指针（urgent pointer）有效。

需要注意的是：

- 不要将确认序号 ack 与标志位中的 ACK 搞混了。
- 确认方 ack=发起方 seq+1，两端配对。

### 三次握手

> 三次握手的本质是确认通信双方收发数据的能力

A->B

A 发送给 B，B 若收到

> 说明B知道：A可以发，B可以收

B 返回给 A，A 若收到：说明 A 之前发给 B 的 B 收到了，同时 B 也能给自己回信，自己能收到这个回信。

> 说明：A知道：A能发能收，B能收能发

但是此时 B 不知道 A 是否可以收，B 是否发送正常

于是 A 发送给 B，B 若收到：说明 B 的发送回信 A 能收到

> 说明：B 知道 A 可以收，B 可以发，结合第一步，得到 B 也知道 A 能发能收，B 能收能发

![三次握手](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA.png)

### 四次挥手

> 四次挥手的目的是关闭一个连接

![四次挥手](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw.png)

A 和 B 打电话，通话即将结束后，
A 说“我没啥要说的了”，
B 回答“我知道了”，
但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，
A 回答“知道了”，这样通话才算结束。
