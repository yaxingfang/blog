{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/imgs/alipay.jpg","path":"imgs/alipay.jpg","modified":1,"renderable":0},{"_id":"source/imgs/wechat.jpg","path":"imgs/wechat.jpg","modified":1,"renderable":0},{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/wechat.jpg","path":"img/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"65f144aaafaa028db795d82d98f5ec098e9113a1","modified":1673961684803},{"_id":"source/about/.DS_Store","hash":"34fe290bc8d934cf4c51deea76c7ec16f3cf4d2f","modified":1673929875866},{"_id":"source/about/index.md","hash":"35fd2deabb9fb305739d73ad4628a2be3403304a","modified":1673946754499},{"_id":"source/categories/index.md","hash":"34befbcc0cb1361fe6ab629e0efcb19c0ee86647","modified":1673929754157},{"_id":"source/categories/.DS_Store","hash":"34fe290bc8d934cf4c51deea76c7ec16f3cf4d2f","modified":1671761650651},{"_id":"source/_posts/12张图回忆我的2022.md","hash":"2fa277b175c35bd4f4adfab1cef458731ebf9d6a","modified":1673919281080},{"_id":"source/_posts/.DS_Store","hash":"c9de02b28f9c45b6545d14f99988ecc16682a5b8","modified":1674426324937},{"_id":"source/_posts/Java八股文 - Java基础.md","hash":"7277fe8148e862b835a2ad15af65f9df11a34b2d","modified":1674463579750},{"_id":"source/_posts/Java八股文 - Java异常.md","hash":"a5ed1a7995cbbc7a79c83a72f7b28b81a3bde17b","modified":1674463588846},{"_id":"source/_posts/Java八股文 - Java集合.md","hash":"fcef603cf39c920cffd7b75e99ff19da36182458","modified":1674463608897},{"_id":"source/_posts/2022实习总结.md","hash":"a7dfc6e236d32a00ac9ad1780b233c010ffc6ec8","modified":1673919096271},{"_id":"source/_posts/Java八股文 - MyBatis.md","hash":"16333af5accc98f33efaf9e65760cba4cae7b8b4","modified":1674463632143},{"_id":"source/_posts/2022秋招总结.md","hash":"fb66d0c72c1e3051feda71c3acdc141c628eefca","modified":1673919154053},{"_id":"source/_posts/Java八股文 - Spring.md","hash":"04b1ce216eaee399a16daf7d90384c741a992fea","modified":1674463635868},{"_id":"source/_posts/Java八股文 - SpringMVC.md","hash":"f911d9cef568a5682d27eb42db4bff7f4b3d8989","modified":1674463642666},{"_id":"source/_posts/字节暑期实习同组实习生秋招情况分享.md","hash":"48232ce118c80b150e88f47341a1e0d3da65bd9a","modified":1673919235150},{"_id":"source/_posts/Typora配置阿里云OSS图床.md","hash":"925a467c76b79bfb3d658a7c8ce79a0548d1d108","modified":1673921367111},{"_id":"source/_posts/回老家的一周.md","hash":"479d7dfd0f78087f92e4bb96e1cdf4f849ecbe55","modified":1673919260538},{"_id":"source/_posts/新买的小书桌.md","hash":"ce557f4dc51c0d7c1c7188b4bec4697f8f7a8402","modified":1673919384834},{"_id":"source/_posts/开了个B站大会员.md","hash":"4e0f99778887d0f244479017e8d892757ad6e036","modified":1673919249679},{"_id":"source/_posts/手把手带你搭建个人博客.md","hash":"84652e02091ae84983566fac5df4f4a17bdac8c0","modified":1673957565141},{"_id":"source/_posts/新年快乐！.md","hash":"a1d29f9cabd7a9f2d2a87c29c455c56726ff2487","modified":1674463160578},{"_id":"source/_posts/江苏省考考完啦.md","hash":"8d9e78d8a31b9d77d0e392278914c72784b05468","modified":1673919255047},{"_id":"source/tags/index.md","hash":"95d08ed3da8f867aaab215ddace25b88fbf1a14f","modified":1673931830273},{"_id":"source/_posts/最近关于校招、互联网的一些信息.md","hash":"4983eeafd9e929c0b0776972d17e035fa20f907f","modified":1673919286943},{"_id":"source/imgs/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1671703105000},{"_id":"source/_posts/Java八股文 - Java并发.md","hash":"391cf571efa361ff709b4d3b90d9dd16f55d0747","modified":1674463629147},{"_id":"source/imgs/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1671703075000},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406353},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406360},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406364},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406372},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406368},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406219},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406321},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406290},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406335},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406346},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1673879406442},{"_id":"themes/icarus/package.json","hash":"9d42eb99acdaf56afbda664adea40d8d80cdb0b0","modified":1673879406412},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1673879406385},{"_id":"themes/icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1673879406442},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1673879406375},{"_id":"themes/icarus/include/dependency.js","hash":"0ca35dec92ccf383f45db905db1a5a0e92d7209e","modified":1673879406388},{"_id":"themes/icarus/.DS_Store","hash":"5b559435f1621224e3831be57a6c74f226edc1f8","modified":1674354255289},{"_id":"themes/icarus/include/register.js","hash":"ec6596b63bfb4349ba61792d905abe8e06fea625","modified":1673879406395},{"_id":"themes/icarus/include/.DS_Store","hash":"201de63d0ec04970108d6af3d91e0bdae872026a","modified":1674354226964},{"_id":"themes/icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1673879406471},{"_id":"themes/icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1673879406471},{"_id":"themes/icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1673879406470},{"_id":"themes/icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1673879406472},{"_id":"themes/icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1673879406473},{"_id":"themes/icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1673879406474},{"_id":"themes/icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1673879406474},{"_id":"themes/icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1673879406474},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1673879406475},{"_id":"themes/icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1673879406476},{"_id":"themes/icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1673879406478},{"_id":"themes/icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1673879406477},{"_id":"themes/icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1673879406477},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1673879406479},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1673879406479},{"_id":"themes/icarus/layout/archive.jsx","hash":"99bf235042d0c57af15d2f108ba5eda77443fea8","modified":1673879406424},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1673879406427},{"_id":"themes/icarus/layout/.DS_Store","hash":"282592d5239b152794d0c05ad8384bd7de1b9dec","modified":1674355043735},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1673879406427},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1673879406432},{"_id":"themes/icarus/layout/layout.jsx","hash":"a7ba430119c32bcb39a85ec0f8fa2c199b38e4c4","modified":1673962797554},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1673879406433},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1673879406440},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1673879406435},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1673879406440},{"_id":"themes/icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1673879406390},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1673879406391},{"_id":"themes/icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1673879406398},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1673879406396},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1673879406396},{"_id":"themes/icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1673879406397},{"_id":"themes/icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1673879406448},{"_id":"themes/icarus/include/schema/config.json","hash":"b949c52d02d5ee520ae4666a016ce91faf6fb350","modified":1673879406409},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1673879406448},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1673879406449},{"_id":"themes/icarus/source/.DS_Store","hash":"fa38fb826dec66318c0a571326ecc579c1e0e4d1","modified":1673962237963},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1673879406449},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1673879406450},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1673879406454},{"_id":"themes/icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1673879406455},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1673919825476},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1673879406453},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1673879406456},{"_id":"themes/icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1673879406456},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1673879406457},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1673879406466},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1673879406457},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1673879406387},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1673879406467},{"_id":"themes/icarus/layout/common/article.jsx","hash":"efe38d9c10d6421f142407651b6230e257a57451","modified":1674357530930},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1673879406428},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1673963514188},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1673879406430},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1673879406435},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1673879406433},{"_id":"themes/icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1673879406431},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"4816c9099a881b5f7b13af3e42caae36edbffccd","modified":1673879406438},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1673879406439},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"45f869e8cab0eb00827164a927156a30e1d29bb7","modified":1673962836208},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1673879406440},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1673879406422},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1673879406426},{"_id":"themes/icarus/include/schema/.DS_Store","hash":"0c99a902830c52fa5cf73bb54a4028ce3da36077","modified":1674354250279},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1673879406437},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1673879406465},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1673879406452},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1673879406467},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1673879406452},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1673879406444},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1673879406468},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1673879406447},{"_id":"themes/icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1673879406378},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1673879406469},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1673879406379},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1673879406469},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1673879406380},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1673879406405},{"_id":"themes/icarus/source/js/main.js","hash":"ef8a0e5c80dc9cb02423fe18b142e17f99f8e9cb","modified":1674356784330},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"f49270b619f5d2c3decde6b0b5a0c3bbab4b54a5","modified":1673879406407},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1673879406409},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1673879406410},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1673879406411},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1673879406411},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1673879406414},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1673879406417},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1673879406417},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1673879406418},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1673879406419},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1673879406419},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1673879406401},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1673879406407},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1673879406416},{"_id":"themes/icarus/source/img/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1673963549028},{"_id":"themes/icarus/source/img/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1673963549027},{"_id":"public/baidusitemap.xml","hash":"f9f4b53609f914465aeb6124c49f15d4910a8333","modified":1674463674151},{"_id":"public/atom.xml","hash":"04054cbfbee2a190ef5facad940f218434e45235","modified":1674463674151},{"_id":"public/search.xml","hash":"c8720ac25c217615ee1a7066665bdfd5b1fc6e01","modified":1674463674151},{"_id":"public/sitemap.xml","hash":"e646edc4caac355ef93c877f5fc4399a11e6874c","modified":1674463674151},{"_id":"public/sitemap.txt","hash":"2bad3305af03c2a3bb08f8c66324c139cb5745cb","modified":1674463674151},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1674463674151},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1674463674151},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1674463674151},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1674463674151},{"_id":"public/content.json","hash":"7599f1cd53128cfadd353dff8a20263fc1d28c6a","modified":1674463674151},{"_id":"public/manifest.json","hash":"4a4efab11b9e9d2f34509cad49a130e06418fb6f","modified":1674463674151},{"_id":"public/about/index.html","hash":"4eca95c33e3a566fd4f1ad0e26a9147d5f4669ba","modified":1674463674151},{"_id":"public/categories/index.html","hash":"60dfe06f1a0a1f25025dbecadfa793dc2413ede3","modified":1674463674151},{"_id":"public/tags/index.html","hash":"9357d5b64144cc805b435bd6bed3f2e17b2bf342","modified":1674463674151},{"_id":"public/2023-happy-spring-festival.html","hash":"ceef991b278c8033e25cf34e5090e9ce26ea3874","modified":1674463674151},{"_id":"public/archives/index.html","hash":"43c5abdc1e1e398c416f49eb868858eac4ec3c24","modified":1674463674151},{"_id":"public/archives/page/2/index.html","hash":"f284606e00dcdcd14fc2ecfe932978b711ff690f","modified":1674463674151},{"_id":"public/archives/2022/index.html","hash":"ea2622d721bb6e975a4dad0deac43d33c0fd85ea","modified":1674463674151},{"_id":"public/archives/2022/12/index.html","hash":"d962b497aad4a519e81b1f51a421a81459cb8f6e","modified":1674463674151},{"_id":"public/archives/2023/index.html","hash":"69d0e0ca16d3fad41abcb25abe854dbbad8f5dfb","modified":1674463674151},{"_id":"public/archives/2023/01/index.html","hash":"a33e046f1eae7404b2dab84298e0283dec9b78b0","modified":1674463674151},{"_id":"public/categories/实习秋招/index.html","hash":"3b88ceaf1819967bca19cdb27d3410e0ed304019","modified":1674463674151},{"_id":"public/categories/实习秋招/实习/index.html","hash":"27635707db96bd7130ca4a01c908d34d5a224517","modified":1674463674151},{"_id":"public/categories/实习秋招/秋招/index.html","hash":"5bbc1e89c2f48983953ccf353226ffe4d0a6afde","modified":1674463674151},{"_id":"public/categories/技术总结/index.html","hash":"438d6fe52a2a04db23ee81b2e97d6d75f7eb06c6","modified":1674463674151},{"_id":"public/java-springmvc.html","hash":"95b53364ffeeed81794bd4e29a38b857a4161ec3","modified":1674463674151},{"_id":"public/java-spring.html","hash":"d131587061f71b4910042b7e492d3c1471d00592","modified":1674463674151},{"_id":"public/java-mybatis.html","hash":"eb3191c0be1fe0d1e0d05282b695d24d8aee2c94","modified":1674463674151},{"_id":"public/java-concurrent-programming.html","hash":"59de760218bbbba1cdcb3f5de452fa342d872ddb","modified":1674463674151},{"_id":"public/java-collection.html","hash":"568e20d02de1b8d19cadcf20ffcf425388b1275b","modified":1674463674151},{"_id":"public/java-exception-error.html","hash":"e44c232a4c3b90af4a3b2f55c5880f042fba73f0","modified":1674463674151},{"_id":"public/java-basic-knowledge.html","hash":"b8231c1cd9c1682fda2a113934b3d6579d7d104b","modified":1674463674151},{"_id":"public/202301-it-info.html","hash":"bc1a9d495886611f84eda87702617ab5b91b8a83","modified":1674463674151},{"_id":"public/2022-memory.html","hash":"bb13c9d0888baa93dbd9cc7ffe7f359586e31297","modified":1674463674151},{"_id":"public/week-back-home.html","hash":"0a22d4ffde3bc7f859b9aebd016695975db3b67d","modified":1674463674151},{"_id":"public/2022-jiangsu-gwy.html","hash":"b2067df469f7287ed796127f22a629a373b9f7ad","modified":1674463674151},{"_id":"public/bilibili-vip.html","hash":"59a4a4d86452c645cea5558cfe102ee748f23739","modified":1674463674151},{"_id":"public/new-desk.html","hash":"8cd6c532e11d56273515e9901731406ecc92637b","modified":1674463674151},{"_id":"public/my-bytedance-internship-friends-offer.html","hash":"67fa0572cb5705bae7725903e055e24d516b1aa0","modified":1674463674151},{"_id":"public/image-host.html","hash":"0cb997f881b2c6c442378b78604159cc813b4b40","modified":1674463674151},{"_id":"public/build-blog.html","hash":"0c8262d28b9789e9230e16b72d22c659105226f8","modified":1674463674151},{"_id":"public/2022-autumn-recruitment-summary.html","hash":"182985808deeddf8d2bef4f4aa3cf4e2fd97ade6","modified":1674463674151},{"_id":"public/2022-internship-summary.html","hash":"da56fe9eab07fcf302bfa322f8d2513b03579839","modified":1674463674151},{"_id":"public/categories/日常小记/index.html","hash":"531859e576dee1df948aa3b4842e8a6b76487b68","modified":1674463674151},{"_id":"public/categories/Java八股文/index.html","hash":"68615a3c4e597d95da0950cf6736226027163b39","modified":1674463674151},{"_id":"public/index.html","hash":"e5f996efce69e7a2c01e1971c4d7124621800912","modified":1674463674151},{"_id":"public/page/2/index.html","hash":"752f01ba804558b4c178fa00abfa94409cce3819","modified":1674463674151},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1674463674151},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1674463674151},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1674463674151},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1674463674151},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1674463674151},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1674463674151},{"_id":"public/imgs/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1674463674151},{"_id":"public/imgs/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1674463674151},{"_id":"public/img/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1674463674151},{"_id":"public/img/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1674463674151},{"_id":"public/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1674463674151},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1674463674151},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1674463674151},{"_id":"public/js/main.js","hash":"ef8a0e5c80dc9cb02423fe18b142e17f99f8e9cb","modified":1674463674151},{"_id":"public/css/cyberpunk.css","hash":"b462177bee11f76e84e649f8192d5a68cb4b1402","modified":1674463674151},{"_id":"public/css/default.css","hash":"8717dd0ed1fe2a4237fbfb4f4f6e566cb1ee16b7","modified":1674463674151},{"_id":"public/css/style.css","hash":"8717dd0ed1fe2a4237fbfb4f4f6e566cb1ee16b7","modified":1674463674151}],"Category":[{"name":"日常小记","_id":"cld8kfsip0004zvt86uh15bd8"},{"name":"实习秋招","_id":"cld8kfsit0009zvt8ds7207xq"},{"name":"Java八股文","_id":"cld8kfsix000gzvt8cfljb67j"},{"name":"实习","parent":"cld8kfsit0009zvt8ds7207xq","_id":"cld8kfsj1000szvt8a3k007f2"},{"name":"秋招","parent":"cld8kfsit0009zvt8ds7207xq","_id":"cld8kfsj40015zvt86m8cez11"},{"name":"技术总结","_id":"cld8kfsj5001czvt86tcq7jot"}],"Data":[],"Page":[{"_content":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n🔭 本科：苏州大学纳米科学与技术学院，纳米物理方向；硕士：苏州大学计算机科学与技术学院，计算机技术。\n\n🌱 在字节跳动实习过4个月，担任飞书 EA-finance - 后端开发一职，秋招拿到了字节跳动、上海银行、高中信息技术老师等offer。\n\n⚡ 编程语言熟悉Java、Python，数据库熟悉MySQL、Redis，框架熟悉Spring全家桶，常用工具熟悉Git、Maven、Linux……\n\n❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 yaxingfang@163.com\n","source":"about/index.md","raw":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n🔭 本科：苏州大学纳米科学与技术学院，纳米物理方向；硕士：苏州大学计算机科学与技术学院，计算机技术。\n\n🌱 在字节跳动实习过4个月，担任飞书 EA-finance - 后端开发一职，秋招拿到了字节跳动、上海银行、高中信息技术老师等offer。\n\n⚡ 编程语言熟悉Java、Python，数据库熟悉MySQL、Redis，框架熟悉Spring全家桶，常用工具熟悉Git、Maven、Linux……\n\n❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 yaxingfang@163.com\n","date":"2023-01-17T12:00:04.997Z","updated":"2023-01-17T09:12:34.499Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cld8kfsih0000zvt8hnb867qa","content":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n<p>🔭 本科：苏州大学纳米科学与技术学院，纳米物理方向；硕士：苏州大学计算机科学与技术学院，计算机技术。</p>\n<p>🌱 在字节跳动实习过4个月，担任飞书 EA-finance - 后端开发一职，秋招拿到了字节跳动、上海银行、高中信息技术老师等offer。</p>\n<p>⚡ 编程语言熟悉Java、Python，数据库熟悉MySQL、Redis，框架熟悉Spring全家桶，常用工具熟悉Git、Maven、Linux……</p>\n<p>❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 <a href=\"mailto:&#121;&#97;&#x78;&#105;&#x6e;&#x67;&#x66;&#97;&#x6e;&#x67;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;\">&#121;&#97;&#x78;&#105;&#x6e;&#x67;&#x66;&#97;&#x6e;&#x67;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"length":324,"excerpt":"","more":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n<p>🔭 本科：苏州大学纳米科学与技术学院，纳米物理方向；硕士：苏州大学计算机科学与技术学院，计算机技术。</p>\n<p>🌱 在字节跳动实习过4个月，担任飞书 EA-finance - 后端开发一职，秋招拿到了字节跳动、上海银行、高中信息技术老师等offer。</p>\n<p>⚡ 编程语言熟悉Java、Python，数据库熟悉MySQL、Redis，框架熟悉Spring全家桶，常用工具熟悉Git、Maven、Linux……</p>\n<p>❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 <a href=\"mailto:&#121;&#97;&#x78;&#105;&#x6e;&#x67;&#x66;&#97;&#x6e;&#x67;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;\">&#121;&#97;&#x78;&#105;&#x6e;&#x67;&#x66;&#97;&#x6e;&#x67;&#x40;&#49;&#54;&#x33;&#x2e;&#x63;&#x6f;&#109;</a></p>\n"},{"title":"Categories","type":"categories","date":"2022-12-12T02:27:11.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ntype: \"categories\"\ndate: 2022-12-12 10:27:11\n---\n","updated":"2023-01-17T04:29:14.157Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cld8kfsin0002zvt88c1s5gab","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n\n","date":"2023-01-17T05:03:50.281Z","updated":"2023-01-17T05:03:50.273Z","path":"tags/index.html","comments":1,"_id":"cld8kfsiq0005zvt85d7vfg2h","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"12张图回忆我的2022","copyright":true,"mathjax":true,"date":"2023-01-01T12:59:55.000Z","urlname":"2022-memory","_content":"\n2022年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的2022留个回忆。\n\n<!--more-->\n\n### 1月\n\n这张照片我记得是一月份的某一天，和lbh去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。\n\n![1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG)\n\n### 2月\n\n2月的第一天就是大年初一过新年，早上早起在家门口放爆竹。\n\n![2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg)\n\n### 3月\n\n3月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。\n\n![3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG)\n\n### 4月\n\n4月收到字节跳动的实习offer啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。\n\n![4](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg)\n\n### 5月\n\n5月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。\n\n![2205](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg)\n\n### 6月\n\n这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。\n\n![6](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG)\n\n### 7月\n\n7月和高中老同学一起约了个饭，逛了逛西湖，7月的荷花开的很茂盛，西湖旁全是人。\n\n![7](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG)\n\n### 8月\n\n8月离职前瞅了一眼代码量，如下是4个月的成果，感觉还可以，没有很水。\n\n![8](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg)\n\n### 9月\n\n9月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。\n\n![9](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG)\n\n### 10月\n\n10月去参加了表弟的婚礼，4个伴郎+新郎的自拍，小帅。\n\n![10](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG)\n\n### 11月\n\n宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。\n\n![11](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG)\n\n### 12月\n\n回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。\n\n![12](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg)\n","source":"_posts/12张图回忆我的2022.md","raw":"---\ntitle: 12张图回忆我的2022\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2023-01-01 20:59:55\nurlname: 2022-memory\n---\n\n2022年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的2022留个回忆。\n\n<!--more-->\n\n### 1月\n\n这张照片我记得是一月份的某一天，和lbh去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。\n\n![1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG)\n\n### 2月\n\n2月的第一天就是大年初一过新年，早上早起在家门口放爆竹。\n\n![2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg)\n\n### 3月\n\n3月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。\n\n![3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG)\n\n### 4月\n\n4月收到字节跳动的实习offer啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。\n\n![4](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg)\n\n### 5月\n\n5月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。\n\n![2205](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg)\n\n### 6月\n\n这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。\n\n![6](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG)\n\n### 7月\n\n7月和高中老同学一起约了个饭，逛了逛西湖，7月的荷花开的很茂盛，西湖旁全是人。\n\n![7](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG)\n\n### 8月\n\n8月离职前瞅了一眼代码量，如下是4个月的成果，感觉还可以，没有很水。\n\n![8](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg)\n\n### 9月\n\n9月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。\n\n![9](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG)\n\n### 10月\n\n10月去参加了表弟的婚礼，4个伴郎+新郎的自拍，小帅。\n\n![10](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG)\n\n### 11月\n\n宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。\n\n![11](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG)\n\n### 12月\n\n回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。\n\n![12](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg)\n","slug":"12张图回忆我的2022","published":1,"updated":"2023-01-17T01:34:41.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsik0001zvt8co8o6kyx","content":"<p>2022年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的2022留个回忆。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1月\"><a href=\"#1月\" class=\"headerlink\" title=\"1月\"></a>1月</h3><p>这张照片我记得是一月份的某一天，和lbh去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG\" alt=\"1\"></p>\n<h3 id=\"2月\"><a href=\"#2月\" class=\"headerlink\" title=\"2月\"></a>2月</h3><p>2月的第一天就是大年初一过新年，早上早起在家门口放爆竹。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h3 id=\"3月\"><a href=\"#3月\" class=\"headerlink\" title=\"3月\"></a>3月</h3><p>3月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG\" alt=\"3\"></p>\n<h3 id=\"4月\"><a href=\"#4月\" class=\"headerlink\" title=\"4月\"></a>4月</h3><p>4月收到字节跳动的实习offer啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg\" alt=\"4\"></p>\n<h3 id=\"5月\"><a href=\"#5月\" class=\"headerlink\" title=\"5月\"></a>5月</h3><p>5月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg\" alt=\"2205\"></p>\n<h3 id=\"6月\"><a href=\"#6月\" class=\"headerlink\" title=\"6月\"></a>6月</h3><p>这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG\" alt=\"6\"></p>\n<h3 id=\"7月\"><a href=\"#7月\" class=\"headerlink\" title=\"7月\"></a>7月</h3><p>7月和高中老同学一起约了个饭，逛了逛西湖，7月的荷花开的很茂盛，西湖旁全是人。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG\" alt=\"7\"></p>\n<h3 id=\"8月\"><a href=\"#8月\" class=\"headerlink\" title=\"8月\"></a>8月</h3><p>8月离职前瞅了一眼代码量，如下是4个月的成果，感觉还可以，没有很水。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg\" alt=\"8\"></p>\n<h3 id=\"9月\"><a href=\"#9月\" class=\"headerlink\" title=\"9月\"></a>9月</h3><p>9月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG\" alt=\"9\"></p>\n<h3 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h3><p>10月去参加了表弟的婚礼，4个伴郎+新郎的自拍，小帅。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG\" alt=\"10\"></p>\n<h3 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h3><p>宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG\" alt=\"11\"></p>\n<h3 id=\"12月\"><a href=\"#12月\" class=\"headerlink\" title=\"12月\"></a>12月</h3><p>回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg\" alt=\"12\"></p>\n","site":{"data":{}},"length":530,"excerpt":"<p>2022年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的2022留个回忆。</p>","more":"<h3 id=\"1月\"><a href=\"#1月\" class=\"headerlink\" title=\"1月\"></a>1月</h3><p>这张照片我记得是一月份的某一天，和lbh去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG\" alt=\"1\"></p>\n<h3 id=\"2月\"><a href=\"#2月\" class=\"headerlink\" title=\"2月\"></a>2月</h3><p>2月的第一天就是大年初一过新年，早上早起在家门口放爆竹。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h3 id=\"3月\"><a href=\"#3月\" class=\"headerlink\" title=\"3月\"></a>3月</h3><p>3月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG\" alt=\"3\"></p>\n<h3 id=\"4月\"><a href=\"#4月\" class=\"headerlink\" title=\"4月\"></a>4月</h3><p>4月收到字节跳动的实习offer啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg\" alt=\"4\"></p>\n<h3 id=\"5月\"><a href=\"#5月\" class=\"headerlink\" title=\"5月\"></a>5月</h3><p>5月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg\" alt=\"2205\"></p>\n<h3 id=\"6月\"><a href=\"#6月\" class=\"headerlink\" title=\"6月\"></a>6月</h3><p>这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG\" alt=\"6\"></p>\n<h3 id=\"7月\"><a href=\"#7月\" class=\"headerlink\" title=\"7月\"></a>7月</h3><p>7月和高中老同学一起约了个饭，逛了逛西湖，7月的荷花开的很茂盛，西湖旁全是人。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG\" alt=\"7\"></p>\n<h3 id=\"8月\"><a href=\"#8月\" class=\"headerlink\" title=\"8月\"></a>8月</h3><p>8月离职前瞅了一眼代码量，如下是4个月的成果，感觉还可以，没有很水。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg\" alt=\"8\"></p>\n<h3 id=\"9月\"><a href=\"#9月\" class=\"headerlink\" title=\"9月\"></a>9月</h3><p>9月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG\" alt=\"9\"></p>\n<h3 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h3><p>10月去参加了表弟的婚礼，4个伴郎+新郎的自拍，小帅。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG\" alt=\"10\"></p>\n<h3 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h3><p>宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG\" alt=\"11\"></p>\n<h3 id=\"12月\"><a href=\"#12月\" class=\"headerlink\" title=\"12月\"></a>12月</h3><p>回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg\" alt=\"12\"></p>"},{"title":"2022实习总结","date":"2022-12-12T02:40:27.000Z","urlname":"2022-internship-summary","description":null,"copyright":true,"mathjax":true,"_content":"\n> 写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，\"毕业季\"，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。\n\n<!-- more -->\n\n## 已面试\n\n### 微软\n\n3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 \n\n* 微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。\n* 尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。\n\n### 美团\n\n3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂\n\n面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。\n\n### 字节\n\n3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer审批 →  4.11 offer邮件\n\n* 字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。\n* 流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。\n* 综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。\n\n### 携程\n\n3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）\n\n携程一面问的比较基础，算法也比较简单。\n\n### 阿里\n\n3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试\n\n阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。\n更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题\n\n\n### 恒生\n\n3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话\n\n问的偏业务，貌似一面过了，拿了字节 offer 就拒了。\n\n## 已笔试\n\n* 360 3.19 笔试（1.9 / 2） \n\n* 贝壳 3.21 笔试（1.6 / 3）\n\n* 网易雷火 3.26 笔试（1.5 / 2）\n\n* 网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多AK的同学被笔试挂的，挺迷）\n\n* 便利蜂 3.31 笔试（惨）\n\n* 京东 4.2 笔试（0.7 / 2）\n\n* 百度 4.12 笔试 终止流程\n\n## 已投递简历挂\n\nOPPO、网易互娱\n\n## 已投递无后续\n\n顺丰、58同城、联想、趋势科技\n","source":"_posts/2022实习总结.md","raw":"---\ntitle: 2022实习总结\ndate: 2022-12-12 10:40:27\ncategories: \n  - 实习秋招\n  - 实习\ntags: \nurlname: 2022-internship-summary\ndescription: \ncopyright: true\nmathjax: true\n---\n\n> 写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，\"毕业季\"，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。\n\n<!-- more -->\n\n## 已面试\n\n### 微软\n\n3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 \n\n* 微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。\n* 尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。\n\n### 美团\n\n3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂\n\n面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。\n\n### 字节\n\n3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer审批 →  4.11 offer邮件\n\n* 字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。\n* 流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。\n* 综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。\n\n### 携程\n\n3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）\n\n携程一面问的比较基础，算法也比较简单。\n\n### 阿里\n\n3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试\n\n阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。\n更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题\n\n\n### 恒生\n\n3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话\n\n问的偏业务，貌似一面过了，拿了字节 offer 就拒了。\n\n## 已笔试\n\n* 360 3.19 笔试（1.9 / 2） \n\n* 贝壳 3.21 笔试（1.6 / 3）\n\n* 网易雷火 3.26 笔试（1.5 / 2）\n\n* 网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多AK的同学被笔试挂的，挺迷）\n\n* 便利蜂 3.31 笔试（惨）\n\n* 京东 4.2 笔试（0.7 / 2）\n\n* 百度 4.12 笔试 终止流程\n\n## 已投递简历挂\n\nOPPO、网易互娱\n\n## 已投递无后续\n\n顺丰、58同城、联想、趋势科技\n","slug":"2022实习总结","published":1,"updated":"2023-01-17T01:31:36.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsin0003zvt85kb1cvmo","content":"<blockquote>\n<p>写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，”毕业季”，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"已面试\"><a href=\"#已面试\" class=\"headerlink\" title=\"已面试\"></a>已面试</h2><h3 id=\"微软\"><a href=\"#微软\" class=\"headerlink\" title=\"微软\"></a>微软</h3><p>3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 </p>\n<ul>\n<li>微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。</li>\n<li>尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。</li>\n</ul>\n<h3 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h3><p>3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂</p>\n<p>面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。</p>\n<h3 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h3><p>3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer审批 →  4.11 offer邮件</p>\n<ul>\n<li>字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。</li>\n<li>流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。</li>\n<li>综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。</li>\n</ul>\n<h3 id=\"携程\"><a href=\"#携程\" class=\"headerlink\" title=\"携程\"></a>携程</h3><p>3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）</p>\n<p>携程一面问的比较基础，算法也比较简单。</p>\n<h3 id=\"阿里\"><a href=\"#阿里\" class=\"headerlink\" title=\"阿里\"></a>阿里</h3><p>3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试</p>\n<p>阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。<br>更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题</p>\n<h3 id=\"恒生\"><a href=\"#恒生\" class=\"headerlink\" title=\"恒生\"></a>恒生</h3><p>3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话</p>\n<p>问的偏业务，貌似一面过了，拿了字节 offer 就拒了。</p>\n<h2 id=\"已笔试\"><a href=\"#已笔试\" class=\"headerlink\" title=\"已笔试\"></a>已笔试</h2><ul>\n<li><p>360 3.19 笔试（1.9 / 2） </p>\n</li>\n<li><p>贝壳 3.21 笔试（1.6 / 3）</p>\n</li>\n<li><p>网易雷火 3.26 笔试（1.5 / 2）</p>\n</li>\n<li><p>网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多AK的同学被笔试挂的，挺迷）</p>\n</li>\n<li><p>便利蜂 3.31 笔试（惨）</p>\n</li>\n<li><p>京东 4.2 笔试（0.7 / 2）</p>\n</li>\n<li><p>百度 4.12 笔试 终止流程</p>\n</li>\n</ul>\n<h2 id=\"已投递简历挂\"><a href=\"#已投递简历挂\" class=\"headerlink\" title=\"已投递简历挂\"></a>已投递简历挂</h2><p>OPPO、网易互娱</p>\n<h2 id=\"已投递无后续\"><a href=\"#已投递无后续\" class=\"headerlink\" title=\"已投递无后续\"></a>已投递无后续</h2><p>顺丰、58同城、联想、趋势科技</p>\n","site":{"data":{}},"length":1022,"excerpt":"<blockquote>\n<p>写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，”毕业季”，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。</p>\n</blockquote>","more":"<h2 id=\"已面试\"><a href=\"#已面试\" class=\"headerlink\" title=\"已面试\"></a>已面试</h2><h3 id=\"微软\"><a href=\"#微软\" class=\"headerlink\" title=\"微软\"></a>微软</h3><p>3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 </p>\n<ul>\n<li>微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。</li>\n<li>尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。</li>\n</ul>\n<h3 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h3><p>3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂</p>\n<p>面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。</p>\n<h3 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h3><p>3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer审批 →  4.11 offer邮件</p>\n<ul>\n<li>字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。</li>\n<li>流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。</li>\n<li>综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。</li>\n</ul>\n<h3 id=\"携程\"><a href=\"#携程\" class=\"headerlink\" title=\"携程\"></a>携程</h3><p>3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）</p>\n<p>携程一面问的比较基础，算法也比较简单。</p>\n<h3 id=\"阿里\"><a href=\"#阿里\" class=\"headerlink\" title=\"阿里\"></a>阿里</h3><p>3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试</p>\n<p>阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。<br>更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题</p>\n<h3 id=\"恒生\"><a href=\"#恒生\" class=\"headerlink\" title=\"恒生\"></a>恒生</h3><p>3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话</p>\n<p>问的偏业务，貌似一面过了，拿了字节 offer 就拒了。</p>\n<h2 id=\"已笔试\"><a href=\"#已笔试\" class=\"headerlink\" title=\"已笔试\"></a>已笔试</h2><ul>\n<li><p>360 3.19 笔试（1.9 / 2） </p>\n</li>\n<li><p>贝壳 3.21 笔试（1.6 / 3）</p>\n</li>\n<li><p>网易雷火 3.26 笔试（1.5 / 2）</p>\n</li>\n<li><p>网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多AK的同学被笔试挂的，挺迷）</p>\n</li>\n<li><p>便利蜂 3.31 笔试（惨）</p>\n</li>\n<li><p>京东 4.2 笔试（0.7 / 2）</p>\n</li>\n<li><p>百度 4.12 笔试 终止流程</p>\n</li>\n</ul>\n<h2 id=\"已投递简历挂\"><a href=\"#已投递简历挂\" class=\"headerlink\" title=\"已投递简历挂\"></a>已投递简历挂</h2><p>OPPO、网易互娱</p>\n<h2 id=\"已投递无后续\"><a href=\"#已投递无后续\" class=\"headerlink\" title=\"已投递无后续\"></a>已投递无后续</h2><p>顺丰、58同城、联想、趋势科技</p>"},{"title":"2022秋招总结","date":"2022-12-12T03:57:22.000Z","urlname":"2022-autumn-recruitment-summary","copyright":true,"mathjax":true,"_content":"\n19年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。\n\n研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。\n\n从12月到2月，断断续续复习Java后端开发所需的知识。\n\n从2月底找实习，4月底入职字节跳动，8月底离职返校，直到11月底（11.27）正式签订三方，过程坎坷，内心惆怅。\n\n秋招投了约50家公司，都是Java后端，主要有以下：\n\n<!--more-->\n\n蚂蚁，二面挂\n\n中移苏研，第二批次，面试走完，没有收到体检\n\n浙商银行，面试走完，没有材料审核\n\n山石网科，hr面挂\n\n荣耀，面试走完，口头谈薪\n\n上海银行，总行苏州base，收到offer\n\n苏州农行，收到体检\n\n字节跳动，转正offer，sp\n\n总体而言，今年强的人还是能拿到多个大厂offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的offer）。\n\n关于offer选择，最终是考虑字节跳动base杭州，还有一个江苏省某地级市top1高中的信息技术老师（进编）的offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。\n\n未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。\n\n不管什么offer选择，有得必定有失，十全十美的工作几乎没有。所以在进行offer选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。\n\n做出选择就好好冲吧，未来可期。大家都有光明的未来！\n","source":"_posts/2022秋招总结.md","raw":"---\ntitle: 2022秋招总结\ndate: 2022-12-12 11:57:22\ncategories: \n  - 实习秋招\n  - 秋招\ntags: \nurlname: 2022-autumn-recruitment-summary\ncopyright: true\nmathjax: true\n---\n\n19年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。\n\n研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。\n\n从12月到2月，断断续续复习Java后端开发所需的知识。\n\n从2月底找实习，4月底入职字节跳动，8月底离职返校，直到11月底（11.27）正式签订三方，过程坎坷，内心惆怅。\n\n秋招投了约50家公司，都是Java后端，主要有以下：\n\n<!--more-->\n\n蚂蚁，二面挂\n\n中移苏研，第二批次，面试走完，没有收到体检\n\n浙商银行，面试走完，没有材料审核\n\n山石网科，hr面挂\n\n荣耀，面试走完，口头谈薪\n\n上海银行，总行苏州base，收到offer\n\n苏州农行，收到体检\n\n字节跳动，转正offer，sp\n\n总体而言，今年强的人还是能拿到多个大厂offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的offer）。\n\n关于offer选择，最终是考虑字节跳动base杭州，还有一个江苏省某地级市top1高中的信息技术老师（进编）的offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。\n\n未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。\n\n不管什么offer选择，有得必定有失，十全十美的工作几乎没有。所以在进行offer选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。\n\n做出选择就好好冲吧，未来可期。大家都有光明的未来！\n","slug":"2022秋招总结","published":1,"updated":"2023-01-17T01:32:34.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiq0006zvt8eejq2hpk","content":"<p>19年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。</p>\n<p>研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。</p>\n<p>从12月到2月，断断续续复习Java后端开发所需的知识。</p>\n<p>从2月底找实习，4月底入职字节跳动，8月底离职返校，直到11月底（11.27）正式签订三方，过程坎坷，内心惆怅。</p>\n<p>秋招投了约50家公司，都是Java后端，主要有以下：</p>\n<span id=\"more\"></span>\n\n<p>蚂蚁，二面挂</p>\n<p>中移苏研，第二批次，面试走完，没有收到体检</p>\n<p>浙商银行，面试走完，没有材料审核</p>\n<p>山石网科，hr面挂</p>\n<p>荣耀，面试走完，口头谈薪</p>\n<p>上海银行，总行苏州base，收到offer</p>\n<p>苏州农行，收到体检</p>\n<p>字节跳动，转正offer，sp</p>\n<p>总体而言，今年强的人还是能拿到多个大厂offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的offer）。</p>\n<p>关于offer选择，最终是考虑字节跳动base杭州，还有一个江苏省某地级市top1高中的信息技术老师（进编）的offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。</p>\n<p>未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。</p>\n<p>不管什么offer选择，有得必定有失，十全十美的工作几乎没有。所以在进行offer选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。</p>\n<p>做出选择就好好冲吧，未来可期。大家都有光明的未来！</p>\n","site":{"data":{}},"length":646,"excerpt":"<p>19年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。</p>\n<p>研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。</p>\n<p>从12月到2月，断断续续复习Java后端开发所需的知识。</p>\n<p>从2月底找实习，4月底入职字节跳动，8月底离职返校，直到11月底（11.27）正式签订三方，过程坎坷，内心惆怅。</p>\n<p>秋招投了约50家公司，都是Java后端，主要有以下：</p>","more":"<p>蚂蚁，二面挂</p>\n<p>中移苏研，第二批次，面试走完，没有收到体检</p>\n<p>浙商银行，面试走完，没有材料审核</p>\n<p>山石网科，hr面挂</p>\n<p>荣耀，面试走完，口头谈薪</p>\n<p>上海银行，总行苏州base，收到offer</p>\n<p>苏州农行，收到体检</p>\n<p>字节跳动，转正offer，sp</p>\n<p>总体而言，今年强的人还是能拿到多个大厂offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的offer）。</p>\n<p>关于offer选择，最终是考虑字节跳动base杭州，还有一个江苏省某地级市top1高中的信息技术老师（进编）的offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。</p>\n<p>未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。</p>\n<p>不管什么offer选择，有得必定有失，十全十美的工作几乎没有。所以在进行offer选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。</p>\n<p>做出选择就好好冲吧，未来可期。大家都有光明的未来！</p>"},{"title":"Java八股文 - Java基础","copyright":true,"mathjax":false,"date":"2023-01-23T02:05:51.000Z","toc":true,"urlname":"java-basic-knowledge","_content":"\n> 整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java概述\n\n### JVM、JRE和JDK的关系\n\nJVM：Java Virtual Machine，Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。\n\nJRE：Java Runtime Environment，Java运行环境，包括Java虚拟机和Java程序所需的核心类库等。\n\nJDK：Java Development Kit，Java开发工具包，包括了JRE和开发工具。\n\n### 什么是跨平台性？原理是什么\n\n所谓跨平台性，是指Java语言编写的程序，一次编译，到处运行。\n\n实现原理：Java程序是通过Java虚拟机在系统平台上运行的，只要该系统可以安装相应的Java虚拟机，该系统就可以运行Java程序。\n\n### Java语言有哪些特点\n\n面向对象（封装，继承，多态）\n\n平台无关性（Java虚拟机实现平台无关性）\n\n### 什么是字节码？采用字节码的最大好处是什么\n\n**字节码**：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld执行程序）\n\n**编译与解释并存**\n\nJava源代码(.Java文件)---->编译器---->jvm可执行的Java字节码(.class文件)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行\n\n### 什么是Java程序的主类？\n\n一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。\n主类是Java程序执行的入口。（main方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）\n\n### Java和C++的区别\n\n相同点：都是**面向对象**的语言，都支持**封装、继承和多态**\n\n不同点：\n\n- **Java不提供指针**来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存\n\n- Java的**类是单继承**的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\n\n\t为什么Java中类不支持多继承？——多重继承的钻石问题\n\n\t![多重继承的钻石问题](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png)\n\t类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？\n\n- Java有**自动内存管理**机制，不需要程序员手动释放无用内存\n\n## 基础语法\n\n### 数据类型\n\n**定义**：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。\n\n**分类**\n\n- 基本数据类型\n\t- 数值型\n\t\t- 整数类型(byte,short,int,long)\n\t\t- 浮点类型(float,double)\n\t- 字符型(char)\n\t- 布尔型(boolean)\n- 引用数据类型\n\t- 类(class)\n\t- 接口(interface)\n\t- 数组([])\n\n**Java基本数据类型图**\n\n![Java基本数据类型图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png)\n\n### 类型转换\n\n自动类型转换\n\n> 两种数据类型彼此兼容\n>\n> 低级类型数据转换成高级类型数据\n\n- 数值型数据的转换：byte→short→int→long→float→double\n- 字符型转换为整型：char→int。\n\n强制类型转换\n\n> 当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换\n\n### 访问修饰符\n\n![访问修饰符](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png)\n\n### 关键字\n\n#### final 有什么用？\n\n用于修饰类、方法和变量；\n\n- 被final修饰的类不可以被继承\n\n- 被final修饰的方法不可以被重写\n\n- 被final修饰的变量不可以被改变，被final修饰**不可变的是变量的引用，而不是引用指向的内容**，引用指向的内容是可以改变\n\n\t```java\n\tfinal int[] nums = new int[]{1, 2, 3};\n\tnums[0] = 11;\n\tSystem.out.println(Arrays.toString(nums));\t// [11, 2, 3]\n\t```\n\n#### final、finally、finalize区别\n\n- final是Java修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。\n- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块\n\t中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\n- finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的finalize()方法，并且在该方法中对象可能可以复活。\n\n#### this关键字的用法\n\n指向对象本身的一个指针。\n\n#### super关键字的用法\n\n指向自己父类对象（最近的父类）的一个指针。\n\n#### static存在的主要意义\n\nstatic**静态变量**：和类一起加载，**以致于即使没有创建对象，也能使用属性和调用方法。**\n\nstatic**静态代码块**：在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。\n加载 → 链接（验证、准备、解析） → 初始化\n\nstatic类型的变量在准备阶段进行默认初始化，但是有static final修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。\n\n#### static注意事项\n\n1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。\n\n### 初始化顺序\n\n静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数\n\n### 流程控制语句\n\n#### break 、continue、return 的区别及作用\n\nbreak 结束当前的循环体\n\ncontinue 结束正在执行的循环，进入下一个循环条件\n\nreturn 结束当前的方法，直接返回\n\n#### 跳出当前的多重嵌套循环\n\n在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：\n\n```java\npublic static void main(String[] args) {\n    ok:\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            System.out.println(\"i=\" + i + \",j=\" + j);\n            if (j == 5) {\n                break ok;\n            }\n        }\n    }\n}\n```\n\n## 面向对象\n\n### 面向对象三大特性\n\n#### 面向对象的特征有哪些方面\n\n**抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n\n**封装**\n\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。\n\n**继承**\n\n继承是**使用已存在的类作为基础建立新类**的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。\n\n关于继承如下 3 点请记住：\n\n1. 子类拥有父类非 private 的属性和方法。\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3. 子类可以用自己的方式实现父类的方法，override重写。\n\n**多态**\n\n所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。\n\n父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。\n\n在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n\n方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。\n\nJava实现多态有三个必要条件：继承、重写、向上转型。\n\n> 继承：在多态中必须存在有继承关系的子类和父类。\n>\n> 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n>\n> 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n\n#### 抽象类和接口的对比\n\n抽象类是对类的抽象，用来**捕捉通用特性**。接口是**行为的抽象**，抽象方法的集合。\n\n**相同点**\n\n- 接口和抽象类都不能实例化\n- 都位于继承的顶端，用于被其他类实现或继承\n- 都包含抽象方法，其子类都必须重写这些抽象方法\n\n**不同点**\n\n| 参数       | 抽象类                             | 接口                                             |\n| ---------- | ---------------------------------- | ------------------------------------------------ |\n| 声明       | 抽象类使用abstract关键字声明       | 接口使用interface关键字声明                      |\n| 实现       | 子类使用extends关键字来继承抽象类  | 子类使用implements关键字来实现接口               |\n| 构造器     | 抽象类可以有构造器                 | 接口不能有构造器                                 |\n| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public，也可以不加访问修饰符 |\n| 多继承     | 一个类最多只能继承一个抽象类       | 一个类可以实现多个接口                           |\n\n#### 普通类和抽象类有哪些区别？\n\n- 普通类不能包含抽象方法，抽象类可以包含抽象方法。\n- 抽象类不能直接实例化，普通类可以直接实例化。\n\n#### 成员变量和局部变量的区别\n\n|              | 成员变量               | 局部变量                                     |\n| ------------ | ---------------------- | -------------------------------------------- |\n| **作用域**   | 整个类可使用           | 方法体内使用                                 |\n| **存储位置** | 属于对象，存在堆内存中 | 属于方法，存在栈帧中                         |\n| **生命周期** | 和对象同生命周期       | 和方法同生命周期                             |\n| **初始值**   | 不指定的话有默认初始值 | 必须手动初始化否则<br />不能使用（编译错误） |\n\n**使用原则**\n\n在使用变量时需要遵循的原则为：就近原则\n首先在局部范围找，有就使用；接着在成员位置找。\n\n```java\npublic class Main {\n    int a = 2;\n    public static void main(String[] args) {\n        int a = 1;\n        System.out.println(a);\t// 1\n    }\n}\n```\n\n### 内部类\n\n#### 什么是内部类？\n\n在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是**内部类**。\n\n#### 内部类的分类有哪些\n\n内部类可以分为四种：**静态内部类、成员内部类、局部内部类、匿名内部类**。\n\n##### 静态内部类\n\n定义在类内部的静态类，就是静态内部类。\n\n静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量\n\n##### 成员内部类\n\n定义在类内部，成员位置上的非静态类，就是成员内部类。\n\n成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。\n\n##### 局部内部类\n\n定义在方法中的内部类，就是局部内部类。\n\n定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法\n\n##### 匿名内部类\n\n匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法\n\n#### 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\n\n局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？\n\n先看这段代码：\n\n```java\npublic class Outer {\n    void outMethod(){\n        final int a =10;\n        class Inner {\n            void innerMethod(){\n                System.out.println(a);\n            }\n        }\n    }\n}\n```\n\n以上例子，为什么要加final呢？是因为**生命周期不一致**\n\n局部变量存储在栈中，当方法执行结束后，如果不用final修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。\n加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。\n\n### 重写与重载\n\n#### 构造器（constructor）是否可被重写（override）\n\n构造器不能被继承，因此不能被重写，但可以被重载。\n\n#### 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n\n方法的重载和重写都是实现多态的方式，区别在于重载实现的是**编译时的多态性**，而重写实现的是**运行时的多态性**。\n\n重载：发生在**同一个类**中，**方法名相同 参数列表不同**（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关\n\n重写：发生在**父子类**中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，**访问修饰符大于等于父类**（里氏代换原则）\n\n### 对象相等判断\n\n#### == 和 equals 的区别是什么\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。\n(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n情况1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\n情况2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n\n#### hashCode 与 equals\n\n**hashCode()介绍**\n\nhashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个int整数。hashCode() 定义在JDK的Object类中，这就意味着Java中的任何类都有hashCode()方法。\n\n**为什么要有 hashCode**\n\n**我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode**：\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。\n\n**hashCode()与equals()的相关规定**\n\n- 如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）。\n- 如果两个对象的hashCode值相等并且equals()方法也返回 true，我们才认为这两个对象相等。\n- 如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。\n\n#### 只重写 hashCode 可以吗？\n\n如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。\n\n> 两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n> 如果定义一个set里面存放Person对象，Person只重写了equals方法即可以判断对象内容是否相同。\n>\n> 如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。\n>\n> 但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。\n\n### 值传递\n\n#### 为什么 Java 中只有值传递\n\nJava采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。\n\nexample 1\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果**：\n\n```java\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析**：\n\n![swap(int a, int b)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png)\n\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\nexample 2\n\n```java\n    public static void main(String[] args) {\n        int[] arr = { 1, 2, 3, 4, 5 };\n        System.out.println(arr[0]);\n        change(arr);\n        System.out.println(arr[0]);\n    }\n\n    public static void change(int[] array) {\n        // 将数组的第一个元素变为0\n        array[0] = 0;\n    }\n```\n\n**结果**：\n\n```undefined\n1\n0\n```\n\n**解析**：\n\n![change(int[] array)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\nexample 3\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Student s1 = new Student(\"小张\");\n        Student s2 = new Student(\"小李\");\n        Test.swap(s1, s2);\n        System.out.println(\"s1:\" + s1.getName());\n        System.out.println(\"s2:\" + s2.getName());\n    }\n\n    public static void swap(Student x, Student y) {\n        Student temp = x;\n        x = y;\n        y = temp;\n        System.out.println(\"x:\" + x.getName());\n        System.out.println(\"y:\" + y.getName());\n    }\n}\n```\n\n**结果**：\n\n```undefined\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析**：\n\n交换之前：\n\n![before swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png)\n\n交换之后：\n\n![after swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png)\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n#### 值传递和引用传递有什么区别\n\n值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\n\n## IO流\n\n> 参考：https://blog.csdn.net/weixin_44579258/article/details/90758359\n\n阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待\n同步和异步是指访问数据的机制，同步一般主动请求等待IO操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待IO完毕通知，这可以使进程在数据读写时也不阻塞\n\n准备数据：网卡 → 内核\n数据就绪：数据拷贝到了内核\n拷贝数据：将内核数据拷贝到用户空间\n\n### Blocking I/O\n\n**BIO 属于同步阻塞 IO 模型** 。\n\n同步阻塞 IO 模型中，应用程序**发起 read 调用**后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。\n\n![BIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png)\n\n### NIO (Non-blocking I/O)\n\n同步非阻塞 IO 模型中，用户进程会**一直发起 read 调用**（如果内核返回error则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。\n\n> 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png)\n\n### IO多路复用（NIO）\n\nselect/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png)\n\nIO复用和同步阻塞本质一样，在NIO中，每次用户进程进行read轮询数据是否准备就绪，而在IO多路复用中，利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。\n\n当用户线程调用select，那么整个进程会被阻塞，而同时，kernel内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回可读条件让用户进程发起read调用，用户进程发起调用read操作，将数据从内核空间拷贝到用户空间。\n\n\n### Asynchronous I/O\n\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n用户发起read调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用read的进程，数据已经拷贝到用户空间了。\n\n![AIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png)\n\n## 反射\n\n### 什么是反射机制？\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。\n\n### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的Java代码要慢很多。\n\n### 反射机制的应用场景有哪些？\n\n①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；\n\n②Spring 通过 XML 配置模式装载 Bean 的过程\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入\n\n### Java获取反射的三种方法\n\n1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制\n\n## 包装类\n\n#### 自动装箱与拆箱\n\n**装箱**：将基本类型用它们对应的引用类型包装起来；`Integer a = 1;`\n\n**拆箱**：将包装类型转换为基本数据类型；`int b = a;`\n\n#### int 和 Integer 有什么区别\n\n引入包装类是为了能够将这些**基本数据类型当成对象操作**\n\nJava 为每个原始类型提供了包装类型：\n\n原始类型: boolean，char，byte，short，int，long，float，double\n\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n#### Integer a = 127 与 Integer b = 127相等吗\n\n> 包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，\n>\n> 只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。\n\n对于对象引用类型：==比较的是对象的内存地址。\n对于基本数据类型：==比较的是值。\n\n```java\npublic static void main(String[] args) {\n    Integer a = new Integer(3);\n  \tInteger b = 3;\n    int c = 3;\n    Integer d = 3;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // true，包装类自动装箱且数值范围在cache范围内\n\n    Integer a = new Integer(128);\n    Integer b = 128;\n    int c = 128;\n    Integer d = 128;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // false，包装类自动装箱但是数值范围不在cache范围内\n}\n```\n\n","source":"_posts/Java八股文 - Java基础.md","raw":"---\ntitle: Java八股文 - Java基础\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 10:05:51\ntags:\ntoc: true\nurlname: java-basic-knowledge\n---\n\n> 整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java概述\n\n### JVM、JRE和JDK的关系\n\nJVM：Java Virtual Machine，Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。\n\nJRE：Java Runtime Environment，Java运行环境，包括Java虚拟机和Java程序所需的核心类库等。\n\nJDK：Java Development Kit，Java开发工具包，包括了JRE和开发工具。\n\n### 什么是跨平台性？原理是什么\n\n所谓跨平台性，是指Java语言编写的程序，一次编译，到处运行。\n\n实现原理：Java程序是通过Java虚拟机在系统平台上运行的，只要该系统可以安装相应的Java虚拟机，该系统就可以运行Java程序。\n\n### Java语言有哪些特点\n\n面向对象（封装，继承，多态）\n\n平台无关性（Java虚拟机实现平台无关性）\n\n### 什么是字节码？采用字节码的最大好处是什么\n\n**字节码**：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld执行程序）\n\n**编译与解释并存**\n\nJava源代码(.Java文件)---->编译器---->jvm可执行的Java字节码(.class文件)---->jvm---->jvm中解释器----->机器可执行的二进制机器码---->程序运行\n\n### 什么是Java程序的主类？\n\n一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。\n主类是Java程序执行的入口。（main方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）\n\n### Java和C++的区别\n\n相同点：都是**面向对象**的语言，都支持**封装、继承和多态**\n\n不同点：\n\n- **Java不提供指针**来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存\n\n- Java的**类是单继承**的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\n\n\t为什么Java中类不支持多继承？——多重继承的钻石问题\n\n\t![多重继承的钻石问题](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png)\n\t类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？\n\n- Java有**自动内存管理**机制，不需要程序员手动释放无用内存\n\n## 基础语法\n\n### 数据类型\n\n**定义**：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。\n\n**分类**\n\n- 基本数据类型\n\t- 数值型\n\t\t- 整数类型(byte,short,int,long)\n\t\t- 浮点类型(float,double)\n\t- 字符型(char)\n\t- 布尔型(boolean)\n- 引用数据类型\n\t- 类(class)\n\t- 接口(interface)\n\t- 数组([])\n\n**Java基本数据类型图**\n\n![Java基本数据类型图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png)\n\n### 类型转换\n\n自动类型转换\n\n> 两种数据类型彼此兼容\n>\n> 低级类型数据转换成高级类型数据\n\n- 数值型数据的转换：byte→short→int→long→float→double\n- 字符型转换为整型：char→int。\n\n强制类型转换\n\n> 当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换\n\n### 访问修饰符\n\n![访问修饰符](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png)\n\n### 关键字\n\n#### final 有什么用？\n\n用于修饰类、方法和变量；\n\n- 被final修饰的类不可以被继承\n\n- 被final修饰的方法不可以被重写\n\n- 被final修饰的变量不可以被改变，被final修饰**不可变的是变量的引用，而不是引用指向的内容**，引用指向的内容是可以改变\n\n\t```java\n\tfinal int[] nums = new int[]{1, 2, 3};\n\tnums[0] = 11;\n\tSystem.out.println(Arrays.toString(nums));\t// [11, 2, 3]\n\t```\n\n#### final、finally、finalize区别\n\n- final是Java修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。\n- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块\n\t中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\n- finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的finalize()方法，并且在该方法中对象可能可以复活。\n\n#### this关键字的用法\n\n指向对象本身的一个指针。\n\n#### super关键字的用法\n\n指向自己父类对象（最近的父类）的一个指针。\n\n#### static存在的主要意义\n\nstatic**静态变量**：和类一起加载，**以致于即使没有创建对象，也能使用属性和调用方法。**\n\nstatic**静态代码块**：在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。\n加载 → 链接（验证、准备、解析） → 初始化\n\nstatic类型的变量在准备阶段进行默认初始化，但是有static final修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。\n\n#### static注意事项\n\n1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。\n\n### 初始化顺序\n\n静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数\n\n### 流程控制语句\n\n#### break 、continue、return 的区别及作用\n\nbreak 结束当前的循环体\n\ncontinue 结束正在执行的循环，进入下一个循环条件\n\nreturn 结束当前的方法，直接返回\n\n#### 跳出当前的多重嵌套循环\n\n在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：\n\n```java\npublic static void main(String[] args) {\n    ok:\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            System.out.println(\"i=\" + i + \",j=\" + j);\n            if (j == 5) {\n                break ok;\n            }\n        }\n    }\n}\n```\n\n## 面向对象\n\n### 面向对象三大特性\n\n#### 面向对象的特征有哪些方面\n\n**抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n\n**封装**\n\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。\n\n**继承**\n\n继承是**使用已存在的类作为基础建立新类**的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。\n\n关于继承如下 3 点请记住：\n\n1. 子类拥有父类非 private 的属性和方法。\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3. 子类可以用自己的方式实现父类的方法，override重写。\n\n**多态**\n\n所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。\n\n父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。\n\n在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n\n方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。\n\nJava实现多态有三个必要条件：继承、重写、向上转型。\n\n> 继承：在多态中必须存在有继承关系的子类和父类。\n>\n> 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n>\n> 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n\n#### 抽象类和接口的对比\n\n抽象类是对类的抽象，用来**捕捉通用特性**。接口是**行为的抽象**，抽象方法的集合。\n\n**相同点**\n\n- 接口和抽象类都不能实例化\n- 都位于继承的顶端，用于被其他类实现或继承\n- 都包含抽象方法，其子类都必须重写这些抽象方法\n\n**不同点**\n\n| 参数       | 抽象类                             | 接口                                             |\n| ---------- | ---------------------------------- | ------------------------------------------------ |\n| 声明       | 抽象类使用abstract关键字声明       | 接口使用interface关键字声明                      |\n| 实现       | 子类使用extends关键字来继承抽象类  | 子类使用implements关键字来实现接口               |\n| 构造器     | 抽象类可以有构造器                 | 接口不能有构造器                                 |\n| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public，也可以不加访问修饰符 |\n| 多继承     | 一个类最多只能继承一个抽象类       | 一个类可以实现多个接口                           |\n\n#### 普通类和抽象类有哪些区别？\n\n- 普通类不能包含抽象方法，抽象类可以包含抽象方法。\n- 抽象类不能直接实例化，普通类可以直接实例化。\n\n#### 成员变量和局部变量的区别\n\n|              | 成员变量               | 局部变量                                     |\n| ------------ | ---------------------- | -------------------------------------------- |\n| **作用域**   | 整个类可使用           | 方法体内使用                                 |\n| **存储位置** | 属于对象，存在堆内存中 | 属于方法，存在栈帧中                         |\n| **生命周期** | 和对象同生命周期       | 和方法同生命周期                             |\n| **初始值**   | 不指定的话有默认初始值 | 必须手动初始化否则<br />不能使用（编译错误） |\n\n**使用原则**\n\n在使用变量时需要遵循的原则为：就近原则\n首先在局部范围找，有就使用；接着在成员位置找。\n\n```java\npublic class Main {\n    int a = 2;\n    public static void main(String[] args) {\n        int a = 1;\n        System.out.println(a);\t// 1\n    }\n}\n```\n\n### 内部类\n\n#### 什么是内部类？\n\n在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是**内部类**。\n\n#### 内部类的分类有哪些\n\n内部类可以分为四种：**静态内部类、成员内部类、局部内部类、匿名内部类**。\n\n##### 静态内部类\n\n定义在类内部的静态类，就是静态内部类。\n\n静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量\n\n##### 成员内部类\n\n定义在类内部，成员位置上的非静态类，就是成员内部类。\n\n成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。\n\n##### 局部内部类\n\n定义在方法中的内部类，就是局部内部类。\n\n定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法\n\n##### 匿名内部类\n\n匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法\n\n#### 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\n\n局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？\n\n先看这段代码：\n\n```java\npublic class Outer {\n    void outMethod(){\n        final int a =10;\n        class Inner {\n            void innerMethod(){\n                System.out.println(a);\n            }\n        }\n    }\n}\n```\n\n以上例子，为什么要加final呢？是因为**生命周期不一致**\n\n局部变量存储在栈中，当方法执行结束后，如果不用final修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。\n加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。\n\n### 重写与重载\n\n#### 构造器（constructor）是否可被重写（override）\n\n构造器不能被继承，因此不能被重写，但可以被重载。\n\n#### 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n\n方法的重载和重写都是实现多态的方式，区别在于重载实现的是**编译时的多态性**，而重写实现的是**运行时的多态性**。\n\n重载：发生在**同一个类**中，**方法名相同 参数列表不同**（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关\n\n重写：发生在**父子类**中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，**访问修饰符大于等于父类**（里氏代换原则）\n\n### 对象相等判断\n\n#### == 和 equals 的区别是什么\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。\n(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n情况1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\n情况2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n\n#### hashCode 与 equals\n\n**hashCode()介绍**\n\nhashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个int整数。hashCode() 定义在JDK的Object类中，这就意味着Java中的任何类都有hashCode()方法。\n\n**为什么要有 hashCode**\n\n**我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode**：\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。\n\n**hashCode()与equals()的相关规定**\n\n- 如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）。\n- 如果两个对象的hashCode值相等并且equals()方法也返回 true，我们才认为这两个对象相等。\n- 如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。\n\n#### 只重写 hashCode 可以吗？\n\n如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。\n\n> 两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n> 如果定义一个set里面存放Person对象，Person只重写了equals方法即可以判断对象内容是否相同。\n>\n> 如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。\n>\n> 但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。\n\n### 值传递\n\n#### 为什么 Java 中只有值传递\n\nJava采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。\n\nexample 1\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果**：\n\n```java\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析**：\n\n![swap(int a, int b)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png)\n\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\nexample 2\n\n```java\n    public static void main(String[] args) {\n        int[] arr = { 1, 2, 3, 4, 5 };\n        System.out.println(arr[0]);\n        change(arr);\n        System.out.println(arr[0]);\n    }\n\n    public static void change(int[] array) {\n        // 将数组的第一个元素变为0\n        array[0] = 0;\n    }\n```\n\n**结果**：\n\n```undefined\n1\n0\n```\n\n**解析**：\n\n![change(int[] array)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\nexample 3\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Student s1 = new Student(\"小张\");\n        Student s2 = new Student(\"小李\");\n        Test.swap(s1, s2);\n        System.out.println(\"s1:\" + s1.getName());\n        System.out.println(\"s2:\" + s2.getName());\n    }\n\n    public static void swap(Student x, Student y) {\n        Student temp = x;\n        x = y;\n        y = temp;\n        System.out.println(\"x:\" + x.getName());\n        System.out.println(\"y:\" + y.getName());\n    }\n}\n```\n\n**结果**：\n\n```undefined\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析**：\n\n交换之前：\n\n![before swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png)\n\n交换之后：\n\n![after swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png)\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n#### 值传递和引用传递有什么区别\n\n值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\n\n## IO流\n\n> 参考：https://blog.csdn.net/weixin_44579258/article/details/90758359\n\n阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待\n同步和异步是指访问数据的机制，同步一般主动请求等待IO操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待IO完毕通知，这可以使进程在数据读写时也不阻塞\n\n准备数据：网卡 → 内核\n数据就绪：数据拷贝到了内核\n拷贝数据：将内核数据拷贝到用户空间\n\n### Blocking I/O\n\n**BIO 属于同步阻塞 IO 模型** 。\n\n同步阻塞 IO 模型中，应用程序**发起 read 调用**后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。\n\n![BIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png)\n\n### NIO (Non-blocking I/O)\n\n同步非阻塞 IO 模型中，用户进程会**一直发起 read 调用**（如果内核返回error则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。\n\n> 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png)\n\n### IO多路复用（NIO）\n\nselect/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png)\n\nIO复用和同步阻塞本质一样，在NIO中，每次用户进程进行read轮询数据是否准备就绪，而在IO多路复用中，利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。\n\n当用户线程调用select，那么整个进程会被阻塞，而同时，kernel内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回可读条件让用户进程发起read调用，用户进程发起调用read操作，将数据从内核空间拷贝到用户空间。\n\n\n### Asynchronous I/O\n\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n用户发起read调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用read的进程，数据已经拷贝到用户空间了。\n\n![AIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png)\n\n## 反射\n\n### 什么是反射机制？\n\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。\n\n### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的Java代码要慢很多。\n\n### 反射机制的应用场景有哪些？\n\n①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；\n\n②Spring 通过 XML 配置模式装载 Bean 的过程\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入\n\n### Java获取反射的三种方法\n\n1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制\n\n## 包装类\n\n#### 自动装箱与拆箱\n\n**装箱**：将基本类型用它们对应的引用类型包装起来；`Integer a = 1;`\n\n**拆箱**：将包装类型转换为基本数据类型；`int b = a;`\n\n#### int 和 Integer 有什么区别\n\n引入包装类是为了能够将这些**基本数据类型当成对象操作**\n\nJava 为每个原始类型提供了包装类型：\n\n原始类型: boolean，char，byte，short，int，long，float，double\n\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n#### Integer a = 127 与 Integer b = 127相等吗\n\n> 包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，\n>\n> 只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。\n\n对于对象引用类型：==比较的是对象的内存地址。\n对于基本数据类型：==比较的是值。\n\n```java\npublic static void main(String[] args) {\n    Integer a = new Integer(3);\n  \tInteger b = 3;\n    int c = 3;\n    Integer d = 3;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // true，包装类自动装箱且数值范围在cache范围内\n\n    Integer a = new Integer(128);\n    Integer b = 128;\n    int c = 128;\n    Integer d = 128;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // false，包装类自动装箱但是数值范围不在cache范围内\n}\n```\n\n","slug":"Java八股文 - Java基础","published":1,"updated":"2023-01-23T08:46:19.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsir0007zvt8b5os7454","content":"<blockquote>\n<p>整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Java概述\"><a href=\"#Java概述\" class=\"headerlink\" title=\"Java概述\"></a>Java概述</h2><h3 id=\"JVM、JRE和JDK的关系\"><a href=\"#JVM、JRE和JDK的关系\" class=\"headerlink\" title=\"JVM、JRE和JDK的关系\"></a>JVM、JRE和JDK的关系</h3><p>JVM：Java Virtual Machine，Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>\n<p>JRE：Java Runtime Environment，Java运行环境，包括Java虚拟机和Java程序所需的核心类库等。</p>\n<p>JDK：Java Development Kit，Java开发工具包，包括了JRE和开发工具。</p>\n<h3 id=\"什么是跨平台性？原理是什么\"><a href=\"#什么是跨平台性？原理是什么\" class=\"headerlink\" title=\"什么是跨平台性？原理是什么\"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指Java语言编写的程序，一次编译，到处运行。</p>\n<p>实现原理：Java程序是通过Java虚拟机在系统平台上运行的，只要该系统可以安装相应的Java虚拟机，该系统就可以运行Java程序。</p>\n<h3 id=\"Java语言有哪些特点\"><a href=\"#Java语言有哪些特点\" class=\"headerlink\" title=\"Java语言有哪些特点\"></a>Java语言有哪些特点</h3><p>面向对象（封装，继承，多态）</p>\n<p>平台无关性（Java虚拟机实现平台无关性）</p>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么\"><a href=\"#什么是字节码？采用字节码的最大好处是什么\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么\"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld执行程序）</p>\n<p><strong>编译与解释并存</strong></p>\n<p>Java源代码(.Java文件)—-&gt;编译器—-&gt;jvm可执行的Java字节码(.class文件)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行</p>\n<h3 id=\"什么是Java程序的主类？\"><a href=\"#什么是Java程序的主类？\" class=\"headerlink\" title=\"什么是Java程序的主类？\"></a>什么是Java程序的主类？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。<br>主类是Java程序执行的入口。（main方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>相同点：都是<strong>面向对象</strong>的语言，都支持<strong>封装、继承和多态</strong></p>\n<p>不同点：</p>\n<ul>\n<li><p><strong>Java不提供指针</strong>来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存</p>\n</li>\n<li><p>Java的<strong>类是单继承</strong>的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</p>\n<p>  为什么Java中类不支持多继承？——多重继承的钻石问题</p>\n<p>  <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png\" alt=\"多重继承的钻石问题\"><br>  类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？</p>\n</li>\n<li><p>Java有<strong>自动内存管理</strong>机制，不需要程序员手动释放无用内存</p>\n</li>\n</ul>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>\n<p><strong>分类</strong></p>\n<ul>\n<li>基本数据类型<ul>\n<li>数值型<ul>\n<li>整数类型(byte,short,int,long)</li>\n<li>浮点类型(float,double)</li>\n</ul>\n</li>\n<li>字符型(char)</li>\n<li>布尔型(boolean)</li>\n</ul>\n</li>\n<li>引用数据类型<ul>\n<li>类(class)</li>\n<li>接口(interface)</li>\n<li>数组([])</li>\n</ul>\n</li>\n</ul>\n<p><strong>Java基本数据类型图</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png\" alt=\"Java基本数据类型图\"></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>自动类型转换</p>\n<blockquote>\n<p>两种数据类型彼此兼容</p>\n<p>低级类型数据转换成高级类型数据</p>\n</blockquote>\n<ul>\n<li>数值型数据的转换：byte→short→int→long→float→double</li>\n<li>字符型转换为整型：char→int。</li>\n</ul>\n<p>强制类型转换</p>\n<blockquote>\n<p>当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换</p>\n</blockquote>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png\" alt=\"访问修饰符\"></p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><h4 id=\"final-有什么用？\"><a href=\"#final-有什么用？\" class=\"headerlink\" title=\"final 有什么用？\"></a>final 有什么用？</h4><p>用于修饰类、方法和变量；</p>\n<ul>\n<li><p>被final修饰的类不可以被继承</p>\n</li>\n<li><p>被final修饰的方法不可以被重写</p>\n</li>\n<li><p>被final修饰的变量不可以被改变，被final修饰<strong>不可变的是变量的引用，而不是引用指向的内容</strong>，引用指向的内容是可以改变</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">nums[<span class=\"number\">0</span>] = <span class=\"number\">11</span>;</span><br><span class=\"line\">System.out.println(Arrays.toString(nums));\t<span class=\"comment\">// [11, 2, 3]</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"final、finally、finalize区别\"><a href=\"#final、finally、finalize区别\" class=\"headerlink\" title=\"final、finally、finalize区别\"></a>final、finally、finalize区别</h4><ul>\n<li>final是Java修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。</li>\n<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块<br>  中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>\n<li>finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的finalize()方法，并且在该方法中对象可能可以复活。</li>\n</ul>\n<h4 id=\"this关键字的用法\"><a href=\"#this关键字的用法\" class=\"headerlink\" title=\"this关键字的用法\"></a>this关键字的用法</h4><p>指向对象本身的一个指针。</p>\n<h4 id=\"super关键字的用法\"><a href=\"#super关键字的用法\" class=\"headerlink\" title=\"super关键字的用法\"></a>super关键字的用法</h4><p>指向自己父类对象（最近的父类）的一个指针。</p>\n<h4 id=\"static存在的主要意义\"><a href=\"#static存在的主要意义\" class=\"headerlink\" title=\"static存在的主要意义\"></a>static存在的主要意义</h4><p>static<strong>静态变量</strong>：和类一起加载，<strong>以致于即使没有创建对象，也能使用属性和调用方法。</strong></p>\n<p>static<strong>静态代码块</strong>：在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。<br>加载 → 链接（验证、准备、解析） → 初始化</p>\n<p>static类型的变量在准备阶段进行默认初始化，但是有static final修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。</p>\n<h4 id=\"static注意事项\"><a href=\"#static注意事项\" class=\"headerlink\" title=\"static注意事项\"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>\n<h3 id=\"初始化顺序\"><a href=\"#初始化顺序\" class=\"headerlink\" title=\"初始化顺序\"></a>初始化顺序</h3><p>静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数</p>\n<h3 id=\"流程控制语句\"><a href=\"#流程控制语句\" class=\"headerlink\" title=\"流程控制语句\"></a>流程控制语句</h3><h4 id=\"break-、continue、return-的区别及作用\"><a href=\"#break-、continue、return-的区别及作用\" class=\"headerlink\" title=\"break 、continue、return 的区别及作用\"></a>break 、continue、return 的区别及作用</h4><p>break 结束当前的循环体</p>\n<p>continue 结束正在执行的循环，进入下一个循环条件</p>\n<p>return 结束当前的方法，直接返回</p>\n<h4 id=\"跳出当前的多重嵌套循环\"><a href=\"#跳出当前的多重嵌套循环\" class=\"headerlink\" title=\"跳出当前的多重嵌套循环\"></a>跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    ok:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + i + <span class=\"string\">&quot;,j=&quot;</span> + j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> ok;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"面向对象三大特性\"><a href=\"#面向对象三大特性\" class=\"headerlink\" title=\"面向对象三大特性\"></a>面向对象三大特性</h3><h4 id=\"面向对象的特征有哪些方面\"><a href=\"#面向对象的特征有哪些方面\" class=\"headerlink\" title=\"面向对象的特征有哪些方面\"></a>面向对象的特征有哪些方面</h4><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>\n<p><strong>封装</strong></p>\n<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。</p>\n<p><strong>继承</strong></p>\n<p>继承是<strong>使用已存在的类作为基础建立新类</strong>的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。</p>\n<p>关于继承如下 3 点请记住：</p>\n<ol>\n<li>子类拥有父类非 private 的属性和方法。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法，override重写。</li>\n</ol>\n<p><strong>多态</strong></p>\n<p>所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。</p>\n<p>父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。</p>\n<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>\n<p>方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。</p>\n<p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>\n<blockquote>\n<p>继承：在多态中必须存在有继承关系的子类和父类。</p>\n<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>\n<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>\n</blockquote>\n<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>\n<h4 id=\"抽象类和接口的对比\"><a href=\"#抽象类和接口的对比\" class=\"headerlink\" title=\"抽象类和接口的对比\"></a>抽象类和接口的对比</h4><p>抽象类是对类的抽象，用来<strong>捕捉通用特性</strong>。接口是<strong>行为的抽象</strong>，抽象方法的集合。</p>\n<p><strong>相同点</strong></p>\n<ul>\n<li>接口和抽象类都不能实例化</li>\n<li>都位于继承的顶端，用于被其他类实现或继承</li>\n<li>都包含抽象方法，其子类都必须重写这些抽象方法</li>\n</ul>\n<p><strong>不同点</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>抽象类</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>声明</td>\n<td>抽象类使用abstract关键字声明</td>\n<td>接口使用interface关键字声明</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>子类使用extends关键字来继承抽象类</td>\n<td>子类使用implements关键字来实现接口</td>\n</tr>\n<tr>\n<td>构造器</td>\n<td>抽象类可以有构造器</td>\n<td>接口不能有构造器</td>\n</tr>\n<tr>\n<td>访问修饰符</td>\n<td>抽象类中的方法可以是任意访问修饰符</td>\n<td>接口方法默认修饰符是public，也可以不加访问修饰符</td>\n</tr>\n<tr>\n<td>多继承</td>\n<td>一个类最多只能继承一个抽象类</td>\n<td>一个类可以实现多个接口</td>\n</tr>\n</tbody></table>\n<h4 id=\"普通类和抽象类有哪些区别？\"><a href=\"#普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"普通类和抽象类有哪些区别？\"></a>普通类和抽象类有哪些区别？</h4><ul>\n<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化。</li>\n</ul>\n<h4 id=\"成员变量和局部变量的区别\"><a href=\"#成员变量和局部变量的区别\" class=\"headerlink\" title=\"成员变量和局部变量的区别\"></a>成员变量和局部变量的区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>作用域</strong></td>\n<td>整个类可使用</td>\n<td>方法体内使用</td>\n</tr>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>属于对象，存在堆内存中</td>\n<td>属于方法，存在栈帧中</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>和对象同生命周期</td>\n<td>和方法同生命周期</td>\n</tr>\n<tr>\n<td><strong>初始值</strong></td>\n<td>不指定的话有默认初始值</td>\n<td>必须手动初始化否则<br />不能使用（编译错误）</td>\n</tr>\n</tbody></table>\n<p><strong>使用原则</strong></p>\n<p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(a);\t<span class=\"comment\">// 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><h4 id=\"什么是内部类？\"><a href=\"#什么是内部类？\" class=\"headerlink\" title=\"什么是内部类？\"></a>什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</p>\n<h4 id=\"内部类的分类有哪些\"><a href=\"#内部类的分类有哪些\" class=\"headerlink\" title=\"内部类的分类有哪些\"></a>内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>静态内部类、成员内部类、局部内部类、匿名内部类</strong>。</p>\n<h5 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p>\n<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量</p>\n<h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>\n<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。</p>\n<h5 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p>\n<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法</p>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法</p>\n<h4 id=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"><a href=\"#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\" class=\"headerlink\" title=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</p>\n<p>先看这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">outMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong></p>\n<p>局部变量存储在栈中，当方法执行结束后，如果不用final修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。<br>加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>\n<h3 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a>重写与重载</h3><h4 id=\"构造器（constructor）是否可被重写（override）\"><a href=\"#构造器（constructor）是否可被重写（override）\" class=\"headerlink\" title=\"构造器（constructor）是否可被重写（override）\"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>\n<h4 id=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"><a href=\"#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\" class=\"headerlink\" title=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的是<strong>编译时的多态性</strong>，而重写实现的是<strong>运行时的多态性</strong>。</p>\n<p>重载：发生在<strong>同一个类</strong>中，<strong>方法名相同 参数列表不同</strong>（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关</p>\n<p>重写：发生在<strong>父子类</strong>中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，<strong>访问修饰符大于等于父类</strong>（里氏代换原则）</p>\n<h3 id=\"对象相等判断\"><a href=\"#对象相等判断\" class=\"headerlink\" title=\"对象相等判断\"></a>对象相等判断</h3><h4 id=\"x3D-x3D-和-equals-的区别是什么\"><a href=\"#x3D-x3D-和-equals-的区别是什么\" class=\"headerlink\" title=\"&#x3D;&#x3D; 和 equals 的区别是什么\"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<p>情况1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>\n<p>情况2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>\n<h4 id=\"hashCode-与-equals\"><a href=\"#hashCode-与-equals\" class=\"headerlink\" title=\"hashCode 与 equals\"></a>hashCode 与 equals</h4><p><strong>hashCode()介绍</strong></p>\n<p>hashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个int整数。hashCode() 定义在JDK的Object类中，这就意味着Java中的任何类都有hashCode()方法。</p>\n<p><strong>为什么要有 hashCode</strong></p>\n<p><strong>我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p>\n<p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>\n<p><strong>hashCode()与equals()的相关规定</strong></p>\n<ul>\n<li>如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）。</li>\n<li>如果两个对象的hashCode值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li>\n<li>如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。</li>\n</ul>\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。</p>\n<blockquote>\n<p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n</blockquote>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<blockquote>\n<p>如果定义一个set里面存放Person对象，Person只重写了equals方法即可以判断对象内容是否相同。</p>\n<p>如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。</p>\n<p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。</p>\n</blockquote>\n<h3 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h3><h4 id=\"为什么-Java-中只有值传递\"><a href=\"#为什么-Java-中只有值传递\" class=\"headerlink\" title=\"为什么 Java 中只有值传递\"></a>为什么 Java 中只有值传递</h4><p>Java采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>\n<p>example 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num1 = &quot;</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num2 = &quot;</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a = &quot;</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b = &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">20</span></span><br><span class=\"line\">b = <span class=\"number\">10</span></span><br><span class=\"line\">num1 = <span class=\"number\">10</span></span><br><span class=\"line\">num2 = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png\" alt=\"swap(int a, int b)\"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<p>example 2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    change(arr);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png\" alt=\"change(int[] array)\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p>example 3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小张&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小李&quot;</span>);</span><br><span class=\"line\">        Test.swap(s1, s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s1:&quot;</span> + s1.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s2:&quot;</span> + s2.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Student x, Student y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        x = y;</span><br><span class=\"line\">        y = temp;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x:&quot;</span> + x.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y:&quot;</span> + y.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p>交换之前：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png\" alt=\"before swap(Student x, Student y)\"></p>\n<p>交换之后：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png\" alt=\"after swap(Student x, Student y)\"></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h4 id=\"值传递和引用传递有什么区别\"><a href=\"#值传递和引用传递有什么区别\" class=\"headerlink\" title=\"值传递和引用传递有什么区别\"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>\n<h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_44579258/article/details/90758359\">https://blog.csdn.net/weixin_44579258/article/details/90758359</a></p>\n</blockquote>\n<p>阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待<br>同步和异步是指访问数据的机制，同步一般主动请求等待IO操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待IO完毕通知，这可以使进程在数据读写时也不阻塞</p>\n<p>准备数据：网卡 → 内核<br>数据就绪：数据拷贝到了内核<br>拷贝数据：将内核数据拷贝到用户空间</p>\n<h3 id=\"Blocking-I-x2F-O\"><a href=\"#Blocking-I-x2F-O\" class=\"headerlink\" title=\"Blocking I&#x2F;O\"></a>Blocking I&#x2F;O</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序<strong>发起 read 调用</strong>后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png\" alt=\"BIO\"></p>\n<h3 id=\"NIO-Non-blocking-I-x2F-O\"><a href=\"#NIO-Non-blocking-I-x2F-O\" class=\"headerlink\" title=\"NIO (Non-blocking I&#x2F;O)\"></a>NIO (Non-blocking I&#x2F;O)</h3><p>同步非阻塞 IO 模型中，用户进程会<strong>一直发起 read 调用</strong>（如果内核返回error则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。</p>\n<blockquote>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png\" alt=\"NIO\"></p>\n<h3 id=\"IO多路复用（NIO）\"><a href=\"#IO多路复用（NIO）\" class=\"headerlink\" title=\"IO多路复用（NIO）\"></a>IO多路复用（NIO）</h3><p>select&#x2F;epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png\" alt=\"NIO\"></p>\n<p>IO复用和同步阻塞本质一样，在NIO中，每次用户进程进行read轮询数据是否准备就绪，而在IO多路复用中，利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。</p>\n<p>当用户线程调用select，那么整个进程会被阻塞，而同时，kernel内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回可读条件让用户进程发起read调用，用户进程发起调用read操作，将数据从内核空间拷贝到用户空间。</p>\n<h3 id=\"Asynchronous-I-x2F-O\"><a href=\"#Asynchronous-I-x2F-O\" class=\"headerlink\" title=\"Asynchronous I&#x2F;O\"></a>Asynchronous I&#x2F;O</h3><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p>用户发起read调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用read的进程，数据已经拷贝到用户空间了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png\" alt=\"AIO\"></p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"什么是反射机制？\"><a href=\"#什么是反射机制？\" class=\"headerlink\" title=\"什么是反射机制？\"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>\n<h3 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h3><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的Java代码要慢很多。</li>\n</ul>\n<h3 id=\"反射机制的应用场景有哪些？\"><a href=\"#反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"反射机制的应用场景有哪些？\"></a>反射机制的应用场景有哪些？</h3><p>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p>\n<p>②Spring 通过 XML 配置模式装载 Bean 的过程</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入</li>\n</ol>\n<h3 id=\"Java获取反射的三种方法\"><a href=\"#Java获取反射的三种方法\" class=\"headerlink\" title=\"Java获取反射的三种方法\"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>\n<h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><h4 id=\"自动装箱与拆箱\"><a href=\"#自动装箱与拆箱\" class=\"headerlink\" title=\"自动装箱与拆箱\"></a>自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；<code>Integer a = 1;</code></p>\n<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；<code>int b = a;</code></p>\n<h4 id=\"int-和-Integer-有什么区别\"><a href=\"#int-和-Integer-有什么区别\" class=\"headerlink\" title=\"int 和 Integer 有什么区别\"></a>int 和 Integer 有什么区别</h4><p>引入包装类是为了能够将这些<strong>基本数据类型当成对象操作</strong></p>\n<p>Java 为每个原始类型提供了包装类型：</p>\n<p>原始类型: boolean，char，byte，short，int，long，float，double</p>\n<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>\n<h4 id=\"Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\"><a href=\"#Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\" class=\"headerlink\" title=\"Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗\"></a>Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗</h4><blockquote>\n<p>包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，</p>\n<p>只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。</p>\n</blockquote>\n<p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">  \t<span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// true，包装类自动装箱且数值范围在cache范围内</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// false，包装类自动装箱但是数值范围不在cache范围内</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":10743,"excerpt":"<blockquote>\n<p>整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Java概述\"><a href=\"#Java概述\" class=\"headerlink\" title=\"Java概述\"></a>Java概述</h2><h3 id=\"JVM、JRE和JDK的关系\"><a href=\"#JVM、JRE和JDK的关系\" class=\"headerlink\" title=\"JVM、JRE和JDK的关系\"></a>JVM、JRE和JDK的关系</h3><p>JVM：Java Virtual Machine，Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>\n<p>JRE：Java Runtime Environment，Java运行环境，包括Java虚拟机和Java程序所需的核心类库等。</p>\n<p>JDK：Java Development Kit，Java开发工具包，包括了JRE和开发工具。</p>\n<h3 id=\"什么是跨平台性？原理是什么\"><a href=\"#什么是跨平台性？原理是什么\" class=\"headerlink\" title=\"什么是跨平台性？原理是什么\"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指Java语言编写的程序，一次编译，到处运行。</p>\n<p>实现原理：Java程序是通过Java虚拟机在系统平台上运行的，只要该系统可以安装相应的Java虚拟机，该系统就可以运行Java程序。</p>\n<h3 id=\"Java语言有哪些特点\"><a href=\"#Java语言有哪些特点\" class=\"headerlink\" title=\"Java语言有哪些特点\"></a>Java语言有哪些特点</h3><p>面向对象（封装，继承，多态）</p>\n<p>平台无关性（Java虚拟机实现平台无关性）</p>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么\"><a href=\"#什么是字节码？采用字节码的最大好处是什么\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么\"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld执行程序）</p>\n<p><strong>编译与解释并存</strong></p>\n<p>Java源代码(.Java文件)—-&gt;编译器—-&gt;jvm可执行的Java字节码(.class文件)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行</p>\n<h3 id=\"什么是Java程序的主类？\"><a href=\"#什么是Java程序的主类？\" class=\"headerlink\" title=\"什么是Java程序的主类？\"></a>什么是Java程序的主类？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。<br>主类是Java程序执行的入口。（main方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>相同点：都是<strong>面向对象</strong>的语言，都支持<strong>封装、继承和多态</strong></p>\n<p>不同点：</p>\n<ul>\n<li><p><strong>Java不提供指针</strong>来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存</p>\n</li>\n<li><p>Java的<strong>类是单继承</strong>的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</p>\n<p>  为什么Java中类不支持多继承？——多重继承的钻石问题</p>\n<p>  <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png\" alt=\"多重继承的钻石问题\"><br>  类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？</p>\n</li>\n<li><p>Java有<strong>自动内存管理</strong>机制，不需要程序员手动释放无用内存</p>\n</li>\n</ul>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>\n<p><strong>分类</strong></p>\n<ul>\n<li>基本数据类型<ul>\n<li>数值型<ul>\n<li>整数类型(byte,short,int,long)</li>\n<li>浮点类型(float,double)</li>\n</ul>\n</li>\n<li>字符型(char)</li>\n<li>布尔型(boolean)</li>\n</ul>\n</li>\n<li>引用数据类型<ul>\n<li>类(class)</li>\n<li>接口(interface)</li>\n<li>数组([])</li>\n</ul>\n</li>\n</ul>\n<p><strong>Java基本数据类型图</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png\" alt=\"Java基本数据类型图\"></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>自动类型转换</p>\n<blockquote>\n<p>两种数据类型彼此兼容</p>\n<p>低级类型数据转换成高级类型数据</p>\n</blockquote>\n<ul>\n<li>数值型数据的转换：byte→short→int→long→float→double</li>\n<li>字符型转换为整型：char→int。</li>\n</ul>\n<p>强制类型转换</p>\n<blockquote>\n<p>当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换</p>\n</blockquote>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png\" alt=\"访问修饰符\"></p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><h4 id=\"final-有什么用？\"><a href=\"#final-有什么用？\" class=\"headerlink\" title=\"final 有什么用？\"></a>final 有什么用？</h4><p>用于修饰类、方法和变量；</p>\n<ul>\n<li><p>被final修饰的类不可以被继承</p>\n</li>\n<li><p>被final修饰的方法不可以被重写</p>\n</li>\n<li><p>被final修饰的变量不可以被改变，被final修饰<strong>不可变的是变量的引用，而不是引用指向的内容</strong>，引用指向的内容是可以改变</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">nums[<span class=\"number\">0</span>] = <span class=\"number\">11</span>;</span><br><span class=\"line\">System.out.println(Arrays.toString(nums));\t<span class=\"comment\">// [11, 2, 3]</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"final、finally、finalize区别\"><a href=\"#final、finally、finalize区别\" class=\"headerlink\" title=\"final、finally、finalize区别\"></a>final、finally、finalize区别</h4><ul>\n<li>final是Java修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。</li>\n<li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块<br>  中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li>\n<li>finalize是Object类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的finalize()方法，并且在该方法中对象可能可以复活。</li>\n</ul>\n<h4 id=\"this关键字的用法\"><a href=\"#this关键字的用法\" class=\"headerlink\" title=\"this关键字的用法\"></a>this关键字的用法</h4><p>指向对象本身的一个指针。</p>\n<h4 id=\"super关键字的用法\"><a href=\"#super关键字的用法\" class=\"headerlink\" title=\"super关键字的用法\"></a>super关键字的用法</h4><p>指向自己父类对象（最近的父类）的一个指针。</p>\n<h4 id=\"static存在的主要意义\"><a href=\"#static存在的主要意义\" class=\"headerlink\" title=\"static存在的主要意义\"></a>static存在的主要意义</h4><p>static<strong>静态变量</strong>：和类一起加载，<strong>以致于即使没有创建对象，也能使用属性和调用方法。</strong></p>\n<p>static<strong>静态代码块</strong>：在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。<br>加载 → 链接（验证、准备、解析） → 初始化</p>\n<p>static类型的变量在准备阶段进行默认初始化，但是有static final修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。</p>\n<h4 id=\"static注意事项\"><a href=\"#static注意事项\" class=\"headerlink\" title=\"static注意事项\"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>\n<h3 id=\"初始化顺序\"><a href=\"#初始化顺序\" class=\"headerlink\" title=\"初始化顺序\"></a>初始化顺序</h3><p>静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数</p>\n<h3 id=\"流程控制语句\"><a href=\"#流程控制语句\" class=\"headerlink\" title=\"流程控制语句\"></a>流程控制语句</h3><h4 id=\"break-、continue、return-的区别及作用\"><a href=\"#break-、continue、return-的区别及作用\" class=\"headerlink\" title=\"break 、continue、return 的区别及作用\"></a>break 、continue、return 的区别及作用</h4><p>break 结束当前的循环体</p>\n<p>continue 结束正在执行的循环，进入下一个循环条件</p>\n<p>return 结束当前的方法，直接返回</p>\n<h4 id=\"跳出当前的多重嵌套循环\"><a href=\"#跳出当前的多重嵌套循环\" class=\"headerlink\" title=\"跳出当前的多重嵌套循环\"></a>跳出当前的多重嵌套循环</h4><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    ok:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + i + <span class=\"string\">&quot;,j=&quot;</span> + j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> ok;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"面向对象三大特性\"><a href=\"#面向对象三大特性\" class=\"headerlink\" title=\"面向对象三大特性\"></a>面向对象三大特性</h3><h4 id=\"面向对象的特征有哪些方面\"><a href=\"#面向对象的特征有哪些方面\" class=\"headerlink\" title=\"面向对象的特征有哪些方面\"></a>面向对象的特征有哪些方面</h4><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>\n<p><strong>封装</strong></p>\n<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。</p>\n<p><strong>继承</strong></p>\n<p>继承是<strong>使用已存在的类作为基础建立新类</strong>的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。</p>\n<p>关于继承如下 3 点请记住：</p>\n<ol>\n<li>子类拥有父类非 private 的属性和方法。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法，override重写。</li>\n</ol>\n<p><strong>多态</strong></p>\n<p>所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。</p>\n<p>父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。</p>\n<p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>\n<p>方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。</p>\n<p>Java实现多态有三个必要条件：继承、重写、向上转型。</p>\n<blockquote>\n<p>继承：在多态中必须存在有继承关系的子类和父类。</p>\n<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>\n<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>\n</blockquote>\n<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>\n<h4 id=\"抽象类和接口的对比\"><a href=\"#抽象类和接口的对比\" class=\"headerlink\" title=\"抽象类和接口的对比\"></a>抽象类和接口的对比</h4><p>抽象类是对类的抽象，用来<strong>捕捉通用特性</strong>。接口是<strong>行为的抽象</strong>，抽象方法的集合。</p>\n<p><strong>相同点</strong></p>\n<ul>\n<li>接口和抽象类都不能实例化</li>\n<li>都位于继承的顶端，用于被其他类实现或继承</li>\n<li>都包含抽象方法，其子类都必须重写这些抽象方法</li>\n</ul>\n<p><strong>不同点</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>抽象类</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>声明</td>\n<td>抽象类使用abstract关键字声明</td>\n<td>接口使用interface关键字声明</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>子类使用extends关键字来继承抽象类</td>\n<td>子类使用implements关键字来实现接口</td>\n</tr>\n<tr>\n<td>构造器</td>\n<td>抽象类可以有构造器</td>\n<td>接口不能有构造器</td>\n</tr>\n<tr>\n<td>访问修饰符</td>\n<td>抽象类中的方法可以是任意访问修饰符</td>\n<td>接口方法默认修饰符是public，也可以不加访问修饰符</td>\n</tr>\n<tr>\n<td>多继承</td>\n<td>一个类最多只能继承一个抽象类</td>\n<td>一个类可以实现多个接口</td>\n</tr>\n</tbody></table>\n<h4 id=\"普通类和抽象类有哪些区别？\"><a href=\"#普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"普通类和抽象类有哪些区别？\"></a>普通类和抽象类有哪些区别？</h4><ul>\n<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化。</li>\n</ul>\n<h4 id=\"成员变量和局部变量的区别\"><a href=\"#成员变量和局部变量的区别\" class=\"headerlink\" title=\"成员变量和局部变量的区别\"></a>成员变量和局部变量的区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>作用域</strong></td>\n<td>整个类可使用</td>\n<td>方法体内使用</td>\n</tr>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>属于对象，存在堆内存中</td>\n<td>属于方法，存在栈帧中</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>和对象同生命周期</td>\n<td>和方法同生命周期</td>\n</tr>\n<tr>\n<td><strong>初始值</strong></td>\n<td>不指定的话有默认初始值</td>\n<td>必须手动初始化否则<br />不能使用（编译错误）</td>\n</tr>\n</tbody></table>\n<p><strong>使用原则</strong></p>\n<p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(a);\t<span class=\"comment\">// 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><h4 id=\"什么是内部类？\"><a href=\"#什么是内部类？\" class=\"headerlink\" title=\"什么是内部类？\"></a>什么是内部类？</h4><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</p>\n<h4 id=\"内部类的分类有哪些\"><a href=\"#内部类的分类有哪些\" class=\"headerlink\" title=\"内部类的分类有哪些\"></a>内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>静态内部类、成员内部类、局部内部类、匿名内部类</strong>。</p>\n<h5 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p>\n<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量</p>\n<h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>\n<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。</p>\n<h5 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p>\n<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法</p>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法</p>\n<h4 id=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"><a href=\"#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\" class=\"headerlink\" title=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？</p>\n<p>先看这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">outMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong></p>\n<p>局部变量存储在栈中，当方法执行结束后，如果不用final修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。<br>加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>\n<h3 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a>重写与重载</h3><h4 id=\"构造器（constructor）是否可被重写（override）\"><a href=\"#构造器（constructor）是否可被重写（override）\" class=\"headerlink\" title=\"构造器（constructor）是否可被重写（override）\"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>\n<h4 id=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"><a href=\"#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\" class=\"headerlink\" title=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的是<strong>编译时的多态性</strong>，而重写实现的是<strong>运行时的多态性</strong>。</p>\n<p>重载：发生在<strong>同一个类</strong>中，<strong>方法名相同 参数列表不同</strong>（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关</p>\n<p>重写：发生在<strong>父子类</strong>中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，<strong>访问修饰符大于等于父类</strong>（里氏代换原则）</p>\n<h3 id=\"对象相等判断\"><a href=\"#对象相等判断\" class=\"headerlink\" title=\"对象相等判断\"></a>对象相等判断</h3><h4 id=\"x3D-x3D-和-equals-的区别是什么\"><a href=\"#x3D-x3D-和-equals-的区别是什么\" class=\"headerlink\" title=\"&#x3D;&#x3D; 和 equals 的区别是什么\"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<p>情况1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>\n<p>情况2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>\n<h4 id=\"hashCode-与-equals\"><a href=\"#hashCode-与-equals\" class=\"headerlink\" title=\"hashCode 与 equals\"></a>hashCode 与 equals</h4><p><strong>hashCode()介绍</strong></p>\n<p>hashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个int整数。hashCode() 定义在JDK的Object类中，这就意味着Java中的任何类都有hashCode()方法。</p>\n<p><strong>为什么要有 hashCode</strong></p>\n<p><strong>我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p>\n<p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>\n<p><strong>hashCode()与equals()的相关规定</strong></p>\n<ul>\n<li>如果两个对象的hashCode值相等，那这两个对象不一定相等（哈希碰撞）。</li>\n<li>如果两个对象的hashCode值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li>\n<li>如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。</li>\n</ul>\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。</p>\n<blockquote>\n<p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n</blockquote>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<blockquote>\n<p>如果定义一个set里面存放Person对象，Person只重写了equals方法即可以判断对象内容是否相同。</p>\n<p>如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。</p>\n<p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。</p>\n</blockquote>\n<h3 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h3><h4 id=\"为什么-Java-中只有值传递\"><a href=\"#为什么-Java-中只有值传递\" class=\"headerlink\" title=\"为什么 Java 中只有值传递\"></a>为什么 Java 中只有值传递</h4><p>Java采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>\n<p>example 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num1 = &quot;</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num2 = &quot;</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a = &quot;</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b = &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">20</span></span><br><span class=\"line\">b = <span class=\"number\">10</span></span><br><span class=\"line\">num1 = <span class=\"number\">10</span></span><br><span class=\"line\">num2 = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png\" alt=\"swap(int a, int b)\"></p>\n<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<p>example 2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    change(arr);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png\" alt=\"change(int[] array)\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p>example 3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小张&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小李&quot;</span>);</span><br><span class=\"line\">        Test.swap(s1, s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s1:&quot;</span> + s1.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s2:&quot;</span> + s2.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Student x, Student y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        x = y;</span><br><span class=\"line\">        y = temp;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x:&quot;</span> + x.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y:&quot;</span> + y.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p>交换之前：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png\" alt=\"before swap(Student x, Student y)\"></p>\n<p>交换之后：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png\" alt=\"after swap(Student x, Student y)\"></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h4 id=\"值传递和引用传递有什么区别\"><a href=\"#值传递和引用传递有什么区别\" class=\"headerlink\" title=\"值传递和引用传递有什么区别\"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>\n<h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_44579258/article/details/90758359\">https://blog.csdn.net/weixin_44579258/article/details/90758359</a></p>\n</blockquote>\n<p>阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待<br>同步和异步是指访问数据的机制，同步一般主动请求等待IO操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待IO完毕通知，这可以使进程在数据读写时也不阻塞</p>\n<p>准备数据：网卡 → 内核<br>数据就绪：数据拷贝到了内核<br>拷贝数据：将内核数据拷贝到用户空间</p>\n<h3 id=\"Blocking-I-x2F-O\"><a href=\"#Blocking-I-x2F-O\" class=\"headerlink\" title=\"Blocking I&#x2F;O\"></a>Blocking I&#x2F;O</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序<strong>发起 read 调用</strong>后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png\" alt=\"BIO\"></p>\n<h3 id=\"NIO-Non-blocking-I-x2F-O\"><a href=\"#NIO-Non-blocking-I-x2F-O\" class=\"headerlink\" title=\"NIO (Non-blocking I&#x2F;O)\"></a>NIO (Non-blocking I&#x2F;O)</h3><p>同步非阻塞 IO 模型中，用户进程会<strong>一直发起 read 调用</strong>（如果内核返回error则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。</p>\n<blockquote>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png\" alt=\"NIO\"></p>\n<h3 id=\"IO多路复用（NIO）\"><a href=\"#IO多路复用（NIO）\" class=\"headerlink\" title=\"IO多路复用（NIO）\"></a>IO多路复用（NIO）</h3><p>select&#x2F;epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png\" alt=\"NIO\"></p>\n<p>IO复用和同步阻塞本质一样，在NIO中，每次用户进程进行read轮询数据是否准备就绪，而在IO多路复用中，利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。</p>\n<p>当用户线程调用select，那么整个进程会被阻塞，而同时，kernel内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回可读条件让用户进程发起read调用，用户进程发起调用read操作，将数据从内核空间拷贝到用户空间。</p>\n<h3 id=\"Asynchronous-I-x2F-O\"><a href=\"#Asynchronous-I-x2F-O\" class=\"headerlink\" title=\"Asynchronous I&#x2F;O\"></a>Asynchronous I&#x2F;O</h3><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p>用户发起read调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用read的进程，数据已经拷贝到用户空间了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png\" alt=\"AIO\"></p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"什么是反射机制？\"><a href=\"#什么是反射机制？\" class=\"headerlink\" title=\"什么是反射机制？\"></a>什么是反射机制？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</p>\n<h3 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h3><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的Java代码要慢很多。</li>\n</ul>\n<h3 id=\"反射机制的应用场景有哪些？\"><a href=\"#反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"反射机制的应用场景有哪些？\"></a>反射机制的应用场景有哪些？</h3><p>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p>\n<p>②Spring 通过 XML 配置模式装载 Bean 的过程</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入</li>\n</ol>\n<h3 id=\"Java获取反射的三种方法\"><a href=\"#Java获取反射的三种方法\" class=\"headerlink\" title=\"Java获取反射的三种方法\"></a>Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>\n<h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><h4 id=\"自动装箱与拆箱\"><a href=\"#自动装箱与拆箱\" class=\"headerlink\" title=\"自动装箱与拆箱\"></a>自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；<code>Integer a = 1;</code></p>\n<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；<code>int b = a;</code></p>\n<h4 id=\"int-和-Integer-有什么区别\"><a href=\"#int-和-Integer-有什么区别\" class=\"headerlink\" title=\"int 和 Integer 有什么区别\"></a>int 和 Integer 有什么区别</h4><p>引入包装类是为了能够将这些<strong>基本数据类型当成对象操作</strong></p>\n<p>Java 为每个原始类型提供了包装类型：</p>\n<p>原始类型: boolean，char，byte，short，int，long，float，double</p>\n<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>\n<h4 id=\"Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\"><a href=\"#Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\" class=\"headerlink\" title=\"Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗\"></a>Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗</h4><blockquote>\n<p>包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，</p>\n<p>只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。</p>\n</blockquote>\n<p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">  \t<span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// true，包装类自动装箱且数值范围在cache范围内</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// false，包装类自动装箱但是数值范围不在cache范围内</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java八股文 - Java异常","copyright":true,"mathjax":false,"date":"2023-01-23T02:06:31.000Z","toc":true,"urlname":"java-exception-error","_content":"\n> 整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java异常架构\n\n![Java异常架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png)\n\n### 1. Throwable\n\nThrowable 是 Java 语言中所有错误与异常的超类。\n\nThrowable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\n\n### 2. Error（错误）\n\nError 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\n\n非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\n\n### 3. Exception（异常）\n\n程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\n\n#### 运行时异常\n\nException 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）\n\n#### 编译时异常\n\nException 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）\n\n## Java异常关键字\n\n• **try** – 用于监听。将要被监听的代（可能抛出异常的代码）放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\n• **catch** – 用于捕获异常。catch用来捕获try语句块中发生的异常。\n• **finally** – finally语句块总是会被执行。它主要用于回收在try块里打开的资源(如数据库连接、网络连接和磁盘文件)。\n• **throw** – 用于手动抛出catch到的异常。\n• **throws** – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意catch这个可能跑出的异常。\n\n## Java异常处理\n\n### 直接抛出异常\n\n通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 **throws** 关键字声明可能会抛出的异常。调用该方法的方法需要注意catch这个可能跑出的异常。\n\n```java\nprivate static void readFile(String filePath) throws IOException {\n    File file = new File(filePath);\n    String result;\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    while((result = reader.readLine())!=null) {\n        System.out.println(result);\n    }\n    reader.close();\n}\n```\n\n### 封装异常再抛出\n\n有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\n\n```java\nprivate static void readFile(String filePath) throws MyException {    \n    try {\n        // code\n    } catch (IOException e) {\n        MyException ex = new MyException(\"read file failed.\");\n        ex.initCause(e);\n        throw ex;\n    }\n}\n```\n\n### 捕获异常\n\n在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException e) {\n        // handle FileNotFoundException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n同一个 catch 也可以捕获多种类型异常，用 | 隔开\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException | UnknownHostException e) {\n        // handle FileNotFoundException or UnknownHostException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n### 自定义异常\n\n习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）\n\n```java\npublic class MyException extends Exception {\n    public MyException(){ }\n    public MyException(String msg){\n        super(msg);\n    }\n    // ...\n}\n```\n\n## Java异常常见面试题\n\n### 1. Error 和 Exception 区别是什么？\n\nError 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；\n\nException 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。\n\n### 2. 运行时异常和一般异常(受检异常)区别是什么？\n\n运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。\n\n受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。\n\n**RuntimeException异常和受检异常之间的区别**：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。\n\n### 3. JVM 是如何处理异常的？\n\n在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。\n\nJVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。\n\n### 4. throw 和 throws 的区别是什么？\n\nJava 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。\n\n**throws 关键字和 throw 关键字在使用上的几点区别如下**：\n\n- throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\n- throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\n\n### 5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n\n**答：会执行，在 return 前执行。**\n\n**代码示例1：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally，finally执行过后回来执行return a\n    } finally {\n        a = 40;\n    }\n\treturn a;\n}\n```\n\n执行结果：30\n\n**代码示例2：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally\n    } finally {\n        a = 40;\n        return a;\t// finally中有return就直接return了\n    }\n}\n```\n\n执行结果：40\n\n### 6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\n\n```java\npublic class ExceptionA extends Exception {\n    public ExceptionA(String message) {\n        super(message);\n    }\n}\npublic class ExceptionB extends ExceptionA {\n    public ExceptionB(String message) {\n        super(message);\n    }\n}\n\ntry {\n  throw new ExceptionB(\"a\");\n} catch (ExceptionA ea) {\n  System.out.println(\"ExceptionA\");\n} catch (Exception e) {\n  System.out.println(\"Exception\");\n}\n```\n\n输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）\n\n```java\ntry {\n  throw new ExceptionB(\"b\");\n} catch (Exception e) {\n  System.out.println(\"Exception: \" + e);\n}\n```\n\n输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。\n\n面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）\n\n```java\nclass Annoyance extends Exception {\n}\nclass Sneeze extends Annoyance {\n}\nclass Human {\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tthrow new Sneeze();\n\t\t\t} catch ( Annoyance a ) {\n\t\t\t\tSystem.out.println(\"Caught Annoyance\");\n\t\t\t\tthrow a;\n\t\t\t}\n\t\t} catch ( Sneeze s ) {\n\t\t\tSystem.out.println(\"Caught Sneeze\");\n\t\t\treturn ;\n\t\t} finally {\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t}\n\t}\n}\n```\n\n结果\n\n```java\nCaught Annoyance\nCaught Sneeze\nHello World!\n```\n\n","source":"_posts/Java八股文 - Java异常.md","raw":"---\ntitle: Java八股文 - Java异常\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 10:06:31\ntags:\ntoc: true\nurlname: java-exception-error\n---\n\n> 整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java异常架构\n\n![Java异常架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png)\n\n### 1. Throwable\n\nThrowable 是 Java 语言中所有错误与异常的超类。\n\nThrowable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\n\n### 2. Error（错误）\n\nError 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\n\n非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\n\n### 3. Exception（异常）\n\n程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\n\n#### 运行时异常\n\nException 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）\n\n#### 编译时异常\n\nException 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）\n\n## Java异常关键字\n\n• **try** – 用于监听。将要被监听的代（可能抛出异常的代码）放在try语句块之内，当try语句块内发生异常时，异常就被抛出。\n• **catch** – 用于捕获异常。catch用来捕获try语句块中发生的异常。\n• **finally** – finally语句块总是会被执行。它主要用于回收在try块里打开的资源(如数据库连接、网络连接和磁盘文件)。\n• **throw** – 用于手动抛出catch到的异常。\n• **throws** – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意catch这个可能跑出的异常。\n\n## Java异常处理\n\n### 直接抛出异常\n\n通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 **throws** 关键字声明可能会抛出的异常。调用该方法的方法需要注意catch这个可能跑出的异常。\n\n```java\nprivate static void readFile(String filePath) throws IOException {\n    File file = new File(filePath);\n    String result;\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    while((result = reader.readLine())!=null) {\n        System.out.println(result);\n    }\n    reader.close();\n}\n```\n\n### 封装异常再抛出\n\n有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\n\n```java\nprivate static void readFile(String filePath) throws MyException {    \n    try {\n        // code\n    } catch (IOException e) {\n        MyException ex = new MyException(\"read file failed.\");\n        ex.initCause(e);\n        throw ex;\n    }\n}\n```\n\n### 捕获异常\n\n在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException e) {\n        // handle FileNotFoundException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n同一个 catch 也可以捕获多种类型异常，用 | 隔开\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException | UnknownHostException e) {\n        // handle FileNotFoundException or UnknownHostException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n### 自定义异常\n\n习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）\n\n```java\npublic class MyException extends Exception {\n    public MyException(){ }\n    public MyException(String msg){\n        super(msg);\n    }\n    // ...\n}\n```\n\n## Java异常常见面试题\n\n### 1. Error 和 Exception 区别是什么？\n\nError 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；\n\nException 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。\n\n### 2. 运行时异常和一般异常(受检异常)区别是什么？\n\n运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。\n\n受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。\n\n**RuntimeException异常和受检异常之间的区别**：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。\n\n### 3. JVM 是如何处理异常的？\n\n在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。\n\nJVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。\n\n### 4. throw 和 throws 的区别是什么？\n\nJava 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。\n\n**throws 关键字和 throw 关键字在使用上的几点区别如下**：\n\n- throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\n- throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\n\n### 5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n\n**答：会执行，在 return 前执行。**\n\n**代码示例1：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally，finally执行过后回来执行return a\n    } finally {\n        a = 40;\n    }\n\treturn a;\n}\n```\n\n执行结果：30\n\n**代码示例2：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally\n    } finally {\n        a = 40;\n        return a;\t// finally中有return就直接return了\n    }\n}\n```\n\n执行结果：40\n\n### 6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\n\n```java\npublic class ExceptionA extends Exception {\n    public ExceptionA(String message) {\n        super(message);\n    }\n}\npublic class ExceptionB extends ExceptionA {\n    public ExceptionB(String message) {\n        super(message);\n    }\n}\n\ntry {\n  throw new ExceptionB(\"a\");\n} catch (ExceptionA ea) {\n  System.out.println(\"ExceptionA\");\n} catch (Exception e) {\n  System.out.println(\"Exception\");\n}\n```\n\n输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）\n\n```java\ntry {\n  throw new ExceptionB(\"b\");\n} catch (Exception e) {\n  System.out.println(\"Exception: \" + e);\n}\n```\n\n输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。\n\n面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）\n\n```java\nclass Annoyance extends Exception {\n}\nclass Sneeze extends Annoyance {\n}\nclass Human {\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tthrow new Sneeze();\n\t\t\t} catch ( Annoyance a ) {\n\t\t\t\tSystem.out.println(\"Caught Annoyance\");\n\t\t\t\tthrow a;\n\t\t\t}\n\t\t} catch ( Sneeze s ) {\n\t\t\tSystem.out.println(\"Caught Sneeze\");\n\t\t\treturn ;\n\t\t} finally {\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t}\n\t}\n}\n```\n\n结果\n\n```java\nCaught Annoyance\nCaught Sneeze\nHello World!\n```\n\n","slug":"Java八股文 - Java异常","published":1,"updated":"2023-01-23T08:46:28.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsis0008zvt89obi96oc","content":"<blockquote>\n<p>整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Java异常架构\"><a href=\"#Java异常架构\" class=\"headerlink\" title=\"Java异常架构\"></a>Java异常架构</h2><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png\" alt=\"Java异常架构\"></p>\n<h3 id=\"1-Throwable\"><a href=\"#1-Throwable\" class=\"headerlink\" title=\"1. Throwable\"></a>1. Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>\n<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>\n<h3 id=\"2-Error（错误）\"><a href=\"#2-Error（错误）\" class=\"headerlink\" title=\"2. Error（错误）\"></a>2. Error（错误）</h3><p>Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>\n<p>非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>\n<h3 id=\"3-Exception（异常）\"><a href=\"#3-Exception（异常）\" class=\"headerlink\" title=\"3. Exception（异常）\"></a>3. Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>Exception 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）</p>\n<h4 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h4><p>Exception 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）</p>\n<h2 id=\"Java异常关键字\"><a href=\"#Java异常关键字\" class=\"headerlink\" title=\"Java异常关键字\"></a>Java异常关键字</h2><p>• <strong>try</strong> – 用于监听。将要被监听的代（可能抛出异常的代码）放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>• <strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>• <strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的资源(如数据库连接、网络连接和磁盘文件)。<br>• <strong>throw</strong> – 用于手动抛出catch到的异常。<br>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意catch这个可能跑出的异常。</p>\n<h2 id=\"Java异常处理\"><a href=\"#Java异常处理\" class=\"headerlink\" title=\"Java异常处理\"></a>Java异常处理</h2><h3 id=\"直接抛出异常\"><a href=\"#直接抛出异常\" class=\"headerlink\" title=\"直接抛出异常\"></a>直接抛出异常</h3><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。调用该方法的方法需要注意catch这个可能跑出的异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filePath);</span><br><span class=\"line\">    String result;</span><br><span class=\"line\">    <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(file));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((result = reader.readLine())!=<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装异常再抛出\"><a href=\"#封装异常再抛出\" class=\"headerlink\" title=\"封装异常再抛出\"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> MyException &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"type\">MyException</span> <span class=\"variable\">ex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyException</span>(<span class=\"string\">&quot;read file failed.&quot;</span>);</span><br><span class=\"line\">        ex.initCause(e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException or UnknownHostException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">()</span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java异常常见面试题\"><a href=\"#Java异常常见面试题\" class=\"headerlink\" title=\"Java异常常见面试题\"></a>Java异常常见面试题</h2><h3 id=\"1-Error-和-Exception-区别是什么？\"><a href=\"#1-Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"1. Error 和 Exception 区别是什么？\"></a>1. Error 和 Exception 区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>\n<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>\n<h3 id=\"2-运行时异常和一般异常-受检异常-区别是什么？\"><a href=\"#2-运行时异常和一般异常-受检异常-区别是什么？\" class=\"headerlink\" title=\"2. 运行时异常和一般异常(受检异常)区别是什么？\"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h3><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>\n<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>\n<p><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p>\n<h3 id=\"3-JVM-是如何处理异常的？\"><a href=\"#3-JVM-是如何处理异常的？\" class=\"headerlink\" title=\"3. JVM 是如何处理异常的？\"></a>3. JVM 是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>\n<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>\n<h3 id=\"4-throw-和-throws-的区别是什么？\"><a href=\"#4-throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"4. throw 和 throws 的区别是什么？\"></a>4. throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>\n<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>\n<ul>\n<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>\n<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>\n</ul>\n<h3 id=\"5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><strong>答：会执行，在 return 前执行。</strong></p>\n<p><strong>代码示例1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally，finally执行过后回来执行return a</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：30</p>\n<p><strong>代码示例2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// finally中有return就直接return了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：40</p>\n<h3 id=\"6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\"><a href=\"#6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\" class=\"headerlink\" title=\"6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\"></a>6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionA</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExceptionA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionB</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExceptionA ea) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;ExceptionA&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception: &quot;</span> + e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。</p>\n<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Annoyance</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sneeze</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Annoyance</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Human</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Sneeze</span>();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> ( Annoyance a ) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Annoyance&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> a;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> ( Sneeze s ) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Sneeze&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caught Annoyance</span><br><span class=\"line\">Caught Sneeze</span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":5179,"excerpt":"<blockquote>\n<p>整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Java异常架构\"><a href=\"#Java异常架构\" class=\"headerlink\" title=\"Java异常架构\"></a>Java异常架构</h2><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png\" alt=\"Java异常架构\"></p>\n<h3 id=\"1-Throwable\"><a href=\"#1-Throwable\" class=\"headerlink\" title=\"1. Throwable\"></a>1. Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>\n<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>\n<h3 id=\"2-Error（错误）\"><a href=\"#2-Error（错误）\" class=\"headerlink\" title=\"2. Error（错误）\"></a>2. Error（错误）</h3><p>Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>\n<p>非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>\n<h3 id=\"3-Exception（异常）\"><a href=\"#3-Exception（异常）\" class=\"headerlink\" title=\"3. Exception（异常）\"></a>3. Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>Exception 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）</p>\n<h4 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h4><p>Exception 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）</p>\n<h2 id=\"Java异常关键字\"><a href=\"#Java异常关键字\" class=\"headerlink\" title=\"Java异常关键字\"></a>Java异常关键字</h2><p>• <strong>try</strong> – 用于监听。将要被监听的代（可能抛出异常的代码）放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>• <strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>• <strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的资源(如数据库连接、网络连接和磁盘文件)。<br>• <strong>throw</strong> – 用于手动抛出catch到的异常。<br>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意catch这个可能跑出的异常。</p>\n<h2 id=\"Java异常处理\"><a href=\"#Java异常处理\" class=\"headerlink\" title=\"Java异常处理\"></a>Java异常处理</h2><h3 id=\"直接抛出异常\"><a href=\"#直接抛出异常\" class=\"headerlink\" title=\"直接抛出异常\"></a>直接抛出异常</h3><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。调用该方法的方法需要注意catch这个可能跑出的异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filePath);</span><br><span class=\"line\">    String result;</span><br><span class=\"line\">    <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(file));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((result = reader.readLine())!=<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装异常再抛出\"><a href=\"#封装异常再抛出\" class=\"headerlink\" title=\"封装异常再抛出\"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> MyException &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"type\">MyException</span> <span class=\"variable\">ex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyException</span>(<span class=\"string\">&quot;read file failed.&quot;</span>);</span><br><span class=\"line\">        ex.initCause(e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException or UnknownHostException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">()</span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java异常常见面试题\"><a href=\"#Java异常常见面试题\" class=\"headerlink\" title=\"Java异常常见面试题\"></a>Java异常常见面试题</h2><h3 id=\"1-Error-和-Exception-区别是什么？\"><a href=\"#1-Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"1. Error 和 Exception 区别是什么？\"></a>1. Error 和 Exception 区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>\n<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>\n<h3 id=\"2-运行时异常和一般异常-受检异常-区别是什么？\"><a href=\"#2-运行时异常和一般异常-受检异常-区别是什么？\" class=\"headerlink\" title=\"2. 运行时异常和一般异常(受检异常)区别是什么？\"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h3><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>\n<p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>\n<p><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p>\n<h3 id=\"3-JVM-是如何处理异常的？\"><a href=\"#3-JVM-是如何处理异常的？\" class=\"headerlink\" title=\"3. JVM 是如何处理异常的？\"></a>3. JVM 是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>\n<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>\n<h3 id=\"4-throw-和-throws-的区别是什么？\"><a href=\"#4-throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"4. throw 和 throws 的区别是什么？\"></a>4. throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>\n<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>\n<ul>\n<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>\n<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>\n</ul>\n<h3 id=\"5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><strong>答：会执行，在 return 前执行。</strong></p>\n<p><strong>代码示例1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally，finally执行过后回来执行return a</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：30</p>\n<p><strong>代码示例2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// finally中有return就直接return了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：40</p>\n<h3 id=\"6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\"><a href=\"#6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\" class=\"headerlink\" title=\"6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\"></a>6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionA</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExceptionA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionB</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExceptionA ea) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;ExceptionA&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception: &quot;</span> + e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。</p>\n<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Annoyance</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sneeze</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Annoyance</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Human</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Sneeze</span>();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> ( Annoyance a ) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Annoyance&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> a;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> ( Sneeze s ) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Sneeze&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caught Annoyance</span><br><span class=\"line\">Caught Sneeze</span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>"},{"title":"Java八股文 - Java并发","copyright":true,"mathjax":false,"date":"2023-01-23T07:29:48.000Z","toc":true,"urlname":"java-concurrent-programming","_content":"\n> 整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 基础知识\n\n### 并发编程的优缺点\n\n优点：为了能提高程序的执行效率，提高程序运行速度；\n\n缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。\n\n#### 并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\n\n并发编程三要素（线程的安全性问题体现在）：\n\n**原子性**：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）\n\n**可见性**：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）\n\n**有序性**：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）\n\n> volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用`atomicInteger.getAndSet()`原子操作。\n\n### 线程和进程\n\n#### 进程间的通信方式\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；\n2. **有名管道(Names Pipes)**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；\n3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**；\n5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。  \n6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n7. **套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n#### 线程间的同步方式\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；\n2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；\n3. **事件(Event)** ：wait/notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\n\n#### 什么是线程和进程?\n\n**进程**：进程是应用程序的一次运行，每个进程都有自己独立的内存空间；是操作系统资源分配的基本单位；\n\n**线程**：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。\n\n#### 什么是上下文切换?\n\n多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。\n\n当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n#### 守护线程和用户线程有什么区别呢？\n\n- **用户 (User) 线程**：运行在前台，执行具体的任务\n- **守护 (Daemon) 线程**：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作\n\n**注意事项：**\n\n1. `setDaemon(true)`必须在`start()`方法前执行，否则会抛出 `IllegalThreadStateException` 异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n4. 守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。\n\n#### 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\n\nWindows上面用任务管理器看，Linux下可以用 top 这个命令看。\n\n#### 什么是线程死锁\n\n死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。\n\n如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\n\n![线程死锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png)\n\n下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：\n\n```java\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();\t//资源 1\n    private static Object resource2 = new Object();\t//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过`Thread.sleep(1000)`；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。\n\n#### 形成死锁的四个必要条件是什么\n\n1. 互斥条件：一个资源只能被一个线程占用，直到被该线程释放；\n2. 请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；\n3. 不剥夺条件：线程；已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；\n4. 循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞\n\n#### 如何避免线程死锁\n\n我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n**破坏互斥条件**：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；\n\n**破坏请求与保持条件**：一次性申请所有的资源；\n\n**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，**如果申请不到，可以主动释放它占有的资源**；\n\n**破坏循环等待条件**：靠**按序申请**资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n我们对线程 2 的代码修改成下面这样就不会产生死锁了。\n\n```java\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n```\n\n我们分析一下上面的代码为什么避免了死锁的发生?\n\n线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。\n\n#### 创建线程有哪几种方式？\n\n创建线程有四种方式：\n\n- 继承 Thread 类；\n- 实现 Runnable 接口；\n- 实现 Callable 接口；\n- 使用 Executors 工具类创建线程池\n\n**继承 Thread 类**\n\n1. 定义一个 Thread 类的子类，重写 run 方法\n2. 创建自定义的线程子类对象\n3. 调用子类实例的 start() 方法来启动线程\n\n```java\npublic class Main {\n    static class MyThread extends Thread {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n\n    }\n    public static void main(String[] args) {\n        new MyThread().start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Runnable 接口**\n\n1. 定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法\n2. 创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 对象，**该Thread对象才是真正的线程对象**\n3. 调用线程对象的 start() 方法\n\n```java\npublic class Main {\n    static class MyRunnable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n\n    }\n    public static void main(String[] args) {\n        new Thread(new MyRunnable()).start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Callable 接口**\n\n1. 创建实现 Callable 接口的类 myCallable\n2. ⭐以 myCallable 为参数创建 FutureTask 对象\n3. 将 FutureTask 作为参数创建 Thread 对象\n4. 调用线程对象的 start() 方法\n\n```java\npublic class Main {\n    static class MyCallable implements Callable<Integer> {\n\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(Thread.currentThread().getName() + \" call()方法执行中...\");\n            return 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\n        new Thread(futureTask).start();\n        try {\n            Thread.sleep(10);\n            System.out.println(futureTask.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行完成\");\n    }\n}\n```\n\n**使用 Executors 工具类创建线程池**\n\nExecutors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。\n\n主要有 new[Single/Fixed/Cached/Scheduled]ThreadPool 这四种线程池\n\n```java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" run()方法执行中...\");\n    }\n}\n\npublic class SingleThreadExecutorTest {n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        MyRunnable myRunnable = new MyRunnable();\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(myRunnable);\n        }\n\n        System.out.println(\"线程任务开始执行\");\n        executorService.shutdown();\n    }\n}\n```\n\n#### 说一下 runnable 和 callable 有什么区别？\n\n相同点\n\n- 都是接口\n- 都可以用来实现多线程\n- 都采用 Thread.start() 启动线程\n\n**主要区别**\n\n- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果\n- Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常\n\n#### 线程的 run()和 start()有什么区别？\n\n> start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。\n\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用run()，其实就相当于是调用了一个普通函数而已。\nstart() 只能调用一次，run() 可以重复调用。\n\n#### 什么是 Callable 和 Future?\n\n```java\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nnew Thread(futureTask).start();\n```\n\n将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，\n之后可以用 future 来获取 callable  中 call() 的返回结果。\n\n#### 线程的状态和基本操作\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n#### Java 中用到的线程调度算法是什么？\n\n线程调度是指按照特定机制为多个线程分配 CPU 的使用权。\n\n有两种调度模型：**时间片轮转**模型和**优先级调度**模型。\n\n**Java虚拟机采用优先级调度模型**，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。\n\n#### 请说出与线程同步以及线程调度相关的方法。\n\n（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；\n\n（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；\n\n（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\n\n（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n#### wait() 和 sleep() 有什么区别？\n\n两者都可以暂停线程的执行\n\n- 类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。\n- 释放锁：wait() 释放锁，sleep() 不释放锁。\n- 用途不同：wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。\n- 自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。\n\n#### 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\n\n> 使用 while 判断条件是否得到满足\n\n使用 if 来判断会存在以下问题：\n\n1. 另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。\n\n2. 存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。\n\n\t```java\n\tsynchronized (monitor) {\n\t    //  判断条件谓词是否得到满足\n\t    while(!locked) {\n\t        //  等待唤醒\n\t        monitor.wait();\n\t    }\n\t    //  处理其他的业务逻辑\n\t}\n\t```\n\n#### 为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\n\nJava 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。\n\n#### Thread 类中的 yield 方法有什么作用？\n\n使当前线程从运行状态变为就绪状态。\n\n#### 线程的 sleep()方法和 yield()方法有什么区别？\n\n1. sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；\n\n\tyield()方法只会给**相同或更高优先级**的线程以运行的机会；\n\n2. 线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；\n\n#### 如何停止一个正在运行的线程？\n\n1. 当 run 方法完成后线程终止；\n2. 使用 interrupt 方法中断线程。\n\n#### notify() 和 notifyAll() 有什么区别？\n\n如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n\nnotifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。\n\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n\n#### 如何在两个线程间共享数据？\n\nJava 线程之间的通信由 Java 内存模型（简称JMM）控制：\n\n1. 所有的共享变量都存在主内存中\n2. 每个线程都保存了一份该线程使用到的共享变量的副本\n3. 如果线程A与线程B之间要通信：\n\t1. 线程A将本地内存A中更新过的共享变量刷新到主内存中去\n\t2. 线程B到主内存中去读取线程A之前已经更新过的共享变量。\n\n#### Java 如何实现多线程之间的通讯和协作？\n\nJava中线程通信协作的最常见的两种方式：\n\n1. synchronized 加锁的线程 + Object 类的 wait()/notify()/notifyAll()\n\n2. ReentrantLock 类加锁的线程 + Condition 类的 await()/signal()/signalAll()\n\n#### 同步方法和同步块，哪个是更好的选择？\n\n同步的范围越小越好。\n\n因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。\n\n#### 什么是线程同步和线程互斥，有哪几种实现方式？\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。\n\n实现线程同步的方法\n\n- 同步代码方法 / 方法块：sychronized 关键字修饰的方法 / 代码块\n- 使用特殊变量域 volatile 实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制\n- 使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义\n\n#### 在监视器(Monitor)内部，是如何做线程同步的？\n\n在 Java 虚拟机中，每个对象关联一个**监视器**，为了实现监视器的互斥功能，**每个对象都关联着一把锁**。\n\n一旦方法或者代码块被 **synchronized** 修饰，那么这个部分就放入了监视器的监视区域，**确保一次只能有一个线程执行该部分的代码**，线程在获取锁之前不允许执行该部分的代码\n\n另外 Java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案\n\n#### Java 线程数过多会造成什么问题？\n\n- 消耗过多的 CPU 资源\n\n\t如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。\n\n- 降低 JVM 稳定性\n\n\t在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。\n\n## 并发关键字\n\n### synchronized\n\n#### synchronized 的作用？\n\n在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。\n\n#### 怎么使用 synchronized 关键字\n\n**synchronized关键字最主要的三种使用方式：**\n\n- **修饰实例方法：** 给当前对象实例加锁；\n- **修饰静态方法：** 给当前类加锁；\n- **修饰代码块：**给指定对象加锁，进入同步代码块前要获得指定对象的锁。\n\n**总结：** synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。\n\n#### 双重校验锁实现对象单例（线程安全）\n\n```java\npublic class Singleton {\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        // 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例\n        if (uniqueInstance == null) {\t// 线程1、2、3有可能都进来了\n            //类对象加锁\n            synchronized (Singleton.class) {\t// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化\n                if (uniqueInstance == null) {\t// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n\n}\n```\n\n另外，需要注意 instance采用 volatile 关键字修饰也是很有必要。\n\ninstance 采用 volatile 关键字修饰也是很有必要的，instance = new Singleton() 这段代码其实是分为三步执行：\n\n1. 为 instance 分配内存空间\n2. 初始化 instance\n3. 将 instance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance不为空，因此**返回 T1 实例化但未初始化**的 instance。\n\n#### synchronized 底层实现原理？（监视器monitor）\n\nsynchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。\n\nsynchronized 同步语句块的情况\n\n```java\npublic class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n```\n\n通过JDK 反汇编指令 javap -c -v SynchronizedDemo\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。\n\n为什么会有两个monitorexit呢？（line 19）\n\n这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。**因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。**\n\n#### synchronized 可重入的原理\n\n重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。\n底层原理维护一个**计数器**，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。\n\n#### 什么是自旋\n\n> 不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环\n\n很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为**线程阻塞涉及到用户态和内核态切换的问题开销很大**，而是**在 synchronized 的边界做忙循环**，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n\n#### 多线程中 synchronized 锁升级的原理是什么？\n\n> 目的：锁升级是为了减低了锁带来的性能消耗。\n\nJava 的锁都是基于对象的，Java 对象有对象头，内容包括：\n\n1. Mark Word，存储对象的 hashCode、锁信息等；\n2. Class Metadata Address，存储到对象类型数据的指针；\n3. 数组的长度（如果是数组）\n\n每一个线程在准备获取共享资源时： \n\n第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “**偏向锁**” ；\n\n第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：\n\n- CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；\n- CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。\n\n第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；\n\n第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；\n\n第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 **轻量级锁**的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；\n\n第六步，进入**重量级锁**的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。\n\n#### 线程 B 怎么知道线程 A 修改了变量\n\n* volatile 修饰变量\n\n* synchronized 修饰修改变量的方法\n* lock 对修改变量的代码块加锁\n\n#### synchronized 和 Lock 有什么区别？\n\n- synchronized 是 Java 关键字，而Lock 是个接口；\n- synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；\n- synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；\n- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\n#### synchronized 和 ReentrantLock 区别是什么？\n\n**相同点：**\n\n两者都是可重入锁\n\n“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，**如果不可锁重入的话，就会造成死锁**。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n\n**不同点：**\n\n* synchronized 是关键字，ReentrantLock 是类；\n* ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；\n\n- ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\n- 二者的锁机制其实也是不一样的：\n\tReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word\n\n### volatile\n\n#### 为什么代码会重排序？\n\n在执行程序时，为了**提高性能**，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：\n\n- **在单线程环境下不能改变程序运行的结果；**\n- **存在数据依赖关系的不允许重排序**\n\n需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。\n\n#### as-if-serial 规则和 happens-before 规则的区别\n\n- as-if-serial 规则保证 **单线程** 内程序的执行结果不被改变，happens-before 规则保证 **正确同步的多线程** 程序的执行结果不被改变。\n- as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n\n#### volatile 关键字的作用\n\n对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n#### JMM内存屏障插入策略\n\n**插入屏障**\n\nStoreStore屏障 - volatile 写 - StoreLoad屏障\n\nvolatile读 - LoadLoad屏障 - LoadStore屏障\n\n**volatile 与普通变量的重排序规则**\n\n1. 如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；\n2. 如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；\n3. 如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。\n\n#### volatile 能使得一个非原子操作变成原子操作吗？\n\nvolatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。\n\n#### volatile 修饰符的有过什么实践？\n\n单例模式-双重锁检验里面用 volatile 修饰实例变量。\n\n#### volatile 和 synchronized 的区别是什么？\n\n- volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；\n- volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，\n\t而 synchronized 则可以保证变量的修改原子性和可见性；\n- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；\n- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。synchronized关键字在JavaSE1.6之后进行了主要包括为了**减少获得锁和释放锁带来的性能消耗**而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。\n\n## Lock 体系\n\n### Lock 简介\n\n#### Lock 接口是什么？对比同步它有什么优势？\n\nLock 接口比同步方法和同步块提供了更具扩展性的锁操作。\n\n（1）可以使锁更**公平**\n\n（2）可以使线程在**等待锁的时候响应中断**\n\n（3）可以**让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间**\n\n#### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\n\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。\n\t传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。\n\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n\t乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\n\n#### 什么是 CAS\n\nCAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。\n\n如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。\n\n####  Java实现CAS的原理 - Unsafe类\n\n在Java中，有一个`Unsafe`类，它在`sun.misc`包中。它里面是一些`native`方法（由底层的JVM使用C或者C++去实现），其中就有几个关于CAS的：\n\n```java\nboolean compareAndSwapObject(Object o, long offset,Object expected, Object x);\nboolean compareAndSwapInt(Object o, long offset,int expected,int x);\nboolean compareAndSwapLong(Object o, long offset,long expected,long x);\n```\n\n当然，他们都是`public native`的。\n\nUnsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。\n\nLinux 的 X86 下主要是通过`cmpxchgl`这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用`lock`指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。\n\n当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的`park`和`unpark`， LockSupport类底层就是调用了这两个方法。还有支持反射操作的`allocateInstance()`方法。\n\n#### CAS 会产生什么问题？\n\n1、**ABA 问题**：\n\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。\n\n2、**循环时间长开销大**：\n\n对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。\n\n3、**只能保证一个共享变量的原子操作**：\n\n当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是**对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁**。\n\n#### 死锁与活锁的区别，死锁与饥饿的区别？\n\n> 区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。\n\n死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n\n活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致**一直重复尝试，失败，尝试，失败**。\n\n活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。\n\n饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。\n\nJava 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。\n\n### AQS详解\n\n#### AQS 介绍\n\nAQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。\n\n使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。\n\n#### AQS 原理分析\n\n**如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。\n如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。**\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。\n\n看个AQS(AbstractQueuedSynchronizer)原理图：\n\n![AQS原理图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png)\n\nAQS使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\n```java\nprivate volatile int state;\t// 共享变量，使用volatile修饰保证线程可见性\n```\n\n状态信息通过 protected 类型的 getState，setState，compareAndSetState进行操作\n\n```java\n// 返回同步状态的当前值\nprotected final int getState() {  \n    return state;\n}\n// 设置同步状态的值\nprotected final void setState(int newState) { \n    state = newState;\n}\n// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n**AQS 对资源的共享方式**\n\nAQS定义两种资源共享方式\n\n- **Exclusive**（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：\n\t- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n\t- 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\n- **Share**（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\n**AQS底层使用了模板方法模式**\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器（**模板方法模式**很经典的一个应用）：\n\n1. 使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）\n2. 调用 AQS 的模板方法，会进一步调用使用者重写的方法。\n\n**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**\n\n```java\nisHeldExclusively()\t// 该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)\t// 独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)\t// 独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)\t// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)\t// 共享方式。尝试释放资源，成功则返回true，失败则返回false。\n```\n\n以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。\n\n以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即state=0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\n\n### 读写锁\n\n首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。\n\nReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，**实现了读写的分离，读锁是共享的，写锁是独占的**，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n\n## 并发容器\n\n### ConcurrentHashMap\n\n#### 什么是ConcurrentHashMap？\n\nConcurrentHashMap是Java中的一个**线程安全且高效的HashMap实现**。\n\n那么它到底是如何实现线程安全的？\n\nJDK 1.6版本关键要素：\n\n- segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；\n- segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。\n\nJDK1.8后，ConcurrentHashMap抛弃了原有的 Segment 分段锁，而**采用了 CAS + synchronized 来保证并发安全性**。\n\n插入元素过程：\n\n如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；\n\n如果相应位置的Node不为空，则对该节点加synchronized锁进行插入或更新操作。\n\n### CopyOnWriteArrayList\n\nCopyOnWrite容器即**写时复制的容器**，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。\n\n**CopyOnWriteArrayList 的使用场景**\n\n通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。\n\n**CopyOnWriteArrayList 的缺点**\n\n1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。\n2. **不能用于实时读的场景**，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，**读取到数据可能还是旧的**，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。\n\n### ThreadLocal\n\n#### ThreadLocal的数据结构\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry为 <threadLocal的弱引用，value为强引用> 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。\n\n```java\npublic class ThreadLocalDemo {\n    // private static final ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>(){\n    //     @Override\n    //     protected Integer initialValue() {\n    //         return 0;\n    //     }\n    // };\n\n    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++) {\n            new Thread(() -> {\n                for (int j = 0; j < 5; j++) {\n                    Integer val = threadLocal.get();\n                    threadLocal.set(++val);\n                    System.out.println(Thread.currentThread().getName() + \" ---- \" + val);\n                }\n            }, \"Thread-\" + i).start();\n        }\n\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(Thread.currentThread().getName() + \" ---- \" + threadLocal.get());\n    }\n}\n```\n\n打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后threadLocal.get仍然是0\n\n```java\nThread-1 ---- 1\nThread-0 ---- 1\nThread-1 ---- 2\nThread-0 ---- 2\nThread-1 ---- 3\nThread-1 ---- 4\nThread-1 ---- 5\nThread-0 ---- 3\nThread-0 ---- 4\nThread-0 ---- 5\nmain ---- 0\n```\n\n### ThreadLocal内存泄漏\n\n#### ThreadLocal造成内存泄漏的原因？\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的remove()方法，清理掉 key 为 null 的记录。\n\n### BlockingQueue\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。\n\n在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n\n阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\nJDK7 提供了 7 个阻塞队列。分别是：\n\n> ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\n> LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\n> PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\n> DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n> SynchronousQueue：一个不存储元素的阻塞队列。\n> LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n> LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\nJava 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。\n\nBlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，**当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞**，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。\n\n## 线程池\n\n### Executors 创建四种常见线程池\n\n#### 什么是线程池？有哪几种创建方式？\n\n> 池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是**尽可能减少创建和销毁对象的次数**，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。\n\n线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\n\n（1）Executors.newSingleThreadExecutor：`1, 1, new LinkedBlockingQueue`。所有任务按照**先来先执行**的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）\n\n（2）Executors.newFixedThreadPool：`nCoreThreads, nCoreThreads, new LinkedBlockingQueue`，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）\n\n（3） Executors.newCachedThreadPool：`0, Integer.MAX_VALUE`，不创建核心线程，线程池最大为Integer.MAX_VALUE。（线程池太大导致OOM）\n\nnewCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。\nFixedThreadPool 是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。\n\n（4）Executors.newScheduledThreadPool：`nCoreThreads, Integer.MAX_VALUE`创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n#### 线程池有什么优点？\n\n- 降低资源消耗：重用存在的线程，减少对象创建销毁的开销；\n- 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；\n- 提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。\n\n#### 线程池都有哪些状态？\n\n- RUNNING：接受新的任务提交，处理等待队列中的任务；\n- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；\n- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；\n- TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；\n- TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n#### 在 Java 中 Executor 和 Executors 的区别？\n\n- **Executors 工具类**的不同方法按照我们的需求**创建了不同的线程池**，来满足业务的需求；\n- **Executor 接口对象执行我们的线程任务**，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。\n\n#### 线程池中 submit() 和 execute() 方法有什么区别？\n\n接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而execute()只能执行 Runnable 类型的任务；\n\n返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；\n\n异常处理：submit() 方便 Exception 处理。\n\n### ThreadPoolExecutor 自定义线程池\n\n#### Executors\n\n《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是**通过 ThreadPoolExecutor 的方式**，这样的处理方式让写的同学**更加明确线程池的运行规则，规避资源耗尽的风险**\n\nExecutors 各个方法的弊端：\n\n- newSingleThreadExecutor 和 newFixedThreadPool :\n\t`0, 0`和 `n, n` ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE\n\n\t主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。\n\n- newCachedThreadPool 和 newScheduledThreadPool:\n\t`0, Integer.MAX_VALUE` 和 `n, Integer.MAX_VALUE`\n\n\t主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM\n\nThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定\n\n#### ThreaPoolExecutor \n\n创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。\n\nThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。\n\n#### ThreadPoolExecutor构造函数重要参数分析\n\n**`ThreadPoolExecutor`** **3 个最重要的参数：**\n\n- **`corePoolSize`** ：核心线程数，线程数定义了最小可以同时运行的线程数量\n- **`maximumPoolSize`** ：线程池中允许存在的工作线程的最大数量\n- **`workQueue`**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中\n\n`ThreadPoolExecutor`其他常见参数:\n\n1. **`keepAliveTime`**：非核心线程如果处于闲置状态超过该值，就会被销毁。\n2. **`unit`** ：`keepAliveTime` 闲置销毁时长的时间单位\n3. **`threadFactory`**：为线程池提供创建新线程的线程工厂\n4. **`handler`** ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略\n\n#### ThreadPoolExecutor拒绝策略\n\n**`ThreadPoolExecutor`** **拒绝策略定义:**\n\n如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，`ThreadPoolTaskExecutor` 定义一些策略:\n\n- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。\n- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务。\n- **`ThreadPoolExecutor.DiscardPolicy`**：不处理新任务，直接丢弃掉。\n- **`ThreadPoolExecutor.DiscardOldestPolicy`**： 此策略将丢弃最早的未处理的任务请求。\n\n#### 一个简单的线程池Demo:`Runnable` + `ThreadPoolExecutor`\n\n线程池实现原理\n\n![线程池实现原理](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png)\n\n**总结一下处理流程**\n\n1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 < corePoolSize时）。**注意，这一步需要获得全局锁。**\n2. 线程总数量 >= corePoolSize时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了**线程复用**）。 \n3. 当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**\n4. 缓存队列之前满了， 现在加非核心线程且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。\n\n整个过程如图所示：\n\n为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。\n\n首先创建一个 `Runnable` 接口的实现类（当然也可以是 `Callable` 接口，我们上面也说了两者的区别。）\n\n```java\nimport Java.util.Date;\n\n/**\n * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n */\npublic class MyRunnable implements Runnable {\n\n    private String command;\n\n    public MyRunnable(String s) {\n        this.command = s;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n        processCommand();\n        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n    }\n\n    private void processCommand() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return this.command;\n    }\n}\n```\n\n编写测试程序，我们这里以阿里巴巴推荐的使用 `ThreadPoolExecutor` 构造函数自定义参数的方式来创建线程池。\n\n```java\nimport Java.util.concurrent.ArrayBlockingQueue;\nimport Java.util.concurrent.ThreadPoolExecutor;\nimport Java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolExecutorDemo {\n\n    private static final int CORE_POOL_SIZE = 5;\n    private static final int MAX_POOL_SIZE = 10;\n    private static final int QUEUE_CAPACITY = 100;\n    private static final Long KEEP_ALIVE_TIME = 1L;\n    public static void main(String[] args) {\n\n        //使用阿里巴巴推荐的创建线程池的方式\n        //通过ThreadPoolExecutor构造函数自定义参数创建\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE,\n                MAX_POOL_SIZE,\n                KEEP_ALIVE_TIME,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n                new ThreadPoolExecutor.CallerRunsPolicy());\n\n        for (int i = 0; i < 10; i++) {\n            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n            Runnable worker = new MyRunnable(\"\" + i);\n            //执行Runnable\n            executor.execute(worker);\n        }\n        //终止线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n        }\n        System.out.println(\"Finished all threads\");\n    }\n}\n```\n\n可以看到我们上面的代码指定了：\n\n1. `corePoolSize`: 核心线程数为 5。\n2. `maximumPoolSize` ：最大线程数 10\n3. `keepAliveTime` : 等待时间为 1L。\n4. `unit`: 等待时间的单位为 TimeUnit.SECONDS。\n5. `workQueue`：任务队列为 `ArrayBlockingQueue`，并且容量为 100;\n6. `handler`:饱和策略为 `CallerRunsPolicy`。\n\n**Output：**\n\n```java\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:54 CST 2019\n```\n\n## 并发工具\n\n### CountDownLatch 与 CyclicBarrier\n\nCountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n\n- CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；\n- 调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；\n- CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。\n\n### Semaphore\n\n**Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\n\nSemaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。\n\n## 模拟\n\n### 死锁\n\n```java\npublic class DeadLock {\n    private static Object A = new Object();\n    private static Object B = new Object();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (A) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源B\");\n                synchronized (B) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                }\n            }\n        }, \"线程1\").start();\n\n        new Thread(() -> {\n            synchronized (B) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源A\");\n                synchronized (A) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                }\n            }\n        }, \"线程2\").start();\n    }\n}\n```\n\n> 线程1 已获得资源A\n> 线程2 已获得资源B\n> 线程1 等待获得资源B\n> 线程2 等待获得资源A\n\n### run方法和start方法\n\n```java\npublic class DiffStartRun {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程A\").run();\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程B\").start();\n    }\n}\n```\n\n> main\n> 线程B\n>\n> new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。\n>\n> **总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。**\n\n### 两个线程，交替加减\n\n1. synchronized\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithSync {\n\t    private static int value = 0;\n\t\n\t    private static final Object lock = new Object();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 0) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 1) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t\n\t}\n\t```\n\n2. lock + condition\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithLock {\n\t    private static int value = 0;\n\t\n\t    private static final Lock lock = new ReentrantLock();\n\t\n\t    static Condition a = lock.newCondition();\n\t\n\t    static Condition b = lock.newCondition();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 0) {\n\t                        a.await();\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    b.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 1) {\n\t                        b.await();\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    a.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t}\n\t```\n\n### 三个线程，循环打印\n\n```java\npublic class Demo5 {\n    private int value = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition a = lock.newCondition();\n    private Condition b = lock.newCondition();\n    private Condition c = lock.newCondition();\n\n    public void outputA(int round) {\n        try {\n            lock.lock();\n            while (value != 0) {\n                a.await();\n            }\n            value = 1;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出A\");\n            b.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputB(int round) {\n        try {\n            lock.lock();\n            while (value != 1) {\n                b.await();\n            }\n            value = 2;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出B\");\n            c.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputC(int round) {\n        try {\n            lock.lock();\n            while (value != 2) {\n                c.await();\n            }\n            value = 0;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出C\");\n            a.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo5 s = new Demo5();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputA(i);\n            }\n        }, \"Thread-A\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputB(i);\n            }\n        }, \"Thread-B\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputC(i);\n            }\n        }, \"Thread-C\").start();\n\n    }\n}\n```\n","source":"_posts/Java八股文 - Java并发.md","raw":"---\ntitle: Java八股文 - Java并发\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 15:29:48\ntags:\ntoc: true\nurlname: java-concurrent-programming\n---\n\n> 整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 基础知识\n\n### 并发编程的优缺点\n\n优点：为了能提高程序的执行效率，提高程序运行速度；\n\n缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。\n\n#### 并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\n\n并发编程三要素（线程的安全性问题体现在）：\n\n**原子性**：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）\n\n**可见性**：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）\n\n**有序性**：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）\n\n> volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用`atomicInteger.getAndSet()`原子操作。\n\n### 线程和进程\n\n#### 进程间的通信方式\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；\n2. **有名管道(Names Pipes)**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；\n3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**；\n5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。  \n6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n7. **套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n#### 线程间的同步方式\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；\n2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；\n3. **事件(Event)** ：wait/notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\n\n#### 什么是线程和进程?\n\n**进程**：进程是应用程序的一次运行，每个进程都有自己独立的内存空间；是操作系统资源分配的基本单位；\n\n**线程**：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。\n\n#### 什么是上下文切换?\n\n多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。\n\n当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n#### 守护线程和用户线程有什么区别呢？\n\n- **用户 (User) 线程**：运行在前台，执行具体的任务\n- **守护 (Daemon) 线程**：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作\n\n**注意事项：**\n\n1. `setDaemon(true)`必须在`start()`方法前执行，否则会抛出 `IllegalThreadStateException` 异常\n2. 在守护线程中产生的新线程也是守护线程\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑\n4. 守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。\n\n#### 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\n\nWindows上面用任务管理器看，Linux下可以用 top 这个命令看。\n\n#### 什么是线程死锁\n\n死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。\n\n如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。\n\n![线程死锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png)\n\n下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：\n\n```java\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();\t//资源 1\n    private static Object resource2 = new Object();\t//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过`Thread.sleep(1000)`；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。\n\n#### 形成死锁的四个必要条件是什么\n\n1. 互斥条件：一个资源只能被一个线程占用，直到被该线程释放；\n2. 请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；\n3. 不剥夺条件：线程；已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；\n4. 循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞\n\n#### 如何避免线程死锁\n\n我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n**破坏互斥条件**：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；\n\n**破坏请求与保持条件**：一次性申请所有的资源；\n\n**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，**如果申请不到，可以主动释放它占有的资源**；\n\n**破坏循环等待条件**：靠**按序申请**资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n我们对线程 2 的代码修改成下面这样就不会产生死锁了。\n\n```java\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n```\n\n我们分析一下上面的代码为什么避免了死锁的发生?\n\n线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。\n\n#### 创建线程有哪几种方式？\n\n创建线程有四种方式：\n\n- 继承 Thread 类；\n- 实现 Runnable 接口；\n- 实现 Callable 接口；\n- 使用 Executors 工具类创建线程池\n\n**继承 Thread 类**\n\n1. 定义一个 Thread 类的子类，重写 run 方法\n2. 创建自定义的线程子类对象\n3. 调用子类实例的 start() 方法来启动线程\n\n```java\npublic class Main {\n    static class MyThread extends Thread {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n\n    }\n    public static void main(String[] args) {\n        new MyThread().start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Runnable 接口**\n\n1. 定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法\n2. 创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 对象，**该Thread对象才是真正的线程对象**\n3. 调用线程对象的 start() 方法\n\n```java\npublic class Main {\n    static class MyRunnable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n\n    }\n    public static void main(String[] args) {\n        new Thread(new MyRunnable()).start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Callable 接口**\n\n1. 创建实现 Callable 接口的类 myCallable\n2. ⭐以 myCallable 为参数创建 FutureTask 对象\n3. 将 FutureTask 作为参数创建 Thread 对象\n4. 调用线程对象的 start() 方法\n\n```java\npublic class Main {\n    static class MyCallable implements Callable<Integer> {\n\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(Thread.currentThread().getName() + \" call()方法执行中...\");\n            return 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\n        new Thread(futureTask).start();\n        try {\n            Thread.sleep(10);\n            System.out.println(futureTask.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行完成\");\n    }\n}\n```\n\n**使用 Executors 工具类创建线程池**\n\nExecutors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。\n\n主要有 new[Single/Fixed/Cached/Scheduled]ThreadPool 这四种线程池\n\n```java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" run()方法执行中...\");\n    }\n}\n\npublic class SingleThreadExecutorTest {n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        MyRunnable myRunnable = new MyRunnable();\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(myRunnable);\n        }\n\n        System.out.println(\"线程任务开始执行\");\n        executorService.shutdown();\n    }\n}\n```\n\n#### 说一下 runnable 和 callable 有什么区别？\n\n相同点\n\n- 都是接口\n- 都可以用来实现多线程\n- 都采用 Thread.start() 启动线程\n\n**主要区别**\n\n- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果\n- Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常\n\n#### 线程的 run()和 start()有什么区别？\n\n> start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。\n\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用run()，其实就相当于是调用了一个普通函数而已。\nstart() 只能调用一次，run() 可以重复调用。\n\n#### 什么是 Callable 和 Future?\n\n```java\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nnew Thread(futureTask).start();\n```\n\n将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，\n之后可以用 future 来获取 callable  中 call() 的返回结果。\n\n#### 线程的状态和基本操作\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n#### Java 中用到的线程调度算法是什么？\n\n线程调度是指按照特定机制为多个线程分配 CPU 的使用权。\n\n有两种调度模型：**时间片轮转**模型和**优先级调度**模型。\n\n**Java虚拟机采用优先级调度模型**，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。\n\n#### 请说出与线程同步以及线程调度相关的方法。\n\n（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；\n\n（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；\n\n（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\n\n（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n#### wait() 和 sleep() 有什么区别？\n\n两者都可以暂停线程的执行\n\n- 类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。\n- 释放锁：wait() 释放锁，sleep() 不释放锁。\n- 用途不同：wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。\n- 自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。\n\n#### 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\n\n> 使用 while 判断条件是否得到满足\n\n使用 if 来判断会存在以下问题：\n\n1. 另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。\n\n2. 存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。\n\n\t```java\n\tsynchronized (monitor) {\n\t    //  判断条件谓词是否得到满足\n\t    while(!locked) {\n\t        //  等待唤醒\n\t        monitor.wait();\n\t    }\n\t    //  处理其他的业务逻辑\n\t}\n\t```\n\n#### 为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\n\nJava 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。\n\n#### Thread 类中的 yield 方法有什么作用？\n\n使当前线程从运行状态变为就绪状态。\n\n#### 线程的 sleep()方法和 yield()方法有什么区别？\n\n1. sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；\n\n\tyield()方法只会给**相同或更高优先级**的线程以运行的机会；\n\n2. 线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；\n\n#### 如何停止一个正在运行的线程？\n\n1. 当 run 方法完成后线程终止；\n2. 使用 interrupt 方法中断线程。\n\n#### notify() 和 notifyAll() 有什么区别？\n\n如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n\nnotifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。\n\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n\n#### 如何在两个线程间共享数据？\n\nJava 线程之间的通信由 Java 内存模型（简称JMM）控制：\n\n1. 所有的共享变量都存在主内存中\n2. 每个线程都保存了一份该线程使用到的共享变量的副本\n3. 如果线程A与线程B之间要通信：\n\t1. 线程A将本地内存A中更新过的共享变量刷新到主内存中去\n\t2. 线程B到主内存中去读取线程A之前已经更新过的共享变量。\n\n#### Java 如何实现多线程之间的通讯和协作？\n\nJava中线程通信协作的最常见的两种方式：\n\n1. synchronized 加锁的线程 + Object 类的 wait()/notify()/notifyAll()\n\n2. ReentrantLock 类加锁的线程 + Condition 类的 await()/signal()/signalAll()\n\n#### 同步方法和同步块，哪个是更好的选择？\n\n同步的范围越小越好。\n\n因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。\n\n#### 什么是线程同步和线程互斥，有哪几种实现方式？\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。\n\n实现线程同步的方法\n\n- 同步代码方法 / 方法块：sychronized 关键字修饰的方法 / 代码块\n- 使用特殊变量域 volatile 实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制\n- 使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义\n\n#### 在监视器(Monitor)内部，是如何做线程同步的？\n\n在 Java 虚拟机中，每个对象关联一个**监视器**，为了实现监视器的互斥功能，**每个对象都关联着一把锁**。\n\n一旦方法或者代码块被 **synchronized** 修饰，那么这个部分就放入了监视器的监视区域，**确保一次只能有一个线程执行该部分的代码**，线程在获取锁之前不允许执行该部分的代码\n\n另外 Java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案\n\n#### Java 线程数过多会造成什么问题？\n\n- 消耗过多的 CPU 资源\n\n\t如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。\n\n- 降低 JVM 稳定性\n\n\t在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。\n\n## 并发关键字\n\n### synchronized\n\n#### synchronized 的作用？\n\n在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。\n\n#### 怎么使用 synchronized 关键字\n\n**synchronized关键字最主要的三种使用方式：**\n\n- **修饰实例方法：** 给当前对象实例加锁；\n- **修饰静态方法：** 给当前类加锁；\n- **修饰代码块：**给指定对象加锁，进入同步代码块前要获得指定对象的锁。\n\n**总结：** synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。\n\n#### 双重校验锁实现对象单例（线程安全）\n\n```java\npublic class Singleton {\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        // 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例\n        if (uniqueInstance == null) {\t// 线程1、2、3有可能都进来了\n            //类对象加锁\n            synchronized (Singleton.class) {\t// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化\n                if (uniqueInstance == null) {\t// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n\n}\n```\n\n另外，需要注意 instance采用 volatile 关键字修饰也是很有必要。\n\ninstance 采用 volatile 关键字修饰也是很有必要的，instance = new Singleton() 这段代码其实是分为三步执行：\n\n1. 为 instance 分配内存空间\n2. 初始化 instance\n3. 将 instance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance不为空，因此**返回 T1 实例化但未初始化**的 instance。\n\n#### synchronized 底层实现原理？（监视器monitor）\n\nsynchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。\n\nsynchronized 同步语句块的情况\n\n```java\npublic class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n```\n\n通过JDK 反汇编指令 javap -c -v SynchronizedDemo\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。\n\n为什么会有两个monitorexit呢？（line 19）\n\n这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。**因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。**\n\n#### synchronized 可重入的原理\n\n重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。\n底层原理维护一个**计数器**，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。\n\n#### 什么是自旋\n\n> 不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环\n\n很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为**线程阻塞涉及到用户态和内核态切换的问题开销很大**，而是**在 synchronized 的边界做忙循环**，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n\n#### 多线程中 synchronized 锁升级的原理是什么？\n\n> 目的：锁升级是为了减低了锁带来的性能消耗。\n\nJava 的锁都是基于对象的，Java 对象有对象头，内容包括：\n\n1. Mark Word，存储对象的 hashCode、锁信息等；\n2. Class Metadata Address，存储到对象类型数据的指针；\n3. 数组的长度（如果是数组）\n\n每一个线程在准备获取共享资源时： \n\n第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “**偏向锁**” ；\n\n第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：\n\n- CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；\n- CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。\n\n第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；\n\n第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；\n\n第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 **轻量级锁**的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；\n\n第六步，进入**重量级锁**的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。\n\n#### 线程 B 怎么知道线程 A 修改了变量\n\n* volatile 修饰变量\n\n* synchronized 修饰修改变量的方法\n* lock 对修改变量的代码块加锁\n\n#### synchronized 和 Lock 有什么区别？\n\n- synchronized 是 Java 关键字，而Lock 是个接口；\n- synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；\n- synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；\n- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\n#### synchronized 和 ReentrantLock 区别是什么？\n\n**相同点：**\n\n两者都是可重入锁\n\n“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，**如果不可锁重入的话，就会造成死锁**。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n\n**不同点：**\n\n* synchronized 是关键字，ReentrantLock 是类；\n* ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；\n\n- ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\n- 二者的锁机制其实也是不一样的：\n\tReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word\n\n### volatile\n\n#### 为什么代码会重排序？\n\n在执行程序时，为了**提高性能**，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：\n\n- **在单线程环境下不能改变程序运行的结果；**\n- **存在数据依赖关系的不允许重排序**\n\n需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。\n\n#### as-if-serial 规则和 happens-before 规则的区别\n\n- as-if-serial 规则保证 **单线程** 内程序的执行结果不被改变，happens-before 规则保证 **正确同步的多线程** 程序的执行结果不被改变。\n- as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n\n#### volatile 关键字的作用\n\n对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n#### JMM内存屏障插入策略\n\n**插入屏障**\n\nStoreStore屏障 - volatile 写 - StoreLoad屏障\n\nvolatile读 - LoadLoad屏障 - LoadStore屏障\n\n**volatile 与普通变量的重排序规则**\n\n1. 如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；\n2. 如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；\n3. 如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。\n\n#### volatile 能使得一个非原子操作变成原子操作吗？\n\nvolatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。\n\n#### volatile 修饰符的有过什么实践？\n\n单例模式-双重锁检验里面用 volatile 修饰实例变量。\n\n#### volatile 和 synchronized 的区别是什么？\n\n- volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；\n- volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，\n\t而 synchronized 则可以保证变量的修改原子性和可见性；\n- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；\n- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。synchronized关键字在JavaSE1.6之后进行了主要包括为了**减少获得锁和释放锁带来的性能消耗**而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。\n\n## Lock 体系\n\n### Lock 简介\n\n#### Lock 接口是什么？对比同步它有什么优势？\n\nLock 接口比同步方法和同步块提供了更具扩展性的锁操作。\n\n（1）可以使锁更**公平**\n\n（2）可以使线程在**等待锁的时候响应中断**\n\n（3）可以**让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间**\n\n#### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\n\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。\n\t传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。\n\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n\t乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\n\n#### 什么是 CAS\n\nCAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。\n\n如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。\n\n####  Java实现CAS的原理 - Unsafe类\n\n在Java中，有一个`Unsafe`类，它在`sun.misc`包中。它里面是一些`native`方法（由底层的JVM使用C或者C++去实现），其中就有几个关于CAS的：\n\n```java\nboolean compareAndSwapObject(Object o, long offset,Object expected, Object x);\nboolean compareAndSwapInt(Object o, long offset,int expected,int x);\nboolean compareAndSwapLong(Object o, long offset,long expected,long x);\n```\n\n当然，他们都是`public native`的。\n\nUnsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。\n\nLinux 的 X86 下主要是通过`cmpxchgl`这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用`lock`指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。\n\n当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的`park`和`unpark`， LockSupport类底层就是调用了这两个方法。还有支持反射操作的`allocateInstance()`方法。\n\n#### CAS 会产生什么问题？\n\n1、**ABA 问题**：\n\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。\n\n2、**循环时间长开销大**：\n\n对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。\n\n3、**只能保证一个共享变量的原子操作**：\n\n当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是**对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁**。\n\n#### 死锁与活锁的区别，死锁与饥饿的区别？\n\n> 区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。\n\n死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n\n活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致**一直重复尝试，失败，尝试，失败**。\n\n活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。\n\n饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。\n\nJava 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。\n\n### AQS详解\n\n#### AQS 介绍\n\nAQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。\n\n使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。\n\n#### AQS 原理分析\n\n**如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。\n如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。**\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。\n\n看个AQS(AbstractQueuedSynchronizer)原理图：\n\n![AQS原理图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png)\n\nAQS使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\n```java\nprivate volatile int state;\t// 共享变量，使用volatile修饰保证线程可见性\n```\n\n状态信息通过 protected 类型的 getState，setState，compareAndSetState进行操作\n\n```java\n// 返回同步状态的当前值\nprotected final int getState() {  \n    return state;\n}\n// 设置同步状态的值\nprotected final void setState(int newState) { \n    state = newState;\n}\n// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n**AQS 对资源的共享方式**\n\nAQS定义两种资源共享方式\n\n- **Exclusive**（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：\n\t- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n\t- 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\n- **Share**（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\n**AQS底层使用了模板方法模式**\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器（**模板方法模式**很经典的一个应用）：\n\n1. 使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）\n2. 调用 AQS 的模板方法，会进一步调用使用者重写的方法。\n\n**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**\n\n```java\nisHeldExclusively()\t// 该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)\t// 独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)\t// 独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)\t// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)\t// 共享方式。尝试释放资源，成功则返回true，失败则返回false。\n```\n\n以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。\n\n以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即state=0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\n\n### 读写锁\n\n首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。\n\nReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，**实现了读写的分离，读锁是共享的，写锁是独占的**，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n\n## 并发容器\n\n### ConcurrentHashMap\n\n#### 什么是ConcurrentHashMap？\n\nConcurrentHashMap是Java中的一个**线程安全且高效的HashMap实现**。\n\n那么它到底是如何实现线程安全的？\n\nJDK 1.6版本关键要素：\n\n- segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；\n- segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。\n\nJDK1.8后，ConcurrentHashMap抛弃了原有的 Segment 分段锁，而**采用了 CAS + synchronized 来保证并发安全性**。\n\n插入元素过程：\n\n如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；\n\n如果相应位置的Node不为空，则对该节点加synchronized锁进行插入或更新操作。\n\n### CopyOnWriteArrayList\n\nCopyOnWrite容器即**写时复制的容器**，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。\n\n**CopyOnWriteArrayList 的使用场景**\n\n通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。\n\n**CopyOnWriteArrayList 的缺点**\n\n1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。\n2. **不能用于实时读的场景**，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，**读取到数据可能还是旧的**，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。\n\n### ThreadLocal\n\n#### ThreadLocal的数据结构\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry为 <threadLocal的弱引用，value为强引用> 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。\n\n```java\npublic class ThreadLocalDemo {\n    // private static final ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>(){\n    //     @Override\n    //     protected Integer initialValue() {\n    //         return 0;\n    //     }\n    // };\n\n    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++) {\n            new Thread(() -> {\n                for (int j = 0; j < 5; j++) {\n                    Integer val = threadLocal.get();\n                    threadLocal.set(++val);\n                    System.out.println(Thread.currentThread().getName() + \" ---- \" + val);\n                }\n            }, \"Thread-\" + i).start();\n        }\n\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(Thread.currentThread().getName() + \" ---- \" + threadLocal.get());\n    }\n}\n```\n\n打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后threadLocal.get仍然是0\n\n```java\nThread-1 ---- 1\nThread-0 ---- 1\nThread-1 ---- 2\nThread-0 ---- 2\nThread-1 ---- 3\nThread-1 ---- 4\nThread-1 ---- 5\nThread-0 ---- 3\nThread-0 ---- 4\nThread-0 ---- 5\nmain ---- 0\n```\n\n### ThreadLocal内存泄漏\n\n#### ThreadLocal造成内存泄漏的原因？\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的remove()方法，清理掉 key 为 null 的记录。\n\n### BlockingQueue\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。\n\n在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n\n阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\nJDK7 提供了 7 个阻塞队列。分别是：\n\n> ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\n> LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\n> PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\n> DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n> SynchronousQueue：一个不存储元素的阻塞队列。\n> LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n> LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\nJava 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。\n\nBlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，**当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞**，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。\n\n## 线程池\n\n### Executors 创建四种常见线程池\n\n#### 什么是线程池？有哪几种创建方式？\n\n> 池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是**尽可能减少创建和销毁对象的次数**，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。\n\n线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\n\n（1）Executors.newSingleThreadExecutor：`1, 1, new LinkedBlockingQueue`。所有任务按照**先来先执行**的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）\n\n（2）Executors.newFixedThreadPool：`nCoreThreads, nCoreThreads, new LinkedBlockingQueue`，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）\n\n（3） Executors.newCachedThreadPool：`0, Integer.MAX_VALUE`，不创建核心线程，线程池最大为Integer.MAX_VALUE。（线程池太大导致OOM）\n\nnewCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。\nFixedThreadPool 是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。\n\n（4）Executors.newScheduledThreadPool：`nCoreThreads, Integer.MAX_VALUE`创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n#### 线程池有什么优点？\n\n- 降低资源消耗：重用存在的线程，减少对象创建销毁的开销；\n- 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；\n- 提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。\n\n#### 线程池都有哪些状态？\n\n- RUNNING：接受新的任务提交，处理等待队列中的任务；\n- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；\n- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；\n- TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；\n- TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n#### 在 Java 中 Executor 和 Executors 的区别？\n\n- **Executors 工具类**的不同方法按照我们的需求**创建了不同的线程池**，来满足业务的需求；\n- **Executor 接口对象执行我们的线程任务**，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。\n\n#### 线程池中 submit() 和 execute() 方法有什么区别？\n\n接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而execute()只能执行 Runnable 类型的任务；\n\n返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；\n\n异常处理：submit() 方便 Exception 处理。\n\n### ThreadPoolExecutor 自定义线程池\n\n#### Executors\n\n《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是**通过 ThreadPoolExecutor 的方式**，这样的处理方式让写的同学**更加明确线程池的运行规则，规避资源耗尽的风险**\n\nExecutors 各个方法的弊端：\n\n- newSingleThreadExecutor 和 newFixedThreadPool :\n\t`0, 0`和 `n, n` ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE\n\n\t主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。\n\n- newCachedThreadPool 和 newScheduledThreadPool:\n\t`0, Integer.MAX_VALUE` 和 `n, Integer.MAX_VALUE`\n\n\t主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM\n\nThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定\n\n#### ThreaPoolExecutor \n\n创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。\n\nThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。\n\n#### ThreadPoolExecutor构造函数重要参数分析\n\n**`ThreadPoolExecutor`** **3 个最重要的参数：**\n\n- **`corePoolSize`** ：核心线程数，线程数定义了最小可以同时运行的线程数量\n- **`maximumPoolSize`** ：线程池中允许存在的工作线程的最大数量\n- **`workQueue`**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中\n\n`ThreadPoolExecutor`其他常见参数:\n\n1. **`keepAliveTime`**：非核心线程如果处于闲置状态超过该值，就会被销毁。\n2. **`unit`** ：`keepAliveTime` 闲置销毁时长的时间单位\n3. **`threadFactory`**：为线程池提供创建新线程的线程工厂\n4. **`handler`** ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略\n\n#### ThreadPoolExecutor拒绝策略\n\n**`ThreadPoolExecutor`** **拒绝策略定义:**\n\n如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，`ThreadPoolTaskExecutor` 定义一些策略:\n\n- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。\n- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务。\n- **`ThreadPoolExecutor.DiscardPolicy`**：不处理新任务，直接丢弃掉。\n- **`ThreadPoolExecutor.DiscardOldestPolicy`**： 此策略将丢弃最早的未处理的任务请求。\n\n#### 一个简单的线程池Demo:`Runnable` + `ThreadPoolExecutor`\n\n线程池实现原理\n\n![线程池实现原理](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png)\n\n**总结一下处理流程**\n\n1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 < corePoolSize时）。**注意，这一步需要获得全局锁。**\n2. 线程总数量 >= corePoolSize时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了**线程复用**）。 \n3. 当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**\n4. 缓存队列之前满了， 现在加非核心线程且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。\n\n整个过程如图所示：\n\n为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。\n\n首先创建一个 `Runnable` 接口的实现类（当然也可以是 `Callable` 接口，我们上面也说了两者的区别。）\n\n```java\nimport Java.util.Date;\n\n/**\n * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n */\npublic class MyRunnable implements Runnable {\n\n    private String command;\n\n    public MyRunnable(String s) {\n        this.command = s;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n        processCommand();\n        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n    }\n\n    private void processCommand() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return this.command;\n    }\n}\n```\n\n编写测试程序，我们这里以阿里巴巴推荐的使用 `ThreadPoolExecutor` 构造函数自定义参数的方式来创建线程池。\n\n```java\nimport Java.util.concurrent.ArrayBlockingQueue;\nimport Java.util.concurrent.ThreadPoolExecutor;\nimport Java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolExecutorDemo {\n\n    private static final int CORE_POOL_SIZE = 5;\n    private static final int MAX_POOL_SIZE = 10;\n    private static final int QUEUE_CAPACITY = 100;\n    private static final Long KEEP_ALIVE_TIME = 1L;\n    public static void main(String[] args) {\n\n        //使用阿里巴巴推荐的创建线程池的方式\n        //通过ThreadPoolExecutor构造函数自定义参数创建\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE,\n                MAX_POOL_SIZE,\n                KEEP_ALIVE_TIME,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n                new ThreadPoolExecutor.CallerRunsPolicy());\n\n        for (int i = 0; i < 10; i++) {\n            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n            Runnable worker = new MyRunnable(\"\" + i);\n            //执行Runnable\n            executor.execute(worker);\n        }\n        //终止线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n        }\n        System.out.println(\"Finished all threads\");\n    }\n}\n```\n\n可以看到我们上面的代码指定了：\n\n1. `corePoolSize`: 核心线程数为 5。\n2. `maximumPoolSize` ：最大线程数 10\n3. `keepAliveTime` : 等待时间为 1L。\n4. `unit`: 等待时间的单位为 TimeUnit.SECONDS。\n5. `workQueue`：任务队列为 `ArrayBlockingQueue`，并且容量为 100;\n6. `handler`:饱和策略为 `CallerRunsPolicy`。\n\n**Output：**\n\n```java\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:54 CST 2019\n```\n\n## 并发工具\n\n### CountDownLatch 与 CyclicBarrier\n\nCountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n\n- CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；\n- 调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；\n- CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。\n\n### Semaphore\n\n**Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\n\nSemaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。\n\n## 模拟\n\n### 死锁\n\n```java\npublic class DeadLock {\n    private static Object A = new Object();\n    private static Object B = new Object();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (A) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源B\");\n                synchronized (B) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                }\n            }\n        }, \"线程1\").start();\n\n        new Thread(() -> {\n            synchronized (B) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源A\");\n                synchronized (A) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                }\n            }\n        }, \"线程2\").start();\n    }\n}\n```\n\n> 线程1 已获得资源A\n> 线程2 已获得资源B\n> 线程1 等待获得资源B\n> 线程2 等待获得资源A\n\n### run方法和start方法\n\n```java\npublic class DiffStartRun {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程A\").run();\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程B\").start();\n    }\n}\n```\n\n> main\n> 线程B\n>\n> new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。\n>\n> **总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。**\n\n### 两个线程，交替加减\n\n1. synchronized\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithSync {\n\t    private static int value = 0;\n\t\n\t    private static final Object lock = new Object();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 0) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 1) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t\n\t}\n\t```\n\n2. lock + condition\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithLock {\n\t    private static int value = 0;\n\t\n\t    private static final Lock lock = new ReentrantLock();\n\t\n\t    static Condition a = lock.newCondition();\n\t\n\t    static Condition b = lock.newCondition();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 0) {\n\t                        a.await();\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    b.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 1) {\n\t                        b.await();\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    a.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t}\n\t```\n\n### 三个线程，循环打印\n\n```java\npublic class Demo5 {\n    private int value = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition a = lock.newCondition();\n    private Condition b = lock.newCondition();\n    private Condition c = lock.newCondition();\n\n    public void outputA(int round) {\n        try {\n            lock.lock();\n            while (value != 0) {\n                a.await();\n            }\n            value = 1;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出A\");\n            b.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputB(int round) {\n        try {\n            lock.lock();\n            while (value != 1) {\n                b.await();\n            }\n            value = 2;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出B\");\n            c.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputC(int round) {\n        try {\n            lock.lock();\n            while (value != 2) {\n                c.await();\n            }\n            value = 0;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出C\");\n            a.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo5 s = new Demo5();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputA(i);\n            }\n        }, \"Thread-A\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputB(i);\n            }\n        }, \"Thread-B\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputC(i);\n            }\n        }, \"Thread-C\").start();\n\n    }\n}\n```\n","slug":"Java八股文 - Java并发","published":1,"updated":"2023-01-23T08:47:09.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsit000azvt86vrhhome","content":"<blockquote>\n<p>整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"并发编程的优缺点\"><a href=\"#并发编程的优缺点\" class=\"headerlink\" title=\"并发编程的优缺点\"></a>并发编程的优缺点</h3><p>优点：为了能提高程序的执行效率，提高程序运行速度；</p>\n<p>缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。</p>\n<h4 id=\"并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\"><a href=\"#并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\"></a>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h4><p>并发编程三要素（线程的安全性问题体现在）：</p>\n<p><strong>原子性</strong>：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）</p>\n<p><strong>可见性</strong>：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）</p>\n<p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）</p>\n<blockquote>\n<p>volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用<code>atomicInteger.getAndSet()</code>原子操作。</p>\n</blockquote>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"进程间的通信方式\"><a href=\"#进程间的通信方式\" class=\"headerlink\" title=\"进程间的通信方式\"></a>进程间的通信方式</h4><ol>\n<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；</li>\n<li>**有名管道(Names Pipes)<strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循</strong>先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；</li>\n<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>\n<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</strong>；</li>\n<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。  </li>\n<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>\n<li>**套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h4 id=\"线程间的同步方式\"><a href=\"#线程间的同步方式\" class=\"headerlink\" title=\"线程间的同步方式\"></a>线程间的同步方式</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<ol>\n<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</li>\n<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；</li>\n<li><strong>事件(Event)</strong> ：wait&#x2F;notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>\n</ol>\n<h4 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程?\"></a>什么是线程和进程?</h4><p><strong>进程</strong>：进程是应用程序的一次运行，每个进程都有自己独立的内存空间；是操作系统资源分配的基本单位；</p>\n<p><strong>线程</strong>：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。</p>\n<h4 id=\"什么是上下文切换\"><a href=\"#什么是上下文切换\" class=\"headerlink\" title=\"什么是上下文切换?\"></a>什么是上下文切换?</h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<h4 id=\"守护线程和用户线程有什么区别呢？\"><a href=\"#守护线程和用户线程有什么区别呢？\" class=\"headerlink\" title=\"守护线程和用户线程有什么区别呢？\"></a>守护线程和用户线程有什么区别呢？</h4><ul>\n<li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务</li>\n<li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常</li>\n<li>在守护线程中产生的新线程也是守护线程</li>\n<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li>\n<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li>\n</ol>\n<h4 id=\"如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\"><a href=\"#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\" class=\"headerlink\" title=\"如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h4><p>Windows上面用任务管理器看，Linux下可以用 top 这个命令看。</p>\n<h4 id=\"什么是线程死锁\"><a href=\"#什么是线程死锁\" class=\"headerlink\" title=\"什么是线程死锁\"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png\" alt=\"线程死锁\"></p>\n<p>下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLockDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n\n<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000)</code>；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>\n<h4 id=\"形成死锁的四个必要条件是什么\"><a href=\"#形成死锁的四个必要条件是什么\" class=\"headerlink\" title=\"形成死锁的四个必要条件是什么\"></a>形成死锁的四个必要条件是什么</h4><ol>\n<li>互斥条件：一个资源只能被一个线程占用，直到被该线程释放；</li>\n<li>请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；</li>\n<li>不剥夺条件：线程；已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；</li>\n<li>循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞</li>\n</ol>\n<h4 id=\"如何避免线程死锁\"><a href=\"#如何避免线程死锁\" class=\"headerlink\" title=\"如何避免线程死锁\"></a>如何避免线程死锁</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<p><strong>破坏互斥条件</strong>：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；</p>\n<p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源；</p>\n<p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，<strong>如果申请不到，可以主动释放它占有的资源</strong>；</p>\n<p><strong>破坏循环等待条件</strong>：靠<strong>按序申请</strong>资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>\n<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br></pre></td></tr></table></figure>\n\n<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>\n<p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>\n<h4 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h4><p>创建线程有四种方式：</p>\n<ul>\n<li>继承 Thread 类；</li>\n<li>实现 Runnable 接口；</li>\n<li>实现 Callable 接口；</li>\n<li>使用 Executors 工具类创建线程池</li>\n</ul>\n<p><strong>继承 Thread 类</strong></p>\n<ol>\n<li>定义一个 Thread 类的子类，重写 run 方法</li>\n<li>创建自定义的线程子类对象</li>\n<li>调用子类实例的 start() 方法来启动线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>().start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Runnable 接口</strong></p>\n<ol>\n<li>定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法</li>\n<li>创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 对象，<strong>该Thread对象才是真正的线程对象</strong></li>\n<li>调用线程对象的 start() 方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Callable 接口</strong></p>\n<ol>\n<li>创建实现 Callable 接口的类 myCallable</li>\n<li>⭐以 myCallable 为参数创建 FutureTask 对象</li>\n<li>将 FutureTask 作为参数创建 Thread 对象</li>\n<li>调用线程对象的 start() 方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Integer <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; call()方法执行中...&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            System.out.println(futureTask.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 Executors 工具类创建线程池</strong></p>\n<p>Executors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。</p>\n<p>主要有 new[Single&#x2F;Fixed&#x2F;Cached&#x2F;Scheduled]ThreadPool 这四种线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法执行中...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingleThreadExecutorTest</span> &#123;n</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\">        <span class=\"type\">MyRunnable</span> <span class=\"variable\">myRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(myRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程任务开始执行&quot;</span>);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h4><p>相同点</p>\n<ul>\n<li>都是接口</li>\n<li>都可以用来实现多线程</li>\n<li>都采用 Thread.start() 启动线程</li>\n</ul>\n<p><strong>主要区别</strong></p>\n<ul>\n<li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果</li>\n<li>Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常</li>\n</ul>\n<h4 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h4><blockquote>\n<p>start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>\n</blockquote>\n<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用run()，其实就相当于是调用了一个普通函数而已。<br>start() 只能调用一次，run() 可以重复调用。</p>\n<h4 id=\"什么是-Callable-和-Future\"><a href=\"#什么是-Callable-和-Future\" class=\"headerlink\" title=\"什么是 Callable 和 Future?\"></a>什么是 Callable 和 Future?</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br></pre></td></tr></table></figure>\n\n<p>将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，<br>之后可以用 future 来获取 callable  中 call() 的返回结果。</p>\n<h4 id=\"线程的状态和基本操作\"><a href=\"#线程的状态和基本操作\" class=\"headerlink\" title=\"线程的状态和基本操作\"></a>线程的状态和基本操作</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n<h4 id=\"Java-中用到的线程调度算法是什么？\"><a href=\"#Java-中用到的线程调度算法是什么？\" class=\"headerlink\" title=\"Java 中用到的线程调度算法是什么？\"></a>Java 中用到的线程调度算法是什么？</h4><p>线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p>\n<p>有两种调度模型：<strong>时间片轮转</strong>模型和<strong>优先级调度</strong>模型。</p>\n<p><strong>Java虚拟机采用优先级调度模型</strong>，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p>\n<h4 id=\"请说出与线程同步以及线程调度相关的方法。\"><a href=\"#请说出与线程同步以及线程调度相关的方法。\" class=\"headerlink\" title=\"请说出与线程同步以及线程调度相关的方法。\"></a>请说出与线程同步以及线程调度相关的方法。</h4><p>（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；</p>\n<p>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；</p>\n<p>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>\n<p>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>\n<h4 id=\"wait-和-sleep-有什么区别？\"><a href=\"#wait-和-sleep-有什么区别？\" class=\"headerlink\" title=\"wait() 和 sleep() 有什么区别？\"></a>wait() 和 sleep() 有什么区别？</h4><p>两者都可以暂停线程的执行</p>\n<ul>\n<li>类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。</li>\n<li>释放锁：wait() 释放锁，sleep() 不释放锁。</li>\n<li>用途不同：wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li>\n<li>自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li>\n</ul>\n<h4 id=\"你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\"><a href=\"#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\" class=\"headerlink\" title=\"你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><blockquote>\n<p>使用 while 判断条件是否得到满足</p>\n</blockquote>\n<p>使用 if 来判断会存在以下问题：</p>\n<ol>\n<li><p>另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。</p>\n</li>\n<li><p>存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (monitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  判断条件谓词是否得到满足</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!locked) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  等待唤醒</span></span><br><span class=\"line\">        monitor.wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  处理其他的业务逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\"><a href=\"#为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\" class=\"headerlink\" title=\"为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\"></a>为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？</h4><p>Java 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。</p>\n<h4 id=\"Thread-类中的-yield-方法有什么作用？\"><a href=\"#Thread-类中的-yield-方法有什么作用？\" class=\"headerlink\" title=\"Thread 类中的 yield 方法有什么作用？\"></a>Thread 类中的 yield 方法有什么作用？</h4><p>使当前线程从运行状态变为就绪状态。</p>\n<h4 id=\"线程的-sleep-方法和-yield-方法有什么区别？\"><a href=\"#线程的-sleep-方法和-yield-方法有什么区别？\" class=\"headerlink\" title=\"线程的 sleep()方法和 yield()方法有什么区别？\"></a>线程的 sleep()方法和 yield()方法有什么区别？</h4><ol>\n<li><p>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p>\n<p> yield()方法只会给<strong>相同或更高优先级</strong>的线程以运行的机会；</p>\n</li>\n<li><p>线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；</p>\n</li>\n</ol>\n<h4 id=\"如何停止一个正在运行的线程？\"><a href=\"#如何停止一个正在运行的线程？\" class=\"headerlink\" title=\"如何停止一个正在运行的线程？\"></a>如何停止一个正在运行的线程？</h4><ol>\n<li>当 run 方法完成后线程终止；</li>\n<li>使用 interrupt 方法中断线程。</li>\n</ol>\n<h4 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify() 和 notifyAll() 有什么区别？\"></a>notify() 和 notifyAll() 有什么区别？</h4><p>如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>\n<p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p>\n<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>\n<h4 id=\"如何在两个线程间共享数据？\"><a href=\"#如何在两个线程间共享数据？\" class=\"headerlink\" title=\"如何在两个线程间共享数据？\"></a>如何在两个线程间共享数据？</h4><p>Java 线程之间的通信由 Java 内存模型（简称JMM）控制：</p>\n<ol>\n<li>所有的共享变量都存在主内存中</li>\n<li>每个线程都保存了一份该线程使用到的共享变量的副本</li>\n<li>如果线程A与线程B之间要通信：<ol>\n<li>线程A将本地内存A中更新过的共享变量刷新到主内存中去</li>\n<li>线程B到主内存中去读取线程A之前已经更新过的共享变量。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"Java-如何实现多线程之间的通讯和协作？\"><a href=\"#Java-如何实现多线程之间的通讯和协作？\" class=\"headerlink\" title=\"Java 如何实现多线程之间的通讯和协作？\"></a>Java 如何实现多线程之间的通讯和协作？</h4><p>Java中线程通信协作的最常见的两种方式：</p>\n<ol>\n<li><p>synchronized 加锁的线程 + Object 类的 wait()&#x2F;notify()&#x2F;notifyAll()</p>\n</li>\n<li><p>ReentrantLock 类加锁的线程 + Condition 类的 await()&#x2F;signal()&#x2F;signalAll()</p>\n</li>\n</ol>\n<h4 id=\"同步方法和同步块，哪个是更好的选择？\"><a href=\"#同步方法和同步块，哪个是更好的选择？\" class=\"headerlink\" title=\"同步方法和同步块，哪个是更好的选择？\"></a>同步方法和同步块，哪个是更好的选择？</h4><p>同步的范围越小越好。</p>\n<p>因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。</p>\n<h4 id=\"什么是线程同步和线程互斥，有哪几种实现方式？\"><a href=\"#什么是线程同步和线程互斥，有哪几种实现方式？\" class=\"headerlink\" title=\"什么是线程同步和线程互斥，有哪几种实现方式？\"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<p>线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>\n<p>实现线程同步的方法</p>\n<ul>\n<li>同步代码方法 &#x2F; 方法块：sychronized 关键字修饰的方法 &#x2F; 代码块</li>\n<li>使用特殊变量域 volatile 实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li>\n<li>使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义</li>\n</ul>\n<h4 id=\"在监视器-Monitor-内部，是如何做线程同步的？\"><a href=\"#在监视器-Monitor-内部，是如何做线程同步的？\" class=\"headerlink\" title=\"在监视器(Monitor)内部，是如何做线程同步的？\"></a>在监视器(Monitor)内部，是如何做线程同步的？</h4><p>在 Java 虚拟机中，每个对象关联一个<strong>监视器</strong>，为了实现监视器的互斥功能，<strong>每个对象都关联着一把锁</strong>。</p>\n<p>一旦方法或者代码块被 <strong>synchronized</strong> 修饰，那么这个部分就放入了监视器的监视区域，<strong>确保一次只能有一个线程执行该部分的代码</strong>，线程在获取锁之前不允许执行该部分的代码</p>\n<p>另外 Java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p>\n<h4 id=\"Java-线程数过多会造成什么问题？\"><a href=\"#Java-线程数过多会造成什么问题？\" class=\"headerlink\" title=\"Java 线程数过多会造成什么问题？\"></a>Java 线程数过多会造成什么问题？</h4><ul>\n<li><p>消耗过多的 CPU 资源</p>\n<p>  如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。</p>\n</li>\n<li><p>降低 JVM 稳定性</p>\n<p>  在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>\n</li>\n</ul>\n<h2 id=\"并发关键字\"><a href=\"#并发关键字\" class=\"headerlink\" title=\"并发关键字\"></a>并发关键字</h2><h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><h4 id=\"synchronized-的作用？\"><a href=\"#synchronized-的作用？\" class=\"headerlink\" title=\"synchronized 的作用？\"></a>synchronized 的作用？</h4><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。</p>\n<h4 id=\"怎么使用-synchronized-关键字\"><a href=\"#怎么使用-synchronized-关键字\" class=\"headerlink\" title=\"怎么使用 synchronized 关键字\"></a>怎么使用 synchronized 关键字</h4><p><strong>synchronized关键字最主要的三种使用方式：</strong></p>\n<ul>\n<li><strong>修饰实例方法：</strong> 给当前对象实例加锁；</li>\n<li><strong>修饰静态方法：</strong> 给当前类加锁；</li>\n<li><strong>修饰代码块：</strong>给指定对象加锁，进入同步代码块前要获得指定对象的锁。</li>\n</ul>\n<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。</p>\n<h4 id=\"双重校验锁实现对象单例（线程安全）\"><a href=\"#双重校验锁实现对象单例（线程安全）\" class=\"headerlink\" title=\"双重校验锁实现对象单例（线程安全）\"></a>双重校验锁实现对象单例（线程安全）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 线程1、2、3有可能都进来了</span></span><br><span class=\"line\">            <span class=\"comment\">//类对象加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;\t<span class=\"comment\">// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。</span></span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，需要注意 instance采用 volatile 关键字修饰也是很有必要。</p>\n<p>instance 采用 volatile 关键字修饰也是很有必要的，instance &#x3D; new Singleton() 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 instance 分配内存空间</li>\n<li>初始化 instance</li>\n<li>将 instance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance不为空，因此<strong>返回 T1 实例化但未初始化</strong>的 instance。</p>\n<h4 id=\"synchronized-底层实现原理？（监视器monitor）\"><a href=\"#synchronized-底层实现原理？（监视器monitor）\" class=\"headerlink\" title=\"synchronized 底层实现原理？（监视器monitor）\"></a>synchronized 底层实现原理？（监视器monitor）</h4><p>synchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。</p>\n<p>synchronized 同步语句块的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SynchronizedDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;synchronized 代码块&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过JDK 反汇编指令 javap -c -v SynchronizedDemo</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n<p>可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。</p>\n<p>为什么会有两个monitorexit呢？（line 19）</p>\n<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<strong>因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</strong></p>\n<h4 id=\"synchronized-可重入的原理\"><a href=\"#synchronized-可重入的原理\" class=\"headerlink\" title=\"synchronized 可重入的原理\"></a>synchronized 可重入的原理</h4><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。<br>底层原理维护一个<strong>计数器</strong>，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>\n<h4 id=\"什么是自旋\"><a href=\"#什么是自旋\" class=\"headerlink\" title=\"什么是自旋\"></a>什么是自旋</h4><blockquote>\n<p>不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环</p>\n</blockquote>\n<p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为<strong>线程阻塞涉及到用户态和内核态切换的问题开销很大</strong>，而是<strong>在 synchronized 的边界做忙循环</strong>，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<h4 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h4><blockquote>\n<p>目的：锁升级是为了减低了锁带来的性能消耗。</p>\n</blockquote>\n<p>Java 的锁都是基于对象的，Java 对象有对象头，内容包括：</p>\n<ol>\n<li>Mark Word，存储对象的 hashCode、锁信息等；</li>\n<li>Class Metadata Address，存储到对象类型数据的指针；</li>\n<li>数组的长度（如果是数组）</li>\n</ol>\n<p>每一个线程在准备获取共享资源时： </p>\n<p>第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “<strong>偏向锁</strong>” ；</p>\n<p>第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p>\n<ul>\n<li>CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li>\n<li>CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li>\n</ul>\n<p>第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；</p>\n<p>第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；</p>\n<p>第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 <strong>轻量级锁</strong>的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；</p>\n<p>第六步，进入<strong>重量级锁</strong>的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。</p>\n<h4 id=\"线程-B-怎么知道线程-A-修改了变量\"><a href=\"#线程-B-怎么知道线程-A-修改了变量\" class=\"headerlink\" title=\"线程 B 怎么知道线程 A 修改了变量\"></a>线程 B 怎么知道线程 A 修改了变量</h4><ul>\n<li><p>volatile 修饰变量</p>\n</li>\n<li><p>synchronized 修饰修改变量的方法</p>\n</li>\n<li><p>lock 对修改变量的代码块加锁</p>\n</li>\n</ul>\n<h4 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h4><ul>\n<li>synchronized 是 Java 关键字，而Lock 是个接口；</li>\n<li>synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；</li>\n<li>synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h4 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p><strong>相同点：</strong></p>\n<p>两者都是可重入锁</p>\n<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果不可锁重入的话，就会造成死锁</strong>。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>不同点：</strong></p>\n<ul>\n<li>synchronized 是关键字，ReentrantLock 是类；</li>\n<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；</li>\n</ul>\n<ul>\n<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>\n<li>二者的锁机制其实也是不一样的：<br>  ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li>\n</ul>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h4 id=\"为什么代码会重排序？\"><a href=\"#为什么代码会重排序？\" class=\"headerlink\" title=\"为什么代码会重排序？\"></a>为什么代码会重排序？</h4><p>在执行程序时，为了<strong>提高性能</strong>，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>\n<ul>\n<li><strong>在单线程环境下不能改变程序运行的结果；</strong></li>\n<li><strong>存在数据依赖关系的不允许重排序</strong></li>\n</ul>\n<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>\n<h4 id=\"as-if-serial-规则和-happens-before-规则的区别\"><a href=\"#as-if-serial-规则和-happens-before-规则的区别\" class=\"headerlink\" title=\"as-if-serial 规则和 happens-before 规则的区别\"></a>as-if-serial 规则和 happens-before 规则的区别</h4><ul>\n<li>as-if-serial 规则保证 <strong>单线程</strong> 内程序的执行结果不被改变，happens-before 规则保证 <strong>正确同步的多线程</strong> 程序的执行结果不被改变。</li>\n<li>as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li>\n</ul>\n<h4 id=\"volatile-关键字的作用\"><a href=\"#volatile-关键字的作用\" class=\"headerlink\" title=\"volatile 关键字的作用\"></a>volatile 关键字的作用</h4><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<h4 id=\"JMM内存屏障插入策略\"><a href=\"#JMM内存屏障插入策略\" class=\"headerlink\" title=\"JMM内存屏障插入策略\"></a>JMM内存屏障插入策略</h4><p><strong>插入屏障</strong></p>\n<p>StoreStore屏障 - volatile 写 - StoreLoad屏障</p>\n<p>volatile读 - LoadLoad屏障 - LoadStore屏障</p>\n<p><strong>volatile 与普通变量的重排序规则</strong></p>\n<ol>\n<li>如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；</li>\n<li>如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；</li>\n<li>如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。</li>\n</ol>\n<h4 id=\"volatile-能使得一个非原子操作变成原子操作吗？\"><a href=\"#volatile-能使得一个非原子操作变成原子操作吗？\" class=\"headerlink\" title=\"volatile 能使得一个非原子操作变成原子操作吗？\"></a>volatile 能使得一个非原子操作变成原子操作吗？</h4><p>volatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。</p>\n<h4 id=\"volatile-修饰符的有过什么实践？\"><a href=\"#volatile-修饰符的有过什么实践？\" class=\"headerlink\" title=\"volatile 修饰符的有过什么实践？\"></a>volatile 修饰符的有过什么实践？</h4><p>单例模式-双重锁检验里面用 volatile 修饰实例变量。</p>\n<h4 id=\"volatile-和-synchronized-的区别是什么？\"><a href=\"#volatile-和-synchronized-的区别是什么？\" class=\"headerlink\" title=\"volatile 和 synchronized 的区别是什么？\"></a>volatile 和 synchronized 的区别是什么？</h4><ul>\n<li>volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；</li>\n<li>volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，<br>  而 synchronized 则可以保证变量的修改原子性和可见性；</li>\n<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li>\n<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了<strong>减少获得锁和释放锁带来的性能消耗</strong>而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>\n</ul>\n<h2 id=\"Lock-体系\"><a href=\"#Lock-体系\" class=\"headerlink\" title=\"Lock 体系\"></a>Lock 体系</h2><h3 id=\"Lock-简介\"><a href=\"#Lock-简介\" class=\"headerlink\" title=\"Lock 简介\"></a>Lock 简介</h3><h4 id=\"Lock-接口是什么？对比同步它有什么优势？\"><a href=\"#Lock-接口是什么？对比同步它有什么优势？\" class=\"headerlink\" title=\"Lock 接口是什么？对比同步它有什么优势？\"></a>Lock 接口是什么？对比同步它有什么优势？</h4><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。</p>\n<p>（1）可以使锁更<strong>公平</strong></p>\n<p>（2）可以使线程在<strong>等待锁的时候响应中断</strong></p>\n<p>（3）可以<strong>让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</strong></p>\n<h4 id=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"><a href=\"#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\" class=\"headerlink\" title=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<br>    传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>\n<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<br>    乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>\n<h4 id=\"什么是-CAS\"><a href=\"#什么是-CAS\" class=\"headerlink\" title=\"什么是 CAS\"></a>什么是 CAS</h4><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。</p>\n<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。</p>\n<p>如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。</p>\n<h4 id=\"Java实现CAS的原理-Unsafe类\"><a href=\"#Java实现CAS的原理-Unsafe类\" class=\"headerlink\" title=\"Java实现CAS的原理 - Unsafe类\"></a>Java实现CAS的原理 - Unsafe类</h4><p>在Java中，有一个<code>Unsafe</code>类，它在<code>sun.misc</code>包中。它里面是一些<code>native</code>方法（由底层的JVM使用C或者C++去实现），其中就有几个关于CAS的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapObject</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,Object expected, Object x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapInt</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">int</span> expected,<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapLong</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">long</span> expected,<span class=\"type\">long</span> x)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然，他们都是<code>public native</code>的。</p>\n<p>Unsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。</p>\n<p>Linux 的 X86 下主要是通过<code>cmpxchgl</code>这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p>\n<p>当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p>\n<h4 id=\"CAS-会产生什么问题？\"><a href=\"#CAS-会产生什么问题？\" class=\"headerlink\" title=\"CAS 会产生什么问题？\"></a>CAS 会产生什么问题？</h4><p>1、<strong>ABA 问题</strong>：</p>\n<p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>\n<p>2、<strong>循环时间长开销大</strong>：</p>\n<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p>\n<p>3、<strong>只能保证一个共享变量的原子操作</strong>：</p>\n<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是<strong>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁</strong>。</p>\n<h4 id=\"死锁与活锁的区别，死锁与饥饿的区别？\"><a href=\"#死锁与活锁的区别，死锁与饥饿的区别？\" class=\"headerlink\" title=\"死锁与活锁的区别，死锁与饥饿的区别？\"></a>死锁与活锁的区别，死锁与饥饿的区别？</h4><blockquote>\n<p>区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。</p>\n</blockquote>\n<p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致<strong>一直重复尝试，失败，尝试，失败</strong>。</p>\n<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>\n<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>\n<p>Java 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>\n<h3 id=\"AQS详解\"><a href=\"#AQS详解\" class=\"headerlink\" title=\"AQS详解\"></a>AQS详解</h3><h4 id=\"AQS-介绍\"><a href=\"#AQS-介绍\" class=\"headerlink\" title=\"AQS 介绍\"></a>AQS 介绍</h4><p>AQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。</p>\n<p>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>\n<h4 id=\"AQS-原理分析\"><a href=\"#AQS-原理分析\" class=\"headerlink\" title=\"AQS 原理分析\"></a>AQS 原理分析</h4><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。</strong></p>\n<blockquote>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。</p>\n</blockquote>\n<p>看个AQS(AbstractQueuedSynchronizer)原理图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png\" alt=\"AQS原理图\"></p>\n<p>AQS使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;\t<span class=\"comment\">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>\n\n<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回同步状态的当前值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置同步状态的值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(<span class=\"type\">int</span> newState)</span> &#123; </span><br><span class=\"line\">    state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetState</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AQS 对资源的共享方式</strong></p>\n<p>AQS定义两种资源共享方式</p>\n<ul>\n<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>\n</ul>\n</li>\n<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>\n</ul>\n<p><strong>AQS底层使用了模板方法模式</strong></p>\n<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器（<strong>模板方法模式</strong>很经典的一个应用）：</p>\n<ol>\n<li>使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）</li>\n<li>调用 AQS 的模板方法，会进一步调用使用者重写的方法。</li>\n</ol>\n<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isHeldExclusively()\t<span class=\"comment\">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class=\"line\">tryAcquire(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>\n\n<p>以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。</p>\n<p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即state&#x3D;0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p>\n<p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，<strong>实现了读写的分离，读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><h4 id=\"什么是ConcurrentHashMap？\"><a href=\"#什么是ConcurrentHashMap？\" class=\"headerlink\" title=\"什么是ConcurrentHashMap？\"></a>什么是ConcurrentHashMap？</h4><p>ConcurrentHashMap是Java中的一个<strong>线程安全且高效的HashMap实现</strong>。</p>\n<p>那么它到底是如何实现线程安全的？</p>\n<p>JDK 1.6版本关键要素：</p>\n<ul>\n<li>segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；</li>\n<li>segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。</li>\n</ul>\n<p>JDK1.8后，ConcurrentHashMap抛弃了原有的 Segment 分段锁，而<strong>采用了 CAS + synchronized 来保证并发安全性</strong>。</p>\n<p>插入元素过程：</p>\n<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>\n<p>如果相应位置的Node不为空，则对该节点加synchronized锁进行插入或更新操作。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>CopyOnWrite容器即<strong>写时复制的容器</strong>，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>\n<p><strong>CopyOnWriteArrayList 的使用场景</strong></p>\n<p>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p>\n<p><strong>CopyOnWriteArrayList 的缺点</strong></p>\n<ol>\n<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li>\n<li><strong>不能用于实时读的场景</strong>，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，<strong>读取到数据可能还是旧的</strong>，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>\n</ol>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><h4 id=\"ThreadLocal的数据结构\"><a href=\"#ThreadLocal的数据结构\" class=\"headerlink\" title=\"ThreadLocal的数据结构\"></a>ThreadLocal的数据结构</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n<p>每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry为 &lt;threadLocal的弱引用，value为强引用&gt; 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// private static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     @Override</span></span><br><span class=\"line\">    <span class=\"comment\">//     protected Integer initialValue() &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         return 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"type\">Integer</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> threadLocal.get();</span><br><span class=\"line\">                    threadLocal.set(++val);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;Thread-&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + threadLocal.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后threadLocal.get仍然是0</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">main ---- <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><h4 id=\"ThreadLocal造成内存泄漏的原因？\"><a href=\"#ThreadLocal造成内存泄漏的原因？\" class=\"headerlink\" title=\"ThreadLocal造成内存泄漏的原因？\"></a>ThreadLocal造成内存泄漏的原因？</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的remove()方法，清理掉 key 为 null 的记录。</p>\n<h3 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>\n<p>在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>\n<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>\n<p>JDK7 提供了 7 个阻塞队列。分别是：</p>\n<blockquote>\n<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n</blockquote>\n<p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>\n<p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，<strong>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞</strong>，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"Executors-创建四种常见线程池\"><a href=\"#Executors-创建四种常见线程池\" class=\"headerlink\" title=\"Executors 创建四种常见线程池\"></a>Executors 创建四种常见线程池</h3><h4 id=\"什么是线程池？有哪几种创建方式？\"><a href=\"#什么是线程池？有哪几种创建方式？\" class=\"headerlink\" title=\"什么是线程池？有哪几种创建方式？\"></a>什么是线程池？有哪几种创建方式？</h4><blockquote>\n<p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是<strong>尽可能减少创建和销毁对象的次数</strong>，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>\n<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>\n<p>（1）Executors.newSingleThreadExecutor：<code>1, 1, new LinkedBlockingQueue</code>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）</p>\n<p>（2）Executors.newFixedThreadPool：<code>nCoreThreads, nCoreThreads, new LinkedBlockingQueue</code>，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）</p>\n<p>（3） Executors.newCachedThreadPool：<code>0, Integer.MAX_VALUE</code>，不创建核心线程，线程池最大为Integer.MAX_VALUE。（线程池太大导致OOM）</p>\n<p>newCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。<br>FixedThreadPool 是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</p>\n<p>（4）Executors.newScheduledThreadPool：<code>nCoreThreads, Integer.MAX_VALUE</code>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<h4 id=\"线程池有什么优点？\"><a href=\"#线程池有什么优点？\" class=\"headerlink\" title=\"线程池有什么优点？\"></a>线程池有什么优点？</h4><ul>\n<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销；</li>\n<li>提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；</li>\n<li>提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h4 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h4><ul>\n<li>RUNNING：接受新的任务提交，处理等待队列中的任务；</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；</li>\n<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>\n</ul>\n<h4 id=\"在-Java-中-Executor-和-Executors-的区别？\"><a href=\"#在-Java-中-Executor-和-Executors-的区别？\" class=\"headerlink\" title=\"在 Java 中 Executor 和 Executors 的区别？\"></a>在 Java 中 Executor 和 Executors 的区别？</h4><ul>\n<li><strong>Executors 工具类</strong>的不同方法按照我们的需求<strong>创建了不同的线程池</strong>，来满足业务的需求；</li>\n<li><strong>Executor 接口对象执行我们的线程任务</strong>，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>\n</ul>\n<h4 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit() 和 execute() 方法有什么区别？\"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><p>接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而execute()只能执行 Runnable 类型的任务；</p>\n<p>返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；</p>\n<p>异常处理：submit() 方便 Exception 处理。</p>\n<h3 id=\"ThreadPoolExecutor-自定义线程池\"><a href=\"#ThreadPoolExecutor-自定义线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 自定义线程池\"></a>ThreadPoolExecutor 自定义线程池</h3><h4 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h4><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是<strong>通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让写的同学<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<p>Executors 各个方法的弊端：</p>\n<ul>\n<li><p>newSingleThreadExecutor 和 newFixedThreadPool :<br>  <code>0, 0</code>和 <code>n, n</code> ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE</p>\n<p>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</p>\n</li>\n<li><p>newCachedThreadPool 和 newScheduledThreadPool:<br>  <code>0, Integer.MAX_VALUE</code> 和 <code>n, Integer.MAX_VALUE</code></p>\n<p>  主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM</p>\n</li>\n</ul>\n<p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>\n<h4 id=\"ThreaPoolExecutor\"><a href=\"#ThreaPoolExecutor\" class=\"headerlink\" title=\"ThreaPoolExecutor\"></a>ThreaPoolExecutor</h4><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p>\n<p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p>\n<h4 id=\"ThreadPoolExecutor构造函数重要参数分析\"><a href=\"#ThreadPoolExecutor构造函数重要参数分析\" class=\"headerlink\" title=\"ThreadPoolExecutor构造函数重要参数分析\"></a>ThreadPoolExecutor构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code></strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量</li>\n<li><strong><code>maximumPoolSize</code></strong> ：线程池中允许存在的工作线程的最大数量</li>\n<li>**<code>workQueue</code>**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数:</p>\n<ol>\n<li>**<code>keepAliveTime</code>**：非核心线程如果处于闲置状态超过该值，就会被销毁。</li>\n<li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 闲置销毁时长的时间单位</li>\n<li>**<code>threadFactory</code>**：为线程池提供创建新线程的线程工厂</li>\n<li><strong><code>handler</code></strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li>\n</ol>\n<h4 id=\"ThreadPoolExecutor拒绝策略\"><a href=\"#ThreadPoolExecutor拒绝策略\" class=\"headerlink\" title=\"ThreadPoolExecutor拒绝策略\"></a>ThreadPoolExecutor拒绝策略</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>拒绝策略定义:</strong></p>\n<p>如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>\n<ul>\n<li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：调用执行自己的线程运行任务。</li>\n<li>**<code>ThreadPoolExecutor.DiscardPolicy</code>**：不处理新任务，直接丢弃掉。</li>\n<li>**<code>ThreadPoolExecutor.DiscardOldestPolicy</code>**： 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<h4 id=\"一个简单的线程池Demo-Runnable-ThreadPoolExecutor\"><a href=\"#一个简单的线程池Demo-Runnable-ThreadPoolExecutor\" class=\"headerlink\" title=\"一个简单的线程池Demo:Runnable + ThreadPoolExecutor\"></a>一个简单的线程池Demo:<code>Runnable</code> + <code>ThreadPoolExecutor</code></h4><p>线程池实现原理</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png\" alt=\"线程池实现原理\"></p>\n<p><strong>总结一下处理流程</strong></p>\n<ol>\n<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。 </li>\n<li>当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>缓存队列之前满了， 现在加非核心线程且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>\n</ol>\n<p>整个过程如图所示：</p>\n<p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>\n<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String command;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyRunnable</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.command = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; Start. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">        processCommand();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; End. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processCommand</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.command;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolExecutorDemo</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CORE_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">QUEUE_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">KEEP_ALIVE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class=\"line\">        <span class=\"comment\">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class=\"line\">        <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                CORE_POOL_SIZE,</span><br><span class=\"line\">                MAX_POOL_SIZE,</span><br><span class=\"line\">                KEEP_ALIVE_TIME,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class=\"line\">            <span class=\"type\">Runnable</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>(<span class=\"string\">&quot;&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">//执行Runnable</span></span><br><span class=\"line\">            executor.execute(worker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//终止线程池</span></span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!executor.isTerminated()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Finished all threads&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们上面的代码指定了：</p>\n<ol>\n<li><code>corePoolSize</code>: 核心线程数为 5。</li>\n<li><code>maximumPoolSize</code> ：最大线程数 10</li>\n<li><code>keepAliveTime</code> : 等待时间为 1L。</li>\n<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>\n<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>\n<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>\n</ol>\n<p><strong>Output：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><h3 id=\"CountDownLatch-与-CyclicBarrier\"><a href=\"#CountDownLatch-与-CyclicBarrier\" class=\"headerlink\" title=\"CountDownLatch 与 CyclicBarrier\"></a>CountDownLatch 与 CyclicBarrier</h3><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>\n<ul>\n<li>CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；</li>\n<li>调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>\n<li>CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。</li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</p>\n<p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。</p>\n<h2 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h2><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">A</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">B</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>线程1 已获得资源A<br>线程2 已获得资源B<br>线程1 等待获得资源B<br>线程2 等待获得资源A</p>\n</blockquote>\n<h3 id=\"run方法和start方法\"><a href=\"#run方法和start方法\" class=\"headerlink\" title=\"run方法和start方法\"></a>run方法和start方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DiffStartRun</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程A&quot;</span>).run();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>main<br>线程B</p>\n<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>\n</blockquote>\n<h3 id=\"两个线程，交替加减\"><a href=\"#两个线程，交替加减\" class=\"headerlink\" title=\"两个线程，交替加减\"></a>两个线程，交替加减</h3><ol>\n<li><p>synchronized</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithSync</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lock + condition</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        a.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    b.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        b.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    a.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"三个线程，循环打印\"><a href=\"#三个线程，循环打印\" class=\"headerlink\" title=\"三个线程，循环打印\"></a>三个线程，循环打印</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo5</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputA</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                a.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">1</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出A&quot;</span>);</span><br><span class=\"line\">            b.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputB</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                b.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">2</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出B&quot;</span>);</span><br><span class=\"line\">            c.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputC</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                c.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">0</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出C&quot;</span>);</span><br><span class=\"line\">            a.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Demo5</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo5</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputA(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputB(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputC(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-C&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":35754,"excerpt":"<blockquote>\n<p>整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"并发编程的优缺点\"><a href=\"#并发编程的优缺点\" class=\"headerlink\" title=\"并发编程的优缺点\"></a>并发编程的优缺点</h3><p>优点：为了能提高程序的执行效率，提高程序运行速度；</p>\n<p>缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。</p>\n<h4 id=\"并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\"><a href=\"#并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\"></a>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h4><p>并发编程三要素（线程的安全性问题体现在）：</p>\n<p><strong>原子性</strong>：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）</p>\n<p><strong>可见性</strong>：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）</p>\n<p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）</p>\n<blockquote>\n<p>volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用<code>atomicInteger.getAndSet()</code>原子操作。</p>\n</blockquote>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"进程间的通信方式\"><a href=\"#进程间的通信方式\" class=\"headerlink\" title=\"进程间的通信方式\"></a>进程间的通信方式</h4><ol>\n<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；</li>\n<li>**有名管道(Names Pipes)<strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循</strong>先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；</li>\n<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>\n<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</strong>；</li>\n<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。  </li>\n<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>\n<li>**套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h4 id=\"线程间的同步方式\"><a href=\"#线程间的同步方式\" class=\"headerlink\" title=\"线程间的同步方式\"></a>线程间的同步方式</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<ol>\n<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</li>\n<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；</li>\n<li><strong>事件(Event)</strong> ：wait&#x2F;notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>\n</ol>\n<h4 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程?\"></a>什么是线程和进程?</h4><p><strong>进程</strong>：进程是应用程序的一次运行，每个进程都有自己独立的内存空间；是操作系统资源分配的基本单位；</p>\n<p><strong>线程</strong>：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。</p>\n<h4 id=\"什么是上下文切换\"><a href=\"#什么是上下文切换\" class=\"headerlink\" title=\"什么是上下文切换?\"></a>什么是上下文切换?</h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<h4 id=\"守护线程和用户线程有什么区别呢？\"><a href=\"#守护线程和用户线程有什么区别呢？\" class=\"headerlink\" title=\"守护线程和用户线程有什么区别呢？\"></a>守护线程和用户线程有什么区别呢？</h4><ul>\n<li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务</li>\n<li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常</li>\n<li>在守护线程中产生的新线程也是守护线程</li>\n<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li>\n<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li>\n</ol>\n<h4 id=\"如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\"><a href=\"#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\" class=\"headerlink\" title=\"如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h4><p>Windows上面用任务管理器看，Linux下可以用 top 这个命令看。</p>\n<h4 id=\"什么是线程死锁\"><a href=\"#什么是线程死锁\" class=\"headerlink\" title=\"什么是线程死锁\"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png\" alt=\"线程死锁\"></p>\n<p>下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLockDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n\n<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000)</code>；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>\n<h4 id=\"形成死锁的四个必要条件是什么\"><a href=\"#形成死锁的四个必要条件是什么\" class=\"headerlink\" title=\"形成死锁的四个必要条件是什么\"></a>形成死锁的四个必要条件是什么</h4><ol>\n<li>互斥条件：一个资源只能被一个线程占用，直到被该线程释放；</li>\n<li>请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；</li>\n<li>不剥夺条件：线程；已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；</li>\n<li>循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞</li>\n</ol>\n<h4 id=\"如何避免线程死锁\"><a href=\"#如何避免线程死锁\" class=\"headerlink\" title=\"如何避免线程死锁\"></a>如何避免线程死锁</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<p><strong>破坏互斥条件</strong>：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；</p>\n<p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源；</p>\n<p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，<strong>如果申请不到，可以主动释放它占有的资源</strong>；</p>\n<p><strong>破坏循环等待条件</strong>：靠<strong>按序申请</strong>资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>\n<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br></pre></td></tr></table></figure>\n\n<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>\n<p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>\n<h4 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h4><p>创建线程有四种方式：</p>\n<ul>\n<li>继承 Thread 类；</li>\n<li>实现 Runnable 接口；</li>\n<li>实现 Callable 接口；</li>\n<li>使用 Executors 工具类创建线程池</li>\n</ul>\n<p><strong>继承 Thread 类</strong></p>\n<ol>\n<li>定义一个 Thread 类的子类，重写 run 方法</li>\n<li>创建自定义的线程子类对象</li>\n<li>调用子类实例的 start() 方法来启动线程</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>().start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Runnable 接口</strong></p>\n<ol>\n<li>定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法</li>\n<li>创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 对象，<strong>该Thread对象才是真正的线程对象</strong></li>\n<li>调用线程对象的 start() 方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Callable 接口</strong></p>\n<ol>\n<li>创建实现 Callable 接口的类 myCallable</li>\n<li>⭐以 myCallable 为参数创建 FutureTask 对象</li>\n<li>将 FutureTask 作为参数创建 Thread 对象</li>\n<li>调用线程对象的 start() 方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;Integer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Integer <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; call()方法执行中...&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            System.out.println(futureTask.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 Executors 工具类创建线程池</strong></p>\n<p>Executors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。</p>\n<p>主要有 new[Single&#x2F;Fixed&#x2F;Cached&#x2F;Scheduled]ThreadPool 这四种线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法执行中...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingleThreadExecutorTest</span> &#123;n</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\">        <span class=\"type\">MyRunnable</span> <span class=\"variable\">myRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(myRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程任务开始执行&quot;</span>);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h4><p>相同点</p>\n<ul>\n<li>都是接口</li>\n<li>都可以用来实现多线程</li>\n<li>都采用 Thread.start() 启动线程</li>\n</ul>\n<p><strong>主要区别</strong></p>\n<ul>\n<li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果</li>\n<li>Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常</li>\n</ul>\n<h4 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h4><blockquote>\n<p>start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>\n</blockquote>\n<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用run()，其实就相当于是调用了一个普通函数而已。<br>start() 只能调用一次，run() 可以重复调用。</p>\n<h4 id=\"什么是-Callable-和-Future\"><a href=\"#什么是-Callable-和-Future\" class=\"headerlink\" title=\"什么是 Callable 和 Future?\"></a>什么是 Callable 和 Future?</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br></pre></td></tr></table></figure>\n\n<p>将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，<br>之后可以用 future 来获取 callable  中 call() 的返回结果。</p>\n<h4 id=\"线程的状态和基本操作\"><a href=\"#线程的状态和基本操作\" class=\"headerlink\" title=\"线程的状态和基本操作\"></a>线程的状态和基本操作</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n<h4 id=\"Java-中用到的线程调度算法是什么？\"><a href=\"#Java-中用到的线程调度算法是什么？\" class=\"headerlink\" title=\"Java 中用到的线程调度算法是什么？\"></a>Java 中用到的线程调度算法是什么？</h4><p>线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p>\n<p>有两种调度模型：<strong>时间片轮转</strong>模型和<strong>优先级调度</strong>模型。</p>\n<p><strong>Java虚拟机采用优先级调度模型</strong>，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p>\n<h4 id=\"请说出与线程同步以及线程调度相关的方法。\"><a href=\"#请说出与线程同步以及线程调度相关的方法。\" class=\"headerlink\" title=\"请说出与线程同步以及线程调度相关的方法。\"></a>请说出与线程同步以及线程调度相关的方法。</h4><p>（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；</p>\n<p>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；</p>\n<p>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>\n<p>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>\n<h4 id=\"wait-和-sleep-有什么区别？\"><a href=\"#wait-和-sleep-有什么区别？\" class=\"headerlink\" title=\"wait() 和 sleep() 有什么区别？\"></a>wait() 和 sleep() 有什么区别？</h4><p>两者都可以暂停线程的执行</p>\n<ul>\n<li>类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。</li>\n<li>释放锁：wait() 释放锁，sleep() 不释放锁。</li>\n<li>用途不同：wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li>\n<li>自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li>\n</ul>\n<h4 id=\"你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\"><a href=\"#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\" class=\"headerlink\" title=\"你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><blockquote>\n<p>使用 while 判断条件是否得到满足</p>\n</blockquote>\n<p>使用 if 来判断会存在以下问题：</p>\n<ol>\n<li><p>另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。</p>\n</li>\n<li><p>存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (monitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  判断条件谓词是否得到满足</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!locked) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  等待唤醒</span></span><br><span class=\"line\">        monitor.wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  处理其他的业务逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\"><a href=\"#为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\" class=\"headerlink\" title=\"为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\"></a>为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？</h4><p>Java 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。</p>\n<h4 id=\"Thread-类中的-yield-方法有什么作用？\"><a href=\"#Thread-类中的-yield-方法有什么作用？\" class=\"headerlink\" title=\"Thread 类中的 yield 方法有什么作用？\"></a>Thread 类中的 yield 方法有什么作用？</h4><p>使当前线程从运行状态变为就绪状态。</p>\n<h4 id=\"线程的-sleep-方法和-yield-方法有什么区别？\"><a href=\"#线程的-sleep-方法和-yield-方法有什么区别？\" class=\"headerlink\" title=\"线程的 sleep()方法和 yield()方法有什么区别？\"></a>线程的 sleep()方法和 yield()方法有什么区别？</h4><ol>\n<li><p>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p>\n<p> yield()方法只会给<strong>相同或更高优先级</strong>的线程以运行的机会；</p>\n</li>\n<li><p>线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；</p>\n</li>\n</ol>\n<h4 id=\"如何停止一个正在运行的线程？\"><a href=\"#如何停止一个正在运行的线程？\" class=\"headerlink\" title=\"如何停止一个正在运行的线程？\"></a>如何停止一个正在运行的线程？</h4><ol>\n<li>当 run 方法完成后线程终止；</li>\n<li>使用 interrupt 方法中断线程。</li>\n</ol>\n<h4 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify() 和 notifyAll() 有什么区别？\"></a>notify() 和 notifyAll() 有什么区别？</h4><p>如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>\n<p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p>\n<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>\n<h4 id=\"如何在两个线程间共享数据？\"><a href=\"#如何在两个线程间共享数据？\" class=\"headerlink\" title=\"如何在两个线程间共享数据？\"></a>如何在两个线程间共享数据？</h4><p>Java 线程之间的通信由 Java 内存模型（简称JMM）控制：</p>\n<ol>\n<li>所有的共享变量都存在主内存中</li>\n<li>每个线程都保存了一份该线程使用到的共享变量的副本</li>\n<li>如果线程A与线程B之间要通信：<ol>\n<li>线程A将本地内存A中更新过的共享变量刷新到主内存中去</li>\n<li>线程B到主内存中去读取线程A之前已经更新过的共享变量。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"Java-如何实现多线程之间的通讯和协作？\"><a href=\"#Java-如何实现多线程之间的通讯和协作？\" class=\"headerlink\" title=\"Java 如何实现多线程之间的通讯和协作？\"></a>Java 如何实现多线程之间的通讯和协作？</h4><p>Java中线程通信协作的最常见的两种方式：</p>\n<ol>\n<li><p>synchronized 加锁的线程 + Object 类的 wait()&#x2F;notify()&#x2F;notifyAll()</p>\n</li>\n<li><p>ReentrantLock 类加锁的线程 + Condition 类的 await()&#x2F;signal()&#x2F;signalAll()</p>\n</li>\n</ol>\n<h4 id=\"同步方法和同步块，哪个是更好的选择？\"><a href=\"#同步方法和同步块，哪个是更好的选择？\" class=\"headerlink\" title=\"同步方法和同步块，哪个是更好的选择？\"></a>同步方法和同步块，哪个是更好的选择？</h4><p>同步的范围越小越好。</p>\n<p>因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。</p>\n<h4 id=\"什么是线程同步和线程互斥，有哪几种实现方式？\"><a href=\"#什么是线程同步和线程互斥，有哪几种实现方式？\" class=\"headerlink\" title=\"什么是线程同步和线程互斥，有哪几种实现方式？\"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<p>线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>\n<p>实现线程同步的方法</p>\n<ul>\n<li>同步代码方法 &#x2F; 方法块：sychronized 关键字修饰的方法 &#x2F; 代码块</li>\n<li>使用特殊变量域 volatile 实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li>\n<li>使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义</li>\n</ul>\n<h4 id=\"在监视器-Monitor-内部，是如何做线程同步的？\"><a href=\"#在监视器-Monitor-内部，是如何做线程同步的？\" class=\"headerlink\" title=\"在监视器(Monitor)内部，是如何做线程同步的？\"></a>在监视器(Monitor)内部，是如何做线程同步的？</h4><p>在 Java 虚拟机中，每个对象关联一个<strong>监视器</strong>，为了实现监视器的互斥功能，<strong>每个对象都关联着一把锁</strong>。</p>\n<p>一旦方法或者代码块被 <strong>synchronized</strong> 修饰，那么这个部分就放入了监视器的监视区域，<strong>确保一次只能有一个线程执行该部分的代码</strong>，线程在获取锁之前不允许执行该部分的代码</p>\n<p>另外 Java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p>\n<h4 id=\"Java-线程数过多会造成什么问题？\"><a href=\"#Java-线程数过多会造成什么问题？\" class=\"headerlink\" title=\"Java 线程数过多会造成什么问题？\"></a>Java 线程数过多会造成什么问题？</h4><ul>\n<li><p>消耗过多的 CPU 资源</p>\n<p>  如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。</p>\n</li>\n<li><p>降低 JVM 稳定性</p>\n<p>  在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>\n</li>\n</ul>\n<h2 id=\"并发关键字\"><a href=\"#并发关键字\" class=\"headerlink\" title=\"并发关键字\"></a>并发关键字</h2><h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><h4 id=\"synchronized-的作用？\"><a href=\"#synchronized-的作用？\" class=\"headerlink\" title=\"synchronized 的作用？\"></a>synchronized 的作用？</h4><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。</p>\n<h4 id=\"怎么使用-synchronized-关键字\"><a href=\"#怎么使用-synchronized-关键字\" class=\"headerlink\" title=\"怎么使用 synchronized 关键字\"></a>怎么使用 synchronized 关键字</h4><p><strong>synchronized关键字最主要的三种使用方式：</strong></p>\n<ul>\n<li><strong>修饰实例方法：</strong> 给当前对象实例加锁；</li>\n<li><strong>修饰静态方法：</strong> 给当前类加锁；</li>\n<li><strong>修饰代码块：</strong>给指定对象加锁，进入同步代码块前要获得指定对象的锁。</li>\n</ul>\n<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。</p>\n<h4 id=\"双重校验锁实现对象单例（线程安全）\"><a href=\"#双重校验锁实现对象单例（线程安全）\" class=\"headerlink\" title=\"双重校验锁实现对象单例（线程安全）\"></a>双重校验锁实现对象单例（线程安全）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 线程1、2、3有可能都进来了</span></span><br><span class=\"line\">            <span class=\"comment\">//类对象加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;\t<span class=\"comment\">// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。</span></span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，需要注意 instance采用 volatile 关键字修饰也是很有必要。</p>\n<p>instance 采用 volatile 关键字修饰也是很有必要的，instance &#x3D; new Singleton() 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 instance 分配内存空间</li>\n<li>初始化 instance</li>\n<li>将 instance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance不为空，因此<strong>返回 T1 实例化但未初始化</strong>的 instance。</p>\n<h4 id=\"synchronized-底层实现原理？（监视器monitor）\"><a href=\"#synchronized-底层实现原理？（监视器monitor）\" class=\"headerlink\" title=\"synchronized 底层实现原理？（监视器monitor）\"></a>synchronized 底层实现原理？（监视器monitor）</h4><p>synchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。</p>\n<p>synchronized 同步语句块的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SynchronizedDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;synchronized 代码块&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过JDK 反汇编指令 javap -c -v SynchronizedDemo</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n<p>可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。</p>\n<p>为什么会有两个monitorexit呢？（line 19）</p>\n<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<strong>因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</strong></p>\n<h4 id=\"synchronized-可重入的原理\"><a href=\"#synchronized-可重入的原理\" class=\"headerlink\" title=\"synchronized 可重入的原理\"></a>synchronized 可重入的原理</h4><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。<br>底层原理维护一个<strong>计数器</strong>，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>\n<h4 id=\"什么是自旋\"><a href=\"#什么是自旋\" class=\"headerlink\" title=\"什么是自旋\"></a>什么是自旋</h4><blockquote>\n<p>不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环</p>\n</blockquote>\n<p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为<strong>线程阻塞涉及到用户态和内核态切换的问题开销很大</strong>，而是<strong>在 synchronized 的边界做忙循环</strong>，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<h4 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h4><blockquote>\n<p>目的：锁升级是为了减低了锁带来的性能消耗。</p>\n</blockquote>\n<p>Java 的锁都是基于对象的，Java 对象有对象头，内容包括：</p>\n<ol>\n<li>Mark Word，存储对象的 hashCode、锁信息等；</li>\n<li>Class Metadata Address，存储到对象类型数据的指针；</li>\n<li>数组的长度（如果是数组）</li>\n</ol>\n<p>每一个线程在准备获取共享资源时： </p>\n<p>第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “<strong>偏向锁</strong>” ；</p>\n<p>第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p>\n<ul>\n<li>CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li>\n<li>CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li>\n</ul>\n<p>第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；</p>\n<p>第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；</p>\n<p>第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 <strong>轻量级锁</strong>的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；</p>\n<p>第六步，进入<strong>重量级锁</strong>的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。</p>\n<h4 id=\"线程-B-怎么知道线程-A-修改了变量\"><a href=\"#线程-B-怎么知道线程-A-修改了变量\" class=\"headerlink\" title=\"线程 B 怎么知道线程 A 修改了变量\"></a>线程 B 怎么知道线程 A 修改了变量</h4><ul>\n<li><p>volatile 修饰变量</p>\n</li>\n<li><p>synchronized 修饰修改变量的方法</p>\n</li>\n<li><p>lock 对修改变量的代码块加锁</p>\n</li>\n</ul>\n<h4 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h4><ul>\n<li>synchronized 是 Java 关键字，而Lock 是个接口；</li>\n<li>synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；</li>\n<li>synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h4 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p><strong>相同点：</strong></p>\n<p>两者都是可重入锁</p>\n<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果不可锁重入的话，就会造成死锁</strong>。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>不同点：</strong></p>\n<ul>\n<li>synchronized 是关键字，ReentrantLock 是类；</li>\n<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；</li>\n</ul>\n<ul>\n<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>\n<li>二者的锁机制其实也是不一样的：<br>  ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li>\n</ul>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h4 id=\"为什么代码会重排序？\"><a href=\"#为什么代码会重排序？\" class=\"headerlink\" title=\"为什么代码会重排序？\"></a>为什么代码会重排序？</h4><p>在执行程序时，为了<strong>提高性能</strong>，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>\n<ul>\n<li><strong>在单线程环境下不能改变程序运行的结果；</strong></li>\n<li><strong>存在数据依赖关系的不允许重排序</strong></li>\n</ul>\n<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>\n<h4 id=\"as-if-serial-规则和-happens-before-规则的区别\"><a href=\"#as-if-serial-规则和-happens-before-规则的区别\" class=\"headerlink\" title=\"as-if-serial 规则和 happens-before 规则的区别\"></a>as-if-serial 规则和 happens-before 规则的区别</h4><ul>\n<li>as-if-serial 规则保证 <strong>单线程</strong> 内程序的执行结果不被改变，happens-before 规则保证 <strong>正确同步的多线程</strong> 程序的执行结果不被改变。</li>\n<li>as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li>\n</ul>\n<h4 id=\"volatile-关键字的作用\"><a href=\"#volatile-关键字的作用\" class=\"headerlink\" title=\"volatile 关键字的作用\"></a>volatile 关键字的作用</h4><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<h4 id=\"JMM内存屏障插入策略\"><a href=\"#JMM内存屏障插入策略\" class=\"headerlink\" title=\"JMM内存屏障插入策略\"></a>JMM内存屏障插入策略</h4><p><strong>插入屏障</strong></p>\n<p>StoreStore屏障 - volatile 写 - StoreLoad屏障</p>\n<p>volatile读 - LoadLoad屏障 - LoadStore屏障</p>\n<p><strong>volatile 与普通变量的重排序规则</strong></p>\n<ol>\n<li>如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；</li>\n<li>如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；</li>\n<li>如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。</li>\n</ol>\n<h4 id=\"volatile-能使得一个非原子操作变成原子操作吗？\"><a href=\"#volatile-能使得一个非原子操作变成原子操作吗？\" class=\"headerlink\" title=\"volatile 能使得一个非原子操作变成原子操作吗？\"></a>volatile 能使得一个非原子操作变成原子操作吗？</h4><p>volatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。</p>\n<h4 id=\"volatile-修饰符的有过什么实践？\"><a href=\"#volatile-修饰符的有过什么实践？\" class=\"headerlink\" title=\"volatile 修饰符的有过什么实践？\"></a>volatile 修饰符的有过什么实践？</h4><p>单例模式-双重锁检验里面用 volatile 修饰实例变量。</p>\n<h4 id=\"volatile-和-synchronized-的区别是什么？\"><a href=\"#volatile-和-synchronized-的区别是什么？\" class=\"headerlink\" title=\"volatile 和 synchronized 的区别是什么？\"></a>volatile 和 synchronized 的区别是什么？</h4><ul>\n<li>volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；</li>\n<li>volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，<br>  而 synchronized 则可以保证变量的修改原子性和可见性；</li>\n<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li>\n<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了<strong>减少获得锁和释放锁带来的性能消耗</strong>而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>\n</ul>\n<h2 id=\"Lock-体系\"><a href=\"#Lock-体系\" class=\"headerlink\" title=\"Lock 体系\"></a>Lock 体系</h2><h3 id=\"Lock-简介\"><a href=\"#Lock-简介\" class=\"headerlink\" title=\"Lock 简介\"></a>Lock 简介</h3><h4 id=\"Lock-接口是什么？对比同步它有什么优势？\"><a href=\"#Lock-接口是什么？对比同步它有什么优势？\" class=\"headerlink\" title=\"Lock 接口是什么？对比同步它有什么优势？\"></a>Lock 接口是什么？对比同步它有什么优势？</h4><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。</p>\n<p>（1）可以使锁更<strong>公平</strong></p>\n<p>（2）可以使线程在<strong>等待锁的时候响应中断</strong></p>\n<p>（3）可以<strong>让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</strong></p>\n<h4 id=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"><a href=\"#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\" class=\"headerlink\" title=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<br>    传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>\n<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<br>    乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>\n<h4 id=\"什么是-CAS\"><a href=\"#什么是-CAS\" class=\"headerlink\" title=\"什么是 CAS\"></a>什么是 CAS</h4><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。</p>\n<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。</p>\n<p>如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。</p>\n<h4 id=\"Java实现CAS的原理-Unsafe类\"><a href=\"#Java实现CAS的原理-Unsafe类\" class=\"headerlink\" title=\"Java实现CAS的原理 - Unsafe类\"></a>Java实现CAS的原理 - Unsafe类</h4><p>在Java中，有一个<code>Unsafe</code>类，它在<code>sun.misc</code>包中。它里面是一些<code>native</code>方法（由底层的JVM使用C或者C++去实现），其中就有几个关于CAS的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapObject</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,Object expected, Object x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapInt</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">int</span> expected,<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapLong</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">long</span> expected,<span class=\"type\">long</span> x)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然，他们都是<code>public native</code>的。</p>\n<p>Unsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。</p>\n<p>Linux 的 X86 下主要是通过<code>cmpxchgl</code>这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p>\n<p>当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p>\n<h4 id=\"CAS-会产生什么问题？\"><a href=\"#CAS-会产生什么问题？\" class=\"headerlink\" title=\"CAS 会产生什么问题？\"></a>CAS 会产生什么问题？</h4><p>1、<strong>ABA 问题</strong>：</p>\n<p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>\n<p>2、<strong>循环时间长开销大</strong>：</p>\n<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p>\n<p>3、<strong>只能保证一个共享变量的原子操作</strong>：</p>\n<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是<strong>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁</strong>。</p>\n<h4 id=\"死锁与活锁的区别，死锁与饥饿的区别？\"><a href=\"#死锁与活锁的区别，死锁与饥饿的区别？\" class=\"headerlink\" title=\"死锁与活锁的区别，死锁与饥饿的区别？\"></a>死锁与活锁的区别，死锁与饥饿的区别？</h4><blockquote>\n<p>区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。</p>\n</blockquote>\n<p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致<strong>一直重复尝试，失败，尝试，失败</strong>。</p>\n<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>\n<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>\n<p>Java 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>\n<h3 id=\"AQS详解\"><a href=\"#AQS详解\" class=\"headerlink\" title=\"AQS详解\"></a>AQS详解</h3><h4 id=\"AQS-介绍\"><a href=\"#AQS-介绍\" class=\"headerlink\" title=\"AQS 介绍\"></a>AQS 介绍</h4><p>AQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。</p>\n<p>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>\n<h4 id=\"AQS-原理分析\"><a href=\"#AQS-原理分析\" class=\"headerlink\" title=\"AQS 原理分析\"></a>AQS 原理分析</h4><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。</strong></p>\n<blockquote>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。</p>\n</blockquote>\n<p>看个AQS(AbstractQueuedSynchronizer)原理图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png\" alt=\"AQS原理图\"></p>\n<p>AQS使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;\t<span class=\"comment\">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>\n\n<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回同步状态的当前值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置同步状态的值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(<span class=\"type\">int</span> newState)</span> &#123; </span><br><span class=\"line\">    state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetState</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AQS 对资源的共享方式</strong></p>\n<p>AQS定义两种资源共享方式</p>\n<ul>\n<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>\n</ul>\n</li>\n<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>\n</ul>\n<p><strong>AQS底层使用了模板方法模式</strong></p>\n<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器（<strong>模板方法模式</strong>很经典的一个应用）：</p>\n<ol>\n<li>使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）</li>\n<li>调用 AQS 的模板方法，会进一步调用使用者重写的方法。</li>\n</ol>\n<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isHeldExclusively()\t<span class=\"comment\">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class=\"line\">tryAcquire(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>\n\n<p>以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。</p>\n<p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即state&#x3D;0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p>\n<p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，<strong>实现了读写的分离，读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><h4 id=\"什么是ConcurrentHashMap？\"><a href=\"#什么是ConcurrentHashMap？\" class=\"headerlink\" title=\"什么是ConcurrentHashMap？\"></a>什么是ConcurrentHashMap？</h4><p>ConcurrentHashMap是Java中的一个<strong>线程安全且高效的HashMap实现</strong>。</p>\n<p>那么它到底是如何实现线程安全的？</p>\n<p>JDK 1.6版本关键要素：</p>\n<ul>\n<li>segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；</li>\n<li>segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。</li>\n</ul>\n<p>JDK1.8后，ConcurrentHashMap抛弃了原有的 Segment 分段锁，而<strong>采用了 CAS + synchronized 来保证并发安全性</strong>。</p>\n<p>插入元素过程：</p>\n<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>\n<p>如果相应位置的Node不为空，则对该节点加synchronized锁进行插入或更新操作。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>CopyOnWrite容器即<strong>写时复制的容器</strong>，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>\n<p><strong>CopyOnWriteArrayList 的使用场景</strong></p>\n<p>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p>\n<p><strong>CopyOnWriteArrayList 的缺点</strong></p>\n<ol>\n<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li>\n<li><strong>不能用于实时读的场景</strong>，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，<strong>读取到数据可能还是旧的</strong>，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>\n</ol>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><h4 id=\"ThreadLocal的数据结构\"><a href=\"#ThreadLocal的数据结构\" class=\"headerlink\" title=\"ThreadLocal的数据结构\"></a>ThreadLocal的数据结构</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n<p>每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry为 &lt;threadLocal的弱引用，value为强引用&gt; 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// private static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     @Override</span></span><br><span class=\"line\">    <span class=\"comment\">//     protected Integer initialValue() &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         return 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"type\">Integer</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> threadLocal.get();</span><br><span class=\"line\">                    threadLocal.set(++val);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;Thread-&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + threadLocal.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后threadLocal.get仍然是0</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">main ---- <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><h4 id=\"ThreadLocal造成内存泄漏的原因？\"><a href=\"#ThreadLocal造成内存泄漏的原因？\" class=\"headerlink\" title=\"ThreadLocal造成内存泄漏的原因？\"></a>ThreadLocal造成内存泄漏的原因？</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的remove()方法，清理掉 key 为 null 的记录。</p>\n<h3 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>\n<p>在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>\n<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>\n<p>JDK7 提供了 7 个阻塞队列。分别是：</p>\n<blockquote>\n<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n</blockquote>\n<p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>\n<p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，<strong>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞</strong>，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"Executors-创建四种常见线程池\"><a href=\"#Executors-创建四种常见线程池\" class=\"headerlink\" title=\"Executors 创建四种常见线程池\"></a>Executors 创建四种常见线程池</h3><h4 id=\"什么是线程池？有哪几种创建方式？\"><a href=\"#什么是线程池？有哪几种创建方式？\" class=\"headerlink\" title=\"什么是线程池？有哪几种创建方式？\"></a>什么是线程池？有哪几种创建方式？</h4><blockquote>\n<p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是<strong>尽可能减少创建和销毁对象的次数</strong>，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>\n<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>\n<p>（1）Executors.newSingleThreadExecutor：<code>1, 1, new LinkedBlockingQueue</code>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）</p>\n<p>（2）Executors.newFixedThreadPool：<code>nCoreThreads, nCoreThreads, new LinkedBlockingQueue</code>，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为Integer.MAX_VALUE，因此可能OOM）</p>\n<p>（3） Executors.newCachedThreadPool：<code>0, Integer.MAX_VALUE</code>，不创建核心线程，线程池最大为Integer.MAX_VALUE。（线程池太大导致OOM）</p>\n<p>newCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。<br>FixedThreadPool 是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</p>\n<p>（4）Executors.newScheduledThreadPool：<code>nCoreThreads, Integer.MAX_VALUE</code>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<h4 id=\"线程池有什么优点？\"><a href=\"#线程池有什么优点？\" class=\"headerlink\" title=\"线程池有什么优点？\"></a>线程池有什么优点？</h4><ul>\n<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销；</li>\n<li>提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；</li>\n<li>提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h4 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h4><ul>\n<li>RUNNING：接受新的任务提交，处理等待队列中的任务；</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；</li>\n<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>\n</ul>\n<h4 id=\"在-Java-中-Executor-和-Executors-的区别？\"><a href=\"#在-Java-中-Executor-和-Executors-的区别？\" class=\"headerlink\" title=\"在 Java 中 Executor 和 Executors 的区别？\"></a>在 Java 中 Executor 和 Executors 的区别？</h4><ul>\n<li><strong>Executors 工具类</strong>的不同方法按照我们的需求<strong>创建了不同的线程池</strong>，来满足业务的需求；</li>\n<li><strong>Executor 接口对象执行我们的线程任务</strong>，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>\n</ul>\n<h4 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit() 和 execute() 方法有什么区别？\"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><p>接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而execute()只能执行 Runnable 类型的任务；</p>\n<p>返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；</p>\n<p>异常处理：submit() 方便 Exception 处理。</p>\n<h3 id=\"ThreadPoolExecutor-自定义线程池\"><a href=\"#ThreadPoolExecutor-自定义线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 自定义线程池\"></a>ThreadPoolExecutor 自定义线程池</h3><h4 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h4><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是<strong>通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让写的同学<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<p>Executors 各个方法的弊端：</p>\n<ul>\n<li><p>newSingleThreadExecutor 和 newFixedThreadPool :<br>  <code>0, 0</code>和 <code>n, n</code> ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE</p>\n<p>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</p>\n</li>\n<li><p>newCachedThreadPool 和 newScheduledThreadPool:<br>  <code>0, Integer.MAX_VALUE</code> 和 <code>n, Integer.MAX_VALUE</code></p>\n<p>  主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM</p>\n</li>\n</ul>\n<p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>\n<h4 id=\"ThreaPoolExecutor\"><a href=\"#ThreaPoolExecutor\" class=\"headerlink\" title=\"ThreaPoolExecutor\"></a>ThreaPoolExecutor</h4><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p>\n<p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p>\n<h4 id=\"ThreadPoolExecutor构造函数重要参数分析\"><a href=\"#ThreadPoolExecutor构造函数重要参数分析\" class=\"headerlink\" title=\"ThreadPoolExecutor构造函数重要参数分析\"></a>ThreadPoolExecutor构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code></strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量</li>\n<li><strong><code>maximumPoolSize</code></strong> ：线程池中允许存在的工作线程的最大数量</li>\n<li>**<code>workQueue</code>**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数:</p>\n<ol>\n<li>**<code>keepAliveTime</code>**：非核心线程如果处于闲置状态超过该值，就会被销毁。</li>\n<li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 闲置销毁时长的时间单位</li>\n<li>**<code>threadFactory</code>**：为线程池提供创建新线程的线程工厂</li>\n<li><strong><code>handler</code></strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li>\n</ol>\n<h4 id=\"ThreadPoolExecutor拒绝策略\"><a href=\"#ThreadPoolExecutor拒绝策略\" class=\"headerlink\" title=\"ThreadPoolExecutor拒绝策略\"></a>ThreadPoolExecutor拒绝策略</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>拒绝策略定义:</strong></p>\n<p>如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>\n<ul>\n<li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：调用执行自己的线程运行任务。</li>\n<li>**<code>ThreadPoolExecutor.DiscardPolicy</code>**：不处理新任务，直接丢弃掉。</li>\n<li>**<code>ThreadPoolExecutor.DiscardOldestPolicy</code>**： 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<h4 id=\"一个简单的线程池Demo-Runnable-ThreadPoolExecutor\"><a href=\"#一个简单的线程池Demo-Runnable-ThreadPoolExecutor\" class=\"headerlink\" title=\"一个简单的线程池Demo:Runnable + ThreadPoolExecutor\"></a>一个简单的线程池Demo:<code>Runnable</code> + <code>ThreadPoolExecutor</code></h4><p>线程池实现原理</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png\" alt=\"线程池实现原理\"></p>\n<p><strong>总结一下处理流程</strong></p>\n<ol>\n<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>线程总数量 &gt;&#x3D; corePoolSize时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。 </li>\n<li>当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>缓存队列之前满了， 现在加非核心线程且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>\n</ol>\n<p>整个过程如图所示：</p>\n<p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>\n<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String command;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyRunnable</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.command = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; Start. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">        processCommand();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; End. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processCommand</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.command;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolExecutorDemo</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CORE_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">QUEUE_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">KEEP_ALIVE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class=\"line\">        <span class=\"comment\">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class=\"line\">        <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                CORE_POOL_SIZE,</span><br><span class=\"line\">                MAX_POOL_SIZE,</span><br><span class=\"line\">                KEEP_ALIVE_TIME,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class=\"line\">            <span class=\"type\">Runnable</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>(<span class=\"string\">&quot;&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">//执行Runnable</span></span><br><span class=\"line\">            executor.execute(worker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//终止线程池</span></span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!executor.isTerminated()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Finished all threads&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们上面的代码指定了：</p>\n<ol>\n<li><code>corePoolSize</code>: 核心线程数为 5。</li>\n<li><code>maximumPoolSize</code> ：最大线程数 10</li>\n<li><code>keepAliveTime</code> : 等待时间为 1L。</li>\n<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>\n<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>\n<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>\n</ol>\n<p><strong>Output：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><h3 id=\"CountDownLatch-与-CyclicBarrier\"><a href=\"#CountDownLatch-与-CyclicBarrier\" class=\"headerlink\" title=\"CountDownLatch 与 CyclicBarrier\"></a>CountDownLatch 与 CyclicBarrier</h3><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>\n<ul>\n<li>CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；</li>\n<li>调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>\n<li>CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。</li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</p>\n<p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。</p>\n<h2 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h2><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">A</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">B</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>线程1 已获得资源A<br>线程2 已获得资源B<br>线程1 等待获得资源B<br>线程2 等待获得资源A</p>\n</blockquote>\n<h3 id=\"run方法和start方法\"><a href=\"#run方法和start方法\" class=\"headerlink\" title=\"run方法和start方法\"></a>run方法和start方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DiffStartRun</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程A&quot;</span>).run();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>main<br>线程B</p>\n<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>\n</blockquote>\n<h3 id=\"两个线程，交替加减\"><a href=\"#两个线程，交替加减\" class=\"headerlink\" title=\"两个线程，交替加减\"></a>两个线程，交替加减</h3><ol>\n<li><p>synchronized</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithSync</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lock + condition</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        a.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    b.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        b.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    a.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"三个线程，循环打印\"><a href=\"#三个线程，循环打印\" class=\"headerlink\" title=\"三个线程，循环打印\"></a>三个线程，循环打印</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo5</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputA</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                a.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">1</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出A&quot;</span>);</span><br><span class=\"line\">            b.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputB</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                b.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">2</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出B&quot;</span>);</span><br><span class=\"line\">            c.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputC</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                c.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">0</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出C&quot;</span>);</span><br><span class=\"line\">            a.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Demo5</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo5</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputA(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputB(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputC(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-C&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java八股文 - MyBatis","copyright":true,"mathjax":false,"date":"2023-01-23T07:30:00.000Z","toc":true,"urlname":"java-mybatis","_content":"\n> 整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n\n### 什么是MyBatis？\n\n1. MyBatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理**加载驱动、创建连接、创建statement**等繁杂的过程。\n2. 通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中SQL的动态参数进行映射生成最终执行的SQL语句，最后由mybatis框架执行SQL并将结果映射为java对象并返回。（从执行SQL到返回result的过程）。\n\n### ORM是什么\n\nORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来\n\n让我们可以操作实体类就实现操作数据库表。\n\n### 为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\n\nMyBatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，称之为半自动ORM映射工具。\n\n### JDBC编程有哪些不足之处，MyBatis是如何解决的？\n\n1. 数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能\n2. SQL语句写在代码中造成代码**不易维护**\n3. 向SQL语句**传参**麻烦\n4. 对**结果集解析**麻烦\n\n### MyBatis编程步骤是什么样的？\n\n1. 读取配置文件，创建SqlSessionFactory工厂\n2. 通过SqlSessionFactory工厂创建SqlSession 对象\n3. 使用 SqlSession 创建 Dao 接口的代理对象\n4. 使用代理对象执行方法\n5. 调用session.commit()提交事务\n6. 调用session.close()关闭会话\n\n### \\#{}和\\${}的区别是什么？\n\nmybatis在处理 \\#{} 时，会将SQL中的 \\#{} 替换为 ? 号，调用PreparedStatement的set方法来赋值。\n这是**预编译处理**，可以提高SQL执行效率，更重要的是**可以防止SQL注入**；\n\nmybatis在处理 \\${} 时，就是把 \\${} 使用**字符串替换**。使用该方式如果传入id的话，会把id=1转换为id=\"1\"字符串形式，而数据库中id实际为数值型这样就不匹配了，查询失败。（\\${}是字符串替换，通常在EL表达式中使用，用来展示后端传递到前端的值）。\n\n### 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\n\n1. 通过在查询的SQL语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。\n2. 通过 `<resultMap>`来映射字段名和实体类属性名的一一对应的关系。\n\n### 模糊查询like语句该怎么写?\n\n1. 在Java代码中添加SQL通配符。\n\n\t```xml\n\tstring wildcardname = “%smi%”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like #{value}\n\t</select>\n\t```\n\n2. 在SQL语句中拼接通配符%，会引起SQL注入\n\n\t```xml\n\tstring wildcardname = “smi”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like \"%\"#{value}\"%\"\n\t</select>\n\t```\n\n### MyBatis都有哪些Executor执行器？它们之间的区别是什么？\n\nMyBatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。\n\n- **SimpleExecutor** ：每次开启一个Statement对象，用完立刻关闭Statement对象。\n- **ReuseExecutor** ：重复使用创建的Statement对象。\n- **BatchExecutor** ：缓存了多个Statement对象，一起执行批量更新。\n\n### 通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\n\nDao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 SQL 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.yaxing.dao.IUserDao.findAll`，可以唯一找到 namespace 为`com.yaxing.dao.IUserDao`下面`id = findAll`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象，然后执行后续的操作。\n\n```xml\n<mapper namespace=\"com.yaxing.dao.IUserDao\">\n    <select id=\"findAll\" resultType=\"com.yaxing.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\nDao 接口里的方法可以重载，但是MyBatis的XML里面的ID不允许重复，也就是说对于同一个接口方法名，mapper文件中只能有一个该id。\n可以使用动态SQL实现接口重载对应的maper。\n\n```java\n/**\n * Mapper接口里面方法重载\n */\npublic interface StuMapper {\n    List<Student> getAllStu();\n    List<Student> getAllStu(@Param(\"id\") Integer id);\n}\n```\n\n然后在 `StuMapper.xml` 中利用MyBatis的动态SQL就可以实现。\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。\n\n**MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。**\n\n### MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n1. 使用 `<resultMap>`标签，逐一定义数据库列名和对象属性名之间的映射关系。\n\n2. 使用SQL列的别名功能，将列的别名属性对应为对象属性名。\n\n有了列名与属性名的映射关系后，MyBatis**通过反射创建对象**，同时**使用反射给对象的属性逐一赋值**并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n### 在mapper中如何传递多个参数?\n\n1. 顺序传参法，\\#{} 里面的数字代表传入参数的顺序\n2. @Param注解传参法，\\#{} 里面的名称对应的是注解@Param括号里面修饰的名称\n3. map传参，\\#{} 里面的名称对应的是Map里面的key名称。\n4. Java Bean传参法，\\#{} 里面的名称对应的是User类里面的成员属性。\n\n### MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\n\nMyBatis动态SQL可以在xml映射文件内，以标签的形式编写动态SQL.\n\n执行原理是根据表达式的值 完成逻辑判断并动态拼接SQL。\n\nMyBatis提供了9种动态SQL标签： 常用的有 `if|where|foreach`\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n### MyBatis实现一对多有几种方式,怎么操作的？\n\n有**联合查询**和**嵌套查询**。\n\n联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；\n\n嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。\n\n### MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\n\nMyBatis仅支持association关联对象和collection关联集合对象的延迟加载。\nassociation指的就是一对一，collection指的就是一对多查询。\n在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n\n它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n### MyBatis的一级、二级缓存\n\n**一级缓存**：一级缓存是SqlSession范围的缓存\n\n当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。该区域的结构是一个Map。\n当我们再次查询同样的数据时，MyBatis会先去SqlSession中查询是否有，有的话直接拿出来用。\n\n当调用SqlSession的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。\n\n> 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。 \n> 得到用户信息，将用户信息存储到一级缓存中。 \n> 如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 \n> 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。\n\n**二级缓存**：二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的SQL语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n\nMyBatis中SqlSessionFactory对象的缓存\n\n​\t由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。\n\n​\t二级缓存存放的是数据，而不是对象。\n\n> SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。\n> 如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。 \n> SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。\n\n1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；\n\n2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 `<cache/>` ；\n\n3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 \n\n### 什么是MyBatis的接口绑定？有哪些实现方式？\n\n接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。\n\n接口绑定有两种实现方式：\n\n1. 通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；\n2. 通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。\n","source":"_posts/Java八股文 - MyBatis.md","raw":"---\ntitle: Java八股文 - MyBatis\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 15:30:00\ntags:\ntoc: true\nurlname: java-mybatis\n---\n\n> 整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n\n### 什么是MyBatis？\n\n1. MyBatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理**加载驱动、创建连接、创建statement**等繁杂的过程。\n2. 通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中SQL的动态参数进行映射生成最终执行的SQL语句，最后由mybatis框架执行SQL并将结果映射为java对象并返回。（从执行SQL到返回result的过程）。\n\n### ORM是什么\n\nORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来\n\n让我们可以操作实体类就实现操作数据库表。\n\n### 为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\n\nMyBatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，称之为半自动ORM映射工具。\n\n### JDBC编程有哪些不足之处，MyBatis是如何解决的？\n\n1. 数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能\n2. SQL语句写在代码中造成代码**不易维护**\n3. 向SQL语句**传参**麻烦\n4. 对**结果集解析**麻烦\n\n### MyBatis编程步骤是什么样的？\n\n1. 读取配置文件，创建SqlSessionFactory工厂\n2. 通过SqlSessionFactory工厂创建SqlSession 对象\n3. 使用 SqlSession 创建 Dao 接口的代理对象\n4. 使用代理对象执行方法\n5. 调用session.commit()提交事务\n6. 调用session.close()关闭会话\n\n### \\#{}和\\${}的区别是什么？\n\nmybatis在处理 \\#{} 时，会将SQL中的 \\#{} 替换为 ? 号，调用PreparedStatement的set方法来赋值。\n这是**预编译处理**，可以提高SQL执行效率，更重要的是**可以防止SQL注入**；\n\nmybatis在处理 \\${} 时，就是把 \\${} 使用**字符串替换**。使用该方式如果传入id的话，会把id=1转换为id=\"1\"字符串形式，而数据库中id实际为数值型这样就不匹配了，查询失败。（\\${}是字符串替换，通常在EL表达式中使用，用来展示后端传递到前端的值）。\n\n### 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\n\n1. 通过在查询的SQL语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。\n2. 通过 `<resultMap>`来映射字段名和实体类属性名的一一对应的关系。\n\n### 模糊查询like语句该怎么写?\n\n1. 在Java代码中添加SQL通配符。\n\n\t```xml\n\tstring wildcardname = “%smi%”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like #{value}\n\t</select>\n\t```\n\n2. 在SQL语句中拼接通配符%，会引起SQL注入\n\n\t```xml\n\tstring wildcardname = “smi”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like \"%\"#{value}\"%\"\n\t</select>\n\t```\n\n### MyBatis都有哪些Executor执行器？它们之间的区别是什么？\n\nMyBatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。\n\n- **SimpleExecutor** ：每次开启一个Statement对象，用完立刻关闭Statement对象。\n- **ReuseExecutor** ：重复使用创建的Statement对象。\n- **BatchExecutor** ：缓存了多个Statement对象，一起执行批量更新。\n\n### 通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\n\nDao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 SQL 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.yaxing.dao.IUserDao.findAll`，可以唯一找到 namespace 为`com.yaxing.dao.IUserDao`下面`id = findAll`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象，然后执行后续的操作。\n\n```xml\n<mapper namespace=\"com.yaxing.dao.IUserDao\">\n    <select id=\"findAll\" resultType=\"com.yaxing.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\nDao 接口里的方法可以重载，但是MyBatis的XML里面的ID不允许重复，也就是说对于同一个接口方法名，mapper文件中只能有一个该id。\n可以使用动态SQL实现接口重载对应的maper。\n\n```java\n/**\n * Mapper接口里面方法重载\n */\npublic interface StuMapper {\n    List<Student> getAllStu();\n    List<Student> getAllStu(@Param(\"id\") Integer id);\n}\n```\n\n然后在 `StuMapper.xml` 中利用MyBatis的动态SQL就可以实现。\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。\n\n**MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。**\n\n### MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n1. 使用 `<resultMap>`标签，逐一定义数据库列名和对象属性名之间的映射关系。\n\n2. 使用SQL列的别名功能，将列的别名属性对应为对象属性名。\n\n有了列名与属性名的映射关系后，MyBatis**通过反射创建对象**，同时**使用反射给对象的属性逐一赋值**并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n### 在mapper中如何传递多个参数?\n\n1. 顺序传参法，\\#{} 里面的数字代表传入参数的顺序\n2. @Param注解传参法，\\#{} 里面的名称对应的是注解@Param括号里面修饰的名称\n3. map传参，\\#{} 里面的名称对应的是Map里面的key名称。\n4. Java Bean传参法，\\#{} 里面的名称对应的是User类里面的成员属性。\n\n### MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\n\nMyBatis动态SQL可以在xml映射文件内，以标签的形式编写动态SQL.\n\n执行原理是根据表达式的值 完成逻辑判断并动态拼接SQL。\n\nMyBatis提供了9种动态SQL标签： 常用的有 `if|where|foreach`\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n### MyBatis实现一对多有几种方式,怎么操作的？\n\n有**联合查询**和**嵌套查询**。\n\n联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；\n\n嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。\n\n### MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\n\nMyBatis仅支持association关联对象和collection关联集合对象的延迟加载。\nassociation指的就是一对一，collection指的就是一对多查询。\n在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n\n它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n### MyBatis的一级、二级缓存\n\n**一级缓存**：一级缓存是SqlSession范围的缓存\n\n当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。该区域的结构是一个Map。\n当我们再次查询同样的数据时，MyBatis会先去SqlSession中查询是否有，有的话直接拿出来用。\n\n当调用SqlSession的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。\n\n> 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。 \n> 得到用户信息，将用户信息存储到一级缓存中。 \n> 如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 \n> 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。\n\n**二级缓存**：二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的SQL语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n\nMyBatis中SqlSessionFactory对象的缓存\n\n​\t由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。\n\n​\t二级缓存存放的是数据，而不是对象。\n\n> SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。\n> 如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。 \n> SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。\n\n1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；\n\n2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 `<cache/>` ；\n\n3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 \n\n### 什么是MyBatis的接口绑定？有哪些实现方式？\n\n接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。\n\n接口绑定有两种实现方式：\n\n1. 通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；\n2. 通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。\n","slug":"Java八股文 - MyBatis","published":1,"updated":"2023-01-23T08:47:12.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiu000bzvt8gmhrh2x5","content":"<blockquote>\n<p>整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<span id=\"more\"></span></p>\n</blockquote>\n<h3 id=\"什么是MyBatis？\"><a href=\"#什么是MyBatis？\" class=\"headerlink\" title=\"什么是MyBatis？\"></a>什么是MyBatis？</h3><ol>\n<li>MyBatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理<strong>加载驱动、创建连接、创建statement</strong>等繁杂的过程。</li>\n<li>通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中SQL的动态参数进行映射生成最终执行的SQL语句，最后由mybatis框架执行SQL并将结果映射为java对象并返回。（从执行SQL到返回result的过程）。</li>\n</ol>\n<h3 id=\"ORM是什么\"><a href=\"#ORM是什么\" class=\"headerlink\" title=\"ORM是什么\"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来</p>\n<p>让我们可以操作实体类就实现操作数据库表。</p>\n<h3 id=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"><a href=\"#为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\" class=\"headerlink\" title=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"></a>为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>MyBatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，称之为半自动ORM映射工具。</p>\n<h3 id=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"><a href=\"#JDBC编程有哪些不足之处，MyBatis是如何解决的？\" class=\"headerlink\" title=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h3><ol>\n<li>数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能</li>\n<li>SQL语句写在代码中造成代码<strong>不易维护</strong></li>\n<li>向SQL语句<strong>传参</strong>麻烦</li>\n<li>对<strong>结果集解析</strong>麻烦</li>\n</ol>\n<h3 id=\"MyBatis编程步骤是什么样的？\"><a href=\"#MyBatis编程步骤是什么样的？\" class=\"headerlink\" title=\"MyBatis编程步骤是什么样的？\"></a>MyBatis编程步骤是什么样的？</h3><ol>\n<li>读取配置文件，创建SqlSessionFactory工厂</li>\n<li>通过SqlSessionFactory工厂创建SqlSession 对象</li>\n<li>使用 SqlSession 创建 Dao 接口的代理对象</li>\n<li>使用代理对象执行方法</li>\n<li>调用session.commit()提交事务</li>\n<li>调用session.close()关闭会话</li>\n</ol>\n<h3 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h3><p>mybatis在处理 #{} 时，会将SQL中的 #{} 替换为 ? 号，调用PreparedStatement的set方法来赋值。<br>这是<strong>预编译处理</strong>，可以提高SQL执行效率，更重要的是<strong>可以防止SQL注入</strong>；</p>\n<p>mybatis在处理 ${} 时，就是把 ${} 使用<strong>字符串替换</strong>。使用该方式如果传入id的话，会把id&#x3D;1转换为id&#x3D;”1”字符串形式，而数据库中id实际为数值型这样就不匹配了，查询失败。（${}是字符串替换，通常在EL表达式中使用，用来展示后端传递到前端的值）。</p>\n<h3 id=\"当实体类中的属性名和表中的字段名不一样-，怎么办-？\"><a href=\"#当实体类中的属性名和表中的字段名不一样-，怎么办-？\" class=\"headerlink\" title=\"当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><ol>\n<li>通过在查询的SQL语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。</li>\n<li>通过 <code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</li>\n</ol>\n<h3 id=\"模糊查询like语句该怎么写\"><a href=\"#模糊查询like语句该怎么写\" class=\"headerlink\" title=\"模糊查询like语句该怎么写?\"></a>模糊查询like语句该怎么写?</h3><ol>\n<li><p>在Java代码中添加SQL通配符。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “%smi%”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like #&#123;value&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在SQL语句中拼接通配符%，会引起SQL注入</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “smi”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"><a href=\"#MyBatis都有哪些Executor执行器？它们之间的区别是什么？\" class=\"headerlink\" title=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"></a>MyBatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>MyBatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>\n<ul>\n<li><strong>SimpleExecutor</strong> ：每次开启一个Statement对象，用完立刻关闭Statement对象。</li>\n<li><strong>ReuseExecutor</strong> ：重复使用创建的Statement对象。</li>\n<li><strong>BatchExecutor</strong> ：缓存了多个Statement对象，一起执行批量更新。</li>\n</ul>\n<h3 id=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"><a href=\"#通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\" class=\"headerlink\" title=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"></a>通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 SQL 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.yaxing.dao.IUserDao.findAll</code>，可以唯一找到 namespace 为<code>com.yaxing.dao.IUserDao</code>下面<code>id = findAll</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象，然后执行后续的操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.yaxing.dao.IUserDao&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findAll&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.yaxing.domain.User&quot;</span>&gt;</span></span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Dao 接口里的方法可以重载，但是MyBatis的XML里面的ID不允许重复，也就是说对于同一个接口方法名，mapper文件中只能有一个该id。<br>可以使用动态SQL实现接口重载对应的maper。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Mapper接口里面方法重载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StuMapper</span> &#123;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>StuMapper.xml</code> 中利用MyBatis的动态SQL就可以实现。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。</p>\n<p><strong>MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>\n<h3 id=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><ol>\n<li><p>使用 <code>&lt;resultMap&gt;</code>标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>\n</li>\n<li><p>使用SQL列的别名功能，将列的别名属性对应为对象属性名。</p>\n</li>\n</ol>\n<p>有了列名与属性名的映射关系后，MyBatis<strong>通过反射创建对象</strong>，同时<strong>使用反射给对象的属性逐一赋值</strong>并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h3 id=\"在mapper中如何传递多个参数\"><a href=\"#在mapper中如何传递多个参数\" class=\"headerlink\" title=\"在mapper中如何传递多个参数?\"></a>在mapper中如何传递多个参数?</h3><ol>\n<li>顺序传参法，#{} 里面的数字代表传入参数的顺序</li>\n<li>@Param注解传参法，#{} 里面的名称对应的是注解@Param括号里面修饰的名称</li>\n<li>map传参，#{} 里面的名称对应的是Map里面的key名称。</li>\n<li>Java Bean传参法，#{} 里面的名称对应的是User类里面的成员属性。</li>\n</ol>\n<h3 id=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"><a href=\"#MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\" class=\"headerlink\" title=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"></a>MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？</h3><p>MyBatis动态SQL可以在xml映射文件内，以标签的形式编写动态SQL.</p>\n<p>执行原理是根据表达式的值 完成逻辑判断并动态拼接SQL。</p>\n<p>MyBatis提供了9种动态SQL标签： 常用的有 <code>if|where|foreach</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MyBatis实现一对多有几种方式-怎么操作的？\"><a href=\"#MyBatis实现一对多有几种方式-怎么操作的？\" class=\"headerlink\" title=\"MyBatis实现一对多有几种方式,怎么操作的？\"></a>MyBatis实现一对多有几种方式,怎么操作的？</h3><p>有<strong>联合查询</strong>和<strong>嵌套查询</strong>。</p>\n<p>联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；</p>\n<p>嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。</p>\n<h3 id=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载。<br>association指的就是一对一，collection指的就是一对多查询。<br>在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p>\n<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>\n<h3 id=\"MyBatis的一级、二级缓存\"><a href=\"#MyBatis的一级、二级缓存\" class=\"headerlink\" title=\"MyBatis的一级、二级缓存\"></a>MyBatis的一级、二级缓存</h3><p><strong>一级缓存</strong>：一级缓存是SqlSession范围的缓存</p>\n<p>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。该区域的结构是一个Map。<br>当我们再次查询同样的数据时，MyBatis会先去SqlSession中查询是否有，有的话直接拿出来用。</p>\n<p>当调用SqlSession的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。</p>\n<blockquote>\n<p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。<br>得到用户信息，将用户信息存储到一级缓存中。<br>如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。<br>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p>\n</blockquote>\n<p><strong>二级缓存</strong>：二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的SQL语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>\n<p>MyBatis中SqlSessionFactory对象的缓存</p>\n<p>​\t由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</p>\n<p>​\t二级缓存存放的是数据，而不是对象。</p>\n<blockquote>\n<p>SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。<br>如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。<br>SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p>\n</blockquote>\n<p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；</p>\n<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p>\n<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 </p>\n<h3 id=\"什么是MyBatis的接口绑定？有哪些实现方式？\"><a href=\"#什么是MyBatis的接口绑定？有哪些实现方式？\" class=\"headerlink\" title=\"什么是MyBatis的接口绑定？有哪些实现方式？\"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>\n<p>接口绑定有两种实现方式：</p>\n<ol>\n<li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li>\n<li>通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</li>\n</ol>\n","site":{"data":{}},"length":5628,"excerpt":"<blockquote>\n<p>整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h3 id=\"什么是MyBatis？\"><a href=\"#什么是MyBatis？\" class=\"headerlink\" title=\"什么是MyBatis？\"></a>什么是MyBatis？</h3><ol>\n<li>MyBatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理<strong>加载驱动、创建连接、创建statement</strong>等繁杂的过程。</li>\n<li>通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中SQL的动态参数进行映射生成最终执行的SQL语句，最后由mybatis框架执行SQL并将结果映射为java对象并返回。（从执行SQL到返回result的过程）。</li>\n</ol>\n<h3 id=\"ORM是什么\"><a href=\"#ORM是什么\" class=\"headerlink\" title=\"ORM是什么\"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来</p>\n<p>让我们可以操作实体类就实现操作数据库表。</p>\n<h3 id=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"><a href=\"#为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\" class=\"headerlink\" title=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"></a>为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>MyBatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，称之为半自动ORM映射工具。</p>\n<h3 id=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"><a href=\"#JDBC编程有哪些不足之处，MyBatis是如何解决的？\" class=\"headerlink\" title=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h3><ol>\n<li>数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能</li>\n<li>SQL语句写在代码中造成代码<strong>不易维护</strong></li>\n<li>向SQL语句<strong>传参</strong>麻烦</li>\n<li>对<strong>结果集解析</strong>麻烦</li>\n</ol>\n<h3 id=\"MyBatis编程步骤是什么样的？\"><a href=\"#MyBatis编程步骤是什么样的？\" class=\"headerlink\" title=\"MyBatis编程步骤是什么样的？\"></a>MyBatis编程步骤是什么样的？</h3><ol>\n<li>读取配置文件，创建SqlSessionFactory工厂</li>\n<li>通过SqlSessionFactory工厂创建SqlSession 对象</li>\n<li>使用 SqlSession 创建 Dao 接口的代理对象</li>\n<li>使用代理对象执行方法</li>\n<li>调用session.commit()提交事务</li>\n<li>调用session.close()关闭会话</li>\n</ol>\n<h3 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h3><p>mybatis在处理 #{} 时，会将SQL中的 #{} 替换为 ? 号，调用PreparedStatement的set方法来赋值。<br>这是<strong>预编译处理</strong>，可以提高SQL执行效率，更重要的是<strong>可以防止SQL注入</strong>；</p>\n<p>mybatis在处理 ${} 时，就是把 ${} 使用<strong>字符串替换</strong>。使用该方式如果传入id的话，会把id&#x3D;1转换为id&#x3D;”1”字符串形式，而数据库中id实际为数值型这样就不匹配了，查询失败。（${}是字符串替换，通常在EL表达式中使用，用来展示后端传递到前端的值）。</p>\n<h3 id=\"当实体类中的属性名和表中的字段名不一样-，怎么办-？\"><a href=\"#当实体类中的属性名和表中的字段名不一样-，怎么办-？\" class=\"headerlink\" title=\"当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><ol>\n<li>通过在查询的SQL语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。</li>\n<li>通过 <code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</li>\n</ol>\n<h3 id=\"模糊查询like语句该怎么写\"><a href=\"#模糊查询like语句该怎么写\" class=\"headerlink\" title=\"模糊查询like语句该怎么写?\"></a>模糊查询like语句该怎么写?</h3><ol>\n<li><p>在Java代码中添加SQL通配符。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “%smi%”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like #&#123;value&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在SQL语句中拼接通配符%，会引起SQL注入</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “smi”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"><a href=\"#MyBatis都有哪些Executor执行器？它们之间的区别是什么？\" class=\"headerlink\" title=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"></a>MyBatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>MyBatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>\n<ul>\n<li><strong>SimpleExecutor</strong> ：每次开启一个Statement对象，用完立刻关闭Statement对象。</li>\n<li><strong>ReuseExecutor</strong> ：重复使用创建的Statement对象。</li>\n<li><strong>BatchExecutor</strong> ：缓存了多个Statement对象，一起执行批量更新。</li>\n</ul>\n<h3 id=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"><a href=\"#通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\" class=\"headerlink\" title=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"></a>通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 SQL 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.yaxing.dao.IUserDao.findAll</code>，可以唯一找到 namespace 为<code>com.yaxing.dao.IUserDao</code>下面<code>id = findAll</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象，然后执行后续的操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.yaxing.dao.IUserDao&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findAll&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.yaxing.domain.User&quot;</span>&gt;</span></span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Dao 接口里的方法可以重载，但是MyBatis的XML里面的ID不允许重复，也就是说对于同一个接口方法名，mapper文件中只能有一个该id。<br>可以使用动态SQL实现接口重载对应的maper。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Mapper接口里面方法重载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StuMapper</span> &#123;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>StuMapper.xml</code> 中利用MyBatis的动态SQL就可以实现。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。</p>\n<p><strong>MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>\n<h3 id=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><ol>\n<li><p>使用 <code>&lt;resultMap&gt;</code>标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>\n</li>\n<li><p>使用SQL列的别名功能，将列的别名属性对应为对象属性名。</p>\n</li>\n</ol>\n<p>有了列名与属性名的映射关系后，MyBatis<strong>通过反射创建对象</strong>，同时<strong>使用反射给对象的属性逐一赋值</strong>并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h3 id=\"在mapper中如何传递多个参数\"><a href=\"#在mapper中如何传递多个参数\" class=\"headerlink\" title=\"在mapper中如何传递多个参数?\"></a>在mapper中如何传递多个参数?</h3><ol>\n<li>顺序传参法，#{} 里面的数字代表传入参数的顺序</li>\n<li>@Param注解传参法，#{} 里面的名称对应的是注解@Param括号里面修饰的名称</li>\n<li>map传参，#{} 里面的名称对应的是Map里面的key名称。</li>\n<li>Java Bean传参法，#{} 里面的名称对应的是User类里面的成员属性。</li>\n</ol>\n<h3 id=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"><a href=\"#MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\" class=\"headerlink\" title=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"></a>MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？</h3><p>MyBatis动态SQL可以在xml映射文件内，以标签的形式编写动态SQL.</p>\n<p>执行原理是根据表达式的值 完成逻辑判断并动态拼接SQL。</p>\n<p>MyBatis提供了9种动态SQL标签： 常用的有 <code>if|where|foreach</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MyBatis实现一对多有几种方式-怎么操作的？\"><a href=\"#MyBatis实现一对多有几种方式-怎么操作的？\" class=\"headerlink\" title=\"MyBatis实现一对多有几种方式,怎么操作的？\"></a>MyBatis实现一对多有几种方式,怎么操作的？</h3><p>有<strong>联合查询</strong>和<strong>嵌套查询</strong>。</p>\n<p>联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；</p>\n<p>嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置。</p>\n<h3 id=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>MyBatis仅支持association关联对象和collection关联集合对象的延迟加载。<br>association指的就是一对一，collection指的就是一对多查询。<br>在MyBatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p>\n<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的SQL，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>\n<h3 id=\"MyBatis的一级、二级缓存\"><a href=\"#MyBatis的一级、二级缓存\" class=\"headerlink\" title=\"MyBatis的一级、二级缓存\"></a>MyBatis的一级、二级缓存</h3><p><strong>一级缓存</strong>：一级缓存是SqlSession范围的缓存</p>\n<p>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供的一块区域中。该区域的结构是一个Map。<br>当我们再次查询同样的数据时，MyBatis会先去SqlSession中查询是否有，有的话直接拿出来用。</p>\n<p>当调用SqlSession的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。</p>\n<blockquote>\n<p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。<br>得到用户信息，将用户信息存储到一级缓存中。<br>如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。<br>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p>\n</blockquote>\n<p><strong>二级缓存</strong>：二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的SQL语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>\n<p>MyBatis中SqlSessionFactory对象的缓存</p>\n<p>​\t由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</p>\n<p>​\t二级缓存存放的是数据，而不是对象。</p>\n<blockquote>\n<p>SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。<br>如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。<br>SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p>\n</blockquote>\n<p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；</p>\n<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p>\n<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 </p>\n<h3 id=\"什么是MyBatis的接口绑定？有哪些实现方式？\"><a href=\"#什么是MyBatis的接口绑定？有哪些实现方式？\" class=\"headerlink\" title=\"什么是MyBatis的接口绑定？有哪些实现方式？\"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>\n<p>接口绑定有两种实现方式：</p>\n<ol>\n<li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li>\n<li>通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候,用注解绑定, 当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多。</li>\n</ol>"},{"title":"Java八股文 - Spring","copyright":true,"mathjax":false,"date":"2023-01-23T08:14:06.000Z","toc":true,"urlname":"java-spring","_content":"\n> 整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Spring概述\n\n### 什么是spring?\n\nSpring是**一个轻量级Java开发框架**，目的是为了解决开发中的**业务逻辑层和其他各层的耦合问题**，简化Java开发。\n\n### Spring框架的核心是什么\n\n**Spring框架的核心**：IoC容器和AOP模块。\n通过IoC容器管理Java Bean对象及其生命周期以及他们之间的耦合关系；\n通过AOP将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度\n\n### Spring的优缺点是什么？\n\n优点\n\n- 方便解耦，简化开发（**IoC**）\n\n\tSpring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。\n\n- AOP编程的支持（**AOP**）\n\n\tSpring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n\n- 声明式事务的支持（**事务**）\n\n\t只需要通过配置就可以完成对事务的管理，而无需手动编程。\n\n- 方便集成各种优秀框架（**集成**）\n\n\tSpring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。\n\n\n缺点\n\n- Spring**依赖反射，反射影响性能**\n\n### Spring 框架中都用到了哪些设计模式？\n\n1. 工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。\n2. 单例模式：Bean默认为单例模式。\n3. 代理模式：Spring的AOP功能用到了基于接口的JDK的动态代理和基于子类的CGLIB动态代理；\n\n### Spring框架中有哪些不同类型的事件\n\n**Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。**  \n\n如果一个bean实现了`ApplicationListener`接口，当一个`ApplicationEvent` 被发布以后，bean会自动被通知。\n\n```javascript\npublic class AllApplicationEventListener implements ApplicationListener < ApplicationEvent >{\n    @Override\n    public void onApplicationEvent(ApplicationEvent applicationEvent){\n        //process event\n    }\n}\n```\n\n**Spring 提供了以下5种标准的事件：**\n\n- 上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用`ConfigurableApplicationContext` 接口中的`refresh()`方法时被触发。\n- 上下文开始事件（ContextStartedEvent）：当容器调用`ConfigurableApplicationContext`的`Start()`方法开始/重新开始容器时触发该事件。\n- 上下文停止事件（ContextStoppedEvent）：当容器调用`ConfigurableApplicationContext`的`Stop()`方法停止容器时触发该事件。\n- 上下文关闭事件（ContextClosedEvent）：当`ApplicationContext`被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。\n- 请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。\n\n### Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n- Bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n- Bean 配置文件 - 包含类的信息以及如何配置它们。\n- 接口 - 处理 Bean \n- 用户程序 - 它使用接口。\n\n## Spring控制反转(IOC)\n\n### 什么是Spring IOC 容器？\n\nSpring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC让相互协作的组件保持松耦合。\n\n### Spring IoC 的实现机制\n\nSpring 中的 IoC 的实现原理就是**工厂模式加反射**。\n\n```java\ninterface Fruit {\n    void eat();\n}\n\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println(\"Apple\");\n    }\n}\n\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println(\"Orange\");\n    }\n}\n\nclass Factory {\n    public static Fruit getInstance(String className) {\t// 使用反射，用字符串获取到实例\n        Fruit f=null;\n        try {\n            f = (Fruit) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\n\nclass Client {\n    public static void main(String[] a) {\n        Fruit f = Factory.getInstance(\"io.github.dunwu.spring.Apple\");\n        if(f != null){\n            f.eat();\n        }\n    }\n}\n```\n\n### BeanFactory 和 ApplicationContext有什么区别？\n\nBeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。\nApplicationContext是BeanFactory的子接口。\n\n1. 依赖关系\n\nBeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。\n\nApplicationContext接口作为BeanFactory的子接口，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\n\n- 支持国际化。\n- 支持访问文件资源\n- 支持事件发布通知\n- 同时加载多个配置文件。\n\n配置流程：\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。\n3. 加载方式\n\n**BeanFactroy**采用的是**延迟加载**形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入或者是属性注入错误，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\n\n**ApplicationContext**，它是在容器启动时，**一次性创建**了所有的Bean。这样，在容器启动时，我们就可以**发现Spring中存在的配置错误**，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n由于在容器启动时一次性创建所有的Bean，因此ApplicationContext 更加占用内存空间，当配置的Bean比较多时，程序启动较慢。\n\n#### ⭐BeanFactory和FactoryBean区别？\n\nBeanFactory：是spring IoC容器的底层接口，可以用来管理bean及其生命周期；\n\nFactoryBean：如果某个 bean 实现了FactoryBean这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值\n\n### ApplicationContext通常的实现是什么？\n\n**FileSystemXmlApplicationContext** ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\n\n**ClassPathXmlApplicationContext**：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。\n\n**AnnotationConfigApplicationContext**：它是用于读取注解创建容器的\n\n### 什么是Spring的依赖注入？\n\n具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。\n\n### 依赖注入有什么优势\n\n依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：\n\n- 查找定位操作与应用代码完全无关。\n- 不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。\n- 不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。\n\n### 有哪些不同类型的依赖注入实现方式？\n\n**构造器依赖注入**：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\n\n**Setter方法注入**：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。\n\n### 构造器依赖注入和 setter方法注入的区别\n\n（部分注入）在setter注入,可以将依赖项部分注入,构造方法注入不能部分注入。\n\n（属性覆盖）如果我们为同一属性提供setter和构造方法注入，setter注入将覆盖构造方法注入。但是构造方法注入不能覆盖setter注入值。显然，构造方法注入被称为创建实例的第一选项。\n\n（循环依赖）在构造函数注入,如果A和B对象相互依赖：A依赖于B,B也依赖于A,此时在创建对象的A或者B时，Spring抛出ObjectCurrentlyInCreationException。所以Spring可以通过setter注入,从而解决循环依赖的问题。\n\n**最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖**\n\n### 讲一讲Spring中的循环依赖\n\nhttps://www.cnblogs.com/daimzh/p/13256413.html\n\nhttps://blog.csdn.net/weixin_49592546/article/details/108050566\n\n#### 什么是循环依赖？\n\n```java\n@Component\npublic class A {\n    // A中注入了B\n\t@Autowired\n\tprivate B b;\n}\n\n@Component\npublic class B {\n    // B中也注入了A\n\t@Autowired\n\tprivate A a;\n}\n```\n\n#### Spring是如何解决的循环依赖？\n\n> 以下：\n>\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n首先，Spring 解决循环依赖有两个前提条件：\n\n1. 不全是构造器方式的循环依赖\n2. 必须是单例\n\n基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。\n\n```java\n/** Cache of singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n/** Cache of early singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n/** Cache of singleton factories: bean name to ObjectFactory. */\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n```\n\n第一级缓存：用来保存实例化、初始化都完成的对象\n\n第二级缓存：用来保存实例化完成，但是未初始化完成的对象\n\n第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象\n\n![Spring三级缓存](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg)\n\n假设一个简单的循环依赖场景，A、B互相依赖。\n\n![简单的循环依赖场景](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg)\n\nA对象的创建过程：\n\n1. 创建对象A，实例化的时候把A对象工厂放入三级缓存；\n\n![实例化对象A](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg)\n\n\n\n2. A注入属性时，发现依赖B，转而去实例化B\n\n3. 同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。\n\n![创建对象B](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg)\n\n4. 接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存\n\n5. 最后，一级缓存中保存着实例化、初始化都完成的A、B对象\n\n![最终结果](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg)\n\n因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。\n\n### 8. 为什么要三级缓存？二级不行吗？\n\n不可以，主要是为了生成代理对象。\n\n因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。\n\n假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，`BeanPostProcessor`去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。\n\n![A代理对象覆盖A普通Bean](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg)\n\n\n\n## Spring Beans\n\n### 如何给Spring 容器提供配置元数据？Spring有几种配置方式\n\n这里有三种重要的方法给Spring 容器提供配置元数据。\n\n- XML配置文件。\n- 基于注解的配置。\n- 基于Java的配置。\n\n### Spring配置文件包含了哪些信息\n\nSpring配置文件是个XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入ioc容器中，该对象可以通过id来获取\n\n### Spring基于xml注入bean的几种方式\n\n1. Set方法注入：`<property name=\"xxx\" value=\"yyy\"/>`\n2. 构造器注入：`<construtor-arg type/index/name=\"xxx\" value=\"yyy\"/>`\n3. 静态工厂注入；factory-bean factory-method\n4. 实例工厂； class factory-method\n\n### 解释Spring支持的几种bean的作用域\n\nSpring框架支持以下五种bean的作用域：\n\n- **singleton :** bean在每个Spring ioc 容器中只有一个实例。\n- **prototype**：一个bean的定义可以有多个实例。\n- **request**：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。\n- **session**：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。\n- **global-session**：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。\n\n**注意：** 缺省的Spring bean 的作用域是singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。\n\n### Spring框架中的单例bean是线程安全的吗？\n\n不是，Spring框架中的单例bean不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n\n然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。\n\n> 有状态就是有数据存储功能\n> 无状态就是不会保存数据\n\n### Spring如何处理线程并发问题？\n\n**Spring使用ThreadLocal对一些Bean的线程安全问题进行处理**。\n\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\n\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n\n### 解释Spring框架中bean的生命周期\n\n参考：https://www.cnblogs.com/javazhiyin/p/10905294.html\n\n![Spring中Bean的生命周期](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png)\n\n**1、实例化Bean：**\n\n对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。\n对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。\n\n**2、依赖注入：**\n\n实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。\n\n**3、处理Aware接口（配置Bean对象的id值、工厂/上下文）：**\n\n接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：\n\n- 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；\n- 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身；\n- 如果这个Bean已经实现了ApplicationContextAware接口，会调setApplicationContext(ApplicationContext)方法，传入Spring上下文；\n\n**4、postProcessBeforeInitialization（初始化前置处理）：**\n\n如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；\n\n**5、自定义初始化init-method：**\n\n如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的**自定义初始化**方法。\n\n**6、postProcessAfterInitialization（初始化后置处理）**\n\n如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法，**AOP在这个时候进行代理对象的创建**。\n\n**NOW** 以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。\n\n**7、清理阶段destroy：**\n\n当Bean不再需要时，会进入清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；\n\n**8、自定义销毁destroy-method：**\n\n最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的**自定义销毁**方法。\n\n### 在 Spring中如何注入一个Java集合？\n\n用`<list>`注入一列值，用`<map>`注入一组映射数据。\n\n### 什么是bean装配？\n\n通过bean的依赖关系，使用依赖注入将spring中的bean装配在一起。\nspring可以通过bean的依赖关系自动完成bean之间的配置。\n\n### Spring 自动装配 bean 有哪些方式？\n\n在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。\n\n在Spring框架xml配置中共有5种自动装配：\n\n- no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。\n- byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。\n- byType：通过参数的数据类型进行自动装配。\n- constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。\n- autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。\n\n### 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置注解扫描 `<context:annotation-config />`。\n\n在启动spring IoC时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中**查询对应类型**的bean：\n\n- 如果对应类型查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n- 如果对应类型查询的结果不止一个，那么@Autowired会根据名称来查找；\n- 如果上述查找的结果为空或者不止一个，那么会抛出异常。\n\n## Spring注解\n\n### 什么是基于Java的Spring注解配置? 给一些注解的例子\n\n基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。\n\n以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。\n\n另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。\n\n```java\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n```\n\n### 怎样开启注解装配？\n\n注解装配在默认情况下是不开启的，为了使用注解装配，必须在Spring配置文件中配置 `<context:annotation-config/>`。\n\n### @Component, @Controller, @Repository, @Service 有何区别？\n\n@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到IoC容器中。\n\n@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n\n@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n\n@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n### @Required 注解有什么作用\n\n`@Required`注解作用于Bean`setter`方法上，用于检查一个Bean的属性的值**在配置期间是否被赋予或设置**，如果未被设置，容器将抛出BeanInitializationException。示例：\n\n```java\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n```\n\n### @Autowired和@Resource之间的区别\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n@Autowired和@Resource之间的区别\n\n- @Autowired默认是**按照类型装配注入**的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n- @Resource默认是**按照名称来装配注入**的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n### @Qualifier 注解有什么作用\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n### @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：\n\n- 类级别：映射请求的 URL\n- 方法级别：映射 URL 以及 HTTP 请求方法\n\n## Spring事务\n\n### Spring支持的事务管理类型/事务实现方式有哪些？\n\nSpring支持两种类型的事务管理：\n\n**编程式事务管理**：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。\n\n**声明式事务管理**：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。\n\n### Spring事务的实现方式和实现原理\n\nSpring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring是无法提供事务功能的。\n\n```xml\n<!-- 2、配置事务的通知以及事务的属性-->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n<!-- 配置事务的属性\nisolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔\n离级别。\npropagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会\n有事务。查询方法可以选择SUPPORTS。\nread-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是\nfalse，表示读写。\ntimeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，\n以秒为单位。\nrollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，\n事务不回滚。没有默认值。表示任何异常都回滚。\nno-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常\n时事务回滚。没有默认值。表示任何异常都回滚。\n-->\n<tx:attributes>\n    <!--非查询方法-->\n    <tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/>\n    <!--查询方法-->\n    <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n### 说一下Spring的事务传播行为\n\nspring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。\n\n> ① **PROPAGATION_REQUIRED**：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）\n> ② **PROPAGATION_SUPPORTS**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）\n> ③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n> ④ **PROPAGATION_REQUIRES_NEW**：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）\n> ⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n> ⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n> ⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### 说一下 spring 的事务隔离？\n\nspring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：\n\n1. ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\n2. ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；\n3. ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；\n4. ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\n5. ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n## Spring面向切面编程(AOP)\n\n### 什么是AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些**公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等**。\n\n### Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\n\nAOP实现的关键在于 代理模式，AOP代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。\n\n（1）AspectJ 采用静态代理模式，属于**编译时增强**，会在编译阶段织入切面生成相应的代理对象\n\n（2）Spring AOP 采用动态代理模式，属于**运行时增强**，每次运行时织入切面在内存中临时生成相应的代理对象\n\n### JDK动态代理和CGLIB动态代理的区别\n\nJDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。\n\n而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是**基于 asm 第三方框架**，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。\n\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 解释一下Spring AOP里面的几个名词\n\n（1）切面（Aspect）：切面是通知和切点的结合。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n\n（2）连接点（Join point）：方法\n\n（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强\n\n（4）切入点（Pointcut）：哪些连接点需要增强\n\n（5）目标对象（Target Object）： 被代理（proxied） 对象。\n\n（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。\n\n（7）Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类。\n\n> - 编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。\n> - 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。\n> - 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。\n\n### Spring通知有哪些类型？\n\n在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。\n\nSpring切面可以应用5种类型的通知：\n\n1. 前置通知（Before）：在目标方法被调用之前调用通知功能；\n2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；\n3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；\n4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；\n5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。\n\n> 同一个aspect，不同advice的执行顺序：\n>\n> ①没有异常情况下的执行顺序：\n>\n> around before advice\t方法调用之前自定义行为\n> before advice\n> target method 执行\n> around after advice\t方法调用后自定义行为\n> after advice\n> afterReturning\n>\n> ②有异常情况下的执行顺序：\n>\n> around before advice\n> before advice\n> target method 执行\n> around after advice\n> after advice\n> afterThrowing:异常发生\n> Java.lang.RuntimeException: 异常发生\n\n### 什么是切面 Aspect？\n\naspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 \nAOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  \n\n- 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n- 如何在 advice 中编写切面代码\n\n可以简单地认为, 使用 @Aspect 注解的类就是切面\n\n![在这里插入图片描述](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png)\n","source":"_posts/Java八股文 - Spring.md","raw":"---\ntitle: Java八股文 - Spring\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 16:14:06\ntags:\ntoc: true\nurlname: java-spring\n---\n\n> 整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Spring概述\n\n### 什么是spring?\n\nSpring是**一个轻量级Java开发框架**，目的是为了解决开发中的**业务逻辑层和其他各层的耦合问题**，简化Java开发。\n\n### Spring框架的核心是什么\n\n**Spring框架的核心**：IoC容器和AOP模块。\n通过IoC容器管理Java Bean对象及其生命周期以及他们之间的耦合关系；\n通过AOP将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度\n\n### Spring的优缺点是什么？\n\n优点\n\n- 方便解耦，简化开发（**IoC**）\n\n\tSpring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。\n\n- AOP编程的支持（**AOP**）\n\n\tSpring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n\n- 声明式事务的支持（**事务**）\n\n\t只需要通过配置就可以完成对事务的管理，而无需手动编程。\n\n- 方便集成各种优秀框架（**集成**）\n\n\tSpring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。\n\n\n缺点\n\n- Spring**依赖反射，反射影响性能**\n\n### Spring 框架中都用到了哪些设计模式？\n\n1. 工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。\n2. 单例模式：Bean默认为单例模式。\n3. 代理模式：Spring的AOP功能用到了基于接口的JDK的动态代理和基于子类的CGLIB动态代理；\n\n### Spring框架中有哪些不同类型的事件\n\n**Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。**  \n\n如果一个bean实现了`ApplicationListener`接口，当一个`ApplicationEvent` 被发布以后，bean会自动被通知。\n\n```javascript\npublic class AllApplicationEventListener implements ApplicationListener < ApplicationEvent >{\n    @Override\n    public void onApplicationEvent(ApplicationEvent applicationEvent){\n        //process event\n    }\n}\n```\n\n**Spring 提供了以下5种标准的事件：**\n\n- 上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用`ConfigurableApplicationContext` 接口中的`refresh()`方法时被触发。\n- 上下文开始事件（ContextStartedEvent）：当容器调用`ConfigurableApplicationContext`的`Start()`方法开始/重新开始容器时触发该事件。\n- 上下文停止事件（ContextStoppedEvent）：当容器调用`ConfigurableApplicationContext`的`Stop()`方法停止容器时触发该事件。\n- 上下文关闭事件（ContextClosedEvent）：当`ApplicationContext`被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。\n- 请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。\n\n### Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n- Bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n- Bean 配置文件 - 包含类的信息以及如何配置它们。\n- 接口 - 处理 Bean \n- 用户程序 - 它使用接口。\n\n## Spring控制反转(IOC)\n\n### 什么是Spring IOC 容器？\n\nSpring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC让相互协作的组件保持松耦合。\n\n### Spring IoC 的实现机制\n\nSpring 中的 IoC 的实现原理就是**工厂模式加反射**。\n\n```java\ninterface Fruit {\n    void eat();\n}\n\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println(\"Apple\");\n    }\n}\n\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println(\"Orange\");\n    }\n}\n\nclass Factory {\n    public static Fruit getInstance(String className) {\t// 使用反射，用字符串获取到实例\n        Fruit f=null;\n        try {\n            f = (Fruit) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\n\nclass Client {\n    public static void main(String[] a) {\n        Fruit f = Factory.getInstance(\"io.github.dunwu.spring.Apple\");\n        if(f != null){\n            f.eat();\n        }\n    }\n}\n```\n\n### BeanFactory 和 ApplicationContext有什么区别？\n\nBeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。\nApplicationContext是BeanFactory的子接口。\n\n1. 依赖关系\n\nBeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。\n\nApplicationContext接口作为BeanFactory的子接口，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：\n\n- 支持国际化。\n- 支持访问文件资源\n- 支持事件发布通知\n- 同时加载多个配置文件。\n\n配置流程：\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。\n3. 加载方式\n\n**BeanFactroy**采用的是**延迟加载**形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入或者是属性注入错误，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。\n\n**ApplicationContext**，它是在容器启动时，**一次性创建**了所有的Bean。这样，在容器启动时，我们就可以**发现Spring中存在的配置错误**，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n由于在容器启动时一次性创建所有的Bean，因此ApplicationContext 更加占用内存空间，当配置的Bean比较多时，程序启动较慢。\n\n#### ⭐BeanFactory和FactoryBean区别？\n\nBeanFactory：是spring IoC容器的底层接口，可以用来管理bean及其生命周期；\n\nFactoryBean：如果某个 bean 实现了FactoryBean这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值\n\n### ApplicationContext通常的实现是什么？\n\n**FileSystemXmlApplicationContext** ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\n\n**ClassPathXmlApplicationContext**：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。\n\n**AnnotationConfigApplicationContext**：它是用于读取注解创建容器的\n\n### 什么是Spring的依赖注入？\n\n具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。\n\n### 依赖注入有什么优势\n\n依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：\n\n- 查找定位操作与应用代码完全无关。\n- 不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。\n- 不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。\n\n### 有哪些不同类型的依赖注入实现方式？\n\n**构造器依赖注入**：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\n\n**Setter方法注入**：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。\n\n### 构造器依赖注入和 setter方法注入的区别\n\n（部分注入）在setter注入,可以将依赖项部分注入,构造方法注入不能部分注入。\n\n（属性覆盖）如果我们为同一属性提供setter和构造方法注入，setter注入将覆盖构造方法注入。但是构造方法注入不能覆盖setter注入值。显然，构造方法注入被称为创建实例的第一选项。\n\n（循环依赖）在构造函数注入,如果A和B对象相互依赖：A依赖于B,B也依赖于A,此时在创建对象的A或者B时，Spring抛出ObjectCurrentlyInCreationException。所以Spring可以通过setter注入,从而解决循环依赖的问题。\n\n**最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖**\n\n### 讲一讲Spring中的循环依赖\n\nhttps://www.cnblogs.com/daimzh/p/13256413.html\n\nhttps://blog.csdn.net/weixin_49592546/article/details/108050566\n\n#### 什么是循环依赖？\n\n```java\n@Component\npublic class A {\n    // A中注入了B\n\t@Autowired\n\tprivate B b;\n}\n\n@Component\npublic class B {\n    // B中也注入了A\n\t@Autowired\n\tprivate A a;\n}\n```\n\n#### Spring是如何解决的循环依赖？\n\n> 以下：\n>\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n首先，Spring 解决循环依赖有两个前提条件：\n\n1. 不全是构造器方式的循环依赖\n2. 必须是单例\n\n基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。\n\n```java\n/** Cache of singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n/** Cache of early singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n/** Cache of singleton factories: bean name to ObjectFactory. */\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n```\n\n第一级缓存：用来保存实例化、初始化都完成的对象\n\n第二级缓存：用来保存实例化完成，但是未初始化完成的对象\n\n第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象\n\n![Spring三级缓存](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg)\n\n假设一个简单的循环依赖场景，A、B互相依赖。\n\n![简单的循环依赖场景](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg)\n\nA对象的创建过程：\n\n1. 创建对象A，实例化的时候把A对象工厂放入三级缓存；\n\n![实例化对象A](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg)\n\n\n\n2. A注入属性时，发现依赖B，转而去实例化B\n\n3. 同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。\n\n![创建对象B](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg)\n\n4. 接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存\n\n5. 最后，一级缓存中保存着实例化、初始化都完成的A、B对象\n\n![最终结果](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg)\n\n因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。\n\n### 8. 为什么要三级缓存？二级不行吗？\n\n不可以，主要是为了生成代理对象。\n\n因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。\n\n假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，`BeanPostProcessor`去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。\n\n![A代理对象覆盖A普通Bean](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg)\n\n\n\n## Spring Beans\n\n### 如何给Spring 容器提供配置元数据？Spring有几种配置方式\n\n这里有三种重要的方法给Spring 容器提供配置元数据。\n\n- XML配置文件。\n- 基于注解的配置。\n- 基于Java的配置。\n\n### Spring配置文件包含了哪些信息\n\nSpring配置文件是个XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入ioc容器中，该对象可以通过id来获取\n\n### Spring基于xml注入bean的几种方式\n\n1. Set方法注入：`<property name=\"xxx\" value=\"yyy\"/>`\n2. 构造器注入：`<construtor-arg type/index/name=\"xxx\" value=\"yyy\"/>`\n3. 静态工厂注入；factory-bean factory-method\n4. 实例工厂； class factory-method\n\n### 解释Spring支持的几种bean的作用域\n\nSpring框架支持以下五种bean的作用域：\n\n- **singleton :** bean在每个Spring ioc 容器中只有一个实例。\n- **prototype**：一个bean的定义可以有多个实例。\n- **request**：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。\n- **session**：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。\n- **global-session**：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。\n\n**注意：** 缺省的Spring bean 的作用域是singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。\n\n### Spring框架中的单例bean是线程安全的吗？\n\n不是，Spring框架中的单例bean不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n\n然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。\n\n> 有状态就是有数据存储功能\n> 无状态就是不会保存数据\n\n### Spring如何处理线程并发问题？\n\n**Spring使用ThreadLocal对一些Bean的线程安全问题进行处理**。\n\nThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。\n\nThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\n\n### 解释Spring框架中bean的生命周期\n\n参考：https://www.cnblogs.com/javazhiyin/p/10905294.html\n\n![Spring中Bean的生命周期](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png)\n\n**1、实例化Bean：**\n\n对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。\n对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。\n\n**2、依赖注入：**\n\n实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。\n\n**3、处理Aware接口（配置Bean对象的id值、工厂/上下文）：**\n\n接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：\n\n- 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；\n- 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身；\n- 如果这个Bean已经实现了ApplicationContextAware接口，会调setApplicationContext(ApplicationContext)方法，传入Spring上下文；\n\n**4、postProcessBeforeInitialization（初始化前置处理）：**\n\n如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；\n\n**5、自定义初始化init-method：**\n\n如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的**自定义初始化**方法。\n\n**6、postProcessAfterInitialization（初始化后置处理）**\n\n如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法，**AOP在这个时候进行代理对象的创建**。\n\n**NOW** 以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。\n\n**7、清理阶段destroy：**\n\n当Bean不再需要时，会进入清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；\n\n**8、自定义销毁destroy-method：**\n\n最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的**自定义销毁**方法。\n\n### 在 Spring中如何注入一个Java集合？\n\n用`<list>`注入一列值，用`<map>`注入一组映射数据。\n\n### 什么是bean装配？\n\n通过bean的依赖关系，使用依赖注入将spring中的bean装配在一起。\nspring可以通过bean的依赖关系自动完成bean之间的配置。\n\n### Spring 自动装配 bean 有哪些方式？\n\n在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。\n\n在Spring框架xml配置中共有5种自动装配：\n\n- no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。\n- byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。\n- byType：通过参数的数据类型进行自动装配。\n- constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。\n- autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。\n\n### 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置注解扫描 `<context:annotation-config />`。\n\n在启动spring IoC时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中**查询对应类型**的bean：\n\n- 如果对应类型查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；\n- 如果对应类型查询的结果不止一个，那么@Autowired会根据名称来查找；\n- 如果上述查找的结果为空或者不止一个，那么会抛出异常。\n\n## Spring注解\n\n### 什么是基于Java的Spring注解配置? 给一些注解的例子\n\n基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。\n\n以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。\n\n另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。\n\n```java\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n```\n\n### 怎样开启注解装配？\n\n注解装配在默认情况下是不开启的，为了使用注解装配，必须在Spring配置文件中配置 `<context:annotation-config/>`。\n\n### @Component, @Controller, @Repository, @Service 有何区别？\n\n@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到IoC容器中。\n\n@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n\n@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n\n@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n### @Required 注解有什么作用\n\n`@Required`注解作用于Bean`setter`方法上，用于检查一个Bean的属性的值**在配置期间是否被赋予或设置**，如果未被设置，容器将抛出BeanInitializationException。示例：\n\n```java\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n```\n\n### @Autowired和@Resource之间的区别\n\n@Autowired可用于：构造函数、成员变量、Setter方法\n\n@Autowired和@Resource之间的区别\n\n- @Autowired默认是**按照类型装配注入**的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。\n- @Resource默认是**按照名称来装配注入**的，只有当找不到与名称匹配的bean才会按照类型来装配注入。\n\n### @Qualifier 注解有什么作用\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n### @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：\n\n- 类级别：映射请求的 URL\n- 方法级别：映射 URL 以及 HTTP 请求方法\n\n## Spring事务\n\n### Spring支持的事务管理类型/事务实现方式有哪些？\n\nSpring支持两种类型的事务管理：\n\n**编程式事务管理**：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。\n\n**声明式事务管理**：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。\n\n### Spring事务的实现方式和实现原理\n\nSpring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring是无法提供事务功能的。\n\n```xml\n<!-- 2、配置事务的通知以及事务的属性-->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n<!-- 配置事务的属性\nisolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔\n离级别。\npropagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会\n有事务。查询方法可以选择SUPPORTS。\nread-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是\nfalse，表示读写。\ntimeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，\n以秒为单位。\nrollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，\n事务不回滚。没有默认值。表示任何异常都回滚。\nno-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常\n时事务回滚。没有默认值。表示任何异常都回滚。\n-->\n<tx:attributes>\n    <!--非查询方法-->\n    <tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/>\n    <!--查询方法-->\n    <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n### 说一下Spring的事务传播行为\n\nspring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。\n\n> ① **PROPAGATION_REQUIRED**：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）\n> ② **PROPAGATION_SUPPORTS**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）\n> ③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n> ④ **PROPAGATION_REQUIRES_NEW**：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）\n> ⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n> ⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n> ⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### 说一下 spring 的事务隔离？\n\nspring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：\n\n1. ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\n2. ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；\n3. ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；\n4. ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\n5. ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n## Spring面向切面编程(AOP)\n\n### 什么是AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些**公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等**。\n\n### Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\n\nAOP实现的关键在于 代理模式，AOP代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。\n\n（1）AspectJ 采用静态代理模式，属于**编译时增强**，会在编译阶段织入切面生成相应的代理对象\n\n（2）Spring AOP 采用动态代理模式，属于**运行时增强**，每次运行时织入切面在内存中临时生成相应的代理对象\n\n### JDK动态代理和CGLIB动态代理的区别\n\nJDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。\n\n而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是**基于 asm 第三方框架**，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。\n\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 解释一下Spring AOP里面的几个名词\n\n（1）切面（Aspect）：切面是通知和切点的结合。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n\n（2）连接点（Join point）：方法\n\n（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强\n\n（4）切入点（Pointcut）：哪些连接点需要增强\n\n（5）目标对象（Target Object）： 被代理（proxied） 对象。\n\n（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。\n\n（7）Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类。\n\n> - 编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。\n> - 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。\n> - 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。\n\n### Spring通知有哪些类型？\n\n在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。\n\nSpring切面可以应用5种类型的通知：\n\n1. 前置通知（Before）：在目标方法被调用之前调用通知功能；\n2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；\n3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；\n4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；\n5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。\n\n> 同一个aspect，不同advice的执行顺序：\n>\n> ①没有异常情况下的执行顺序：\n>\n> around before advice\t方法调用之前自定义行为\n> before advice\n> target method 执行\n> around after advice\t方法调用后自定义行为\n> after advice\n> afterReturning\n>\n> ②有异常情况下的执行顺序：\n>\n> around before advice\n> before advice\n> target method 执行\n> around after advice\n> after advice\n> afterThrowing:异常发生\n> Java.lang.RuntimeException: 异常发生\n\n### 什么是切面 Aspect？\n\naspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 \nAOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  \n\n- 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n- 如何在 advice 中编写切面代码\n\n可以简单地认为, 使用 @Aspect 注解的类就是切面\n\n![在这里插入图片描述](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png)\n","slug":"Java八股文 - Spring","published":1,"updated":"2023-01-23T08:47:15.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiv000ezvt8dj5yb1a7","content":"<blockquote>\n<p>整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Spring概述\"><a href=\"#Spring概述\" class=\"headerlink\" title=\"Spring概述\"></a>Spring概述</h2><h3 id=\"什么是spring\"><a href=\"#什么是spring\" class=\"headerlink\" title=\"什么是spring?\"></a>什么是spring?</h3><p>Spring是<strong>一个轻量级Java开发框架</strong>，目的是为了解决开发中的<strong>业务逻辑层和其他各层的耦合问题</strong>，简化Java开发。</p>\n<h3 id=\"Spring框架的核心是什么\"><a href=\"#Spring框架的核心是什么\" class=\"headerlink\" title=\"Spring框架的核心是什么\"></a>Spring框架的核心是什么</h3><p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。<br>通过IoC容器管理Java Bean对象及其生命周期以及他们之间的耦合关系；<br>通过AOP将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度</p>\n<h3 id=\"Spring的优缺点是什么？\"><a href=\"#Spring的优缺点是什么？\" class=\"headerlink\" title=\"Spring的优缺点是什么？\"></a>Spring的优缺点是什么？</h3><p>优点</p>\n<ul>\n<li><p>方便解耦，简化开发（<strong>IoC</strong>）</p>\n<p>  Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>\n</li>\n<li><p>AOP编程的支持（<strong>AOP</strong>）</p>\n<p>  Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n</li>\n<li><p>声明式事务的支持（<strong>事务</strong>）</p>\n<p>  只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n</li>\n<li><p>方便集成各种优秀框架（<strong>集成</strong>）</p>\n<p>  Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>\n</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>Spring<strong>依赖反射，反射影响性能</strong></li>\n</ul>\n<h3 id=\"Spring-框架中都用到了哪些设计模式？\"><a href=\"#Spring-框架中都用到了哪些设计模式？\" class=\"headerlink\" title=\"Spring 框架中都用到了哪些设计模式？\"></a>Spring 框架中都用到了哪些设计模式？</h3><ol>\n<li>工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。</li>\n<li>单例模式：Bean默认为单例模式。</li>\n<li>代理模式：Spring的AOP功能用到了基于接口的JDK的动态代理和基于子类的CGLIB动态代理；</li>\n</ol>\n<h3 id=\"Spring框架中有哪些不同类型的事件\"><a href=\"#Spring框架中有哪些不同类型的事件\" class=\"headerlink\" title=\"Spring框架中有哪些不同类型的事件\"></a>Spring框架中有哪些不同类型的事件</h3><p><strong>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</strong>  </p>\n<p>如果一个bean实现了<code>ApplicationListener</code>接口，当一个<code>ApplicationEvent</code> 被发布以后，bean会自动被通知。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> <span class=\"title class_\">AllApplicationEventListener</span> implements <span class=\"title class_\">ApplicationListener</span> &lt; <span class=\"title class_\">ApplicationEvent</span> &gt;&#123;</span><br><span class=\"line\">    @<span class=\"title class_\">Override</span></span><br><span class=\"line\">    public <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span>(<span class=\"params\">ApplicationEvent applicationEvent</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//process event</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Spring 提供了以下5种标准的事件：</strong></p>\n<ul>\n<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用<code>ConfigurableApplicationContext</code> 接口中的<code>refresh()</code>方法时被触发。</li>\n<li>上下文开始事件（ContextStartedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Start()</code>方法开始&#x2F;重新开始容器时触发该事件。</li>\n<li>上下文停止事件（ContextStoppedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Stop()</code>方法停止容器时触发该事件。</li>\n<li>上下文关闭事件（ContextClosedEvent）：当<code>ApplicationContext</code>被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>\n<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li>\n</ul>\n<h3 id=\"Spring-应用程序有哪些不同组件？\"><a href=\"#Spring-应用程序有哪些不同组件？\" class=\"headerlink\" title=\"Spring 应用程序有哪些不同组件？\"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>\n<ul>\n<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>\n<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>\n<li>接口 - 处理 Bean </li>\n<li>用户程序 - 它使用接口。</li>\n</ul>\n<h2 id=\"Spring控制反转-IOC\"><a href=\"#Spring控制反转-IOC\" class=\"headerlink\" title=\"Spring控制反转(IOC)\"></a>Spring控制反转(IOC)</h2><h3 id=\"什么是Spring-IOC-容器？\"><a href=\"#什么是Spring-IOC-容器？\" class=\"headerlink\" title=\"什么是Spring IOC 容器？\"></a>什么是Spring IOC 容器？</h3><p>Spring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC让相互协作的组件保持松耦合。</p>\n<h3 id=\"Spring-IoC-的实现机制\"><a href=\"#Spring-IoC-的实现机制\" class=\"headerlink\" title=\"Spring IoC 的实现机制\"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Orange</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Fruit <span class=\"title function_\">getInstance</span><span class=\"params\">(String className)</span> &#123;\t<span class=\"comment\">// 使用反射，用字符串获取到实例</span></span><br><span class=\"line\">        Fruit f=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            f = (Fruit) Class.forName(className).newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] a)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Fruit</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Factory.getInstance(<span class=\"string\">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            f.eat();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BeanFactory-和-ApplicationContext有什么区别？\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别？\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别？\"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。<br>ApplicationContext是BeanFactory的子接口。</p>\n<ol>\n<li>依赖关系</li>\n</ol>\n<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的子接口，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>支持国际化。</li>\n<li>支持访问文件资源</li>\n<li>支持事件发布通知</li>\n<li>同时加载多个配置文件。</li>\n</ul>\n<p>配置流程：</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>\n<li>加载方式</li>\n</ol>\n<p><strong>BeanFactroy</strong>采用的是<strong>延迟加载</strong>形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入或者是属性注入错误，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p><strong>ApplicationContext</strong>，它是在容器启动时，<strong>一次性创建</strong>了所有的Bean。这样，在容器启动时，我们就可以<strong>发现Spring中存在的配置错误</strong>，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>由于在容器启动时一次性创建所有的Bean，因此ApplicationContext 更加占用内存空间，当配置的Bean比较多时，程序启动较慢。</p>\n<h4 id=\"⭐BeanFactory和FactoryBean区别？\"><a href=\"#⭐BeanFactory和FactoryBean区别？\" class=\"headerlink\" title=\"⭐BeanFactory和FactoryBean区别？\"></a>⭐BeanFactory和FactoryBean区别？</h4><p>BeanFactory：是spring IoC容器的底层接口，可以用来管理bean及其生命周期；</p>\n<p>FactoryBean：如果某个 bean 实现了FactoryBean这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值</p>\n<h3 id=\"ApplicationContext通常的实现是什么？\"><a href=\"#ApplicationContext通常的实现是什么？\" class=\"headerlink\" title=\"ApplicationContext通常的实现是什么？\"></a>ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>\n<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>\n<p><strong>AnnotationConfigApplicationContext</strong>：它是用于读取注解创建容器的</p>\n<h3 id=\"什么是Spring的依赖注入？\"><a href=\"#什么是Spring的依赖注入？\" class=\"headerlink\" title=\"什么是Spring的依赖注入？\"></a>什么是Spring的依赖注入？</h3><p>具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</p>\n<h3 id=\"依赖注入有什么优势\"><a href=\"#依赖注入有什么优势\" class=\"headerlink\" title=\"依赖注入有什么优势\"></a>依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>\n<ul>\n<li>查找定位操作与应用代码完全无关。</li>\n<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li>\n<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>\n</ul>\n<h3 id=\"有哪些不同类型的依赖注入实现方式？\"><a href=\"#有哪些不同类型的依赖注入实现方式？\" class=\"headerlink\" title=\"有哪些不同类型的依赖注入实现方式？\"></a>有哪些不同类型的依赖注入实现方式？</h3><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>\n<p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>\n<h3 id=\"构造器依赖注入和-setter方法注入的区别\"><a href=\"#构造器依赖注入和-setter方法注入的区别\" class=\"headerlink\" title=\"构造器依赖注入和 setter方法注入的区别\"></a>构造器依赖注入和 setter方法注入的区别</h3><p>（部分注入）在setter注入,可以将依赖项部分注入,构造方法注入不能部分注入。</p>\n<p>（属性覆盖）如果我们为同一属性提供setter和构造方法注入，setter注入将覆盖构造方法注入。但是构造方法注入不能覆盖setter注入值。显然，构造方法注入被称为创建实例的第一选项。</p>\n<p>（循环依赖）在构造函数注入,如果A和B对象相互依赖：A依赖于B,B也依赖于A,此时在创建对象的A或者B时，Spring抛出ObjectCurrentlyInCreationException。所以Spring可以通过setter注入,从而解决循环依赖的问题。</p>\n<p><strong>最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖</strong></p>\n<h3 id=\"讲一讲Spring中的循环依赖\"><a href=\"#讲一讲Spring中的循环依赖\" class=\"headerlink\" title=\"讲一讲Spring中的循环依赖\"></a>讲一讲Spring中的循环依赖</h3><p><a href=\"https://www.cnblogs.com/daimzh/p/13256413.html\">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_49592546/article/details/108050566\">https://blog.csdn.net/weixin_49592546/article/details/108050566</a></p>\n<h4 id=\"什么是循环依赖？\"><a href=\"#什么是循环依赖？\" class=\"headerlink\" title=\"什么是循环依赖？\"></a>什么是循环依赖？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A中注入了B</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// B中也注入了A</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Spring是如何解决的循环依赖？\"><a href=\"#Spring是如何解决的循环依赖？\" class=\"headerlink\" title=\"Spring是如何解决的循环依赖？\"></a>Spring是如何解决的循环依赖？</h4><blockquote>\n<p>以下：</p>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<p>首先，Spring 解决循环依赖有两个前提条件：</p>\n<ol>\n<li>不全是构造器方式的循环依赖</li>\n<li>必须是单例</li>\n</ol>\n<p>基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>第一级缓存：用来保存实例化、初始化都完成的对象</p>\n<p>第二级缓存：用来保存实例化完成，但是未初始化完成的对象</p>\n<p>第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg\" alt=\"Spring三级缓存\"></p>\n<p>假设一个简单的循环依赖场景，A、B互相依赖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg\" alt=\"简单的循环依赖场景\"></p>\n<p>A对象的创建过程：</p>\n<ol>\n<li>创建对象A，实例化的时候把A对象工厂放入三级缓存；</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg\" alt=\"实例化对象A\"></p>\n<ol start=\"2\">\n<li><p>A注入属性时，发现依赖B，转而去实例化B</p>\n</li>\n<li><p>同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg\" alt=\"创建对象B\"></p>\n<ol start=\"4\">\n<li><p>接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存</p>\n</li>\n<li><p>最后，一级缓存中保存着实例化、初始化都完成的A、B对象</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg\" alt=\"最终结果\"></p>\n<p>因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。</p>\n<h3 id=\"8-为什么要三级缓存？二级不行吗？\"><a href=\"#8-为什么要三级缓存？二级不行吗？\" class=\"headerlink\" title=\"8. 为什么要三级缓存？二级不行吗？\"></a>8. 为什么要三级缓存？二级不行吗？</h3><p>不可以，主要是为了生成代理对象。</p>\n<p>因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。</p>\n<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，<code>BeanPostProcessor</code>去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg\" alt=\"A代理对象覆盖A普通Bean\"></p>\n<h2 id=\"Spring-Beans\"><a href=\"#Spring-Beans\" class=\"headerlink\" title=\"Spring Beans\"></a>Spring Beans</h2><h3 id=\"如何给Spring-容器提供配置元数据？Spring有几种配置方式\"><a href=\"#如何给Spring-容器提供配置元数据？Spring有几种配置方式\" class=\"headerlink\" title=\"如何给Spring 容器提供配置元数据？Spring有几种配置方式\"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>\n<ul>\n<li>XML配置文件。</li>\n<li>基于注解的配置。</li>\n<li>基于Java的配置。</li>\n</ul>\n<h3 id=\"Spring配置文件包含了哪些信息\"><a href=\"#Spring配置文件包含了哪些信息\" class=\"headerlink\" title=\"Spring配置文件包含了哪些信息\"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入ioc容器中，该对象可以通过id来获取</p>\n<h3 id=\"Spring基于xml注入bean的几种方式\"><a href=\"#Spring基于xml注入bean的几种方式\" class=\"headerlink\" title=\"Spring基于xml注入bean的几种方式\"></a>Spring基于xml注入bean的几种方式</h3><ol>\n<li>Set方法注入：<code>&lt;property name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>构造器注入：<code>&lt;construtor-arg type/index/name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>静态工厂注入；factory-bean factory-method</li>\n<li>实例工厂； class factory-method</li>\n</ol>\n<h3 id=\"解释Spring支持的几种bean的作用域\"><a href=\"#解释Spring支持的几种bean的作用域\" class=\"headerlink\" title=\"解释Spring支持的几种bean的作用域\"></a>解释Spring支持的几种bean的作用域</h3><p>Spring框架支持以下五种bean的作用域：</p>\n<ul>\n<li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li>\n<li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li>\n<li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>\n<li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>\n<li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>\n</ul>\n<p><strong>注意：</strong> 缺省的Spring bean 的作用域是singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>\n<h3 id=\"Spring框架中的单例bean是线程安全的吗？\"><a href=\"#Spring框架中的单例bean是线程安全的吗？\" class=\"headerlink\" title=\"Spring框架中的单例bean是线程安全的吗？\"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n<p>然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n<blockquote>\n<p>有状态就是有数据存储功能<br>无状态就是不会保存数据</p>\n</blockquote>\n<h3 id=\"Spring如何处理线程并发问题？\"><a href=\"#Spring如何处理线程并发问题？\" class=\"headerlink\" title=\"Spring如何处理线程并发问题？\"></a>Spring如何处理线程并发问题？</h3><p><strong>Spring使用ThreadLocal对一些Bean的线程安全问题进行处理</strong>。</p>\n<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>\n<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>\n<h3 id=\"解释Spring框架中bean的生命周期\"><a href=\"#解释Spring框架中bean的生命周期\" class=\"headerlink\" title=\"解释Spring框架中bean的生命周期\"></a>解释Spring框架中bean的生命周期</h3><p>参考：<a href=\"https://www.cnblogs.com/javazhiyin/p/10905294.html\">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png\" alt=\"Spring中Bean的生命周期\"></p>\n<p><strong>1、实例化Bean：</strong></p>\n<p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p>\n<p><strong>2、依赖注入：</strong></p>\n<p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p>\n<p><strong>3、处理Aware接口（配置Bean对象的id值、工厂&#x2F;上下文）：</strong></p>\n<p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p>\n<ul>\n<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</li>\n<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身；</li>\n<li>如果这个Bean已经实现了ApplicationContextAware接口，会调setApplicationContext(ApplicationContext)方法，传入Spring上下文；</li>\n</ul>\n<p><strong>4、postProcessBeforeInitialization（初始化前置处理）：</strong></p>\n<p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>\n<p><strong>5、自定义初始化init-method：</strong></p>\n<p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的<strong>自定义初始化</strong>方法。</p>\n<p><strong>6、postProcessAfterInitialization（初始化后置处理）</strong></p>\n<p>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法，<strong>AOP在这个时候进行代理对象的创建</strong>。</p>\n<p><strong>NOW</strong> 以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p>\n<p><strong>7、清理阶段destroy：</strong></p>\n<p>当Bean不再需要时，会进入清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p>\n<p><strong>8、自定义销毁destroy-method：</strong></p>\n<p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的<strong>自定义销毁</strong>方法。</p>\n<h3 id=\"在-Spring中如何注入一个Java集合？\"><a href=\"#在-Spring中如何注入一个Java集合？\" class=\"headerlink\" title=\"在 Spring中如何注入一个Java集合？\"></a>在 Spring中如何注入一个Java集合？</h3><p>用<code>&lt;list&gt;</code>注入一列值，用<code>&lt;map&gt;</code>注入一组映射数据。</p>\n<h3 id=\"什么是bean装配？\"><a href=\"#什么是bean装配？\" class=\"headerlink\" title=\"什么是bean装配？\"></a>什么是bean装配？</h3><p>通过bean的依赖关系，使用依赖注入将spring中的bean装配在一起。<br>spring可以通过bean的依赖关系自动完成bean之间的配置。</p>\n<h3 id=\"Spring-自动装配-bean-有哪些方式？\"><a href=\"#Spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"Spring 自动装配 bean 有哪些方式？\"></a>Spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p>\n<p>在Spring框架xml配置中共有5种自动装配：</p>\n<ul>\n<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>\n<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>\n<li>byType：通过参数的数据类型进行自动装配。</li>\n<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>\n<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>\n</ul>\n<h3 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置注解扫描 <code>&lt;context:annotation-config /&gt;</code>。</p>\n<p>在启动spring IoC时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中<strong>查询对应类型</strong>的bean：</p>\n<ul>\n<li>如果对应类型查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>\n<li>如果对应类型查询的结果不止一个，那么@Autowired会根据名称来查找；</li>\n<li>如果上述查找的结果为空或者不止一个，那么会抛出异常。</li>\n</ul>\n<h2 id=\"Spring注解\"><a href=\"#Spring注解\" class=\"headerlink\" title=\"Spring注解\"></a>Spring注解</h2><h3 id=\"什么是基于Java的Spring注解配置-给一些注解的例子\"><a href=\"#什么是基于Java的Spring注解配置-给一些注解的例子\" class=\"headerlink\" title=\"什么是基于Java的Spring注解配置? 给一些注解的例子\"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>\n<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>\n<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StudentConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StudentBean <span class=\"title function_\">myStudent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StudentBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"怎样开启注解装配？\"><a href=\"#怎样开启注解装配？\" class=\"headerlink\" title=\"怎样开启注解装配？\"></a>怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，必须在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>。</p>\n<h3 id=\"Component-Controller-Repository-Service-有何区别？\"><a href=\"#Component-Controller-Repository-Service-有何区别？\" class=\"headerlink\" title=\"@Component, @Controller, @Repository, @Service 有何区别？\"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到IoC容器中。</p>\n<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>\n<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>\n<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>\n<h3 id=\"Required-注解有什么作用\"><a href=\"#Required-注解有什么作用\" class=\"headerlink\" title=\"@Required 注解有什么作用\"></a>@Required 注解有什么作用</h3><p><code>@Required</code>注解作用于Bean<code>setter</code>方法上，用于检查一个Bean的属性的值<strong>在配置期间是否被赋予或设置</strong>，如果未被设置，容器将抛出BeanInitializationException。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Required</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> string <span class=\"title function_\">getName</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>\n<p>@Autowired和@Resource之间的区别</p>\n<ul>\n<li>@Autowired默认是<strong>按照类型装配注入</strong>的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>\n<li>@Resource默认是<strong>按照名称来装配注入</strong>的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>\n</ul>\n<h3 id=\"Qualifier-注解有什么作用\"><a href=\"#Qualifier-注解有什么作用\" class=\"headerlink\" title=\"@Qualifier 注解有什么作用\"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<h3 id=\"RequestMapping-注解有什么用？\"><a href=\"#RequestMapping-注解有什么用？\" class=\"headerlink\" title=\"@RequestMapping 注解有什么用？\"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p>\n<ul>\n<li>类级别：映射请求的 URL</li>\n<li>方法级别：映射 URL 以及 HTTP 请求方法</li>\n</ul>\n<h2 id=\"Spring事务\"><a href=\"#Spring事务\" class=\"headerlink\" title=\"Spring事务\"></a>Spring事务</h2><h3 id=\"Spring支持的事务管理类型-x2F-事务实现方式有哪些？\"><a href=\"#Spring支持的事务管理类型-x2F-事务实现方式有哪些？\" class=\"headerlink\" title=\"Spring支持的事务管理类型&#x2F;事务实现方式有哪些？\"></a>Spring支持的事务管理类型&#x2F;事务实现方式有哪些？</h3><p>Spring支持两种类型的事务管理：</p>\n<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>\n<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>\n<h3 id=\"Spring事务的实现方式和实现原理\"><a href=\"#Spring事务的实现方式和实现原理\" class=\"headerlink\" title=\"Spring事务的实现方式和实现原理\"></a>Spring事务的实现方式和实现原理</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring是无法提供事务功能的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 2、配置事务的通知以及事务的属性--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务的属性</span></span><br><span class=\"line\"><span class=\"comment\">isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔</span></span><br><span class=\"line\"><span class=\"comment\">离级别。</span></span><br><span class=\"line\"><span class=\"comment\">propagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会</span></span><br><span class=\"line\"><span class=\"comment\">有事务。查询方法可以选择SUPPORTS。</span></span><br><span class=\"line\"><span class=\"comment\">read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是</span></span><br><span class=\"line\"><span class=\"comment\">false，表示读写。</span></span><br><span class=\"line\"><span class=\"comment\">timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，</span></span><br><span class=\"line\"><span class=\"comment\">以秒为单位。</span></span><br><span class=\"line\"><span class=\"comment\">rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，</span></span><br><span class=\"line\"><span class=\"comment\">事务不回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常</span></span><br><span class=\"line\"><span class=\"comment\">时事务回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--非查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;find*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;SUPPORTS&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说一下Spring的事务传播行为\"><a href=\"#说一下Spring的事务传播行为\" class=\"headerlink\" title=\"说一下Spring的事务传播行为\"></a>说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>\n<blockquote>\n<p>① <strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）<br>② <strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ <strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n</blockquote>\n<h3 id=\"说一下-spring-的事务隔离？\"><a href=\"#说一下-spring-的事务隔离？\" class=\"headerlink\" title=\"说一下 spring 的事务隔离？\"></a>说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>\n<ol>\n<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>\n<li>ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；</li>\n<li>ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；</li>\n<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>\n<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ol>\n<h2 id=\"Spring面向切面编程-AOP\"><a href=\"#Spring面向切面编程-AOP\" class=\"headerlink\" title=\"Spring面向切面编程(AOP)\"></a>Spring面向切面编程(AOP)</h2><h3 id=\"什么是AOP\"><a href=\"#什么是AOP\" class=\"headerlink\" title=\"什么是AOP\"></a>什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些<strong>公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等</strong>。</p>\n<h3 id=\"Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\"><a href=\"#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\" class=\"headerlink\" title=\"Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。</p>\n<p>（1）AspectJ 采用静态代理模式，属于<strong>编译时增强</strong>，会在编译阶段织入切面生成相应的代理对象</p>\n<p>（2）Spring AOP 采用动态代理模式，属于<strong>运行时增强</strong>，每次运行时织入切面在内存中临时生成相应的代理对象</p>\n<h3 id=\"JDK动态代理和CGLIB动态代理的区别\"><a href=\"#JDK动态代理和CGLIB动态代理的区别\" class=\"headerlink\" title=\"JDK动态代理和CGLIB动态代理的区别\"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。</p>\n<p>而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是<strong>基于 asm 第三方框架</strong>，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。</p>\n<blockquote>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h3 id=\"解释一下Spring-AOP里面的几个名词\"><a href=\"#解释一下Spring-AOP里面的几个名词\" class=\"headerlink\" title=\"解释一下Spring AOP里面的几个名词\"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>\n<p>（2）连接点（Join point）：方法</p>\n<p>（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强</p>\n<p>（4）切入点（Pointcut）：哪些连接点需要增强</p>\n<p>（5）目标对象（Target Object）： 被代理（proxied） 对象。</p>\n<p>（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。</p>\n<p>（7）Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类。</p>\n<blockquote>\n<ul>\n<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>\n</ul>\n</blockquote>\n<h3 id=\"Spring通知有哪些类型？\"><a href=\"#Spring通知有哪些类型？\" class=\"headerlink\" title=\"Spring通知有哪些类型？\"></a>Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>\n<p>Spring切面可以应用5种类型的通知：</p>\n<ol>\n<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>\n<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>\n<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>\n<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>\n<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>\n</ol>\n<blockquote>\n<p>同一个aspect，不同advice的执行顺序：</p>\n<p>①没有异常情况下的执行顺序：</p>\n<p>around before advice\t方法调用之前自定义行为<br>before advice<br>target method 执行<br>around after advice\t方法调用后自定义行为<br>after advice<br>afterReturning</p>\n<p>②有异常情况下的执行顺序：</p>\n<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>Java.lang.RuntimeException: 异常发生</p>\n</blockquote>\n<h3 id=\"什么是切面-Aspect？\"><a href=\"#什么是切面-Aspect？\" class=\"headerlink\" title=\"什么是切面 Aspect？\"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  </p>\n<ul>\n<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>\n<li>如何在 advice 中编写切面代码</li>\n</ul>\n<p>可以简单地认为, 使用 @Aspect 注解的类就是切面</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"length":15032,"excerpt":"<blockquote>\n<p>整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Spring概述\"><a href=\"#Spring概述\" class=\"headerlink\" title=\"Spring概述\"></a>Spring概述</h2><h3 id=\"什么是spring\"><a href=\"#什么是spring\" class=\"headerlink\" title=\"什么是spring?\"></a>什么是spring?</h3><p>Spring是<strong>一个轻量级Java开发框架</strong>，目的是为了解决开发中的<strong>业务逻辑层和其他各层的耦合问题</strong>，简化Java开发。</p>\n<h3 id=\"Spring框架的核心是什么\"><a href=\"#Spring框架的核心是什么\" class=\"headerlink\" title=\"Spring框架的核心是什么\"></a>Spring框架的核心是什么</h3><p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。<br>通过IoC容器管理Java Bean对象及其生命周期以及他们之间的耦合关系；<br>通过AOP将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度</p>\n<h3 id=\"Spring的优缺点是什么？\"><a href=\"#Spring的优缺点是什么？\" class=\"headerlink\" title=\"Spring的优缺点是什么？\"></a>Spring的优缺点是什么？</h3><p>优点</p>\n<ul>\n<li><p>方便解耦，简化开发（<strong>IoC</strong>）</p>\n<p>  Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</p>\n</li>\n<li><p>AOP编程的支持（<strong>AOP</strong>）</p>\n<p>  Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n</li>\n<li><p>声明式事务的支持（<strong>事务</strong>）</p>\n<p>  只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n</li>\n<li><p>方便集成各种优秀框架（<strong>集成</strong>）</p>\n<p>  Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</p>\n</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>Spring<strong>依赖反射，反射影响性能</strong></li>\n</ul>\n<h3 id=\"Spring-框架中都用到了哪些设计模式？\"><a href=\"#Spring-框架中都用到了哪些设计模式？\" class=\"headerlink\" title=\"Spring 框架中都用到了哪些设计模式？\"></a>Spring 框架中都用到了哪些设计模式？</h3><ol>\n<li>工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。</li>\n<li>单例模式：Bean默认为单例模式。</li>\n<li>代理模式：Spring的AOP功能用到了基于接口的JDK的动态代理和基于子类的CGLIB动态代理；</li>\n</ol>\n<h3 id=\"Spring框架中有哪些不同类型的事件\"><a href=\"#Spring框架中有哪些不同类型的事件\" class=\"headerlink\" title=\"Spring框架中有哪些不同类型的事件\"></a>Spring框架中有哪些不同类型的事件</h3><p><strong>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</strong>  </p>\n<p>如果一个bean实现了<code>ApplicationListener</code>接口，当一个<code>ApplicationEvent</code> 被发布以后，bean会自动被通知。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> <span class=\"title class_\">AllApplicationEventListener</span> implements <span class=\"title class_\">ApplicationListener</span> &lt; <span class=\"title class_\">ApplicationEvent</span> &gt;&#123;</span><br><span class=\"line\">    @<span class=\"title class_\">Override</span></span><br><span class=\"line\">    public <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span>(<span class=\"params\">ApplicationEvent applicationEvent</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//process event</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Spring 提供了以下5种标准的事件：</strong></p>\n<ul>\n<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用<code>ConfigurableApplicationContext</code> 接口中的<code>refresh()</code>方法时被触发。</li>\n<li>上下文开始事件（ContextStartedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Start()</code>方法开始&#x2F;重新开始容器时触发该事件。</li>\n<li>上下文停止事件（ContextStoppedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Stop()</code>方法停止容器时触发该事件。</li>\n<li>上下文关闭事件（ContextClosedEvent）：当<code>ApplicationContext</code>被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li>\n<li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。</li>\n</ul>\n<h3 id=\"Spring-应用程序有哪些不同组件？\"><a href=\"#Spring-应用程序有哪些不同组件？\" class=\"headerlink\" title=\"Spring 应用程序有哪些不同组件？\"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>\n<ul>\n<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>\n<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>\n<li>接口 - 处理 Bean </li>\n<li>用户程序 - 它使用接口。</li>\n</ul>\n<h2 id=\"Spring控制反转-IOC\"><a href=\"#Spring控制反转-IOC\" class=\"headerlink\" title=\"Spring控制反转(IOC)\"></a>Spring控制反转(IOC)</h2><h3 id=\"什么是Spring-IOC-容器？\"><a href=\"#什么是Spring-IOC-容器？\" class=\"headerlink\" title=\"什么是Spring IOC 容器？\"></a>什么是Spring IOC 容器？</h3><p>Spring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC让相互协作的组件保持松耦合。</p>\n<h3 id=\"Spring-IoC-的实现机制\"><a href=\"#Spring-IoC-的实现机制\" class=\"headerlink\" title=\"Spring IoC 的实现机制\"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Orange</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Fruit <span class=\"title function_\">getInstance</span><span class=\"params\">(String className)</span> &#123;\t<span class=\"comment\">// 使用反射，用字符串获取到实例</span></span><br><span class=\"line\">        Fruit f=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            f = (Fruit) Class.forName(className).newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] a)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Fruit</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Factory.getInstance(<span class=\"string\">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            f.eat();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BeanFactory-和-ApplicationContext有什么区别？\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别？\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别？\"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。<br>ApplicationContext是BeanFactory的子接口。</p>\n<ol>\n<li>依赖关系</li>\n</ol>\n<p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p>\n<p>ApplicationContext接口作为BeanFactory的子接口，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>支持国际化。</li>\n<li>支持访问文件资源</li>\n<li>支持事件发布通知</li>\n<li>同时加载多个配置文件。</li>\n</ul>\n<p>配置流程：</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>\n<li>加载方式</li>\n</ol>\n<p><strong>BeanFactroy</strong>采用的是<strong>延迟加载</strong>形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入或者是属性注入错误，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>\n<p><strong>ApplicationContext</strong>，它是在容器启动时，<strong>一次性创建</strong>了所有的Bean。这样，在容器启动时，我们就可以<strong>发现Spring中存在的配置错误</strong>，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>由于在容器启动时一次性创建所有的Bean，因此ApplicationContext 更加占用内存空间，当配置的Bean比较多时，程序启动较慢。</p>\n<h4 id=\"⭐BeanFactory和FactoryBean区别？\"><a href=\"#⭐BeanFactory和FactoryBean区别？\" class=\"headerlink\" title=\"⭐BeanFactory和FactoryBean区别？\"></a>⭐BeanFactory和FactoryBean区别？</h4><p>BeanFactory：是spring IoC容器的底层接口，可以用来管理bean及其生命周期；</p>\n<p>FactoryBean：如果某个 bean 实现了FactoryBean这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值</p>\n<h3 id=\"ApplicationContext通常的实现是什么？\"><a href=\"#ApplicationContext通常的实现是什么？\" class=\"headerlink\" title=\"ApplicationContext通常的实现是什么？\"></a>ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>\n<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p>\n<p><strong>AnnotationConfigApplicationContext</strong>：它是用于读取注解创建容器的</p>\n<h3 id=\"什么是Spring的依赖注入？\"><a href=\"#什么是Spring的依赖注入？\" class=\"headerlink\" title=\"什么是Spring的依赖注入？\"></a>什么是Spring的依赖注入？</h3><p>具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</p>\n<h3 id=\"依赖注入有什么优势\"><a href=\"#依赖注入有什么优势\" class=\"headerlink\" title=\"依赖注入有什么优势\"></a>依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>\n<ul>\n<li>查找定位操作与应用代码完全无关。</li>\n<li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li>\n<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>\n</ul>\n<h3 id=\"有哪些不同类型的依赖注入实现方式？\"><a href=\"#有哪些不同类型的依赖注入实现方式？\" class=\"headerlink\" title=\"有哪些不同类型的依赖注入实现方式？\"></a>有哪些不同类型的依赖注入实现方式？</h3><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>\n<p><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p>\n<h3 id=\"构造器依赖注入和-setter方法注入的区别\"><a href=\"#构造器依赖注入和-setter方法注入的区别\" class=\"headerlink\" title=\"构造器依赖注入和 setter方法注入的区别\"></a>构造器依赖注入和 setter方法注入的区别</h3><p>（部分注入）在setter注入,可以将依赖项部分注入,构造方法注入不能部分注入。</p>\n<p>（属性覆盖）如果我们为同一属性提供setter和构造方法注入，setter注入将覆盖构造方法注入。但是构造方法注入不能覆盖setter注入值。显然，构造方法注入被称为创建实例的第一选项。</p>\n<p>（循环依赖）在构造函数注入,如果A和B对象相互依赖：A依赖于B,B也依赖于A,此时在创建对象的A或者B时，Spring抛出ObjectCurrentlyInCreationException。所以Spring可以通过setter注入,从而解决循环依赖的问题。</p>\n<p><strong>最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖</strong></p>\n<h3 id=\"讲一讲Spring中的循环依赖\"><a href=\"#讲一讲Spring中的循环依赖\" class=\"headerlink\" title=\"讲一讲Spring中的循环依赖\"></a>讲一讲Spring中的循环依赖</h3><p><a href=\"https://www.cnblogs.com/daimzh/p/13256413.html\">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_49592546/article/details/108050566\">https://blog.csdn.net/weixin_49592546/article/details/108050566</a></p>\n<h4 id=\"什么是循环依赖？\"><a href=\"#什么是循环依赖？\" class=\"headerlink\" title=\"什么是循环依赖？\"></a>什么是循环依赖？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A中注入了B</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// B中也注入了A</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Spring是如何解决的循环依赖？\"><a href=\"#Spring是如何解决的循环依赖？\" class=\"headerlink\" title=\"Spring是如何解决的循环依赖？\"></a>Spring是如何解决的循环依赖？</h4><blockquote>\n<p>以下：</p>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<p>首先，Spring 解决循环依赖有两个前提条件：</p>\n<ol>\n<li>不全是构造器方式的循环依赖</li>\n<li>必须是单例</li>\n</ol>\n<p>基于上面的问题，我们知道Bean的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>第一级缓存：用来保存实例化、初始化都完成的对象</p>\n<p>第二级缓存：用来保存实例化完成，但是未初始化完成的对象</p>\n<p>第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg\" alt=\"Spring三级缓存\"></p>\n<p>假设一个简单的循环依赖场景，A、B互相依赖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg\" alt=\"简单的循环依赖场景\"></p>\n<p>A对象的创建过程：</p>\n<ol>\n<li>创建对象A，实例化的时候把A对象工厂放入三级缓存；</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg\" alt=\"实例化对象A\"></p>\n<ol start=\"2\">\n<li><p>A注入属性时，发现依赖B，转而去实例化B</p>\n</li>\n<li><p>同样创建对象B，注入属性时发现依赖A，依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg\" alt=\"创建对象B\"></p>\n<ol start=\"4\">\n<li><p>接着继续创建A，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存</p>\n</li>\n<li><p>最后，一级缓存中保存着实例化、初始化都完成的A、B对象</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg\" alt=\"最终结果\"></p>\n<p>因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。</p>\n<h3 id=\"8-为什么要三级缓存？二级不行吗？\"><a href=\"#8-为什么要三级缓存？二级不行吗？\" class=\"headerlink\" title=\"8. 为什么要三级缓存？二级不行吗？\"></a>8. 为什么要三级缓存？二级不行吗？</h3><p>不可以，主要是为了生成代理对象。</p>\n<p>因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。</p>\n<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，<code>BeanPostProcessor</code>去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg\" alt=\"A代理对象覆盖A普通Bean\"></p>\n<h2 id=\"Spring-Beans\"><a href=\"#Spring-Beans\" class=\"headerlink\" title=\"Spring Beans\"></a>Spring Beans</h2><h3 id=\"如何给Spring-容器提供配置元数据？Spring有几种配置方式\"><a href=\"#如何给Spring-容器提供配置元数据？Spring有几种配置方式\" class=\"headerlink\" title=\"如何给Spring 容器提供配置元数据？Spring有几种配置方式\"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p>\n<ul>\n<li>XML配置文件。</li>\n<li>基于注解的配置。</li>\n<li>基于Java的配置。</li>\n</ul>\n<h3 id=\"Spring配置文件包含了哪些信息\"><a href=\"#Spring配置文件包含了哪些信息\" class=\"headerlink\" title=\"Spring配置文件包含了哪些信息\"></a>Spring配置文件包含了哪些信息</h3><p>Spring配置文件是个XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入ioc容器中，该对象可以通过id来获取</p>\n<h3 id=\"Spring基于xml注入bean的几种方式\"><a href=\"#Spring基于xml注入bean的几种方式\" class=\"headerlink\" title=\"Spring基于xml注入bean的几种方式\"></a>Spring基于xml注入bean的几种方式</h3><ol>\n<li>Set方法注入：<code>&lt;property name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>构造器注入：<code>&lt;construtor-arg type/index/name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>静态工厂注入；factory-bean factory-method</li>\n<li>实例工厂； class factory-method</li>\n</ol>\n<h3 id=\"解释Spring支持的几种bean的作用域\"><a href=\"#解释Spring支持的几种bean的作用域\" class=\"headerlink\" title=\"解释Spring支持的几种bean的作用域\"></a>解释Spring支持的几种bean的作用域</h3><p>Spring框架支持以下五种bean的作用域：</p>\n<ul>\n<li><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</li>\n<li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li>\n<li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>\n<li><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>\n<li><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>\n</ul>\n<p><strong>注意：</strong> 缺省的Spring bean 的作用域是singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>\n<h3 id=\"Spring框架中的单例bean是线程安全的吗？\"><a href=\"#Spring框架中的单例bean是线程安全的吗？\" class=\"headerlink\" title=\"Spring框架中的单例bean是线程安全的吗？\"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring框架中的单例bean不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n<p>然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n<blockquote>\n<p>有状态就是有数据存储功能<br>无状态就是不会保存数据</p>\n</blockquote>\n<h3 id=\"Spring如何处理线程并发问题？\"><a href=\"#Spring如何处理线程并发问题？\" class=\"headerlink\" title=\"Spring如何处理线程并发问题？\"></a>Spring如何处理线程并发问题？</h3><p><strong>Spring使用ThreadLocal对一些Bean的线程安全问题进行处理</strong>。</p>\n<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p>\n<p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>\n<h3 id=\"解释Spring框架中bean的生命周期\"><a href=\"#解释Spring框架中bean的生命周期\" class=\"headerlink\" title=\"解释Spring框架中bean的生命周期\"></a>解释Spring框架中bean的生命周期</h3><p>参考：<a href=\"https://www.cnblogs.com/javazhiyin/p/10905294.html\">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png\" alt=\"Spring中Bean的生命周期\"></p>\n<p><strong>1、实例化Bean：</strong></p>\n<p>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。<br>对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</p>\n<p><strong>2、依赖注入：</strong></p>\n<p>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。</p>\n<p><strong>3、处理Aware接口（配置Bean对象的id值、工厂&#x2F;上下文）：</strong></p>\n<p>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean：</p>\n<ul>\n<li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值；</li>\n<li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身；</li>\n<li>如果这个Bean已经实现了ApplicationContextAware接口，会调setApplicationContext(ApplicationContext)方法，传入Spring上下文；</li>\n</ul>\n<p><strong>4、postProcessBeforeInitialization（初始化前置处理）：</strong></p>\n<p>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>\n<p><strong>5、自定义初始化init-method：</strong></p>\n<p>如果Bean在Spring配置文件中配置了 init-method 属性，则会自动调用其配置的<strong>自定义初始化</strong>方法。</p>\n<p><strong>6、postProcessAfterInitialization（初始化后置处理）</strong></p>\n<p>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法，<strong>AOP在这个时候进行代理对象的创建</strong>。</p>\n<p><strong>NOW</strong> 以上几个步骤完成后，Bean就已经被正确创建了，之后就可以使用这个Bean了。</p>\n<p><strong>7、清理阶段destroy：</strong></p>\n<p>当Bean不再需要时，会进入清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法；</p>\n<p><strong>8、自定义销毁destroy-method：</strong></p>\n<p>最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的<strong>自定义销毁</strong>方法。</p>\n<h3 id=\"在-Spring中如何注入一个Java集合？\"><a href=\"#在-Spring中如何注入一个Java集合？\" class=\"headerlink\" title=\"在 Spring中如何注入一个Java集合？\"></a>在 Spring中如何注入一个Java集合？</h3><p>用<code>&lt;list&gt;</code>注入一列值，用<code>&lt;map&gt;</code>注入一组映射数据。</p>\n<h3 id=\"什么是bean装配？\"><a href=\"#什么是bean装配？\" class=\"headerlink\" title=\"什么是bean装配？\"></a>什么是bean装配？</h3><p>通过bean的依赖关系，使用依赖注入将spring中的bean装配在一起。<br>spring可以通过bean的依赖关系自动完成bean之间的配置。</p>\n<h3 id=\"Spring-自动装配-bean-有哪些方式？\"><a href=\"#Spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"Spring 自动装配 bean 有哪些方式？\"></a>Spring 自动装配 bean 有哪些方式？</h3><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p>\n<p>在Spring框架xml配置中共有5种自动装配：</p>\n<ul>\n<li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li>\n<li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li>\n<li>byType：通过参数的数据类型进行自动装配。</li>\n<li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li>\n<li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li>\n</ul>\n<h3 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置注解扫描 <code>&lt;context:annotation-config /&gt;</code>。</p>\n<p>在启动spring IoC时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中<strong>查询对应类型</strong>的bean：</p>\n<ul>\n<li>如果对应类型查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li>\n<li>如果对应类型查询的结果不止一个，那么@Autowired会根据名称来查找；</li>\n<li>如果上述查找的结果为空或者不止一个，那么会抛出异常。</li>\n</ul>\n<h2 id=\"Spring注解\"><a href=\"#Spring注解\" class=\"headerlink\" title=\"Spring注解\"></a>Spring注解</h2><h3 id=\"什么是基于Java的Spring注解配置-给一些注解的例子\"><a href=\"#什么是基于Java的Spring注解配置-给一些注解的例子\" class=\"headerlink\" title=\"什么是基于Java的Spring注解配置? 给一些注解的例子\"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p>\n<p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p>\n<p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StudentConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StudentBean <span class=\"title function_\">myStudent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StudentBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"怎样开启注解装配？\"><a href=\"#怎样开启注解装配？\" class=\"headerlink\" title=\"怎样开启注解装配？\"></a>怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，必须在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>。</p>\n<h3 id=\"Component-Controller-Repository-Service-有何区别？\"><a href=\"#Component-Controller-Repository-Service-有何区别？\" class=\"headerlink\" title=\"@Component, @Controller, @Repository, @Service 有何区别？\"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到IoC容器中。</p>\n<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>\n<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>\n<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>\n<h3 id=\"Required-注解有什么作用\"><a href=\"#Required-注解有什么作用\" class=\"headerlink\" title=\"@Required 注解有什么作用\"></a>@Required 注解有什么作用</h3><p><code>@Required</code>注解作用于Bean<code>setter</code>方法上，用于检查一个Bean的属性的值<strong>在配置期间是否被赋予或设置</strong>，如果未被设置，容器将抛出BeanInitializationException。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Required</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> string <span class=\"title function_\">getName</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired可用于：构造函数、成员变量、Setter方法</p>\n<p>@Autowired和@Resource之间的区别</p>\n<ul>\n<li>@Autowired默认是<strong>按照类型装配注入</strong>的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</li>\n<li>@Resource默认是<strong>按照名称来装配注入</strong>的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</li>\n</ul>\n<h3 id=\"Qualifier-注解有什么作用\"><a href=\"#Qualifier-注解有什么作用\" class=\"headerlink\" title=\"@Qualifier 注解有什么作用\"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<h3 id=\"RequestMapping-注解有什么用？\"><a href=\"#RequestMapping-注解有什么用？\" class=\"headerlink\" title=\"@RequestMapping 注解有什么用？\"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p>\n<ul>\n<li>类级别：映射请求的 URL</li>\n<li>方法级别：映射 URL 以及 HTTP 请求方法</li>\n</ul>\n<h2 id=\"Spring事务\"><a href=\"#Spring事务\" class=\"headerlink\" title=\"Spring事务\"></a>Spring事务</h2><h3 id=\"Spring支持的事务管理类型-x2F-事务实现方式有哪些？\"><a href=\"#Spring支持的事务管理类型-x2F-事务实现方式有哪些？\" class=\"headerlink\" title=\"Spring支持的事务管理类型&#x2F;事务实现方式有哪些？\"></a>Spring支持的事务管理类型&#x2F;事务实现方式有哪些？</h3><p>Spring支持两种类型的事务管理：</p>\n<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>\n<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p>\n<h3 id=\"Spring事务的实现方式和实现原理\"><a href=\"#Spring事务的实现方式和实现原理\" class=\"headerlink\" title=\"Spring事务的实现方式和实现原理\"></a>Spring事务的实现方式和实现原理</h3><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring是无法提供事务功能的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 2、配置事务的通知以及事务的属性--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务的属性</span></span><br><span class=\"line\"><span class=\"comment\">isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔</span></span><br><span class=\"line\"><span class=\"comment\">离级别。</span></span><br><span class=\"line\"><span class=\"comment\">propagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会</span></span><br><span class=\"line\"><span class=\"comment\">有事务。查询方法可以选择SUPPORTS。</span></span><br><span class=\"line\"><span class=\"comment\">read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是</span></span><br><span class=\"line\"><span class=\"comment\">false，表示读写。</span></span><br><span class=\"line\"><span class=\"comment\">timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，</span></span><br><span class=\"line\"><span class=\"comment\">以秒为单位。</span></span><br><span class=\"line\"><span class=\"comment\">rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，</span></span><br><span class=\"line\"><span class=\"comment\">事务不回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常</span></span><br><span class=\"line\"><span class=\"comment\">时事务回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--非查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;find*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;SUPPORTS&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说一下Spring的事务传播行为\"><a href=\"#说一下Spring的事务传播行为\" class=\"headerlink\" title=\"说一下Spring的事务传播行为\"></a>说一下Spring的事务传播行为</h3><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p>\n<blockquote>\n<p>① <strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）<br>② <strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ <strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n</blockquote>\n<h3 id=\"说一下-spring-的事务隔离？\"><a href=\"#说一下-spring-的事务隔离？\" class=\"headerlink\" title=\"说一下 spring 的事务隔离？\"></a>说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>\n<ol>\n<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>\n<li>ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；</li>\n<li>ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；</li>\n<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>\n<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ol>\n<h2 id=\"Spring面向切面编程-AOP\"><a href=\"#Spring面向切面编程-AOP\" class=\"headerlink\" title=\"Spring面向切面编程(AOP)\"></a>Spring面向切面编程(AOP)</h2><h3 id=\"什么是AOP\"><a href=\"#什么是AOP\" class=\"headerlink\" title=\"什么是AOP\"></a>什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些<strong>公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等</strong>。</p>\n<h3 id=\"Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\"><a href=\"#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\" class=\"headerlink\" title=\"Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。</p>\n<p>（1）AspectJ 采用静态代理模式，属于<strong>编译时增强</strong>，会在编译阶段织入切面生成相应的代理对象</p>\n<p>（2）Spring AOP 采用动态代理模式，属于<strong>运行时增强</strong>，每次运行时织入切面在内存中临时生成相应的代理对象</p>\n<h3 id=\"JDK动态代理和CGLIB动态代理的区别\"><a href=\"#JDK动态代理和CGLIB动态代理的区别\" class=\"headerlink\" title=\"JDK动态代理和CGLIB动态代理的区别\"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。</p>\n<p>而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是<strong>基于 asm 第三方框架</strong>，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。</p>\n<blockquote>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h3 id=\"解释一下Spring-AOP里面的几个名词\"><a href=\"#解释一下Spring-AOP里面的几个名词\" class=\"headerlink\" title=\"解释一下Spring AOP里面的几个名词\"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>\n<p>（2）连接点（Join point）：方法</p>\n<p>（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强</p>\n<p>（4）切入点（Pointcut）：哪些连接点需要增强</p>\n<p>（5）目标对象（Target Object）： 被代理（proxied） 对象。</p>\n<p>（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。</p>\n<p>（7）Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类。</p>\n<blockquote>\n<ul>\n<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>\n</ul>\n</blockquote>\n<h3 id=\"Spring通知有哪些类型？\"><a href=\"#Spring通知有哪些类型？\" class=\"headerlink\" title=\"Spring通知有哪些类型？\"></a>Spring通知有哪些类型？</h3><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p>\n<p>Spring切面可以应用5种类型的通知：</p>\n<ol>\n<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>\n<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>\n<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>\n<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>\n<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>\n</ol>\n<blockquote>\n<p>同一个aspect，不同advice的执行顺序：</p>\n<p>①没有异常情况下的执行顺序：</p>\n<p>around before advice\t方法调用之前自定义行为<br>before advice<br>target method 执行<br>around after advice\t方法调用后自定义行为<br>after advice<br>afterReturning</p>\n<p>②有异常情况下的执行顺序：</p>\n<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>Java.lang.RuntimeException: 异常发生</p>\n</blockquote>\n<h3 id=\"什么是切面-Aspect？\"><a href=\"#什么是切面-Aspect？\" class=\"headerlink\" title=\"什么是切面 Aspect？\"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  </p>\n<ul>\n<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>\n<li>如何在 advice 中编写切面代码</li>\n</ul>\n<p>可以简单地认为, 使用 @Aspect 注解的类就是切面</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png\" alt=\"在这里插入图片描述\"></p>"},{"title":"Java八股文 - SpringMVC","copyright":true,"mathjax":false,"date":"2023-01-23T08:14:20.000Z","toc":true,"urlname":"java-springmvc","_content":"\n> 整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n## 概述\n\n### 什么是Spring MVC？简单介绍下你对Spring MVC的理解？\n\nSpring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，简化开发。\n\n## 核心组件\n\n### Spring MVC的主要组件？\n\n（1）前端控制器 DispatcherServlet（不需要程序员开发）\n\n作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器HandlerMapping（不需要程序员开发）\n\n作用：根据请求的URL来查找Handler\n\n（3）处理器适配器HandlerAdapter\n\n注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。\n\n（4）处理器Handler（需要程序员开发）\n\n（5）视图解析器 ViewResolver（不需要程序员开发）\n\n作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）\n\n（6）视图View（需要程序员开发jsp）\n\nView是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）\n\n### 什么是DispatcherServlet\n\nSpring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。\n\n### 什么是Spring MVC框架的控制器？\n\n控制器使用@Controller注解，并且提供了@RequestMapping注解，通过解析url中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。\n\n### Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。\n\n## 工作原理\n\n### 请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\n\n1. 用户发送请求至前端控制器DispatcherServlet；\n2. DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler；\n3. HandlerMapping处理器映射器根据请求url**找到具体的处理器**，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；\n4. DispatcherServlet 调用 HandlerAdapter处理器适配器；\n5. HandlerAdapter 经过适配 **调用具体处理器**(Handler，也叫后端控制器)；\n6. Handler执行完成返回ModelAndView；\n7. HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；\n8. DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；\n9. ViewResolver解析后返回具体View；\n10. DispatcherServlet对View进行渲染成为视图（即将模型数据填充至视图中）；\n11. DispatcherServlet响应用户。\n\n![Spring MVC的工作流程](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png)\n\n## 常用注解\n\n### 注解原理是什么\n\n注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。\n\n### Spring MVC常用的注解有哪些？\n\n@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。\n\n@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户。\n\n### Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\n\n答：一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回json数据＋ @Controller 用于表明控制器\n\n### @Controller注解的作用\n\n@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。通过请求的url和@RequestMapping 注解对应到实际处理请求的处理器。需要开启mvc注解扫描找到@Controller的控制器。\n\n### @RequestMapping注解的作用\n\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。\n\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping注解有六个属性：\n\n**path/value， method**\n\n* value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；\n\n* method： 指定请求的method类型， GET、POST、PUT、DELETE等；\n\n**consumes，produces**\n\n* consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\n\n* produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\n\n**params，headers**\n\n* params： 指定request中必须包含某些参数值时，才让该方法处理。\n\n* headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。\n\n### @PathVariable和@RequestParam的区别\n\n@PathVariable作用： 用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是url占位符。\n\n```java\n/**\n* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法\n* 然后，其中的10就是sid占位符所占的位置的数据，然后通过@PathVaribale注解将其赋值给 id\n*/\n@RequestMapping(path = \"testPathVariable/{sid}\")\npublic String testPathVariable(@PathVariable(value = \"sid\") String id) {\n    System.out.println(\"执行了testPathVariable...\");\n    System.out.println(id);\n    return \"success\";\n}\n```\n\n@RequestParam作用： 把请求中指定名称的参数给控制器中的形参赋值。\n\n```java\n// Controller中的代码：\n@RequestMapping(path = \"/testRequestParam\")\npublic String testRequestParam(@RequestParam(value = \"name\") String username) {\n    // 把请求中指定的name赋值给控制器中的形参username\n    System.out.println(\"执行了testRequestParam...\");\n    System.out.println(username);\n    return \"success\";\n}\n```\n\n## 其他\n\n### Spring MVC怎么样设定转发和重定向的？\n\n（1）转发：使用forward\nforward是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。\n\n（2）重定向：使用redirect\n重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。请求两次服务器。重定向地址改变。\n\n### Spring MVC怎么和AJAX相互调用的？\n\n通过Jackson或者是fastjson就可以把Java里面的对象直接转化成Js可以识别的Json对象，来进行传输。\n\n### 如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n（2）get请求中文参数出现乱码解决方法有两个：\n\n修改tomcat配置文件添加编码与工程编码一致，如下：\n\n```xml\n<ConnectorURIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n\n### Spring MVC的异常处理\n\n可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n### 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\n\n答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。\n\n### 怎样在方法里面得到Request,或者Session？\n\n答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。\n\n### 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n或者使用 RequestParam注解将前台的参数名A传给形参中的参数B\n\n### 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。\n\n### Spring MVC中函数的返回值是什么？\n\n返回值可以有很多类型,有String, ModelAndView（视图和数据合并在一起）。\n\n### Spring MVC用什么对象从后台向前台传递数据的？\n\n通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。\n\n### 怎么样把ModelMap里面的数据放入Session里面？\n\n可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。\n\n### Spring MVC里面拦截器是怎么写的\n\n有两种写法,一种是实现HandlerInterceptor接口，重写prehandle等方法，然后配置拦截器\n","source":"_posts/Java八股文 - SpringMVC.md","raw":"---\ntitle: Java八股文 - SpringMVC\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 16:14:20\ntags:\ntoc: true\nurlname: java-springmvc\n---\n\n> 整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n## 概述\n\n### 什么是Spring MVC？简单介绍下你对Spring MVC的理解？\n\nSpring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，简化开发。\n\n## 核心组件\n\n### Spring MVC的主要组件？\n\n（1）前端控制器 DispatcherServlet（不需要程序员开发）\n\n作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器HandlerMapping（不需要程序员开发）\n\n作用：根据请求的URL来查找Handler\n\n（3）处理器适配器HandlerAdapter\n\n注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。\n\n（4）处理器Handler（需要程序员开发）\n\n（5）视图解析器 ViewResolver（不需要程序员开发）\n\n作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）\n\n（6）视图View（需要程序员开发jsp）\n\nView是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）\n\n### 什么是DispatcherServlet\n\nSpring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。\n\n### 什么是Spring MVC框架的控制器？\n\n控制器使用@Controller注解，并且提供了@RequestMapping注解，通过解析url中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。\n\n### Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。\n\n## 工作原理\n\n### 请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\n\n1. 用户发送请求至前端控制器DispatcherServlet；\n2. DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler；\n3. HandlerMapping处理器映射器根据请求url**找到具体的处理器**，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；\n4. DispatcherServlet 调用 HandlerAdapter处理器适配器；\n5. HandlerAdapter 经过适配 **调用具体处理器**(Handler，也叫后端控制器)；\n6. Handler执行完成返回ModelAndView；\n7. HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；\n8. DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；\n9. ViewResolver解析后返回具体View；\n10. DispatcherServlet对View进行渲染成为视图（即将模型数据填充至视图中）；\n11. DispatcherServlet响应用户。\n\n![Spring MVC的工作流程](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png)\n\n## 常用注解\n\n### 注解原理是什么\n\n注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。\n\n### Spring MVC常用的注解有哪些？\n\n@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。\n\n@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户。\n\n### Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\n\n答：一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回json数据＋ @Controller 用于表明控制器\n\n### @Controller注解的作用\n\n@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。通过请求的url和@RequestMapping 注解对应到实际处理请求的处理器。需要开启mvc注解扫描找到@Controller的控制器。\n\n### @RequestMapping注解的作用\n\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。\n\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping注解有六个属性：\n\n**path/value， method**\n\n* value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；\n\n* method： 指定请求的method类型， GET、POST、PUT、DELETE等；\n\n**consumes，produces**\n\n* consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\n\n* produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\n\n**params，headers**\n\n* params： 指定request中必须包含某些参数值时，才让该方法处理。\n\n* headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。\n\n### @PathVariable和@RequestParam的区别\n\n@PathVariable作用： 用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是url占位符。\n\n```java\n/**\n* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法\n* 然后，其中的10就是sid占位符所占的位置的数据，然后通过@PathVaribale注解将其赋值给 id\n*/\n@RequestMapping(path = \"testPathVariable/{sid}\")\npublic String testPathVariable(@PathVariable(value = \"sid\") String id) {\n    System.out.println(\"执行了testPathVariable...\");\n    System.out.println(id);\n    return \"success\";\n}\n```\n\n@RequestParam作用： 把请求中指定名称的参数给控制器中的形参赋值。\n\n```java\n// Controller中的代码：\n@RequestMapping(path = \"/testRequestParam\")\npublic String testRequestParam(@RequestParam(value = \"name\") String username) {\n    // 把请求中指定的name赋值给控制器中的形参username\n    System.out.println(\"执行了testRequestParam...\");\n    System.out.println(username);\n    return \"success\";\n}\n```\n\n## 其他\n\n### Spring MVC怎么样设定转发和重定向的？\n\n（1）转发：使用forward\nforward是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。\n\n（2）重定向：使用redirect\n重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。请求两次服务器。重定向地址改变。\n\n### Spring MVC怎么和AJAX相互调用的？\n\n通过Jackson或者是fastjson就可以把Java里面的对象直接转化成Js可以识别的Json对象，来进行传输。\n\n### 如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n（2）get请求中文参数出现乱码解决方法有两个：\n\n修改tomcat配置文件添加编码与工程编码一致，如下：\n\n```xml\n<ConnectorURIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n\n### Spring MVC的异常处理\n\n可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n### 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\n\n答：可以在@RequestMapping注解里面加上method=RequestMethod.GET。\n\n### 怎样在方法里面得到Request,或者Session？\n\n答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。\n\n### 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n或者使用 RequestParam注解将前台的参数名A传给形参中的参数B\n\n### 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。\n\n### Spring MVC中函数的返回值是什么？\n\n返回值可以有很多类型,有String, ModelAndView（视图和数据合并在一起）。\n\n### Spring MVC用什么对象从后台向前台传递数据的？\n\n通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。\n\n### 怎么样把ModelMap里面的数据放入Session里面？\n\n可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。\n\n### Spring MVC里面拦截器是怎么写的\n\n有两种写法,一种是实现HandlerInterceptor接口，重写prehandle等方法，然后配置拦截器\n","slug":"Java八股文 - SpringMVC","published":1,"updated":"2023-01-23T08:47:22.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiw000fzvt8477edsy8","content":"<blockquote>\n<p>整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\"><a href=\"#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\" class=\"headerlink\" title=\"什么是Spring MVC？简单介绍下你对Spring MVC的理解？\"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，简化开发。</p>\n<h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><h3 id=\"Spring-MVC的主要组件？\"><a href=\"#Spring-MVC的主要组件？\" class=\"headerlink\" title=\"Spring MVC的主要组件？\"></a>Spring MVC的主要组件？</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>\n<p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>\n<p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p>\n<p>作用：根据请求的URL来查找Handler</p>\n<p>（3）处理器适配器HandlerAdapter</p>\n<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>\n<p>（4）处理器Handler（需要程序员开发）</p>\n<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>\n<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>\n<p>（6）视图View（需要程序员开发jsp）</p>\n<p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>\n<h3 id=\"什么是DispatcherServlet\"><a href=\"#什么是DispatcherServlet\" class=\"headerlink\" title=\"什么是DispatcherServlet\"></a>什么是DispatcherServlet</h3><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>\n<h3 id=\"什么是Spring-MVC框架的控制器？\"><a href=\"#什么是Spring-MVC框架的控制器？\" class=\"headerlink\" title=\"什么是Spring MVC框架的控制器？\"></a>什么是Spring MVC框架的控制器？</h3><p>控制器使用@Controller注解，并且提供了@RequestMapping注解，通过解析url中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。</p>\n<h3 id=\"Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\"><a href=\"#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\" class=\"headerlink\" title=\"Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><p>单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h3 id=\"请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\"><a href=\"#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\" class=\"headerlink\" title=\"请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h3><ol>\n<li>用户发送请求至前端控制器DispatcherServlet；</li>\n<li>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler；</li>\n<li>HandlerMapping处理器映射器根据请求url<strong>找到具体的处理器</strong>，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li>\n<li>DispatcherServlet 调用 HandlerAdapter处理器适配器；</li>\n<li>HandlerAdapter 经过适配 <strong>调用具体处理器</strong>(Handler，也叫后端控制器)；</li>\n<li>Handler执行完成返回ModelAndView；</li>\n<li>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li>\n<li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</li>\n<li>ViewResolver解析后返回具体View；</li>\n<li>DispatcherServlet对View进行渲染成为视图（即将模型数据填充至视图中）；</li>\n<li>DispatcherServlet响应用户。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png\" alt=\"Spring MVC的工作流程\"></p>\n<h2 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h2><h3 id=\"注解原理是什么\"><a href=\"#注解原理是什么\" class=\"headerlink\" title=\"注解原理是什么\"></a>注解原理是什么</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。</p>\n<h3 id=\"Spring-MVC常用的注解有哪些？\"><a href=\"#Spring-MVC常用的注解有哪些？\" class=\"headerlink\" title=\"Spring MVC常用的注解有哪些？\"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>\n<p>@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户。</p>\n<h3 id=\"Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\"><a href=\"#Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\" class=\"headerlink\" title=\"Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\"></a>Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回json数据＋ @Controller 用于表明控制器</p>\n<h3 id=\"Controller注解的作用\"><a href=\"#Controller注解的作用\" class=\"headerlink\" title=\"@Controller注解的作用\"></a>@Controller注解的作用</h3><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。通过请求的url和@RequestMapping 注解对应到实际处理请求的处理器。需要开启mvc注解扫描找到@Controller的控制器。</p>\n<h3 id=\"RequestMapping注解的作用\"><a href=\"#RequestMapping注解的作用\" class=\"headerlink\" title=\"@RequestMapping注解的作用\"></a>@RequestMapping注解的作用</h3><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p>\n<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping注解有六个属性：</p>\n<p><strong>path&#x2F;value， method</strong></p>\n<ul>\n<li><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>\n</li>\n<li><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p>\n</li>\n</ul>\n<p><strong>consumes，produces</strong></p>\n<ul>\n<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</p>\n</li>\n<li><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>\n</li>\n</ul>\n<p><strong>params，headers</strong></p>\n<ul>\n<li><p>params： 指定request中必须包含某些参数值时，才让该方法处理。</p>\n</li>\n<li><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>\n</li>\n</ul>\n<h3 id=\"PathVariable和-RequestParam的区别\"><a href=\"#PathVariable和-RequestParam的区别\" class=\"headerlink\" title=\"@PathVariable和@RequestParam的区别\"></a>@PathVariable和@RequestParam的区别</h3><p>@PathVariable作用： 用于绑定url中的占位符。例如：请求url中 &#x2F;delete&#x2F;{id}，这个{id}就是url占位符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法</span></span><br><span class=\"line\"><span class=\"comment\">* 然后，其中的10就是sid占位符所占的位置的数据，然后通过<span class=\"doctag\">@PathVaribale</span>注解将其赋值给 id</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;testPathVariable/&#123;sid&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testPathVariable</span><span class=\"params\">(<span class=\"meta\">@PathVariable(value = &quot;sid&quot;)</span> String id)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testPathVariable...&quot;</span>);</span><br><span class=\"line\">    System.out.println(id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@RequestParam作用： 把请求中指定名称的参数给控制器中的形参赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller中的代码：</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;/testRequestParam&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testRequestParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam(value = &quot;name&quot;)</span> String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把请求中指定的name赋值给控制器中的形参username</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testRequestParam...&quot;</span>);</span><br><span class=\"line\">    System.out.println(username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Spring-MVC怎么样设定转发和重定向的？\"><a href=\"#Spring-MVC怎么样设定转发和重定向的？\" class=\"headerlink\" title=\"Spring MVC怎么样设定转发和重定向的？\"></a>Spring MVC怎么样设定转发和重定向的？</h3><p>（1）转发：使用forward<br>forward是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。</p>\n<p>（2）重定向：使用redirect<br>重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。请求两次服务器。重定向地址改变。</p>\n<h3 id=\"Spring-MVC怎么和AJAX相互调用的？\"><a href=\"#Spring-MVC怎么和AJAX相互调用的？\" class=\"headerlink\" title=\"Spring MVC怎么和AJAX相互调用的？\"></a>Spring MVC怎么和AJAX相互调用的？</h3><p>通过Jackson或者是fastjson就可以把Java里面的对象直接转化成Js可以识别的Json对象，来进行传输。</p>\n<h3 id=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"><a href=\"#如何解决POST请求中文乱码问题，GET的又如何处理呢？\" class=\"headerlink\" title=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><p>（1）解决post请求乱码问题：</p>\n<p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）get请求中文参数出现乱码解决方法有两个：</p>\n<p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-MVC的异常处理\"><a href=\"#Spring-MVC的异常处理\" class=\"headerlink\" title=\"Spring MVC的异常处理\"></a>Spring MVC的异常处理</h3><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>\n<h3 id=\"如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\"><a href=\"#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\" class=\"headerlink\" title=\"如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。</p>\n<h3 id=\"怎样在方法里面得到Request-或者Session？\"><a href=\"#怎样在方法里面得到Request-或者Session？\" class=\"headerlink\" title=\"怎样在方法里面得到Request,或者Session？\"></a>怎样在方法里面得到Request,或者Session？</h3><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>\n<h3 id=\"如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\"><a href=\"#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\" class=\"headerlink\" title=\"如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。<br>或者使用 RequestParam注解将前台的参数名A传给形参中的参数B</p>\n<h3 id=\"如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\"><a href=\"#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\" class=\"headerlink\" title=\"如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>\n<h3 id=\"Spring-MVC中函数的返回值是什么？\"><a href=\"#Spring-MVC中函数的返回值是什么？\" class=\"headerlink\" title=\"Spring MVC中函数的返回值是什么？\"></a>Spring MVC中函数的返回值是什么？</h3><p>返回值可以有很多类型,有String, ModelAndView（视图和数据合并在一起）。</p>\n<h3 id=\"Spring-MVC用什么对象从后台向前台传递数据的？\"><a href=\"#Spring-MVC用什么对象从后台向前台传递数据的？\" class=\"headerlink\" title=\"Spring MVC用什么对象从后台向前台传递数据的？\"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>\n<h3 id=\"怎么样把ModelMap里面的数据放入Session里面？\"><a href=\"#怎么样把ModelMap里面的数据放入Session里面？\" class=\"headerlink\" title=\"怎么样把ModelMap里面的数据放入Session里面？\"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>\n<h3 id=\"Spring-MVC里面拦截器是怎么写的\"><a href=\"#Spring-MVC里面拦截器是怎么写的\" class=\"headerlink\" title=\"Spring MVC里面拦截器是怎么写的\"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现HandlerInterceptor接口，重写prehandle等方法，然后配置拦截器</p>\n","site":{"data":{}},"length":5011,"excerpt":"<blockquote>\n<p>整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\"><a href=\"#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\" class=\"headerlink\" title=\"什么是Spring MVC？简单介绍下你对Spring MVC的理解？\"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，简化开发。</p>\n<h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><h3 id=\"Spring-MVC的主要组件？\"><a href=\"#Spring-MVC的主要组件？\" class=\"headerlink\" title=\"Spring MVC的主要组件？\"></a>Spring MVC的主要组件？</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>\n<p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>\n<p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p>\n<p>作用：根据请求的URL来查找Handler</p>\n<p>（3）处理器适配器HandlerAdapter</p>\n<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>\n<p>（4）处理器Handler（需要程序员开发）</p>\n<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>\n<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>\n<p>（6）视图View（需要程序员开发jsp）</p>\n<p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>\n<h3 id=\"什么是DispatcherServlet\"><a href=\"#什么是DispatcherServlet\" class=\"headerlink\" title=\"什么是DispatcherServlet\"></a>什么是DispatcherServlet</h3><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>\n<h3 id=\"什么是Spring-MVC框架的控制器？\"><a href=\"#什么是Spring-MVC框架的控制器？\" class=\"headerlink\" title=\"什么是Spring MVC框架的控制器？\"></a>什么是Spring MVC框架的控制器？</h3><p>控制器使用@Controller注解，并且提供了@RequestMapping注解，通过解析url中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。</p>\n<h3 id=\"Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\"><a href=\"#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\" class=\"headerlink\" title=\"Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><p>单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h3 id=\"请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\"><a href=\"#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\" class=\"headerlink\" title=\"请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h3><ol>\n<li>用户发送请求至前端控制器DispatcherServlet；</li>\n<li>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handler；</li>\n<li>HandlerMapping处理器映射器根据请求url<strong>找到具体的处理器</strong>，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li>\n<li>DispatcherServlet 调用 HandlerAdapter处理器适配器；</li>\n<li>HandlerAdapter 经过适配 <strong>调用具体处理器</strong>(Handler，也叫后端控制器)；</li>\n<li>Handler执行完成返回ModelAndView；</li>\n<li>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li>\n<li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</li>\n<li>ViewResolver解析后返回具体View；</li>\n<li>DispatcherServlet对View进行渲染成为视图（即将模型数据填充至视图中）；</li>\n<li>DispatcherServlet响应用户。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png\" alt=\"Spring MVC的工作流程\"></p>\n<h2 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h2><h3 id=\"注解原理是什么\"><a href=\"#注解原理是什么\" class=\"headerlink\" title=\"注解原理是什么\"></a>注解原理是什么</h3><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。</p>\n<h3 id=\"Spring-MVC常用的注解有哪些？\"><a href=\"#Spring-MVC常用的注解有哪些？\" class=\"headerlink\" title=\"Spring MVC常用的注解有哪些？\"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>\n<p>@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户。</p>\n<h3 id=\"Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\"><a href=\"#Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\" class=\"headerlink\" title=\"Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\"></a>Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller注解，也可以使用@RestController，@RestController注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回json数据＋ @Controller 用于表明控制器</p>\n<h3 id=\"Controller注解的作用\"><a href=\"#Controller注解的作用\" class=\"headerlink\" title=\"@Controller注解的作用\"></a>@Controller注解的作用</h3><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。通过请求的url和@RequestMapping 注解对应到实际处理请求的处理器。需要开启mvc注解扫描找到@Controller的控制器。</p>\n<h3 id=\"RequestMapping注解的作用\"><a href=\"#RequestMapping注解的作用\" class=\"headerlink\" title=\"@RequestMapping注解的作用\"></a>@RequestMapping注解的作用</h3><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。</p>\n<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping注解有六个属性：</p>\n<p><strong>path&#x2F;value， method</strong></p>\n<ul>\n<li><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p>\n</li>\n<li><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p>\n</li>\n</ul>\n<p><strong>consumes，produces</strong></p>\n<ul>\n<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</p>\n</li>\n<li><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p>\n</li>\n</ul>\n<p><strong>params，headers</strong></p>\n<ul>\n<li><p>params： 指定request中必须包含某些参数值时，才让该方法处理。</p>\n</li>\n<li><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>\n</li>\n</ul>\n<h3 id=\"PathVariable和-RequestParam的区别\"><a href=\"#PathVariable和-RequestParam的区别\" class=\"headerlink\" title=\"@PathVariable和@RequestParam的区别\"></a>@PathVariable和@RequestParam的区别</h3><p>@PathVariable作用： 用于绑定url中的占位符。例如：请求url中 &#x2F;delete&#x2F;{id}，这个{id}就是url占位符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法</span></span><br><span class=\"line\"><span class=\"comment\">* 然后，其中的10就是sid占位符所占的位置的数据，然后通过<span class=\"doctag\">@PathVaribale</span>注解将其赋值给 id</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;testPathVariable/&#123;sid&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testPathVariable</span><span class=\"params\">(<span class=\"meta\">@PathVariable(value = &quot;sid&quot;)</span> String id)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testPathVariable...&quot;</span>);</span><br><span class=\"line\">    System.out.println(id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@RequestParam作用： 把请求中指定名称的参数给控制器中的形参赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller中的代码：</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;/testRequestParam&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testRequestParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam(value = &quot;name&quot;)</span> String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把请求中指定的name赋值给控制器中的形参username</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testRequestParam...&quot;</span>);</span><br><span class=\"line\">    System.out.println(username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Spring-MVC怎么样设定转发和重定向的？\"><a href=\"#Spring-MVC怎么样设定转发和重定向的？\" class=\"headerlink\" title=\"Spring MVC怎么样设定转发和重定向的？\"></a>Spring MVC怎么样设定转发和重定向的？</h3><p>（1）转发：使用forward<br>forward是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。</p>\n<p>（2）重定向：使用redirect<br>重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。请求两次服务器。重定向地址改变。</p>\n<h3 id=\"Spring-MVC怎么和AJAX相互调用的？\"><a href=\"#Spring-MVC怎么和AJAX相互调用的？\" class=\"headerlink\" title=\"Spring MVC怎么和AJAX相互调用的？\"></a>Spring MVC怎么和AJAX相互调用的？</h3><p>通过Jackson或者是fastjson就可以把Java里面的对象直接转化成Js可以识别的Json对象，来进行传输。</p>\n<h3 id=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"><a href=\"#如何解决POST请求中文乱码问题，GET的又如何处理呢？\" class=\"headerlink\" title=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><p>（1）解决post请求乱码问题：</p>\n<p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）get请求中文参数出现乱码解决方法有两个：</p>\n<p>修改tomcat配置文件添加编码与工程编码一致，如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-MVC的异常处理\"><a href=\"#Spring-MVC的异常处理\" class=\"headerlink\" title=\"Spring MVC的异常处理\"></a>Spring MVC的异常处理</h3><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>\n<h3 id=\"如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\"><a href=\"#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\" class=\"headerlink\" title=\"如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。</p>\n<h3 id=\"怎样在方法里面得到Request-或者Session？\"><a href=\"#怎样在方法里面得到Request-或者Session？\" class=\"headerlink\" title=\"怎样在方法里面得到Request,或者Session？\"></a>怎样在方法里面得到Request,或者Session？</h3><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p>\n<h3 id=\"如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\"><a href=\"#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\" class=\"headerlink\" title=\"如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。<br>或者使用 RequestParam注解将前台的参数名A传给形参中的参数B</p>\n<h3 id=\"如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\"><a href=\"#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\" class=\"headerlink\" title=\"如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p>\n<h3 id=\"Spring-MVC中函数的返回值是什么？\"><a href=\"#Spring-MVC中函数的返回值是什么？\" class=\"headerlink\" title=\"Spring MVC中函数的返回值是什么？\"></a>Spring MVC中函数的返回值是什么？</h3><p>返回值可以有很多类型,有String, ModelAndView（视图和数据合并在一起）。</p>\n<h3 id=\"Spring-MVC用什么对象从后台向前台传递数据的？\"><a href=\"#Spring-MVC用什么对象从后台向前台传递数据的？\" class=\"headerlink\" title=\"Spring MVC用什么对象从后台向前台传递数据的？\"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p>\n<h3 id=\"怎么样把ModelMap里面的数据放入Session里面？\"><a href=\"#怎么样把ModelMap里面的数据放入Session里面？\" class=\"headerlink\" title=\"怎么样把ModelMap里面的数据放入Session里面？\"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p>\n<h3 id=\"Spring-MVC里面拦截器是怎么写的\"><a href=\"#Spring-MVC里面拦截器是怎么写的\" class=\"headerlink\" title=\"Spring MVC里面拦截器是怎么写的\"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现HandlerInterceptor接口，重写prehandle等方法，然后配置拦截器</p>"},{"title":"Java八股文 - Java集合","copyright":true,"mathjax":false,"date":"2023-01-23T02:06:52.000Z","toc":true,"urlname":"java-collection","_content":"\n> 整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 集合容器概述\n\n### 什么是集合\n\n用于存储数据的容器。\n\n### 集合和数组的区别\n\n- 数组是固定长度的；集合可变长度的。\n- 数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n\n### 常用的集合类有哪些？\n\nCollection接口和Map接口是所有集合框架的父接口。\n\nCollection接口：子接口包括Set接口和List接口\n\n1. Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等；\n2. List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等。\n\nMap接口：实现类主要有HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等。\n\n### List、Set、Map三者的区别？\n\n![Collection架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png)\n\nList和Set两大接口是Collection的子接口\n\n- List：有序容器，元素可以重复，可以插入多个null元素，元素都有索引；\n\t常用实现类：ArrayList、LinkedList 和 Vector。\n\t\n- Set：无序容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性；\n\n\t常用实现类：HashSet、LinkedHashSet 以及 TreeSet。\n\n* Map是一个键值对集合，存储键、值和之间的映射。 key无序，唯一；value 不要求有序，允许重复；\n\n\t常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。\n\n### 集合框架底层数据结构\n\n#### Collection\n\n1. List\n\n- Arraylist： Object数组\n- Vector： Object数组\n- LinkedList： 双向链表\n\n2. Set\n\n- HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素\n- LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。\n- TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)\n\n#### Map\n\n- HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。\n- LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\n- HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\n- TreeMap： 红黑树（自平衡的排序二叉树）\n\n### 哪些集合类是线程安全的？\n\nvector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全\n\n### Java集合的快速失败机制 “fail-fast”？\n\nfail-fast是Java集合的一种**错误检测机制**，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。\n\n例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（add、remove、clear等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 **ConcurrentModificationException** 异常，从而产生fail-fast事件。\n\n原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变modCount的值，从而modCount不等于expectedmodCount值抛出异常，也就是产生了fail-fast事件。\n\n解决办法：\n\n1. 在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized；\n2. 使用Java.util.concurrent下的CopyOnWriteArrayList来替换ArrayList；\n3. 使用Java.util.concurrent下的ConcurrentHashMap来替换HashMap。\n\n### 怎么确保一个集合不能被修改？\n\n可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n\n```Java\nList<String> list = new ArrayList<>();\nlist. add(\"x\");\nCollection<String> clist = Collections. unmodifiableCollection(list);\nclist.add(\"y\"); // 运行时此行报错\nSystem.out.println(list. size());\n```\n\n## Collection接口\n\n### List接口\n\n#### 迭代器 Iterator 是什么？\n\nCollection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作。\n\n#### Iterator 怎么使用？有什么特点？\n\n```Java\nList<String> list = new ArrayList<>();\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String obj = it.next();\n    System.out.println(obj);\n}\n```\n\nIterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。\n\n#### 如何边遍历边移除 Collection 中的元素？\n\n边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：\n\n```java\nIterator<Integer> it = list.iterator();\nwhile(it.hasNext()){\n   // do something\n   it.remove();\n}\n```\n\n一种最常见的**错误**代码如下：\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nlist.add(\"3\");\nlist.add(\"4\");\nlist.add(\"5\");\nint cnt = 0;\nfor (String item : list) {\n  System.out.println(++cnt);\n  list.remove(item);\n}\nSystem.out.println(Arrays.toString(list.toArray()));\n```\n\n运行以上错误代码会报 **ConcurrentModificationException 异常**。\n这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据fail-fast机制，会抛异常。\n\n#### 遍历一个 List 有哪些不同的方式？\n\n1. for 循环，维护一个计数器；\n2. 迭代器，Iterator。Collection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作；\n3. 增强for循环。增强for循环foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。\n\t优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。\n\n#### 说一下 ArrayList 的优缺点\n\n**ArrayList 比较适合顺序添加、随机访问的场景。**\n\nArrayList的优点如下：\n\n- ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。\n- ArrayList 在顺序添加一个元素的时候非常方便。\n\nArrayList 的缺点如下：\n\n- 向**中间某个位置删除**元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；\n- 向**中间某个位置插入**元素的时候，也需要做元素复制操作，缺点同上。\n\n#### 如何实现数组和 List 之间的转换？\n\n- 数组转 List：使用 Arrays. asList(array) 进行转换。\n- List 转数组：使用 List 自带的 toArray() 方法。\n\n```Java\n// list to array\nList<String> list = new ArrayList<String>();\nlist.add(\"123\");\nlist.add(\"456\");\nlist.toArray(new String[0]);\n\n// array to list\nString[] array = new String[]{\"123\", \"456\"};\nArrays.asList(array);\n```\n\n#### ArrayList 和 LinkedList 的区别是什么？\n\n- 底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；\n- 访问和增删元素效率：ArrayList 随机访问和顺序插入/删除元素效率更高；\n- 内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；\n- 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。\n\n综合来说，在需要**频繁读取**集合中的元素时，更推荐使用 ArrayList，而在**插入和删除操作较多**时，更推荐使用 LinkedList。\n\n#### ArrayList 和 Vector 的区别是什么？\n\n主要区别是线程安全问题：\nVector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。\n\n#### 多线程场景下如何使用 ArrayList？\n\n可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。\n\n#### 为什么 ArrayList 的 elementData 加上 transient 修饰？\n\nArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。\n对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成1.5倍大小，扩容之后除了新加\n的元素以外还有多的空间没有放元素，比如现在容量是15，而集合里面只存了11个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11个元素），而不是整个数组，从而节省空间和时间。\n\n### ⭐ArrayList扩容机制\n\n> **总结：**\n>\n> * 初始化如果使用无参构造器的话：\n>\n> \t在第一次添加元素的时候，将数组容量设置为10，然后进行添加。\n>\n> \t一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。\n>\n> * 初始化如果使用有参构造器的话：\n>\n> \t那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。\n\n#### 1. 先从 ArrayList 的构造函数说起\n\n**（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：**\n\n```java\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\n**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** \n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 elementData 。\n\n#### 2. 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n##### 2.1.  `add` \n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n   // 添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n##### 2.2. `ensureCapacityInternal()` \n\n（JDK7）可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n\n**当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。**\n\n> 此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。\n\n##### 2.3. `ensureExplicitCapacity()` \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进入（执行）这个方法\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。\n\n##### 2.4. `grow()` \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）** \n\n**我们再来通过例子探究一下grow() 方法 ：**\n\n- 当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，add 方法中 return true,size 增为 1。\n- 当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n##### 2.5. `hugeCapacity()` \n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n### Set接口\n\n#### HashSet 的实现原理？\n\nHashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为Object常量PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。\n\n#### HashSet是如何保证数据不可重复的？\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 \n\n```java\n// Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT = new Object();\nprivate transient HashMap<E,Object> map;\n\npublic HashSet() {\n    map = new HashMap<>();\n}\n\npublic boolean add(E e) {\n    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值\n\treturn map.put(e, PRESENT)==null;\n}\n```\n\n#### 只重写 hashCode 可以吗？\n\n两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n## Map接口\n\n### HashMap线程不安全的主要体现？\n\n1. 在jdk1.7中，在多线程环境下，**扩容**时会造成死链。\n\n\t> 作者：磊哥\n\t> 链接：https://www.zhihu.com/question/394039290/answer/2314917909\n\t> 来源：知乎\n\n\t1.1、\n\n\t死循环是因为并发HashMap扩容导致的，并发扩容的第一步，线程T1和线程T2要对HashMap进行扩容操作，此时T1和T2指向的是链表的头结点元素A，而T1和T2的下一个节点，也就是T1.next和T2.next指向的是B节点，如下图所示： \n\n\t![多线程扩容导致死循环问题-1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg)\n\n\t1.2、\n\n\t死循环的第二步操作是，线程T2时间片用完进入休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒，扩容之后的场景如下图所示： \n\n\t![多线程扩容导致死循环问题-2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg)\n\n\t 从上图可知线程T1执行之后，**因为是头插法，所以HashMap的顺序已经发生了改变**，但线程T2对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2指向的是A元素，T2.next指向的节点是B元素。\n\n\t1.3、\n\n\t当线程T1执行完，而线程T2恢复执行时，死循环就建立了，如下图所示： \n\n\t![多线程扩容导致死循环问题-3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg)\n\n\t 因为T1执行完扩容之后B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩完容完之后的节点顺序是相反的。**T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了**，这就是HashMap死循环导致的原因。\n\n2. 在jdk1.8中，在多线程环境下，**插入**时会发生数据覆盖的情况（**尾插法**）。\n\n### HashMap在JDK1.7和JDK1.8中有哪些不同？\n\n| 不同                         | JDK 1.7                                                      | JDK 1.8                                                      |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **存储结构**                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |\n| **hash值计算方式**           | 扰动处理 = 4次位运算 + 5次异或运算                           | 扰动处理 = 1次位运算 + 1次异或运算                           |\n| **存放数据的规则**           | 无冲突时，存放数组；<br />冲突时，存放链表                   | 无冲突时，存放数组；<br />冲突 & 链表长度 < 8：插入单链表；<br />链表长度>8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树 |\n| **插入数据方式**             | 头插法                                                       | 尾插法                                                       |\n| **扩容后存储位置的计算方式** | 按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&length-1 | 根据元素的hash值进行判断 <br />扩容后的位置=原位置 or 原位置 + 旧容量 |\n\n### HashMap的hash算法\n\n#### 什么是哈希？\n\nHash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；\n\nhash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）\n\n#### 什么是哈希冲突？\n\n当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞/冲突。\n\n#### HashMap的数据结构\n\n底层数据结构：数组+链表\n**数组的特点是：方便查找；链表的特点是：方便插入删除**\n所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**链地址法**的方式可以解决哈希冲突\n\n> 解决哈希冲突的其他方法：\n> 开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；\n> 再哈希法（构造多个不同的哈希函数）。\n\n![HashMap数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png)\n\n#### 扰动处理\n\n由于计算下标时，通过 h & (length - 1)，由于hash值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有hash值的低位，**高位是没有起到任何作用的**，这将会大大增加哈希碰撞的概率。所以我们的思路就是让hashCode值的高位也参与运算，进一步降低hash碰撞的概率，使得**数据分布更平均**，我们把这样的操作称为**扰动**，在**JDK 1.8**中的hash()函数如下：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    // 与自己右移16位进行异或运算（高低位异或）\n}\n```\n\n这比在**JDK 1.7**中，更为简洁，**相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）**；\n\n#### 下标计算\n\n在得到hash值之后，我们要把这些hash值映射到相应的数组下标上，那么就可以考虑使用 hash % length\n\n而 hash % length==hash & (length-1) 并且前提是 length 是2的 n 次方。\n由于采用二进制位操作 &，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）\n\n```java\nstatic int indexFor(int h, int length){\n     return h & (length - 1);\n}\n```\n\n#### 为什么要将数组长度设置为 2 的n次幂呢？\n\n当数组长度为2的n次幂的时候，不同的key与1111（n个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 \n\n#### JDK1.8新增红黑树\n\n为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至O(logn)；\n\n#### HashMap是使用了哪些方法来有效解决哈希冲突的？\n\n1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；\n2. 使用2次扰动函数（1次位运算和1次异或运算）来降低哈希冲突的概率，使得数据分布更平均；\n3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。\n\n### HashMap的get方法的具体流程？\n\n1. 先使用key的hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；\n2. 判断首结点，如果首结点和key的 **hash值** （hashCode值经过扰动函数处理后的值）相等，并且两者的 **key值地址相等、equals相等**，则返回首结点；\n3. 否则，则红黑树或者链表中进行查找，查找时判断两个key的hash值、key值地址相等、equals是否都相等。\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    //Node数组不为空，数组长度大于0，数组对应下标的Node不为空\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        //也是通过 hash & (length - 1) 来替代 hash % length 的\n        (first = tab[(n - 1) & hash]) != null) {\n        \n        //先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等\n        //则返回第一个结点\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null\n        if ((e = first.next) != null) {\n            //如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //是链表结构的话就一个一个遍历，直到找到key对应的结点，\n            //或者e的下一个结点为null退出循环\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### HashMap的put方法的具体流程？\n\n1. 如果table未初始化或者长度为0空则执行resize()进行扩容，转向②\n2. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果table[i]不为空，转向③；\n3. 判断table[i]的首个元素是否和key一样，如果相同（hashCode相同、key地址相同、equals相同）直接覆盖value，否则转向④；\n4. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；\n5. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；\n6. 插入成功后，判断实际存在的键值对数量size是否超出当前最大容量threshold，如果超过，进行扩容。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n//实现Map.put和相关方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 步骤①：tab为空则创建 \n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 步骤②：计算index，并对null做处理  \n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 步骤③：节点key存在，直接覆盖value \n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // 步骤④：判断该链为红黑树 \n        // hash值不相等，即key不相等；为红黑树结点\n        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 步骤⑤：该链为链表 \n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                \n                //判断该链表尾部指针是不是空的\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    //判断链表的长度是否达到转化红黑树的临界值，临界值为8\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //链表结构转树形结构\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 步骤⑥：超过最大容量就扩容 \n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n### HashMap的扩容操作是怎么实现的？\n\n①.在jdk1.8中，resize方法是在hashmap中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的2倍，或者初始化时（扩容为16），就调用resize方法进行扩容；\n\n②.在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash & oldCap)是否为0，重新进行hash分配后，该元素hash值与旧容量与运算为0则留在原始位置，hash值与旧容量与运算为1则移动到 原位置 + oldCap 这个位置上\n\n![HashMap的resize操作](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png)\n\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;//oldTab指向hash桶数组\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {//如果oldCap不为空的话，就是hash桶数组不为空\n        if (oldCap >= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值\n            threshold = Integer.MAX_VALUE;\n            return oldTab;//返回\n        }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold 双倍扩容阀值threshold\n    }\n    // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂\n    // 直接将该值赋给新的容量\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 新的threshold = 新的cap * 0.75\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    // 计算出新的数组长度后赋给当前成员变量table\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//新建hash桶数组\n    table = newTab;//将新数组的值复制给旧的hash桶数组\n    // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散\n    if (oldTab != null) {\n        // 遍历新数组的所有桶下标\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收\n                oldTab[j] = null;\n                // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树\n                if (e.next == null)\n                    // 用同样的hash映射算法把该元素加入新的数组\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                // e是链表的头并且e.next!=null，那么处理链表中元素重排\n                else { // preserve order\n                    // loHead,loTail 代表扩容后不用变换下标，见注1\n                    Node<K,V> loHead = null, loTail = null;\n                    // hiHead,hiTail 代表扩容后变换下标，见注1\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    // 遍历链表\n                    do {             \n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead\n                                // 代表下标保持不变的链表的头元素\n                                loHead = e;\n                            else                                \n                                // loTail.next指向当前e\n                                loTail.next = e;\n                            // loTail指向当前的元素e\n                            // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，\n                            // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....\n                            // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。\n                            loTail = e;                           \n                        }\n                        else {\n                            if (hiTail == null)\n                                // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n### HashMap负载因子为什么设置为 0.75?\n\nhashmap的源码中有一段注释解释了为什么设置为0.75，是**空间和时间效率的折中考虑**。\n\n### 能否使用任何类作为 Map 的 key？\n\n可以使用任何类作为 Map 的 key，前提是该类重写了hashCode和equals方法。重写hashCode() 是为了计算数据的存储位置，重写equals方法是为了确保key在哈希表中的唯一性。最终目的是为了保证 Map 中键key的唯一性。\n\n### 为什么HashMap中String、Integer这样的包装类适合作为key？\n\n重写了hashCode和equals方法，保证了 Map 中键**key的唯一性**。并且他们都不可变，可以将它们的hash值**缓存下来，提高效率**。\n\n### HashMap 与 HashTable 有什么区别？\n\n1. **线程安全**： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 `synchronized` 修饰；\n2. **效率**： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；\n3. **对Null key 和Null value的支持**： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException；\n4. **初始容量大小和每次扩充容量大小的不同 **： \n\t①创建时如果不指定容量初始值，HashTable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍；\n\t②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小；\n5. **底层数据结构**： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。\n\n### ConcurrentHashMap 和 HashTable 的区别？\n\nConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。\n\n- **底层数据结构**： \n\tJDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。\n\tHashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- **实现线程安全的方式（重要）**： \n\t① **在JDK1.7的时候，ConcurrentHashMap使用分段锁** 对整个桶数组进行了分割分段(Segment锁继承ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比HashTable效率提高16倍。）\n\t**到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap\n\t② **HashTable(全表锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n- ⭐**Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。**\n\n**两者的对比图**：\n\nHashTable:\n\n![HashTable全表锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png)\n\nJDK1.7的ConcurrentHashMap：\n\n![JDK1.7的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png)\n\nJDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：\n\n![JDK1.8的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png)\n","source":"_posts/Java八股文 - Java集合.md","raw":"---\ntitle: Java八股文 - Java集合\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 10:06:52\ntags:\ntoc: true\nurlname: java-collection\n---\n\n> 整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 集合容器概述\n\n### 什么是集合\n\n用于存储数据的容器。\n\n### 集合和数组的区别\n\n- 数组是固定长度的；集合可变长度的。\n- 数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n\n### 常用的集合类有哪些？\n\nCollection接口和Map接口是所有集合框架的父接口。\n\nCollection接口：子接口包括Set接口和List接口\n\n1. Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等；\n2. List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等。\n\nMap接口：实现类主要有HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等。\n\n### List、Set、Map三者的区别？\n\n![Collection架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png)\n\nList和Set两大接口是Collection的子接口\n\n- List：有序容器，元素可以重复，可以插入多个null元素，元素都有索引；\n\t常用实现类：ArrayList、LinkedList 和 Vector。\n\t\n- Set：无序容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性；\n\n\t常用实现类：HashSet、LinkedHashSet 以及 TreeSet。\n\n* Map是一个键值对集合，存储键、值和之间的映射。 key无序，唯一；value 不要求有序，允许重复；\n\n\t常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。\n\n### 集合框架底层数据结构\n\n#### Collection\n\n1. List\n\n- Arraylist： Object数组\n- Vector： Object数组\n- LinkedList： 双向链表\n\n2. Set\n\n- HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素\n- LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。\n- TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)\n\n#### Map\n\n- HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。\n- LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\n- HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\n- TreeMap： 红黑树（自平衡的排序二叉树）\n\n### 哪些集合类是线程安全的？\n\nvector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全\n\n### Java集合的快速失败机制 “fail-fast”？\n\nfail-fast是Java集合的一种**错误检测机制**，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。\n\n例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（add、remove、clear等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 **ConcurrentModificationException** 异常，从而产生fail-fast事件。\n\n原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变modCount的值，从而modCount不等于expectedmodCount值抛出异常，也就是产生了fail-fast事件。\n\n解决办法：\n\n1. 在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized；\n2. 使用Java.util.concurrent下的CopyOnWriteArrayList来替换ArrayList；\n3. 使用Java.util.concurrent下的ConcurrentHashMap来替换HashMap。\n\n### 怎么确保一个集合不能被修改？\n\n可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n\n```Java\nList<String> list = new ArrayList<>();\nlist. add(\"x\");\nCollection<String> clist = Collections. unmodifiableCollection(list);\nclist.add(\"y\"); // 运行时此行报错\nSystem.out.println(list. size());\n```\n\n## Collection接口\n\n### List接口\n\n#### 迭代器 Iterator 是什么？\n\nCollection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作。\n\n#### Iterator 怎么使用？有什么特点？\n\n```Java\nList<String> list = new ArrayList<>();\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String obj = it.next();\n    System.out.println(obj);\n}\n```\n\nIterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。\n\n#### 如何边遍历边移除 Collection 中的元素？\n\n边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：\n\n```java\nIterator<Integer> it = list.iterator();\nwhile(it.hasNext()){\n   // do something\n   it.remove();\n}\n```\n\n一种最常见的**错误**代码如下：\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nlist.add(\"3\");\nlist.add(\"4\");\nlist.add(\"5\");\nint cnt = 0;\nfor (String item : list) {\n  System.out.println(++cnt);\n  list.remove(item);\n}\nSystem.out.println(Arrays.toString(list.toArray()));\n```\n\n运行以上错误代码会报 **ConcurrentModificationException 异常**。\n这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据fail-fast机制，会抛异常。\n\n#### 遍历一个 List 有哪些不同的方式？\n\n1. for 循环，维护一个计数器；\n2. 迭代器，Iterator。Collection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作；\n3. 增强for循环。增强for循环foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。\n\t优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。\n\n#### 说一下 ArrayList 的优缺点\n\n**ArrayList 比较适合顺序添加、随机访问的场景。**\n\nArrayList的优点如下：\n\n- ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。\n- ArrayList 在顺序添加一个元素的时候非常方便。\n\nArrayList 的缺点如下：\n\n- 向**中间某个位置删除**元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；\n- 向**中间某个位置插入**元素的时候，也需要做元素复制操作，缺点同上。\n\n#### 如何实现数组和 List 之间的转换？\n\n- 数组转 List：使用 Arrays. asList(array) 进行转换。\n- List 转数组：使用 List 自带的 toArray() 方法。\n\n```Java\n// list to array\nList<String> list = new ArrayList<String>();\nlist.add(\"123\");\nlist.add(\"456\");\nlist.toArray(new String[0]);\n\n// array to list\nString[] array = new String[]{\"123\", \"456\"};\nArrays.asList(array);\n```\n\n#### ArrayList 和 LinkedList 的区别是什么？\n\n- 底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；\n- 访问和增删元素效率：ArrayList 随机访问和顺序插入/删除元素效率更高；\n- 内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；\n- 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。\n\n综合来说，在需要**频繁读取**集合中的元素时，更推荐使用 ArrayList，而在**插入和删除操作较多**时，更推荐使用 LinkedList。\n\n#### ArrayList 和 Vector 的区别是什么？\n\n主要区别是线程安全问题：\nVector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。\n\n#### 多线程场景下如何使用 ArrayList？\n\n可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。\n\n#### 为什么 ArrayList 的 elementData 加上 transient 修饰？\n\nArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。\n对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成1.5倍大小，扩容之后除了新加\n的元素以外还有多的空间没有放元素，比如现在容量是15，而集合里面只存了11个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11个元素），而不是整个数组，从而节省空间和时间。\n\n### ⭐ArrayList扩容机制\n\n> **总结：**\n>\n> * 初始化如果使用无参构造器的话：\n>\n> \t在第一次添加元素的时候，将数组容量设置为10，然后进行添加。\n>\n> \t一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。\n>\n> * 初始化如果使用有参构造器的话：\n>\n> \t那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。\n\n#### 1. 先从 ArrayList 的构造函数说起\n\n**（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：**\n\n```java\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\n**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** \n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 elementData 。\n\n#### 2. 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n##### 2.1.  `add` \n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n   // 添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n##### 2.2. `ensureCapacityInternal()` \n\n（JDK7）可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n\n**当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。**\n\n> 此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。\n\n##### 2.3. `ensureExplicitCapacity()` \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进入（执行）这个方法\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。\n\n##### 2.4. `grow()` \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）** \n\n**我们再来通过例子探究一下grow() 方法 ：**\n\n- 当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，add 方法中 return true,size 增为 1。\n- 当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n##### 2.5. `hugeCapacity()` \n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n### Set接口\n\n#### HashSet 的实现原理？\n\nHashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为Object常量PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。\n\n#### HashSet是如何保证数据不可重复的？\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 \n\n```java\n// Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT = new Object();\nprivate transient HashMap<E,Object> map;\n\npublic HashSet() {\n    map = new HashMap<>();\n}\n\npublic boolean add(E e) {\n    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值\n\treturn map.put(e, PRESENT)==null;\n}\n```\n\n#### 只重写 hashCode 可以吗？\n\n两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n## Map接口\n\n### HashMap线程不安全的主要体现？\n\n1. 在jdk1.7中，在多线程环境下，**扩容**时会造成死链。\n\n\t> 作者：磊哥\n\t> 链接：https://www.zhihu.com/question/394039290/answer/2314917909\n\t> 来源：知乎\n\n\t1.1、\n\n\t死循环是因为并发HashMap扩容导致的，并发扩容的第一步，线程T1和线程T2要对HashMap进行扩容操作，此时T1和T2指向的是链表的头结点元素A，而T1和T2的下一个节点，也就是T1.next和T2.next指向的是B节点，如下图所示： \n\n\t![多线程扩容导致死循环问题-1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg)\n\n\t1.2、\n\n\t死循环的第二步操作是，线程T2时间片用完进入休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒，扩容之后的场景如下图所示： \n\n\t![多线程扩容导致死循环问题-2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg)\n\n\t 从上图可知线程T1执行之后，**因为是头插法，所以HashMap的顺序已经发生了改变**，但线程T2对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2指向的是A元素，T2.next指向的节点是B元素。\n\n\t1.3、\n\n\t当线程T1执行完，而线程T2恢复执行时，死循环就建立了，如下图所示： \n\n\t![多线程扩容导致死循环问题-3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg)\n\n\t 因为T1执行完扩容之后B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩完容完之后的节点顺序是相反的。**T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了**，这就是HashMap死循环导致的原因。\n\n2. 在jdk1.8中，在多线程环境下，**插入**时会发生数据覆盖的情况（**尾插法**）。\n\n### HashMap在JDK1.7和JDK1.8中有哪些不同？\n\n| 不同                         | JDK 1.7                                                      | JDK 1.8                                                      |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **存储结构**                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |\n| **hash值计算方式**           | 扰动处理 = 4次位运算 + 5次异或运算                           | 扰动处理 = 1次位运算 + 1次异或运算                           |\n| **存放数据的规则**           | 无冲突时，存放数组；<br />冲突时，存放链表                   | 无冲突时，存放数组；<br />冲突 & 链表长度 < 8：插入单链表；<br />链表长度>8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树 |\n| **插入数据方式**             | 头插法                                                       | 尾插法                                                       |\n| **扩容后存储位置的计算方式** | 按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&length-1 | 根据元素的hash值进行判断 <br />扩容后的位置=原位置 or 原位置 + 旧容量 |\n\n### HashMap的hash算法\n\n#### 什么是哈希？\n\nHash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；\n\nhash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）\n\n#### 什么是哈希冲突？\n\n当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞/冲突。\n\n#### HashMap的数据结构\n\n底层数据结构：数组+链表\n**数组的特点是：方便查找；链表的特点是：方便插入删除**\n所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**链地址法**的方式可以解决哈希冲突\n\n> 解决哈希冲突的其他方法：\n> 开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；\n> 再哈希法（构造多个不同的哈希函数）。\n\n![HashMap数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png)\n\n#### 扰动处理\n\n由于计算下标时，通过 h & (length - 1)，由于hash值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有hash值的低位，**高位是没有起到任何作用的**，这将会大大增加哈希碰撞的概率。所以我们的思路就是让hashCode值的高位也参与运算，进一步降低hash碰撞的概率，使得**数据分布更平均**，我们把这样的操作称为**扰动**，在**JDK 1.8**中的hash()函数如下：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    // 与自己右移16位进行异或运算（高低位异或）\n}\n```\n\n这比在**JDK 1.7**中，更为简洁，**相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）**；\n\n#### 下标计算\n\n在得到hash值之后，我们要把这些hash值映射到相应的数组下标上，那么就可以考虑使用 hash % length\n\n而 hash % length==hash & (length-1) 并且前提是 length 是2的 n 次方。\n由于采用二进制位操作 &，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）\n\n```java\nstatic int indexFor(int h, int length){\n     return h & (length - 1);\n}\n```\n\n#### 为什么要将数组长度设置为 2 的n次幂呢？\n\n当数组长度为2的n次幂的时候，不同的key与1111（n个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 \n\n#### JDK1.8新增红黑树\n\n为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至O(logn)；\n\n#### HashMap是使用了哪些方法来有效解决哈希冲突的？\n\n1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；\n2. 使用2次扰动函数（1次位运算和1次异或运算）来降低哈希冲突的概率，使得数据分布更平均；\n3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。\n\n### HashMap的get方法的具体流程？\n\n1. 先使用key的hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；\n2. 判断首结点，如果首结点和key的 **hash值** （hashCode值经过扰动函数处理后的值）相等，并且两者的 **key值地址相等、equals相等**，则返回首结点；\n3. 否则，则红黑树或者链表中进行查找，查找时判断两个key的hash值、key值地址相等、equals是否都相等。\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    //Node数组不为空，数组长度大于0，数组对应下标的Node不为空\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        //也是通过 hash & (length - 1) 来替代 hash % length 的\n        (first = tab[(n - 1) & hash]) != null) {\n        \n        //先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等\n        //则返回第一个结点\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null\n        if ((e = first.next) != null) {\n            //如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //是链表结构的话就一个一个遍历，直到找到key对应的结点，\n            //或者e的下一个结点为null退出循环\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### HashMap的put方法的具体流程？\n\n1. 如果table未初始化或者长度为0空则执行resize()进行扩容，转向②\n2. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果table[i]不为空，转向③；\n3. 判断table[i]的首个元素是否和key一样，如果相同（hashCode相同、key地址相同、equals相同）直接覆盖value，否则转向④；\n4. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；\n5. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；\n6. 插入成功后，判断实际存在的键值对数量size是否超出当前最大容量threshold，如果超过，进行扩容。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n//实现Map.put和相关方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 步骤①：tab为空则创建 \n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 步骤②：计算index，并对null做处理  \n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 步骤③：节点key存在，直接覆盖value \n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // 步骤④：判断该链为红黑树 \n        // hash值不相等，即key不相等；为红黑树结点\n        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 步骤⑤：该链为链表 \n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                \n                //判断该链表尾部指针是不是空的\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    //判断链表的长度是否达到转化红黑树的临界值，临界值为8\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //链表结构转树形结构\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 步骤⑥：超过最大容量就扩容 \n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n### HashMap的扩容操作是怎么实现的？\n\n①.在jdk1.8中，resize方法是在hashmap中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的2倍，或者初始化时（扩容为16），就调用resize方法进行扩容；\n\n②.在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash & oldCap)是否为0，重新进行hash分配后，该元素hash值与旧容量与运算为0则留在原始位置，hash值与旧容量与运算为1则移动到 原位置 + oldCap 这个位置上\n\n![HashMap的resize操作](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png)\n\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;//oldTab指向hash桶数组\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {//如果oldCap不为空的话，就是hash桶数组不为空\n        if (oldCap >= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值\n            threshold = Integer.MAX_VALUE;\n            return oldTab;//返回\n        }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold 双倍扩容阀值threshold\n    }\n    // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂\n    // 直接将该值赋给新的容量\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 新的threshold = 新的cap * 0.75\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    // 计算出新的数组长度后赋给当前成员变量table\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//新建hash桶数组\n    table = newTab;//将新数组的值复制给旧的hash桶数组\n    // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散\n    if (oldTab != null) {\n        // 遍历新数组的所有桶下标\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收\n                oldTab[j] = null;\n                // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树\n                if (e.next == null)\n                    // 用同样的hash映射算法把该元素加入新的数组\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                // e是链表的头并且e.next!=null，那么处理链表中元素重排\n                else { // preserve order\n                    // loHead,loTail 代表扩容后不用变换下标，见注1\n                    Node<K,V> loHead = null, loTail = null;\n                    // hiHead,hiTail 代表扩容后变换下标，见注1\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    // 遍历链表\n                    do {             \n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead\n                                // 代表下标保持不变的链表的头元素\n                                loHead = e;\n                            else                                \n                                // loTail.next指向当前e\n                                loTail.next = e;\n                            // loTail指向当前的元素e\n                            // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，\n                            // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....\n                            // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。\n                            loTail = e;                           \n                        }\n                        else {\n                            if (hiTail == null)\n                                // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n### HashMap负载因子为什么设置为 0.75?\n\nhashmap的源码中有一段注释解释了为什么设置为0.75，是**空间和时间效率的折中考虑**。\n\n### 能否使用任何类作为 Map 的 key？\n\n可以使用任何类作为 Map 的 key，前提是该类重写了hashCode和equals方法。重写hashCode() 是为了计算数据的存储位置，重写equals方法是为了确保key在哈希表中的唯一性。最终目的是为了保证 Map 中键key的唯一性。\n\n### 为什么HashMap中String、Integer这样的包装类适合作为key？\n\n重写了hashCode和equals方法，保证了 Map 中键**key的唯一性**。并且他们都不可变，可以将它们的hash值**缓存下来，提高效率**。\n\n### HashMap 与 HashTable 有什么区别？\n\n1. **线程安全**： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 `synchronized` 修饰；\n2. **效率**： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；\n3. **对Null key 和Null value的支持**： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException；\n4. **初始容量大小和每次扩充容量大小的不同 **： \n\t①创建时如果不指定容量初始值，HashTable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍；\n\t②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小；\n5. **底层数据结构**： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。\n\n### ConcurrentHashMap 和 HashTable 的区别？\n\nConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。\n\n- **底层数据结构**： \n\tJDK1.7的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。\n\tHashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- **实现线程安全的方式（重要）**： \n\t① **在JDK1.7的时候，ConcurrentHashMap使用分段锁** 对整个桶数组进行了分割分段(Segment锁继承ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比HashTable效率提高16倍。）\n\t**到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap\n\t② **HashTable(全表锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n- ⭐**Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。**\n\n**两者的对比图**：\n\nHashTable:\n\n![HashTable全表锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png)\n\nJDK1.7的ConcurrentHashMap：\n\n![JDK1.7的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png)\n\nJDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：\n\n![JDK1.8的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png)\n","slug":"Java八股文 - Java集合","published":1,"updated":"2023-01-23T08:46:48.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsix000hzvt8ghzo4q37","content":"<blockquote>\n<p>整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"集合容器概述\"><a href=\"#集合容器概述\" class=\"headerlink\" title=\"集合容器概述\"></a>集合容器概述</h2><h3 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h3><p>用于存储数据的容器。</p>\n<h3 id=\"集合和数组的区别\"><a href=\"#集合和数组的区别\" class=\"headerlink\" title=\"集合和数组的区别\"></a>集合和数组的区别</h3><ul>\n<li>数组是固定长度的；集合可变长度的。</li>\n<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>\n</ul>\n<h3 id=\"常用的集合类有哪些？\"><a href=\"#常用的集合类有哪些？\" class=\"headerlink\" title=\"常用的集合类有哪些？\"></a>常用的集合类有哪些？</h3><p>Collection接口和Map接口是所有集合框架的父接口。</p>\n<p>Collection接口：子接口包括Set接口和List接口</p>\n<ol>\n<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等；</li>\n<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等。</li>\n</ol>\n<p>Map接口：实现类主要有HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等。</p>\n<h3 id=\"List、Set、Map三者的区别？\"><a href=\"#List、Set、Map三者的区别？\" class=\"headerlink\" title=\"List、Set、Map三者的区别？\"></a>List、Set、Map三者的区别？</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png\" alt=\"Collection架构\"></p>\n<p>List和Set两大接口是Collection的子接口</p>\n<ul>\n<li><p>List：有序容器，元素可以重复，可以插入多个null元素，元素都有索引；<br>  常用实现类：ArrayList、LinkedList 和 Vector。</p>\n</li>\n<li><p>Set：无序容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性；</p>\n<p>  常用实现类：HashSet、LinkedHashSet 以及 TreeSet。</p>\n</li>\n</ul>\n<ul>\n<li><p>Map是一个键值对集合，存储键、值和之间的映射。 key无序，唯一；value 不要求有序，允许重复；</p>\n<p>  常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。</p>\n</li>\n</ul>\n<h3 id=\"集合框架底层数据结构\"><a href=\"#集合框架底层数据结构\" class=\"headerlink\" title=\"集合框架底层数据结构\"></a>集合框架底层数据结构</h3><h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><ol>\n<li>List</li>\n</ol>\n<ul>\n<li>Arraylist： Object数组</li>\n<li>Vector： Object数组</li>\n<li>LinkedList： 双向链表</li>\n</ul>\n<ol start=\"2\">\n<li>Set</li>\n</ol>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>\n</ul>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><ul>\n<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。</li>\n<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>\n<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><p>vector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全</p>\n<h3 id=\"Java集合的快速失败机制-“fail-fast”？\"><a href=\"#Java集合的快速失败机制-“fail-fast”？\" class=\"headerlink\" title=\"Java集合的快速失败机制 “fail-fast”？\"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>fail-fast是Java集合的一种<strong>错误检测机制</strong>，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p>\n<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（add、remove、clear等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 <strong>ConcurrentModificationException</strong> 异常，从而产生fail-fast事件。</p>\n<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变modCount的值，从而modCount不等于expectedmodCount值抛出异常，也就是产生了fail-fast事件。</p>\n<p>解决办法：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized；</li>\n<li>使用Java.util.concurrent下的CopyOnWriteArrayList来替换ArrayList；</li>\n<li>使用Java.util.concurrent下的ConcurrentHashMap来替换HashMap。</li>\n</ol>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list. add(<span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class=\"line\">clist.add(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// 运行时此行报错</span></span><br><span class=\"line\">System.out.println(list. size());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>Collection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h4 id=\"如何边遍历边移除-Collection-中的元素？\"><a href=\"#如何边遍历边移除-Collection-中的元素？\" class=\"headerlink\" title=\"如何边遍历边移除 Collection 中的元素？\"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">   it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一种最常见的<strong>错误</strong>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String item : list) &#123;</span><br><span class=\"line\">  System.out.println(++cnt);</span><br><span class=\"line\">  list.remove(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(Arrays.toString(list.toArray()));</span><br></pre></td></tr></table></figure>\n\n<p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。<br>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据fail-fast机制，会抛异常。</p>\n<h4 id=\"遍历一个-List-有哪些不同的方式？\"><a href=\"#遍历一个-List-有哪些不同的方式？\" class=\"headerlink\" title=\"遍历一个 List 有哪些不同的方式？\"></a>遍历一个 List 有哪些不同的方式？</h4><ol>\n<li>for 循环，维护一个计数器；</li>\n<li>迭代器，Iterator。Collection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作；</li>\n<li>增强for循环。增强for循环foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。<br> 优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<h4 id=\"说一下-ArrayList-的优缺点\"><a href=\"#说一下-ArrayList-的优缺点\" class=\"headerlink\" title=\"说一下 ArrayList 的优缺点\"></a>说一下 ArrayList 的优缺点</h4><p><strong>ArrayList 比较适合顺序添加、随机访问的场景。</strong></p>\n<p>ArrayList的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>向<strong>中间某个位置删除</strong>元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；</li>\n<li>向<strong>中间某个位置插入</strong>元素的时候，也需要做元素复制操作，缺点同上。</li>\n</ul>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// list to array</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">list.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// array to list</span></span><br><span class=\"line\">String[] array = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;456&quot;</span>&#125;;</span><br><span class=\"line\">Arrays.asList(array);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>\n<li>底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；</li>\n<li>访问和增删元素效率：ArrayList 随机访问和顺序插入&#x2F;删除元素效率更高；</li>\n<li>内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。</li>\n</ul>\n<p>综合来说，在需要<strong>频繁读取</strong>集合中的元素时，更推荐使用 ArrayList，而在<strong>插入和删除操作较多</strong>时，更推荐使用 LinkedList。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>主要区别是线程安全问题：<br>Vector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。</p>\n<h4 id=\"多线程场景下如何使用-ArrayList？\"><a href=\"#多线程场景下如何使用-ArrayList？\" class=\"headerlink\" title=\"多线程场景下如何使用 ArrayList？\"></a>多线程场景下如何使用 ArrayList？</h4><p>可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。</p>\n<h4 id=\"为什么-ArrayList-的-elementData-加上-transient-修饰？\"><a href=\"#为什么-ArrayList-的-elementData-加上-transient-修饰？\" class=\"headerlink\" title=\"为什么 ArrayList 的 elementData 加上 transient 修饰？\"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<br>对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成1.5倍大小，扩容之后除了新加<br>的元素以外还有多的空间没有放元素，比如现在容量是15，而集合里面只存了11个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11个元素），而不是整个数组，从而节省空间和时间。</p>\n<h3 id=\"⭐ArrayList扩容机制\"><a href=\"#⭐ArrayList扩容机制\" class=\"headerlink\" title=\"⭐ArrayList扩容机制\"></a>⭐ArrayList扩容机制</h3><blockquote>\n<p><strong>总结：</strong></p>\n<ul>\n<li><p>初始化如果使用无参构造器的话：</p>\n<p>  在第一次添加元素的时候，将数组容量设置为10，然后进行添加。</p>\n<p>  一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。</p>\n</li>\n<li><p>初始化如果使用有参构造器的话：</p>\n<p>  那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"1-先从-ArrayList-的构造函数说起\"><a href=\"#1-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"1. 先从 ArrayList 的构造函数说起\"></a>1. 先从 ArrayList 的构造函数说起</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>\n</blockquote>\n<h4 id=\"2-一步一步分析-ArrayList-扩容机制\"><a href=\"#2-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"2. 一步一步分析 ArrayList 扩容机制\"></a>2. 一步一步分析 ArrayList 扩容机制</h4><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h5 id=\"2-1-add\"><a href=\"#2-1-add\" class=\"headerlink\" title=\"2.1.  add\"></a>2.1.  <code>add</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-ensureCapacityInternal\"><a href=\"#2-2-ensureCapacityInternal\" class=\"headerlink\" title=\"2.2. ensureCapacityInternal()\"></a>2.2. <code>ensureCapacityInternal()</code></h5><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>\n<blockquote>\n<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>\n</blockquote>\n<h5 id=\"2-3-ensureExplicitCapacity\"><a href=\"#2-3-ensureExplicitCapacity\" class=\"headerlink\" title=\"2.3. ensureExplicitCapacity()\"></a>2.3. <code>ensureExplicitCapacity()</code></h5><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>\n<h5 id=\"2-4-grow\"><a href=\"#2-4-grow\" class=\"headerlink\" title=\"2.4. grow()\"></a>2.4. <code>grow()</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong> </p>\n<p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p>\n<ul>\n<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>\n<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<h5 id=\"2-5-hugeCapacity\"><a href=\"#2-5-hugeCapacity\" class=\"headerlink\" title=\"2.5. hugeCapacity()\"></a>2.5. <code>hugeCapacity()</code></h5><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"HashSet-的实现原理？\"><a href=\"#HashSet-的实现原理？\" class=\"headerlink\" title=\"HashSet 的实现原理？\"></a>HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为Object常量PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。</p>\n<h4 id=\"HashSet是如何保证数据不可重复的？\"><a href=\"#HashSet是如何保证数据不可重复的？\" class=\"headerlink\" title=\"HashSet是如何保证数据不可重复的？\"></a>HashSet是如何保证数据不可重复的？</h4><p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dummy value to associate with an Object in the backing Map</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap线程不安全的主要体现？\"><a href=\"#HashMap线程不安全的主要体现？\" class=\"headerlink\" title=\"HashMap线程不安全的主要体现？\"></a>HashMap线程不安全的主要体现？</h3><ol>\n<li><p>在jdk1.7中，在多线程环境下，<strong>扩容</strong>时会造成死链。</p>\n<blockquote>\n<p>作者：磊哥<br>链接：<a href=\"https://www.zhihu.com/question/394039290/answer/2314917909\">https://www.zhihu.com/question/394039290/answer/2314917909</a><br>来源：知乎</p>\n</blockquote>\n<p> 1.1、</p>\n<p> 死循环是因为并发HashMap扩容导致的，并发扩容的第一步，线程T1和线程T2要对HashMap进行扩容操作，此时T1和T2指向的是链表的头结点元素A，而T1和T2的下一个节点，也就是T1.next和T2.next指向的是B节点，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg\" alt=\"多线程扩容导致死循环问题-1\"></p>\n<p> 1.2、</p>\n<p> 死循环的第二步操作是，线程T2时间片用完进入休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒，扩容之后的场景如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg\" alt=\"多线程扩容导致死循环问题-2\"></p>\n<p>  从上图可知线程T1执行之后，<strong>因为是头插法，所以HashMap的顺序已经发生了改变</strong>，但线程T2对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2指向的是A元素，T2.next指向的节点是B元素。</p>\n<p> 1.3、</p>\n<p> 当线程T1执行完，而线程T2恢复执行时，死循环就建立了，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg\" alt=\"多线程扩容导致死循环问题-3\"></p>\n<p>  因为T1执行完扩容之后B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩完容完之后的节点顺序是相反的。<strong>T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了</strong>，这就是HashMap死循环导致的原因。</p>\n</li>\n<li><p>在jdk1.8中，在多线程环境下，<strong>插入</strong>时会发生数据覆盖的情况（<strong>尾插法</strong>）。</p>\n</li>\n</ol>\n<h3 id=\"HashMap在JDK1-7和JDK1-8中有哪些不同？\"><a href=\"#HashMap在JDK1-7和JDK1-8中有哪些不同？\" class=\"headerlink\" title=\"HashMap在JDK1.7和JDK1.8中有哪些不同？\"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>存储结构</strong></td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td><strong>hash值计算方式</strong></td>\n<td>扰动处理 &#x3D; 4次位运算 + 5次异或运算</td>\n<td>扰动处理 &#x3D; 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td><strong>存放数据的规则</strong></td>\n<td>无冲突时，存放数组；<br />冲突时，存放链表</td>\n<td>无冲突时，存放数组；<br />冲突 &amp; 链表长度 &lt; 8：插入单链表；<br />链表长度&gt;8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树</td>\n</tr>\n<tr>\n<td><strong>插入数据方式</strong></td>\n<td>头插法</td>\n<td>尾插法</td>\n</tr>\n<tr>\n<td><strong>扩容后存储位置的计算方式</strong></td>\n<td>按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&amp;length-1</td>\n<td>根据元素的hash值进行判断 <br />扩容后的位置&#x3D;原位置 or 原位置 + 旧容量</td>\n</tr>\n</tbody></table>\n<h3 id=\"HashMap的hash算法\"><a href=\"#HashMap的hash算法\" class=\"headerlink\" title=\"HashMap的hash算法\"></a>HashMap的hash算法</h3><h4 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h4><p>Hash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；</p>\n<p>hash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）</p>\n<h4 id=\"什么是哈希冲突？\"><a href=\"#什么是哈希冲突？\" class=\"headerlink\" title=\"什么是哈希冲突？\"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞&#x2F;冲突。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>底层数据结构：数组+链表<br><strong>数组的特点是：方便查找；链表的特点是：方便插入删除</strong><br>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突</p>\n<blockquote>\n<p>解决哈希冲突的其他方法：<br>开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；<br>再哈希法（构造多个不同的哈希函数）。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png\" alt=\"HashMap数据结构\"></p>\n<h4 id=\"扰动处理\"><a href=\"#扰动处理\" class=\"headerlink\" title=\"扰动处理\"></a>扰动处理</h4><p>由于计算下标时，通过 h &amp; (length - 1)，由于hash值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有hash值的低位，<strong>高位是没有起到任何作用的</strong>，这将会大大增加哈希碰撞的概率。所以我们的思路就是让hashCode值的高位也参与运算，进一步降低hash碰撞的概率，使得<strong>数据分布更平均</strong>，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<h4 id=\"下标计算\"><a href=\"#下标计算\" class=\"headerlink\" title=\"下标计算\"></a>下标计算</h4><p>在得到hash值之后，我们要把这些hash值映射到相应的数组下标上，那么就可以考虑使用 hash % length</p>\n<p>而 hash % length&#x3D;&#x3D;hash &amp; (length-1) 并且前提是 length 是2的 n 次方。<br>由于采用二进制位操作 &amp;，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">indexFor</span><span class=\"params\">(<span class=\"type\">int</span> h, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么要将数组长度设置为-2-的n次幂呢？\"><a href=\"#为什么要将数组长度设置为-2-的n次幂呢？\" class=\"headerlink\" title=\"为什么要将数组长度设置为 2 的n次幂呢？\"></a>为什么要将数组长度设置为 2 的n次幂呢？</h4><p>当数组长度为2的n次幂的时候，不同的key与1111（n个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 </p>\n<h4 id=\"JDK1-8新增红黑树\"><a href=\"#JDK1-8新增红黑树\" class=\"headerlink\" title=\"JDK1.8新增红黑树\"></a>JDK1.8新增红黑树</h4><p>为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至O(logn)；</p>\n<h4 id=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"><a href=\"#HashMap是使用了哪些方法来有效解决哈希冲突的？\" class=\"headerlink\" title=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"></a>HashMap是使用了哪些方法来有效解决哈希冲突的？</h4><ol>\n<li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li>\n<li>使用2次扰动函数（1次位运算和1次异或运算）来降低哈希冲突的概率，使得数据分布更平均；</li>\n<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。</li>\n</ol>\n<h3 id=\"HashMap的get方法的具体流程？\"><a href=\"#HashMap的get方法的具体流程？\" class=\"headerlink\" title=\"HashMap的get方法的具体流程？\"></a>HashMap的get方法的具体流程？</h3><ol>\n<li>先使用key的hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；</li>\n<li>判断首结点，如果首结点和key的 <strong>hash值</strong> （hashCode值经过扰动函数处理后的值）相等，并且两者的 <strong>key值地址相等、equals相等</strong>，则返回首结点；</li>\n<li>否则，则红黑树或者链表中进行查找，查找时判断两个key的hash值、key值地址相等、equals是否都相等。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Node数组不为空，数组长度大于0，数组对应下标的Node不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"comment\">//也是通过 hash &amp; (length - 1) 来替代 hash % length 的</span></span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等</span></span><br><span class=\"line\">        <span class=\"comment\">//则返回第一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">//是链表结构的话就一个一个遍历，直到找到key对应的结点，</span></span><br><span class=\"line\">            <span class=\"comment\">//或者e的下一个结点为null退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的put方法的具体流程？\"><a href=\"#HashMap的put方法的具体流程？\" class=\"headerlink\" title=\"HashMap的put方法的具体流程？\"></a>HashMap的put方法的具体流程？</h3><ol>\n<li>如果table未初始化或者长度为0空则执行resize()进行扩容，转向②</li>\n<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果table[i]不为空，转向③；</li>\n<li>判断table[i]的首个元素是否和key一样，如果相同（hashCode相同、key地址相同、equals相同）直接覆盖value，否则转向④；</li>\n<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li>\n<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>\n<li>插入成功后，判断实际存在的键值对数量size是否超出当前最大容量threshold，如果超过，进行扩容。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Map.put和相关方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤①：tab为空则创建 </span></span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤②：计算index，并对null做处理  </span></span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤④：判断该链为红黑树 </span></span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 步骤⑤：该链为链表 </span></span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//判断该链表尾部指针是不是空的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">//链表结构转树形结构</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的扩容操作是怎么实现的？\"><a href=\"#HashMap的扩容操作是怎么实现的？\" class=\"headerlink\" title=\"HashMap的扩容操作是怎么实现的？\"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的2倍，或者初始化时（扩容为16），就调用resize方法进行扩容；</p>\n<p>②.在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素hash值与旧容量与运算为0则留在原始位置，hash值与旧容量与运算为1则移动到 原位置 + oldCap 这个位置上</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png\" alt=\"HashMap的resize操作\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//oldTab指向hash桶数组</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCap</span> <span class=\"operator\">=</span> (oldTab == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldThr</span> <span class=\"operator\">=</span> threshold;</span><br><span class=\"line\">    <span class=\"type\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class=\"comment\">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;<span class=\"comment\">//返回</span></span><br><span class=\"line\">        &#125;<span class=\"comment\">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold 双倍扩容阀值threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将该值赋给新的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"type\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新的threshold = 新的cap * 0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> (<span class=\"type\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"type\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"type\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[newCap];<span class=\"comment\">//新建hash桶数组</span></span><br><span class=\"line\">    table = newTab;<span class=\"comment\">//将新数组的值复制给旧的hash桶数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历新数组的所有桶下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"built_in\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"comment\">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"literal\">null</span>, loTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"literal\">null</span>, hiTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;             </span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class=\"line\">                                <span class=\"comment\">// 代表下标保持不变的链表的头元素</span></span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                </span><br><span class=\"line\">                                <span class=\"comment\">// loTail.next指向当前e</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            <span class=\"comment\">// loTail指向当前的元素e</span></span><br><span class=\"line\">                            <span class=\"comment\">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class=\"line\">                            <span class=\"comment\">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class=\"line\">                            <span class=\"comment\">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class=\"line\">                            loTail = e;                           </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap负载因子为什么设置为-0-75\"><a href=\"#HashMap负载因子为什么设置为-0-75\" class=\"headerlink\" title=\"HashMap负载因子为什么设置为 0.75?\"></a>HashMap负载因子为什么设置为 0.75?</h3><p>hashmap的源码中有一段注释解释了为什么设置为0.75，是<strong>空间和时间效率的折中考虑</strong>。</p>\n<h3 id=\"能否使用任何类作为-Map-的-key？\"><a href=\"#能否使用任何类作为-Map-的-key？\" class=\"headerlink\" title=\"能否使用任何类作为 Map 的 key？\"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，前提是该类重写了hashCode和equals方法。重写hashCode() 是为了计算数据的存储位置，重写equals方法是为了确保key在哈希表中的唯一性。最终目的是为了保证 Map 中键key的唯一性。</p>\n<h3 id=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为key？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"></a>为什么HashMap中String、Integer这样的包装类适合作为key？</h3><p>重写了hashCode和equals方法，保证了 Map 中键<strong>key的唯一性</strong>。并且他们都不可变，可以将它们的hash值<strong>缓存下来，提高效率</strong>。</p>\n<h3 id=\"HashMap-与-HashTable-有什么区别？\"><a href=\"#HashMap-与-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 与 HashTable 有什么区别？\"></a>HashMap 与 HashTable 有什么区别？</h3><ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 <code>synchronized</code> 修饰；</li>\n<li><strong>效率</strong>： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException；</li>\n<li>**初始容量大小和每次扩充容量大小的不同 **：<br> ①创建时如果不指定容量初始值，HashTable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍；<br> ②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小；</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-和-HashTable-的区别？\"><a href=\"#ConcurrentHashMap-和-HashTable-的区别？\" class=\"headerlink\" title=\"ConcurrentHashMap 和 HashTable 的区别？\"></a>ConcurrentHashMap 和 HashTable 的区别？</h3><p>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构</strong>：<br>  JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。<br>  HashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）</strong>：<br>  ① <strong>在JDK1.7的时候，ConcurrentHashMap使用分段锁</strong> 对整个桶数组进行了分割分段(Segment锁继承ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比HashTable效率提高16倍。）<br>  <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap<br>  ② <strong>HashTable(全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n<li>⭐<strong>Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。</strong></li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png\" alt=\"HashTable全表锁\"></p>\n<p>JDK1.7的ConcurrentHashMap：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png\" alt=\"JDK1.7的ConcurrentHashMap分段锁\"></p>\n<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png\" alt=\"JDK1.8的ConcurrentHashMap分段锁\"></p>\n","site":{"data":{}},"length":21285,"excerpt":"<blockquote>\n<p>整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"集合容器概述\"><a href=\"#集合容器概述\" class=\"headerlink\" title=\"集合容器概述\"></a>集合容器概述</h2><h3 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h3><p>用于存储数据的容器。</p>\n<h3 id=\"集合和数组的区别\"><a href=\"#集合和数组的区别\" class=\"headerlink\" title=\"集合和数组的区别\"></a>集合和数组的区别</h3><ul>\n<li>数组是固定长度的；集合可变长度的。</li>\n<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>\n</ul>\n<h3 id=\"常用的集合类有哪些？\"><a href=\"#常用的集合类有哪些？\" class=\"headerlink\" title=\"常用的集合类有哪些？\"></a>常用的集合类有哪些？</h3><p>Collection接口和Map接口是所有集合框架的父接口。</p>\n<p>Collection接口：子接口包括Set接口和List接口</p>\n<ol>\n<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等；</li>\n<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等。</li>\n</ol>\n<p>Map接口：实现类主要有HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等。</p>\n<h3 id=\"List、Set、Map三者的区别？\"><a href=\"#List、Set、Map三者的区别？\" class=\"headerlink\" title=\"List、Set、Map三者的区别？\"></a>List、Set、Map三者的区别？</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png\" alt=\"Collection架构\"></p>\n<p>List和Set两大接口是Collection的子接口</p>\n<ul>\n<li><p>List：有序容器，元素可以重复，可以插入多个null元素，元素都有索引；<br>  常用实现类：ArrayList、LinkedList 和 Vector。</p>\n</li>\n<li><p>Set：无序容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性；</p>\n<p>  常用实现类：HashSet、LinkedHashSet 以及 TreeSet。</p>\n</li>\n</ul>\n<ul>\n<li><p>Map是一个键值对集合，存储键、值和之间的映射。 key无序，唯一；value 不要求有序，允许重复；</p>\n<p>  常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。</p>\n</li>\n</ul>\n<h3 id=\"集合框架底层数据结构\"><a href=\"#集合框架底层数据结构\" class=\"headerlink\" title=\"集合框架底层数据结构\"></a>集合框架底层数据结构</h3><h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><ol>\n<li>List</li>\n</ol>\n<ul>\n<li>Arraylist： Object数组</li>\n<li>Vector： Object数组</li>\n<li>LinkedList： 双向链表</li>\n</ul>\n<ol start=\"2\">\n<li>Set</li>\n</ol>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>\n</ul>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><ul>\n<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。</li>\n<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>\n<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><p>vector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全</p>\n<h3 id=\"Java集合的快速失败机制-“fail-fast”？\"><a href=\"#Java集合的快速失败机制-“fail-fast”？\" class=\"headerlink\" title=\"Java集合的快速失败机制 “fail-fast”？\"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>fail-fast是Java集合的一种<strong>错误检测机制</strong>，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p>\n<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（add、remove、clear等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 <strong>ConcurrentModificationException</strong> 异常，从而产生fail-fast事件。</p>\n<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变modCount的值，从而modCount不等于expectedmodCount值抛出异常，也就是产生了fail-fast事件。</p>\n<p>解决办法：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变modCount值的地方全部加上synchronized；</li>\n<li>使用Java.util.concurrent下的CopyOnWriteArrayList来替换ArrayList；</li>\n<li>使用Java.util.concurrent下的ConcurrentHashMap来替换HashMap。</li>\n</ol>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list. add(<span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class=\"line\">clist.add(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// 运行时此行报错</span></span><br><span class=\"line\">System.out.println(list. size());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>Collection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h4 id=\"如何边遍历边移除-Collection-中的元素？\"><a href=\"#如何边遍历边移除-Collection-中的元素？\" class=\"headerlink\" title=\"如何边遍历边移除 Collection 中的元素？\"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">   it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一种最常见的<strong>错误</strong>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String item : list) &#123;</span><br><span class=\"line\">  System.out.println(++cnt);</span><br><span class=\"line\">  list.remove(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(Arrays.toString(list.toArray()));</span><br></pre></td></tr></table></figure>\n\n<p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。<br>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据fail-fast机制，会抛异常。</p>\n<h4 id=\"遍历一个-List-有哪些不同的方式？\"><a href=\"#遍历一个-List-有哪些不同的方式？\" class=\"headerlink\" title=\"遍历一个 List 有哪些不同的方式？\"></a>遍历一个 List 有哪些不同的方式？</h4><ol>\n<li>for 循环，维护一个计数器；</li>\n<li>迭代器，Iterator。Collection接口实现了Iterable接口，通过实现Iterable接口中的iterator()方法返回Iterator接口的实例，通过iterator对集合的元素进行迭代操作；</li>\n<li>增强for循环。增强for循环foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。<br> 优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<h4 id=\"说一下-ArrayList-的优缺点\"><a href=\"#说一下-ArrayList-的优缺点\" class=\"headerlink\" title=\"说一下 ArrayList 的优缺点\"></a>说一下 ArrayList 的优缺点</h4><p><strong>ArrayList 比较适合顺序添加、随机访问的场景。</strong></p>\n<p>ArrayList的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>向<strong>中间某个位置删除</strong>元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；</li>\n<li>向<strong>中间某个位置插入</strong>元素的时候，也需要做元素复制操作，缺点同上。</li>\n</ul>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// list to array</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">list.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// array to list</span></span><br><span class=\"line\">String[] array = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;456&quot;</span>&#125;;</span><br><span class=\"line\">Arrays.asList(array);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>\n<li>底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；</li>\n<li>访问和增删元素效率：ArrayList 随机访问和顺序插入&#x2F;删除元素效率更高；</li>\n<li>内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。</li>\n</ul>\n<p>综合来说，在需要<strong>频繁读取</strong>集合中的元素时，更推荐使用 ArrayList，而在<strong>插入和删除操作较多</strong>时，更推荐使用 LinkedList。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>主要区别是线程安全问题：<br>Vector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。</p>\n<h4 id=\"多线程场景下如何使用-ArrayList？\"><a href=\"#多线程场景下如何使用-ArrayList？\" class=\"headerlink\" title=\"多线程场景下如何使用 ArrayList？\"></a>多线程场景下如何使用 ArrayList？</h4><p>可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。</p>\n<h4 id=\"为什么-ArrayList-的-elementData-加上-transient-修饰？\"><a href=\"#为什么-ArrayList-的-elementData-加上-transient-修饰？\" class=\"headerlink\" title=\"为什么 ArrayList 的 elementData 加上 transient 修饰？\"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<br>对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成1.5倍大小，扩容之后除了新加<br>的元素以外还有多的空间没有放元素，比如现在容量是15，而集合里面只存了11个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11个元素），而不是整个数组，从而节省空间和时间。</p>\n<h3 id=\"⭐ArrayList扩容机制\"><a href=\"#⭐ArrayList扩容机制\" class=\"headerlink\" title=\"⭐ArrayList扩容机制\"></a>⭐ArrayList扩容机制</h3><blockquote>\n<p><strong>总结：</strong></p>\n<ul>\n<li><p>初始化如果使用无参构造器的话：</p>\n<p>  在第一次添加元素的时候，将数组容量设置为10，然后进行添加。</p>\n<p>  一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。</p>\n</li>\n<li><p>初始化如果使用有参构造器的话：</p>\n<p>  那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"1-先从-ArrayList-的构造函数说起\"><a href=\"#1-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"1. 先从 ArrayList 的构造函数说起\"></a>1. 先从 ArrayList 的构造函数说起</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>\n</blockquote>\n<h4 id=\"2-一步一步分析-ArrayList-扩容机制\"><a href=\"#2-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"2. 一步一步分析 ArrayList 扩容机制\"></a>2. 一步一步分析 ArrayList 扩容机制</h4><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h5 id=\"2-1-add\"><a href=\"#2-1-add\" class=\"headerlink\" title=\"2.1.  add\"></a>2.1.  <code>add</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-ensureCapacityInternal\"><a href=\"#2-2-ensureCapacityInternal\" class=\"headerlink\" title=\"2.2. ensureCapacityInternal()\"></a>2.2. <code>ensureCapacityInternal()</code></h5><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>\n<blockquote>\n<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>\n</blockquote>\n<h5 id=\"2-3-ensureExplicitCapacity\"><a href=\"#2-3-ensureExplicitCapacity\" class=\"headerlink\" title=\"2.3. ensureExplicitCapacity()\"></a>2.3. <code>ensureExplicitCapacity()</code></h5><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>\n<h5 id=\"2-4-grow\"><a href=\"#2-4-grow\" class=\"headerlink\" title=\"2.4. grow()\"></a>2.4. <code>grow()</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong> </p>\n<p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p>\n<ul>\n<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>\n<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<h5 id=\"2-5-hugeCapacity\"><a href=\"#2-5-hugeCapacity\" class=\"headerlink\" title=\"2.5. hugeCapacity()\"></a>2.5. <code>hugeCapacity()</code></h5><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"HashSet-的实现原理？\"><a href=\"#HashSet-的实现原理？\" class=\"headerlink\" title=\"HashSet 的实现原理？\"></a>HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为Object常量PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。</p>\n<h4 id=\"HashSet是如何保证数据不可重复的？\"><a href=\"#HashSet是如何保证数据不可重复的？\" class=\"headerlink\" title=\"HashSet是如何保证数据不可重复的？\"></a>HashSet是如何保证数据不可重复的？</h4><p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dummy value to associate with an Object in the backing Map</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap线程不安全的主要体现？\"><a href=\"#HashMap线程不安全的主要体现？\" class=\"headerlink\" title=\"HashMap线程不安全的主要体现？\"></a>HashMap线程不安全的主要体现？</h3><ol>\n<li><p>在jdk1.7中，在多线程环境下，<strong>扩容</strong>时会造成死链。</p>\n<blockquote>\n<p>作者：磊哥<br>链接：<a href=\"https://www.zhihu.com/question/394039290/answer/2314917909\">https://www.zhihu.com/question/394039290/answer/2314917909</a><br>来源：知乎</p>\n</blockquote>\n<p> 1.1、</p>\n<p> 死循环是因为并发HashMap扩容导致的，并发扩容的第一步，线程T1和线程T2要对HashMap进行扩容操作，此时T1和T2指向的是链表的头结点元素A，而T1和T2的下一个节点，也就是T1.next和T2.next指向的是B节点，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg\" alt=\"多线程扩容导致死循环问题-1\"></p>\n<p> 1.2、</p>\n<p> 死循环的第二步操作是，线程T2时间片用完进入休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒，扩容之后的场景如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg\" alt=\"多线程扩容导致死循环问题-2\"></p>\n<p>  从上图可知线程T1执行之后，<strong>因为是头插法，所以HashMap的顺序已经发生了改变</strong>，但线程T2对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2指向的是A元素，T2.next指向的节点是B元素。</p>\n<p> 1.3、</p>\n<p> 当线程T1执行完，而线程T2恢复执行时，死循环就建立了，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg\" alt=\"多线程扩容导致死循环问题-3\"></p>\n<p>  因为T1执行完扩容之后B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩完容完之后的节点顺序是相反的。<strong>T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了</strong>，这就是HashMap死循环导致的原因。</p>\n</li>\n<li><p>在jdk1.8中，在多线程环境下，<strong>插入</strong>时会发生数据覆盖的情况（<strong>尾插法</strong>）。</p>\n</li>\n</ol>\n<h3 id=\"HashMap在JDK1-7和JDK1-8中有哪些不同？\"><a href=\"#HashMap在JDK1-7和JDK1-8中有哪些不同？\" class=\"headerlink\" title=\"HashMap在JDK1.7和JDK1.8中有哪些不同？\"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>存储结构</strong></td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td><strong>hash值计算方式</strong></td>\n<td>扰动处理 &#x3D; 4次位运算 + 5次异或运算</td>\n<td>扰动处理 &#x3D; 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td><strong>存放数据的规则</strong></td>\n<td>无冲突时，存放数组；<br />冲突时，存放链表</td>\n<td>无冲突时，存放数组；<br />冲突 &amp; 链表长度 &lt; 8：插入单链表；<br />链表长度&gt;8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树</td>\n</tr>\n<tr>\n<td><strong>插入数据方式</strong></td>\n<td>头插法</td>\n<td>尾插法</td>\n</tr>\n<tr>\n<td><strong>扩容后存储位置的计算方式</strong></td>\n<td>按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&amp;length-1</td>\n<td>根据元素的hash值进行判断 <br />扩容后的位置&#x3D;原位置 or 原位置 + 旧容量</td>\n</tr>\n</tbody></table>\n<h3 id=\"HashMap的hash算法\"><a href=\"#HashMap的hash算法\" class=\"headerlink\" title=\"HashMap的hash算法\"></a>HashMap的hash算法</h3><h4 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h4><p>Hash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；</p>\n<p>hash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）</p>\n<h4 id=\"什么是哈希冲突？\"><a href=\"#什么是哈希冲突？\" class=\"headerlink\" title=\"什么是哈希冲突？\"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞&#x2F;冲突。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>底层数据结构：数组+链表<br><strong>数组的特点是：方便查找；链表的特点是：方便插入删除</strong><br>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突</p>\n<blockquote>\n<p>解决哈希冲突的其他方法：<br>开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；<br>再哈希法（构造多个不同的哈希函数）。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png\" alt=\"HashMap数据结构\"></p>\n<h4 id=\"扰动处理\"><a href=\"#扰动处理\" class=\"headerlink\" title=\"扰动处理\"></a>扰动处理</h4><p>由于计算下标时，通过 h &amp; (length - 1)，由于hash值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有hash值的低位，<strong>高位是没有起到任何作用的</strong>，这将会大大增加哈希碰撞的概率。所以我们的思路就是让hashCode值的高位也参与运算，进一步降低hash碰撞的概率，使得<strong>数据分布更平均</strong>，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<h4 id=\"下标计算\"><a href=\"#下标计算\" class=\"headerlink\" title=\"下标计算\"></a>下标计算</h4><p>在得到hash值之后，我们要把这些hash值映射到相应的数组下标上，那么就可以考虑使用 hash % length</p>\n<p>而 hash % length&#x3D;&#x3D;hash &amp; (length-1) 并且前提是 length 是2的 n 次方。<br>由于采用二进制位操作 &amp;，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">indexFor</span><span class=\"params\">(<span class=\"type\">int</span> h, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么要将数组长度设置为-2-的n次幂呢？\"><a href=\"#为什么要将数组长度设置为-2-的n次幂呢？\" class=\"headerlink\" title=\"为什么要将数组长度设置为 2 的n次幂呢？\"></a>为什么要将数组长度设置为 2 的n次幂呢？</h4><p>当数组长度为2的n次幂的时候，不同的key与1111（n个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 </p>\n<h4 id=\"JDK1-8新增红黑树\"><a href=\"#JDK1-8新增红黑树\" class=\"headerlink\" title=\"JDK1.8新增红黑树\"></a>JDK1.8新增红黑树</h4><p>为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至O(logn)；</p>\n<h4 id=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"><a href=\"#HashMap是使用了哪些方法来有效解决哈希冲突的？\" class=\"headerlink\" title=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"></a>HashMap是使用了哪些方法来有效解决哈希冲突的？</h4><ol>\n<li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li>\n<li>使用2次扰动函数（1次位运算和1次异或运算）来降低哈希冲突的概率，使得数据分布更平均；</li>\n<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。</li>\n</ol>\n<h3 id=\"HashMap的get方法的具体流程？\"><a href=\"#HashMap的get方法的具体流程？\" class=\"headerlink\" title=\"HashMap的get方法的具体流程？\"></a>HashMap的get方法的具体流程？</h3><ol>\n<li>先使用key的hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；</li>\n<li>判断首结点，如果首结点和key的 <strong>hash值</strong> （hashCode值经过扰动函数处理后的值）相等，并且两者的 <strong>key值地址相等、equals相等</strong>，则返回首结点；</li>\n<li>否则，则红黑树或者链表中进行查找，查找时判断两个key的hash值、key值地址相等、equals是否都相等。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Node数组不为空，数组长度大于0，数组对应下标的Node不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"comment\">//也是通过 hash &amp; (length - 1) 来替代 hash % length 的</span></span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等</span></span><br><span class=\"line\">        <span class=\"comment\">//则返回第一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">//是链表结构的话就一个一个遍历，直到找到key对应的结点，</span></span><br><span class=\"line\">            <span class=\"comment\">//或者e的下一个结点为null退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的put方法的具体流程？\"><a href=\"#HashMap的put方法的具体流程？\" class=\"headerlink\" title=\"HashMap的put方法的具体流程？\"></a>HashMap的put方法的具体流程？</h3><ol>\n<li>如果table未初始化或者长度为0空则执行resize()进行扩容，转向②</li>\n<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果table[i]不为空，转向③；</li>\n<li>判断table[i]的首个元素是否和key一样，如果相同（hashCode相同、key地址相同、equals相同）直接覆盖value，否则转向④；</li>\n<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li>\n<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>\n<li>插入成功后，判断实际存在的键值对数量size是否超出当前最大容量threshold，如果超过，进行扩容。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Map.put和相关方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤①：tab为空则创建 </span></span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤②：计算index，并对null做处理  </span></span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤④：判断该链为红黑树 </span></span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 步骤⑤：该链为链表 </span></span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//判断该链表尾部指针是不是空的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">//链表结构转树形结构</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的扩容操作是怎么实现的？\"><a href=\"#HashMap的扩容操作是怎么实现的？\" class=\"headerlink\" title=\"HashMap的扩容操作是怎么实现的？\"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在jdk1.8中，resize方法是在hashmap中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的2倍，或者初始化时（扩容为16），就调用resize方法进行扩容；</p>\n<p>②.在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素hash值与旧容量与运算为0则留在原始位置，hash值与旧容量与运算为1则移动到 原位置 + oldCap 这个位置上</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png\" alt=\"HashMap的resize操作\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//oldTab指向hash桶数组</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCap</span> <span class=\"operator\">=</span> (oldTab == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldThr</span> <span class=\"operator\">=</span> threshold;</span><br><span class=\"line\">    <span class=\"type\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class=\"comment\">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;<span class=\"comment\">//返回</span></span><br><span class=\"line\">        &#125;<span class=\"comment\">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold 双倍扩容阀值threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将该值赋给新的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"type\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新的threshold = 新的cap * 0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> (<span class=\"type\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"type\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"type\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[newCap];<span class=\"comment\">//新建hash桶数组</span></span><br><span class=\"line\">    table = newTab;<span class=\"comment\">//将新数组的值复制给旧的hash桶数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历新数组的所有桶下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"built_in\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"comment\">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"literal\">null</span>, loTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"literal\">null</span>, hiTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;             </span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class=\"line\">                                <span class=\"comment\">// 代表下标保持不变的链表的头元素</span></span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                </span><br><span class=\"line\">                                <span class=\"comment\">// loTail.next指向当前e</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            <span class=\"comment\">// loTail指向当前的元素e</span></span><br><span class=\"line\">                            <span class=\"comment\">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class=\"line\">                            <span class=\"comment\">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class=\"line\">                            <span class=\"comment\">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class=\"line\">                            loTail = e;                           </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap负载因子为什么设置为-0-75\"><a href=\"#HashMap负载因子为什么设置为-0-75\" class=\"headerlink\" title=\"HashMap负载因子为什么设置为 0.75?\"></a>HashMap负载因子为什么设置为 0.75?</h3><p>hashmap的源码中有一段注释解释了为什么设置为0.75，是<strong>空间和时间效率的折中考虑</strong>。</p>\n<h3 id=\"能否使用任何类作为-Map-的-key？\"><a href=\"#能否使用任何类作为-Map-的-key？\" class=\"headerlink\" title=\"能否使用任何类作为 Map 的 key？\"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，前提是该类重写了hashCode和equals方法。重写hashCode() 是为了计算数据的存储位置，重写equals方法是为了确保key在哈希表中的唯一性。最终目的是为了保证 Map 中键key的唯一性。</p>\n<h3 id=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为key？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"></a>为什么HashMap中String、Integer这样的包装类适合作为key？</h3><p>重写了hashCode和equals方法，保证了 Map 中键<strong>key的唯一性</strong>。并且他们都不可变，可以将它们的hash值<strong>缓存下来，提高效率</strong>。</p>\n<h3 id=\"HashMap-与-HashTable-有什么区别？\"><a href=\"#HashMap-与-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 与 HashTable 有什么区别？\"></a>HashMap 与 HashTable 有什么区别？</h3><ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 <code>synchronized</code> 修饰；</li>\n<li><strong>效率</strong>： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException；</li>\n<li>**初始容量大小和每次扩充容量大小的不同 **：<br> ①创建时如果不指定容量初始值，HashTable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍；<br> ②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小；</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-和-HashTable-的区别？\"><a href=\"#ConcurrentHashMap-和-HashTable-的区别？\" class=\"headerlink\" title=\"ConcurrentHashMap 和 HashTable 的区别？\"></a>ConcurrentHashMap 和 HashTable 的区别？</h3><p>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构</strong>：<br>  JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。<br>  HashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）</strong>：<br>  ① <strong>在JDK1.7的时候，ConcurrentHashMap使用分段锁</strong> 对整个桶数组进行了分割分段(Segment锁继承ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比HashTable效率提高16倍。）<br>  <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap<br>  ② <strong>HashTable(全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n<li>⭐<strong>Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。</strong></li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png\" alt=\"HashTable全表锁\"></p>\n<p>JDK1.7的ConcurrentHashMap：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png\" alt=\"JDK1.7的ConcurrentHashMap分段锁\"></p>\n<p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png\" alt=\"JDK1.8的ConcurrentHashMap分段锁\"></p>"},{"title":"Typora配置阿里云OSS图床","copyright":true,"mathjax":true,"date":"2022-12-12T14:11:09.000Z","urlname":"image-host","_content":"\n在我们日常使用Typora写文档时，一般图片都是放在本地的一个相对路径下，如果将markdown文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown文件中使用该链接访问图片。在本文中我们使用Typora + PicGo + 阿里云OSS图床实现图片自动上传并自由访问。\n\n<!--more-->\n\n## 下载 Typora\n\n[Typora官网](https://typora.io/) 官网拉到最下，点击 [History Releases](https://typora.io/releases/all)，选择 Dev/Beta Releases，拉到最下 More Beta,\n\n选择对应系统的链接 [old Windows / Linux beta](https://typora.io/windows/dev_release.html)，[old macOS beta](https://typora.io/dev_release.html)\n\nWindows x64：[Download old version (Windows x64)](https://download.typora.io/windows/typora-update-x64-1016.exe)\n\nMac OS：[Download v0.11.18](https://download.typora.io/mac/Typora-0.11.18.dmg)\n\n## 常用设置\n\n### 通用\n\n1. 打开自动保存\n2. 关闭自动检查更新\n3. 关闭发送匿名使用数据\n\n### 外观\n\n1. 自定义字体\n\n2. 勾选侧边栏大纲视图折叠和展开\n\n3. 配置 Next 主题\n\n\t1. 官网：https://theme.typora.io/theme/NexT/\n\n\t2. 下载 zip 压缩包：[typora-theme-next.zip](https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip)\n\n\t3. Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹`xxx`\n\n\t4. 把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹`xxx`下\n\t5. 重启 Typora，设置外观选择Next即可\n\t6. 如果感觉页面宽度太小，可以打开next.css，搜索并配置max-width\n\t7. 如果感觉整体页面偏小，可以`Ctrl Shift +/-`增大/减小整体页面\n\n### 编辑器\n\n1. 设置默认换行符\n2. 取消拼写检查，勾选`不使用拼写检查`\n\n### 图像\n\n1. 插入图片时\n\n\t选择上传图片，勾选`对本地位置的图片应用上述规则`和`对网络位置的图片应用上述规则`\n\n2. 上传服务设定\n\n\t接下来会具体讲到图床的配置\n\n### Markdown\n\n1. 勾选显示代码块行号\n\n## 图床配置\n\n### 1、安装PicGo\n\n下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在PicGo中打开PicGo设置，找到设置Server，点击设置，点击开启Server，点击确定即可。\n\n### 2、配置Typora\n\n文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择picgo.app，选择picgo的安装路径，验证图片上传选项\n\n### 3、阿里云OSS搭建图床\n\n#### 3.1、开通阿里云对象存储\n\n开通阿里云对象存储https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台\n\n#### 3.2、创建bucket\n\n- 在左侧选择概览，然后在右侧Bucket管理中创建一个新的bucket\n\n- 创建Bucket具体配置\n\n\t> Bucket名字不能有大写字母、地域就近选择、存储类型选择`标准存储`，读写权限`公共读`\n\n- 创建成功后，可以在Bucket列表中查看，记住自己的访问域名和地域节点，后面会用到。\n\n#### 3.3、创建AccessKey\n\n页面右上角，鼠标放在头像处，在弹出的框里选择AccessKey管理，在弹出的选项框里，选择`继续使用AccessKey`。\n\n进入后，创建一个`AccessKey`。\n\n在弹出的界面里，记住你的`accessKeyId`和`accessKeySecret`。\n\n#### 3.4、了解收费标准\n\n使用默认的0.12元/1GB/1个月即可。\n\n### 4、配置PicGo\n\n我们打开打开PicGo的主界面,在图床设置里面选择阿里云OSS，依照下面注意事项填写信息。\n\n设定Keyld：填写我们在第三步中获得的AccessKeyID\n\n设定KeySecret：填写我们在第三步中获得的AccessKeyIDSecret\n\n设定储存空间名：填写我们在第二步中填写的bucket名称\n\n确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制oss-cn-Xxxx即可，不需要后面的.aliyuncs.com\n\n### 5、测试使用\n\n经过上面的一系列配置之后，我们就完成了Typora的图床配置，现在我们可以使用Markdown开始写文章了，图片、截图会在粘贴之后，自动通过PicGo上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。\n\n## 参考\n\nhttps://blog.csdn.net/qq_51808107/article/details/124044961\n","source":"_posts/Typora配置阿里云OSS图床.md","raw":"---\ntitle: Typora配置阿里云OSS图床\ncopyright: true\nmathjax: true\ndate: 2022-12-12 22:11:09\ncategories: 技术总结\ntags: \nurlname: image-host\n---\n\n在我们日常使用Typora写文档时，一般图片都是放在本地的一个相对路径下，如果将markdown文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown文件中使用该链接访问图片。在本文中我们使用Typora + PicGo + 阿里云OSS图床实现图片自动上传并自由访问。\n\n<!--more-->\n\n## 下载 Typora\n\n[Typora官网](https://typora.io/) 官网拉到最下，点击 [History Releases](https://typora.io/releases/all)，选择 Dev/Beta Releases，拉到最下 More Beta,\n\n选择对应系统的链接 [old Windows / Linux beta](https://typora.io/windows/dev_release.html)，[old macOS beta](https://typora.io/dev_release.html)\n\nWindows x64：[Download old version (Windows x64)](https://download.typora.io/windows/typora-update-x64-1016.exe)\n\nMac OS：[Download v0.11.18](https://download.typora.io/mac/Typora-0.11.18.dmg)\n\n## 常用设置\n\n### 通用\n\n1. 打开自动保存\n2. 关闭自动检查更新\n3. 关闭发送匿名使用数据\n\n### 外观\n\n1. 自定义字体\n\n2. 勾选侧边栏大纲视图折叠和展开\n\n3. 配置 Next 主题\n\n\t1. 官网：https://theme.typora.io/theme/NexT/\n\n\t2. 下载 zip 压缩包：[typora-theme-next.zip](https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip)\n\n\t3. Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹`xxx`\n\n\t4. 把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹`xxx`下\n\t5. 重启 Typora，设置外观选择Next即可\n\t6. 如果感觉页面宽度太小，可以打开next.css，搜索并配置max-width\n\t7. 如果感觉整体页面偏小，可以`Ctrl Shift +/-`增大/减小整体页面\n\n### 编辑器\n\n1. 设置默认换行符\n2. 取消拼写检查，勾选`不使用拼写检查`\n\n### 图像\n\n1. 插入图片时\n\n\t选择上传图片，勾选`对本地位置的图片应用上述规则`和`对网络位置的图片应用上述规则`\n\n2. 上传服务设定\n\n\t接下来会具体讲到图床的配置\n\n### Markdown\n\n1. 勾选显示代码块行号\n\n## 图床配置\n\n### 1、安装PicGo\n\n下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在PicGo中打开PicGo设置，找到设置Server，点击设置，点击开启Server，点击确定即可。\n\n### 2、配置Typora\n\n文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择picgo.app，选择picgo的安装路径，验证图片上传选项\n\n### 3、阿里云OSS搭建图床\n\n#### 3.1、开通阿里云对象存储\n\n开通阿里云对象存储https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台\n\n#### 3.2、创建bucket\n\n- 在左侧选择概览，然后在右侧Bucket管理中创建一个新的bucket\n\n- 创建Bucket具体配置\n\n\t> Bucket名字不能有大写字母、地域就近选择、存储类型选择`标准存储`，读写权限`公共读`\n\n- 创建成功后，可以在Bucket列表中查看，记住自己的访问域名和地域节点，后面会用到。\n\n#### 3.3、创建AccessKey\n\n页面右上角，鼠标放在头像处，在弹出的框里选择AccessKey管理，在弹出的选项框里，选择`继续使用AccessKey`。\n\n进入后，创建一个`AccessKey`。\n\n在弹出的界面里，记住你的`accessKeyId`和`accessKeySecret`。\n\n#### 3.4、了解收费标准\n\n使用默认的0.12元/1GB/1个月即可。\n\n### 4、配置PicGo\n\n我们打开打开PicGo的主界面,在图床设置里面选择阿里云OSS，依照下面注意事项填写信息。\n\n设定Keyld：填写我们在第三步中获得的AccessKeyID\n\n设定KeySecret：填写我们在第三步中获得的AccessKeyIDSecret\n\n设定储存空间名：填写我们在第二步中填写的bucket名称\n\n确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制oss-cn-Xxxx即可，不需要后面的.aliyuncs.com\n\n### 5、测试使用\n\n经过上面的一系列配置之后，我们就完成了Typora的图床配置，现在我们可以使用Markdown开始写文章了，图片、截图会在粘贴之后，自动通过PicGo上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。\n\n## 参考\n\nhttps://blog.csdn.net/qq_51808107/article/details/124044961\n","slug":"Typora配置阿里云OSS图床","published":1,"updated":"2023-01-17T02:09:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiy000izvt850sub8d8","content":"<p>在我们日常使用Typora写文档时，一般图片都是放在本地的一个相对路径下，如果将markdown文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown文件中使用该链接访问图片。在本文中我们使用Typora + PicGo + 阿里云OSS图床实现图片自动上传并自由访问。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"下载-Typora\"><a href=\"#下载-Typora\" class=\"headerlink\" title=\"下载 Typora\"></a>下载 Typora</h2><p><a href=\"https://typora.io/\">Typora官网</a> 官网拉到最下，点击 <a href=\"https://typora.io/releases/all\">History Releases</a>，选择 Dev/Beta Releases，拉到最下 More Beta,</p>\n<p>选择对应系统的链接 <a href=\"https://typora.io/windows/dev_release.html\">old Windows / Linux beta</a>，<a href=\"https://typora.io/dev_release.html\">old macOS beta</a></p>\n<p>Windows x64：<a href=\"https://download.typora.io/windows/typora-update-x64-1016.exe\">Download old version (Windows x64)</a></p>\n<p>Mac OS：<a href=\"https://download.typora.io/mac/Typora-0.11.18.dmg\">Download v0.11.18</a></p>\n<h2 id=\"常用设置\"><a href=\"#常用设置\" class=\"headerlink\" title=\"常用设置\"></a>常用设置</h2><h3 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h3><ol>\n<li>打开自动保存</li>\n<li>关闭自动检查更新</li>\n<li>关闭发送匿名使用数据</li>\n</ol>\n<h3 id=\"外观\"><a href=\"#外观\" class=\"headerlink\" title=\"外观\"></a>外观</h3><ol>\n<li><p>自定义字体</p>\n</li>\n<li><p>勾选侧边栏大纲视图折叠和展开</p>\n</li>\n<li><p>配置 Next 主题</p>\n<ol>\n<li><p>官网：<a href=\"https://theme.typora.io/theme/NexT/\">https://theme.typora.io/theme/NexT/</a></p>\n</li>\n<li><p>下载 zip 压缩包：<a href=\"https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip\">typora-theme-next.zip</a></p>\n</li>\n<li><p>Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹<code>xxx</code></p>\n</li>\n<li><p>把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹<code>xxx</code>下</p>\n</li>\n<li><p>重启 Typora，设置外观选择Next即可</p>\n</li>\n<li><p>如果感觉页面宽度太小，可以打开next.css，搜索并配置max-width</p>\n</li>\n<li><p>如果感觉整体页面偏小，可以<code>Ctrl Shift +/-</code>增大/减小整体页面</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><ol>\n<li>设置默认换行符</li>\n<li>取消拼写检查，勾选<code>不使用拼写检查</code></li>\n</ol>\n<h3 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h3><ol>\n<li><p>插入图片时</p>\n<p> 选择上传图片，勾选<code>对本地位置的图片应用上述规则</code>和<code>对网络位置的图片应用上述规则</code></p>\n</li>\n<li><p>上传服务设定</p>\n<p> 接下来会具体讲到图床的配置</p>\n</li>\n</ol>\n<h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><ol>\n<li>勾选显示代码块行号</li>\n</ol>\n<h2 id=\"图床配置\"><a href=\"#图床配置\" class=\"headerlink\" title=\"图床配置\"></a>图床配置</h2><h3 id=\"1、安装PicGo\"><a href=\"#1、安装PicGo\" class=\"headerlink\" title=\"1、安装PicGo\"></a>1、安装PicGo</h3><p>下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">https://github.com/Molunerfinn/PicGo/releases</a></p>\n<p>安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在PicGo中打开PicGo设置，找到设置Server，点击设置，点击开启Server，点击确定即可。</p>\n<h3 id=\"2、配置Typora\"><a href=\"#2、配置Typora\" class=\"headerlink\" title=\"2、配置Typora\"></a>2、配置Typora</h3><p>文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择picgo.app，选择picgo的安装路径，验证图片上传选项</p>\n<h3 id=\"3、阿里云OSS搭建图床\"><a href=\"#3、阿里云OSS搭建图床\" class=\"headerlink\" title=\"3、阿里云OSS搭建图床\"></a>3、阿里云OSS搭建图床</h3><h4 id=\"3-1、开通阿里云对象存储\"><a href=\"#3-1、开通阿里云对象存储\" class=\"headerlink\" title=\"3.1、开通阿里云对象存储\"></a>3.1、开通阿里云对象存储</h4><p>开通阿里云对象存储<a href=\"https://www.aliyun.com/product/oss%EF%BC%8C%E6%B3%A8%E5%86%8C%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%A6%E5%8F%B7%E5%90%8E%EF%BC%8C%E5%BC%80%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0\">https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台</a></p>\n<h4 id=\"3-2、创建bucket\"><a href=\"#3-2、创建bucket\" class=\"headerlink\" title=\"3.2、创建bucket\"></a>3.2、创建bucket</h4><ul>\n<li><p>在左侧选择概览，然后在右侧Bucket管理中创建一个新的bucket</p>\n</li>\n<li><p>创建Bucket具体配置</p>\n<blockquote>\n<p>Bucket名字不能有大写字母、地域就近选择、存储类型选择<code>标准存储</code>，读写权限<code>公共读</code></p>\n</blockquote>\n</li>\n<li><p>创建成功后，可以在Bucket列表中查看，记住自己的访问域名和地域节点，后面会用到。</p>\n</li>\n</ul>\n<h4 id=\"3-3、创建AccessKey\"><a href=\"#3-3、创建AccessKey\" class=\"headerlink\" title=\"3.3、创建AccessKey\"></a>3.3、创建AccessKey</h4><p>页面右上角，鼠标放在头像处，在弹出的框里选择AccessKey管理，在弹出的选项框里，选择<code>继续使用AccessKey</code>。</p>\n<p>进入后，创建一个<code>AccessKey</code>。</p>\n<p>在弹出的界面里，记住你的<code>accessKeyId</code>和<code>accessKeySecret</code>。</p>\n<h4 id=\"3-4、了解收费标准\"><a href=\"#3-4、了解收费标准\" class=\"headerlink\" title=\"3.4、了解收费标准\"></a>3.4、了解收费标准</h4><p>使用默认的0.12元/1GB/1个月即可。</p>\n<h3 id=\"4、配置PicGo\"><a href=\"#4、配置PicGo\" class=\"headerlink\" title=\"4、配置PicGo\"></a>4、配置PicGo</h3><p>我们打开打开PicGo的主界面,在图床设置里面选择阿里云OSS，依照下面注意事项填写信息。</p>\n<p>设定Keyld：填写我们在第三步中获得的AccessKeyID</p>\n<p>设定KeySecret：填写我们在第三步中获得的AccessKeyIDSecret</p>\n<p>设定储存空间名：填写我们在第二步中填写的bucket名称</p>\n<p>确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制oss-cn-Xxxx即可，不需要后面的.aliyuncs.com</p>\n<h3 id=\"5、测试使用\"><a href=\"#5、测试使用\" class=\"headerlink\" title=\"5、测试使用\"></a>5、测试使用</h3><p>经过上面的一系列配置之后，我们就完成了Typora的图床配置，现在我们可以使用Markdown开始写文章了，图片、截图会在粘贴之后，自动通过PicGo上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qq_51808107/article/details/124044961\">https://blog.csdn.net/qq_51808107/article/details/124044961</a></p>\n","site":{"data":{}},"length":1802,"excerpt":"<p>在我们日常使用Typora写文档时，一般图片都是放在本地的一个相对路径下，如果将markdown文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown文件中使用该链接访问图片。在本文中我们使用Typora + PicGo + 阿里云OSS图床实现图片自动上传并自由访问。</p>","more":"<h2 id=\"下载-Typora\"><a href=\"#下载-Typora\" class=\"headerlink\" title=\"下载 Typora\"></a>下载 Typora</h2><p><a href=\"https://typora.io/\">Typora官网</a> 官网拉到最下，点击 <a href=\"https://typora.io/releases/all\">History Releases</a>，选择 Dev/Beta Releases，拉到最下 More Beta,</p>\n<p>选择对应系统的链接 <a href=\"https://typora.io/windows/dev_release.html\">old Windows / Linux beta</a>，<a href=\"https://typora.io/dev_release.html\">old macOS beta</a></p>\n<p>Windows x64：<a href=\"https://download.typora.io/windows/typora-update-x64-1016.exe\">Download old version (Windows x64)</a></p>\n<p>Mac OS：<a href=\"https://download.typora.io/mac/Typora-0.11.18.dmg\">Download v0.11.18</a></p>\n<h2 id=\"常用设置\"><a href=\"#常用设置\" class=\"headerlink\" title=\"常用设置\"></a>常用设置</h2><h3 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h3><ol>\n<li>打开自动保存</li>\n<li>关闭自动检查更新</li>\n<li>关闭发送匿名使用数据</li>\n</ol>\n<h3 id=\"外观\"><a href=\"#外观\" class=\"headerlink\" title=\"外观\"></a>外观</h3><ol>\n<li><p>自定义字体</p>\n</li>\n<li><p>勾选侧边栏大纲视图折叠和展开</p>\n</li>\n<li><p>配置 Next 主题</p>\n<ol>\n<li><p>官网：<a href=\"https://theme.typora.io/theme/NexT/\">https://theme.typora.io/theme/NexT/</a></p>\n</li>\n<li><p>下载 zip 压缩包：<a href=\"https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip\">typora-theme-next.zip</a></p>\n</li>\n<li><p>Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹<code>xxx</code></p>\n</li>\n<li><p>把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹<code>xxx</code>下</p>\n</li>\n<li><p>重启 Typora，设置外观选择Next即可</p>\n</li>\n<li><p>如果感觉页面宽度太小，可以打开next.css，搜索并配置max-width</p>\n</li>\n<li><p>如果感觉整体页面偏小，可以<code>Ctrl Shift +/-</code>增大/减小整体页面</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><ol>\n<li>设置默认换行符</li>\n<li>取消拼写检查，勾选<code>不使用拼写检查</code></li>\n</ol>\n<h3 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h3><ol>\n<li><p>插入图片时</p>\n<p> 选择上传图片，勾选<code>对本地位置的图片应用上述规则</code>和<code>对网络位置的图片应用上述规则</code></p>\n</li>\n<li><p>上传服务设定</p>\n<p> 接下来会具体讲到图床的配置</p>\n</li>\n</ol>\n<h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><ol>\n<li>勾选显示代码块行号</li>\n</ol>\n<h2 id=\"图床配置\"><a href=\"#图床配置\" class=\"headerlink\" title=\"图床配置\"></a>图床配置</h2><h3 id=\"1、安装PicGo\"><a href=\"#1、安装PicGo\" class=\"headerlink\" title=\"1、安装PicGo\"></a>1、安装PicGo</h3><p>下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">https://github.com/Molunerfinn/PicGo/releases</a></p>\n<p>安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在PicGo中打开PicGo设置，找到设置Server，点击设置，点击开启Server，点击确定即可。</p>\n<h3 id=\"2、配置Typora\"><a href=\"#2、配置Typora\" class=\"headerlink\" title=\"2、配置Typora\"></a>2、配置Typora</h3><p>文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择picgo.app，选择picgo的安装路径，验证图片上传选项</p>\n<h3 id=\"3、阿里云OSS搭建图床\"><a href=\"#3、阿里云OSS搭建图床\" class=\"headerlink\" title=\"3、阿里云OSS搭建图床\"></a>3、阿里云OSS搭建图床</h3><h4 id=\"3-1、开通阿里云对象存储\"><a href=\"#3-1、开通阿里云对象存储\" class=\"headerlink\" title=\"3.1、开通阿里云对象存储\"></a>3.1、开通阿里云对象存储</h4><p>开通阿里云对象存储<a href=\"https://www.aliyun.com/product/oss%EF%BC%8C%E6%B3%A8%E5%86%8C%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%A6%E5%8F%B7%E5%90%8E%EF%BC%8C%E5%BC%80%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0\">https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台</a></p>\n<h4 id=\"3-2、创建bucket\"><a href=\"#3-2、创建bucket\" class=\"headerlink\" title=\"3.2、创建bucket\"></a>3.2、创建bucket</h4><ul>\n<li><p>在左侧选择概览，然后在右侧Bucket管理中创建一个新的bucket</p>\n</li>\n<li><p>创建Bucket具体配置</p>\n<blockquote>\n<p>Bucket名字不能有大写字母、地域就近选择、存储类型选择<code>标准存储</code>，读写权限<code>公共读</code></p>\n</blockquote>\n</li>\n<li><p>创建成功后，可以在Bucket列表中查看，记住自己的访问域名和地域节点，后面会用到。</p>\n</li>\n</ul>\n<h4 id=\"3-3、创建AccessKey\"><a href=\"#3-3、创建AccessKey\" class=\"headerlink\" title=\"3.3、创建AccessKey\"></a>3.3、创建AccessKey</h4><p>页面右上角，鼠标放在头像处，在弹出的框里选择AccessKey管理，在弹出的选项框里，选择<code>继续使用AccessKey</code>。</p>\n<p>进入后，创建一个<code>AccessKey</code>。</p>\n<p>在弹出的界面里，记住你的<code>accessKeyId</code>和<code>accessKeySecret</code>。</p>\n<h4 id=\"3-4、了解收费标准\"><a href=\"#3-4、了解收费标准\" class=\"headerlink\" title=\"3.4、了解收费标准\"></a>3.4、了解收费标准</h4><p>使用默认的0.12元/1GB/1个月即可。</p>\n<h3 id=\"4、配置PicGo\"><a href=\"#4、配置PicGo\" class=\"headerlink\" title=\"4、配置PicGo\"></a>4、配置PicGo</h3><p>我们打开打开PicGo的主界面,在图床设置里面选择阿里云OSS，依照下面注意事项填写信息。</p>\n<p>设定Keyld：填写我们在第三步中获得的AccessKeyID</p>\n<p>设定KeySecret：填写我们在第三步中获得的AccessKeyIDSecret</p>\n<p>设定储存空间名：填写我们在第二步中填写的bucket名称</p>\n<p>确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制oss-cn-Xxxx即可，不需要后面的.aliyuncs.com</p>\n<h3 id=\"5、测试使用\"><a href=\"#5、测试使用\" class=\"headerlink\" title=\"5、测试使用\"></a>5、测试使用</h3><p>经过上面的一系列配置之后，我们就完成了Typora的图床配置，现在我们可以使用Markdown开始写文章了，图片、截图会在粘贴之后，自动通过PicGo上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qq_51808107/article/details/124044961\">https://blog.csdn.net/qq_51808107/article/details/124044961</a></p>"},{"title":"回老家的一周","copyright":true,"mathjax":true,"date":"2022-12-23T10:46:02.000Z","urlname":"week-back-home","_content":"\n上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。\n\n<!--more-->\n\n在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。\n\n在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。\n\n表侄今年六岁了，很可爱，活蹦乱跳的。\n\n爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。\n\n今天下午回到常州了，准备最近搞搞毕业论文的事了。\n\n","source":"_posts/回老家的一周.md","raw":"---\ntitle: 回老家的一周\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2022-12-23 18:46:02\nurlname: week-back-home\n---\n\n上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。\n\n<!--more-->\n\n在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。\n\n在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。\n\n表侄今年六岁了，很可爱，活蹦乱跳的。\n\n爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。\n\n今天下午回到常州了，准备最近搞搞毕业论文的事了。\n\n","slug":"回老家的一周","published":1,"updated":"2023-01-17T01:34:20.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiy000kzvt81s4l7d8z","content":"<p>上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。</p>\n<span id=\"more\"></span>\n\n<p>在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。</p>\n<p>在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。</p>\n<p>表侄今年六岁了，很可爱，活蹦乱跳的。</p>\n<p>爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。</p>\n<p>今天下午回到常州了，准备最近搞搞毕业论文的事了。</p>\n","site":{"data":{}},"length":323,"excerpt":"<p>上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。</p>","more":"<p>在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。</p>\n<p>在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。</p>\n<p>表侄今年六岁了，很可爱，活蹦乱跳的。</p>\n<p>爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。</p>\n<p>今天下午回到常州了，准备最近搞搞毕业论文的事了。</p>"},{"title":"字节暑期实习同组实习生秋招情况分享","copyright":true,"mathjax":true,"date":"2022-12-13T12:02:14.000Z","urlname":"my-bytedance-internship-friends-offer","_content":"\n突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。\n\n<!--more-->\n\n在字节跳动暑期实习期间，前前后后加上我一共有5名实习生。\n\n实习生A：浙大硕，在我们组从4月中干到7月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。\n\n实习生B：山大硕，多段实习（包括量化，字节多段实习）大佬，7月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大sp offer并顺利签约。\n\n实习生C：重邮本，参加本部门实习转正，顺利收到小sp offer并签约。\n\n实习生D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等offer，选择wlb的农行。\n\n实习生E（本人），具体情况可见我的[2022秋招总结](https://yaxing97.com/2022-autumn-recruitment-summary.html) 。\n\n这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”\n\n我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的mentor比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般8点左右就润了。到家什么都不想做，更别提学习了。幸好618入手了ps5，靠战神4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂offer可能无脑去了，经历过才知道自己所能承受的身心压力。\n\n因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。\n\n以上。\n","source":"_posts/字节暑期实习同组实习生秋招情况分享.md","raw":"---\ntitle: 字节暑期实习同组实习生秋招情况分享\ncopyright: true\nmathjax: true\ndate: 2022-12-13 20:02:14\ncategories: \n  - 实习秋招\n  - 实习\ntags: \nurlname: my-bytedance-internship-friends-offer\n---\n\n突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。\n\n<!--more-->\n\n在字节跳动暑期实习期间，前前后后加上我一共有5名实习生。\n\n实习生A：浙大硕，在我们组从4月中干到7月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。\n\n实习生B：山大硕，多段实习（包括量化，字节多段实习）大佬，7月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大sp offer并顺利签约。\n\n实习生C：重邮本，参加本部门实习转正，顺利收到小sp offer并签约。\n\n实习生D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等offer，选择wlb的农行。\n\n实习生E（本人），具体情况可见我的[2022秋招总结](https://yaxing97.com/2022-autumn-recruitment-summary.html) 。\n\n这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”\n\n我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的mentor比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般8点左右就润了。到家什么都不想做，更别提学习了。幸好618入手了ps5，靠战神4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂offer可能无脑去了，经历过才知道自己所能承受的身心压力。\n\n因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。\n\n以上。\n","slug":"字节暑期实习同组实习生秋招情况分享","published":1,"updated":"2023-01-17T01:33:55.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsiz000lzvt83151b4xq","content":"<p>突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。</p>\n<span id=\"more\"></span>\n\n<p>在字节跳动暑期实习期间，前前后后加上我一共有5名实习生。</p>\n<p>实习生A：浙大硕，在我们组从4月中干到7月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。</p>\n<p>实习生B：山大硕，多段实习（包括量化，字节多段实习）大佬，7月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大sp offer并顺利签约。</p>\n<p>实习生C：重邮本，参加本部门实习转正，顺利收到小sp offer并签约。</p>\n<p>实习生D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等offer，选择wlb的农行。</p>\n<p>实习生E（本人），具体情况可见我的<a href=\"https://yaxing97.com/2022-autumn-recruitment-summary.html\">2022秋招总结</a> 。</p>\n<p>这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”</p>\n<p>我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的mentor比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般8点左右就润了。到家什么都不想做，更别提学习了。幸好618入手了ps5，靠战神4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂offer可能无脑去了，经历过才知道自己所能承受的身心压力。</p>\n<p>因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。</p>\n<p>以上。</p>\n","site":{"data":{}},"length":664,"excerpt":"<p>突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。</p>","more":"<p>在字节跳动暑期实习期间，前前后后加上我一共有5名实习生。</p>\n<p>实习生A：浙大硕，在我们组从4月中干到7月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。</p>\n<p>实习生B：山大硕，多段实习（包括量化，字节多段实习）大佬，7月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大sp offer并顺利签约。</p>\n<p>实习生C：重邮本，参加本部门实习转正，顺利收到小sp offer并签约。</p>\n<p>实习生D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等offer，选择wlb的农行。</p>\n<p>实习生E（本人），具体情况可见我的<a href=\"https://yaxing97.com/2022-autumn-recruitment-summary.html\">2022秋招总结</a> 。</p>\n<p>这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”</p>\n<p>我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的mentor比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般8点左右就润了。到家什么都不想做，更别提学习了。幸好618入手了ps5，靠战神4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂offer可能无脑去了，经历过才知道自己所能承受的身心压力。</p>\n<p>因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。</p>\n<p>以上。</p>"},{"title":"开了个B站大会员","copyright":true,"mathjax":true,"date":"2022-12-15T13:39:46.000Z","urlname":"bilibili-vip","_content":"\n最近巫师3更新了次世代版本（画质优化+中文配音），由于PS5放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（[链接](https://www.bilibili.com/video/BV1L14y1N7b3)）。\n\n<!--more-->\n\n看了一会，诶，咋更新了还这么糊，一看原来是只开了1080P画质，一冲动上某多多买了三个月的大会员，点开4K画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头PS5上再三周目吧，并且期待一手巫师4。\n\n充了大会员，接下来闲的时候再把B站上的电影再看看，总不能浪费了不是hhh。\n\n最近多个平台都在搞年终总结了，比如Apple Music和PlayStation，准备等其他平台都推出年终总结之后搞波分享～\n\n","source":"_posts/开了个B站大会员.md","raw":"---\ntitle: 开了个B站大会员\ncopyright: true\nmathjax: true\ndate: 2022-12-15 21:39:46\ncategories: 日常小记\ntags: \nurlname: bilibili-vip\n---\n\n最近巫师3更新了次世代版本（画质优化+中文配音），由于PS5放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（[链接](https://www.bilibili.com/video/BV1L14y1N7b3)）。\n\n<!--more-->\n\n看了一会，诶，咋更新了还这么糊，一看原来是只开了1080P画质，一冲动上某多多买了三个月的大会员，点开4K画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头PS5上再三周目吧，并且期待一手巫师4。\n\n充了大会员，接下来闲的时候再把B站上的电影再看看，总不能浪费了不是hhh。\n\n最近多个平台都在搞年终总结了，比如Apple Music和PlayStation，准备等其他平台都推出年终总结之后搞波分享～\n\n","slug":"开了个B站大会员","published":1,"updated":"2023-01-17T01:34:09.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsj0000ozvt8d6uhd03t","content":"<p>最近巫师3更新了次世代版本（画质优化+中文配音），由于PS5放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（<a href=\"https://www.bilibili.com/video/BV1L14y1N7b3\">链接</a>）。</p>\n<span id=\"more\"></span>\n\n<p>看了一会，诶，咋更新了还这么糊，一看原来是只开了1080P画质，一冲动上某多多买了三个月的大会员，点开4K画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头PS5上再三周目吧，并且期待一手巫师4。</p>\n<p>充了大会员，接下来闲的时候再把B站上的电影再看看，总不能浪费了不是hhh。</p>\n<p>最近多个平台都在搞年终总结了，比如Apple Music和PlayStation，准备等其他平台都推出年终总结之后搞波分享～</p>\n","site":{"data":{}},"length":276,"excerpt":"<p>最近巫师3更新了次世代版本（画质优化+中文配音），由于PS5放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（<a href=\"https://www.bilibili.com/video/BV1L14y1N7b3\">链接</a>）。</p>","more":"<p>看了一会，诶，咋更新了还这么糊，一看原来是只开了1080P画质，一冲动上某多多买了三个月的大会员，点开4K画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头PS5上再三周目吧，并且期待一手巫师4。</p>\n<p>充了大会员，接下来闲的时候再把B站上的电影再看看，总不能浪费了不是hhh。</p>\n<p>最近多个平台都在搞年终总结了，比如Apple Music和PlayStation，准备等其他平台都推出年终总结之后搞波分享～</p>"},{"title":"手把手带你搭建个人博客","copyright":true,"mathjax":true,"date":"2022-12-12T13:08:31.000Z","toc":true,"urlname":"build-blog","_content":"\n## 系统环境&工具\n\n系统环境：MacOS\n\n工具：博客框架为hexo，博客文件托管于GitHub，博客网站用Netlify生成，国内访问采用CloudFlare进行CDN加速\n\n<!--more-->\n\n## hexo博客框架安装\n\n### 预先环境\n\n1、安装node（使用homebrew）\n\n```bash\nbrew install node\n```\n\n2、查看版本信息，正常看到版本信息即为成功\n\n```bash\nnode -v\nnpm -v\n```\n\n3、切换npm的源将源设置为淘宝源（速度快）\n\n```bash\nnpm config get registry\t# 查看源\nnpm config set registry https://registry.npm.taobao.org # 修改为淘宝源\n```\n\n### 安装\n\n1、安装hexo\n\n```bash\nnpm install hexo-cli -g # 全局安装hexo命令行工具\n```\n\n2、初始化博客项目\n\n```bash\nhexo init \"博客目录名称\"\n# hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解\n```\n\n3、切换至博客目录安装依赖\n\n```bash\ncd blog\nnpm install\n```\n\n4、运行\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n打开链接，本地出现博客界面，即本地搭建成功！\n\n### 添加建站脚本\n\n为了后续`netlify`建站方便，在`package.json`里面添加一个命令：\n\n```json\nJSON\n{\n    // ......\n    \"scripts\": {\n        \"build\": \"hexo generate\",\n        \"clean\": \"hexo clean\",\n        \"deploy\": \"hexo deploy\",\n        \"server\": \"hexo server\",\n        \"netlify\": \"npm run clean && npm run build\" // 新加行\n    },\n    // ......\n}\n```\n\n## GitHub托管项目文件\n\n创建本地仓库，推送到远端服务器\n\n```bash\ncd blog\ngit init\ngit add .\ngit commit -m \"my blog first commit\"\ngit remote add origin \"远端github仓库地址\"\ngit branch -M main\ngit push -u origin main\n```\n\n## Netlify建站\n\n由于GitHub自带的gitpage访问速度较慢，我们使用Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub上的静态网站部署上线。\n\n### 步骤\n\n1、注册并登陆 Netlify\n\n2、add new site - import an existing project\n\n3、连接到GitHub，选择我们托管在GitHub上的博客项目\n\n4、在设置中注意修改一处，Basic build settings - Build command修改为 `npm run netlify`\n\n5、构建完成可以看到一个 xxx.netlify.app 的url，即为我们博客的url，修改该url中的xxx为yaxing97，即设置我的个人博客域名为`yaxing97.netlify.app`\n\n### 配置域名\n\n1、购买域名（国内国外都可）\n\n2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮\n\n3、设置域名解析，类型为`CNAME`，主机记录为`@`，记录值为`yaxing97.netlify.app`，其中`yaxing97`是之前建站步骤中设置的个性二级域名\n\n4、在netlify中配置域名，domain management - domains - add custom domain，一路通过即可\n\n## CloudFlare加速\n\nNetlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。\n\n### 步骤\n\n1、注册Cloudflare并登陆\n\n2、输入您的站点（yaxing97.com），点击添加站点\n\n3、选择免费套餐\n\n4、添加DNS，Type为`CNAME`，Name为`yaxing97.com`，Content为`yaxing97.netlify.app`\n\n5、使用cloudflare提供的dns解析服务器（Cloudflare Nameservers）对 `yaxing97.com` 进行dns解析\n\n6、到阿里云控制台中，DNS管理 - DNS修改，修改DNS服务器\n\n## 配置https\n\n回到netlify中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成\n\n![配置HTTPS](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png)\n\n\n\n## 文章编写\n\n```bash\nhexo new \"文章标题\"\n# 编写好之后\nhexo clean\nhexo g\ngit add *\ngit commit -m \"commit信息\"\ngit push\n```\n\n过片刻，访问我们的`https://yaxing97.com`，可以看到新添加的文章。\n\n## 参考&更多\n\nhttps://blog.cuijiacai.com/blog-building/\n\nhttps://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\n","source":"_posts/手把手带你搭建个人博客.md","raw":"---\ntitle: 手把手带你搭建个人博客\ncopyright: true\nmathjax: true\ndate: 2022-12-12 21:08:31\ncategories: 技术总结\ntags: \ntoc: true\nurlname: build-blog\n---\n\n## 系统环境&工具\n\n系统环境：MacOS\n\n工具：博客框架为hexo，博客文件托管于GitHub，博客网站用Netlify生成，国内访问采用CloudFlare进行CDN加速\n\n<!--more-->\n\n## hexo博客框架安装\n\n### 预先环境\n\n1、安装node（使用homebrew）\n\n```bash\nbrew install node\n```\n\n2、查看版本信息，正常看到版本信息即为成功\n\n```bash\nnode -v\nnpm -v\n```\n\n3、切换npm的源将源设置为淘宝源（速度快）\n\n```bash\nnpm config get registry\t# 查看源\nnpm config set registry https://registry.npm.taobao.org # 修改为淘宝源\n```\n\n### 安装\n\n1、安装hexo\n\n```bash\nnpm install hexo-cli -g # 全局安装hexo命令行工具\n```\n\n2、初始化博客项目\n\n```bash\nhexo init \"博客目录名称\"\n# hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解\n```\n\n3、切换至博客目录安装依赖\n\n```bash\ncd blog\nnpm install\n```\n\n4、运行\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n打开链接，本地出现博客界面，即本地搭建成功！\n\n### 添加建站脚本\n\n为了后续`netlify`建站方便，在`package.json`里面添加一个命令：\n\n```json\nJSON\n{\n    // ......\n    \"scripts\": {\n        \"build\": \"hexo generate\",\n        \"clean\": \"hexo clean\",\n        \"deploy\": \"hexo deploy\",\n        \"server\": \"hexo server\",\n        \"netlify\": \"npm run clean && npm run build\" // 新加行\n    },\n    // ......\n}\n```\n\n## GitHub托管项目文件\n\n创建本地仓库，推送到远端服务器\n\n```bash\ncd blog\ngit init\ngit add .\ngit commit -m \"my blog first commit\"\ngit remote add origin \"远端github仓库地址\"\ngit branch -M main\ngit push -u origin main\n```\n\n## Netlify建站\n\n由于GitHub自带的gitpage访问速度较慢，我们使用Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub上的静态网站部署上线。\n\n### 步骤\n\n1、注册并登陆 Netlify\n\n2、add new site - import an existing project\n\n3、连接到GitHub，选择我们托管在GitHub上的博客项目\n\n4、在设置中注意修改一处，Basic build settings - Build command修改为 `npm run netlify`\n\n5、构建完成可以看到一个 xxx.netlify.app 的url，即为我们博客的url，修改该url中的xxx为yaxing97，即设置我的个人博客域名为`yaxing97.netlify.app`\n\n### 配置域名\n\n1、购买域名（国内国外都可）\n\n2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮\n\n3、设置域名解析，类型为`CNAME`，主机记录为`@`，记录值为`yaxing97.netlify.app`，其中`yaxing97`是之前建站步骤中设置的个性二级域名\n\n4、在netlify中配置域名，domain management - domains - add custom domain，一路通过即可\n\n## CloudFlare加速\n\nNetlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。\n\n### 步骤\n\n1、注册Cloudflare并登陆\n\n2、输入您的站点（yaxing97.com），点击添加站点\n\n3、选择免费套餐\n\n4、添加DNS，Type为`CNAME`，Name为`yaxing97.com`，Content为`yaxing97.netlify.app`\n\n5、使用cloudflare提供的dns解析服务器（Cloudflare Nameservers）对 `yaxing97.com` 进行dns解析\n\n6、到阿里云控制台中，DNS管理 - DNS修改，修改DNS服务器\n\n## 配置https\n\n回到netlify中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成\n\n![配置HTTPS](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png)\n\n\n\n## 文章编写\n\n```bash\nhexo new \"文章标题\"\n# 编写好之后\nhexo clean\nhexo g\ngit add *\ngit commit -m \"commit信息\"\ngit push\n```\n\n过片刻，访问我们的`https://yaxing97.com`，可以看到新添加的文章。\n\n## 参考&更多\n\nhttps://blog.cuijiacai.com/blog-building/\n\nhttps://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\n","slug":"手把手带你搭建个人博客","published":1,"updated":"2023-01-17T12:12:45.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsj0000qzvt83ivcd84m","content":"<h2 id=\"系统环境-amp-工具\"><a href=\"#系统环境-amp-工具\" class=\"headerlink\" title=\"系统环境&工具\"></a>系统环境&amp;工具</h2><p>系统环境：MacOS</p>\n<p>工具：博客框架为hexo，博客文件托管于GitHub，博客网站用Netlify生成，国内访问采用CloudFlare进行CDN加速</p>\n<span id=\"more\"></span>\n\n<h2 id=\"hexo博客框架安装\"><a href=\"#hexo博客框架安装\" class=\"headerlink\" title=\"hexo博客框架安装\"></a>hexo博客框架安装</h2><h3 id=\"预先环境\"><a href=\"#预先环境\" class=\"headerlink\" title=\"预先环境\"></a>预先环境</h3><p>1、安装node（使用homebrew）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n\n<p>2、查看版本信息，正常看到版本信息即为成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n<p>3、切换npm的源将源设置为淘宝源（速度快）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry\t<span class=\"comment\"># 查看源</span></span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org <span class=\"comment\"># 修改为淘宝源</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>1、安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g <span class=\"comment\"># 全局安装hexo命令行工具</span></span><br></pre></td></tr></table></figure>\n\n<p>2、初始化博客项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init <span class=\"string\">\"博客目录名称\"</span></span><br><span class=\"line\"><span class=\"comment\"># hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解</span></span><br></pre></td></tr></table></figure>\n\n<p>3、切换至博客目录安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>4、运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>打开链接，本地出现博客界面，即本地搭建成功！</p>\n<h3 id=\"添加建站脚本\"><a href=\"#添加建站脚本\" class=\"headerlink\" title=\"添加建站脚本\"></a>添加建站脚本</h3><p>为了后续<code>netlify</code>建站方便，在<code>package.json</code>里面添加一个命令：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON</span><br><span class=\"line\"><span class=\"punctuation\">{</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"attr\">\"scripts\"</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">{</span></span><br><span class=\"line\">        <span class=\"attr\">\"build\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo generate\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"clean\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo clean\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"deploy\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo deploy\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"server\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo server\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"netlify\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"npm run clean &amp;&amp; npm run build\"</span> <span class=\"comment\">// 新加行</span></span><br><span class=\"line\">    <span class=\"punctuation\">}</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"punctuation\">}</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GitHub托管项目文件\"><a href=\"#GitHub托管项目文件\" class=\"headerlink\" title=\"GitHub托管项目文件\"></a>GitHub托管项目文件</h2><p>创建本地仓库，推送到远端服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"my blog first commit\"</span></span><br><span class=\"line\">git remote add origin <span class=\"string\">\"远端github仓库地址\"</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Netlify建站\"><a href=\"#Netlify建站\" class=\"headerlink\" title=\"Netlify建站\"></a>Netlify建站</h2><p>由于GitHub自带的gitpage访问速度较慢，我们使用Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub上的静态网站部署上线。</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册并登陆 Netlify</p>\n<p>2、add new site - import an existing project</p>\n<p>3、连接到GitHub，选择我们托管在GitHub上的博客项目</p>\n<p>4、在设置中注意修改一处，Basic build settings - Build command修改为 <code>npm run netlify</code></p>\n<p>5、构建完成可以看到一个 xxx.netlify.app 的url，即为我们博客的url，修改该url中的xxx为yaxing97，即设置我的个人博客域名为<code>yaxing97.netlify.app</code></p>\n<h3 id=\"配置域名\"><a href=\"#配置域名\" class=\"headerlink\" title=\"配置域名\"></a>配置域名</h3><p>1、购买域名（国内国外都可）</p>\n<p>2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮</p>\n<p>3、设置域名解析，类型为<code>CNAME</code>，主机记录为<code>@</code>，记录值为<code>yaxing97.netlify.app</code>，其中<code>yaxing97</code>是之前建站步骤中设置的个性二级域名</p>\n<p>4、在netlify中配置域名，domain management - domains - add custom domain，一路通过即可</p>\n<h2 id=\"CloudFlare加速\"><a href=\"#CloudFlare加速\" class=\"headerlink\" title=\"CloudFlare加速\"></a>CloudFlare加速</h2><p>Netlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。</p>\n<h3 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册Cloudflare并登陆</p>\n<p>2、输入您的站点（yaxing97.com），点击添加站点</p>\n<p>3、选择免费套餐</p>\n<p>4、添加DNS，Type为<code>CNAME</code>，Name为<code>yaxing97.com</code>，Content为<code>yaxing97.netlify.app</code></p>\n<p>5、使用cloudflare提供的dns解析服务器（Cloudflare Nameservers）对 <code>yaxing97.com</code> 进行dns解析</p>\n<p>6、到阿里云控制台中，DNS管理 - DNS修改，修改DNS服务器</p>\n<h2 id=\"配置https\"><a href=\"#配置https\" class=\"headerlink\" title=\"配置https\"></a>配置https</h2><p>回到netlify中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png\" alt=\"配置HTTPS\"></p>\n<h2 id=\"文章编写\"><a href=\"#文章编写\" class=\"headerlink\" title=\"文章编写\"></a>文章编写</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"文章标题\"</span></span><br><span class=\"line\"><span class=\"comment\"># 编写好之后</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">git add *</span><br><span class=\"line\">git commit -m <span class=\"string\">\"commit信息\"</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>过片刻，访问我们的<code>https://yaxing97.com</code>，可以看到新添加的文章。</p>\n<h2 id=\"参考-amp-更多\"><a href=\"#参考-amp-更多\" class=\"headerlink\" title=\"参考&更多\"></a>参考&amp;更多</h2><p><a href=\"https://blog.cuijiacai.com/blog-building/\">https://blog.cuijiacai.com/blog-building/</a></p>\n<p><a href=\"https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\">https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da</a></p>\n","site":{"data":{}},"length":2194,"excerpt":"<h2 id=\"系统环境-amp-工具\"><a href=\"#系统环境-amp-工具\" class=\"headerlink\" title=\"系统环境&工具\"></a>系统环境&amp;工具</h2><p>系统环境：MacOS</p>\n<p>工具：博客框架为hexo，博客文件托管于GitHub，博客网站用Netlify生成，国内访问采用CloudFlare进行CDN加速</p>","more":"<h2 id=\"hexo博客框架安装\"><a href=\"#hexo博客框架安装\" class=\"headerlink\" title=\"hexo博客框架安装\"></a>hexo博客框架安装</h2><h3 id=\"预先环境\"><a href=\"#预先环境\" class=\"headerlink\" title=\"预先环境\"></a>预先环境</h3><p>1、安装node（使用homebrew）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n\n<p>2、查看版本信息，正常看到版本信息即为成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n<p>3、切换npm的源将源设置为淘宝源（速度快）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry\t<span class=\"comment\"># 查看源</span></span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org <span class=\"comment\"># 修改为淘宝源</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>1、安装hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g <span class=\"comment\"># 全局安装hexo命令行工具</span></span><br></pre></td></tr></table></figure>\n\n<p>2、初始化博客项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init <span class=\"string\">\"博客目录名称\"</span></span><br><span class=\"line\"><span class=\"comment\"># hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解</span></span><br></pre></td></tr></table></figure>\n\n<p>3、切换至博客目录安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>4、运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>打开链接，本地出现博客界面，即本地搭建成功！</p>\n<h3 id=\"添加建站脚本\"><a href=\"#添加建站脚本\" class=\"headerlink\" title=\"添加建站脚本\"></a>添加建站脚本</h3><p>为了后续<code>netlify</code>建站方便，在<code>package.json</code>里面添加一个命令：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON</span><br><span class=\"line\"><span class=\"punctuation\">{</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"attr\">\"scripts\"</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">{</span></span><br><span class=\"line\">        <span class=\"attr\">\"build\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo generate\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"clean\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo clean\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"deploy\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo deploy\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"server\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo server\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"netlify\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"npm run clean &amp;&amp; npm run build\"</span> <span class=\"comment\">// 新加行</span></span><br><span class=\"line\">    <span class=\"punctuation\">}</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"punctuation\">}</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GitHub托管项目文件\"><a href=\"#GitHub托管项目文件\" class=\"headerlink\" title=\"GitHub托管项目文件\"></a>GitHub托管项目文件</h2><p>创建本地仓库，推送到远端服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"my blog first commit\"</span></span><br><span class=\"line\">git remote add origin <span class=\"string\">\"远端github仓库地址\"</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Netlify建站\"><a href=\"#Netlify建站\" class=\"headerlink\" title=\"Netlify建站\"></a>Netlify建站</h2><p>由于GitHub自带的gitpage访问速度较慢，我们使用Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub上的静态网站部署上线。</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册并登陆 Netlify</p>\n<p>2、add new site - import an existing project</p>\n<p>3、连接到GitHub，选择我们托管在GitHub上的博客项目</p>\n<p>4、在设置中注意修改一处，Basic build settings - Build command修改为 <code>npm run netlify</code></p>\n<p>5、构建完成可以看到一个 xxx.netlify.app 的url，即为我们博客的url，修改该url中的xxx为yaxing97，即设置我的个人博客域名为<code>yaxing97.netlify.app</code></p>\n<h3 id=\"配置域名\"><a href=\"#配置域名\" class=\"headerlink\" title=\"配置域名\"></a>配置域名</h3><p>1、购买域名（国内国外都可）</p>\n<p>2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮</p>\n<p>3、设置域名解析，类型为<code>CNAME</code>，主机记录为<code>@</code>，记录值为<code>yaxing97.netlify.app</code>，其中<code>yaxing97</code>是之前建站步骤中设置的个性二级域名</p>\n<p>4、在netlify中配置域名，domain management - domains - add custom domain，一路通过即可</p>\n<h2 id=\"CloudFlare加速\"><a href=\"#CloudFlare加速\" class=\"headerlink\" title=\"CloudFlare加速\"></a>CloudFlare加速</h2><p>Netlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。</p>\n<h3 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册Cloudflare并登陆</p>\n<p>2、输入您的站点（yaxing97.com），点击添加站点</p>\n<p>3、选择免费套餐</p>\n<p>4、添加DNS，Type为<code>CNAME</code>，Name为<code>yaxing97.com</code>，Content为<code>yaxing97.netlify.app</code></p>\n<p>5、使用cloudflare提供的dns解析服务器（Cloudflare Nameservers）对 <code>yaxing97.com</code> 进行dns解析</p>\n<p>6、到阿里云控制台中，DNS管理 - DNS修改，修改DNS服务器</p>\n<h2 id=\"配置https\"><a href=\"#配置https\" class=\"headerlink\" title=\"配置https\"></a>配置https</h2><p>回到netlify中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png\" alt=\"配置HTTPS\"></p>\n<h2 id=\"文章编写\"><a href=\"#文章编写\" class=\"headerlink\" title=\"文章编写\"></a>文章编写</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"文章标题\"</span></span><br><span class=\"line\"><span class=\"comment\"># 编写好之后</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">git add *</span><br><span class=\"line\">git commit -m <span class=\"string\">\"commit信息\"</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>过片刻，访问我们的<code>https://yaxing97.com</code>，可以看到新添加的文章。</p>\n<h2 id=\"参考-amp-更多\"><a href=\"#参考-amp-更多\" class=\"headerlink\" title=\"参考&更多\"></a>参考&amp;更多</h2><p><a href=\"https://blog.cuijiacai.com/blog-building/\">https://blog.cuijiacai.com/blog-building/</a></p>\n<p><a href=\"https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\">https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da</a></p>"},{"title":"新买的小书桌","copyright":true,"mathjax":true,"date":"2022-12-14T08:21:02.000Z","urlname":"new-desk","_content":"\n之前买了个LG的27寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有50cm），显示器靠墙前面只能勉强放下我的mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。\n\n<!--more-->\n\n如果要使用27寸及以上尺寸显示器的话，建议购买宽度至少70cm的，我购买的尺寸为 $120 \\times 80 \\times 74 cm$，店铺是“新尚美家居”。\n\n注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。\n\n以下是实拍图 hh。\n\n![新书桌实拍图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG)\n","source":"_posts/新买的小书桌.md","raw":"---\ntitle: 新买的小书桌\ncopyright: true\nmathjax: true\ndate: 2022-12-14 16:21:02\ncategories: 日常小记\ntags: \nurlname: new-desk\n---\n\n之前买了个LG的27寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有50cm），显示器靠墙前面只能勉强放下我的mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。\n\n<!--more-->\n\n如果要使用27寸及以上尺寸显示器的话，建议购买宽度至少70cm的，我购买的尺寸为 $120 \\times 80 \\times 74 cm$，店铺是“新尚美家居”。\n\n注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。\n\n以下是实拍图 hh。\n\n![新书桌实拍图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG)\n","slug":"新买的小书桌","published":1,"updated":"2023-01-17T01:36:24.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsj1000tzvt814db9bze","content":"<p>之前买了个LG的27寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有50cm），显示器靠墙前面只能勉强放下我的mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。</p>\n<span id=\"more\"></span>\n\n<p>如果要使用27寸及以上尺寸显示器的话，建议购买宽度至少70cm的，我购买的尺寸为 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16.416ex\" height=\"1.581ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -677 7255.9 699\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\" transform=\"translate(500,0)\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(1000,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1722.2,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2722.4,0)\"><path data-c=\"38\" d=\"M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3944.7,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(4944.9,0)\"><path data-c=\"37\" d=\"M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z\"></path><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5944.9,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(6377.9,0)\"><path data-c=\"1D45A\" d=\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>，店铺是“新尚美家居”。</p>\n<p>注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。</p>\n<p>以下是实拍图 hh。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG\" alt=\"新书桌实拍图\"></p>\n","site":{"data":{}},"length":240,"excerpt":"<p>之前买了个LG的27寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有50cm），显示器靠墙前面只能勉强放下我的mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。</p>","more":"<p>如果要使用27寸及以上尺寸显示器的话，建议购买宽度至少70cm的，我购买的尺寸为 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16.416ex\" height=\"1.581ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -677 7255.9 699\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\" transform=\"translate(500,0)\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(1000,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1722.2,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2722.4,0)\"><path data-c=\"38\" d=\"M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3944.7,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(4944.9,0)\"><path data-c=\"37\" d=\"M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z\"></path><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5944.9,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(6377.9,0)\"><path data-c=\"1D45A\" d=\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>，店铺是“新尚美家居”。</p>\n<p>注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。</p>\n<p>以下是实拍图 hh。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG\" alt=\"新书桌实拍图\"></p>"},{"title":"新年快乐！","copyright":true,"mathjax":false,"date":"2023-01-22T01:55:21.000Z","toc":null,"urlname":"2023-happy-spring-festival","_content":"\n今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉\n","source":"_posts/新年快乐！.md","raw":"---\ntitle: 新年快乐！\ncopyright: true\nmathjax: false\ncategories:\n  - 日常小记\ndate: 2023-01-22 09:55:21\ntags: \ntoc: \nurlname: 2023-happy-spring-festival\n---\n\n今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉\n","slug":"新年快乐！","published":1,"updated":"2023-01-23T08:39:20.578Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsj2000vzvt8d287ba8h","content":"<p>今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉</p>\n","site":{"data":{}},"length":47,"excerpt":"","more":"<p>今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉</p>\n"},{"title":"最近关于校招、互联网的一些信息","copyright":true,"mathjax":true,"date":"2023-01-13T04:56:40.000Z","urlname":"202301-it-info","_content":"\n最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。\n\n<!--more-->\n\n1、字节飞书EA，base杭州的很多22届校招生没过试用期。\n\n2、抖音上一商家C++基础课程卖2999一份，销量1700+。\n\n3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。\n\n4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。\n\n5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。\n\n6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。\n\n7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业saas能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业saas的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是5-7万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业saas付费呢？\n\n8、上海银行开发岗今年降薪，22年及以前很香的上银，今年风评逐渐变差。\n\n9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。\n\n10、职场pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。\n\n11、某银行：一个内部几十个人用的单体系统，还要搞devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。\n\n12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。\n\n13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。\n\n14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - [宇宙区长孙连城的回答](https://www.zhihu.com/question/576438196/answer/2830715899)\n\n15、字节杭州有部门全撤转base了，虽然人不多。\n\n16、邮储研发中心总包能到30+w，很香，但是貌似要996，个人感觉还是比较香。\n\n17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？\n\n18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。\n\n19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。\n\n20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？\n","source":"_posts/最近关于校招、互联网的一些信息.md","raw":"---\ntitle: 最近关于校招、互联网的一些信息\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2023-01-13 12:56:40\nurlname: 202301-it-info\n---\n\n最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。\n\n<!--more-->\n\n1、字节飞书EA，base杭州的很多22届校招生没过试用期。\n\n2、抖音上一商家C++基础课程卖2999一份，销量1700+。\n\n3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。\n\n4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。\n\n5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。\n\n6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。\n\n7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业saas能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业saas的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是5-7万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业saas付费呢？\n\n8、上海银行开发岗今年降薪，22年及以前很香的上银，今年风评逐渐变差。\n\n9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。\n\n10、职场pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。\n\n11、某银行：一个内部几十个人用的单体系统，还要搞devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。\n\n12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。\n\n13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。\n\n14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - [宇宙区长孙连城的回答](https://www.zhihu.com/question/576438196/answer/2830715899)\n\n15、字节杭州有部门全撤转base了，虽然人不多。\n\n16、邮储研发中心总包能到30+w，很香，但是貌似要996，个人感觉还是比较香。\n\n17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？\n\n18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。\n\n19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。\n\n20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？\n","slug":"最近关于校招、互联网的一些信息","published":1,"updated":"2023-01-17T01:34:46.943Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsj2000yzvt8dzj3a5ca","content":"<p>最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。</p>\n<span id=\"more\"></span>\n\n<p>1、字节飞书EA，base杭州的很多22届校招生没过试用期。</p>\n<p>2、抖音上一商家C++基础课程卖2999一份，销量1700+。</p>\n<p>3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。</p>\n<p>4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。</p>\n<p>5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。</p>\n<p>6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。</p>\n<p>7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业saas能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业saas的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是5-7万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业saas付费呢？</p>\n<p>8、上海银行开发岗今年降薪，22年及以前很香的上银，今年风评逐渐变差。</p>\n<p>9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。</p>\n<p>10、职场pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。</p>\n<p>11、某银行：一个内部几十个人用的单体系统，还要搞devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。</p>\n<p>12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。</p>\n<p>13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。</p>\n<p>14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - <a href=\"https://www.zhihu.com/question/576438196/answer/2830715899\">宇宙区长孙连城的回答</a></p>\n<p>15、字节杭州有部门全撤转base了，虽然人不多。</p>\n<p>16、邮储研发中心总包能到30+w，很香，但是貌似要996，个人感觉还是比较香。</p>\n<p>17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？</p>\n<p>18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。</p>\n<p>19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。</p>\n<p>20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？</p>\n","site":{"data":{}},"length":1596,"excerpt":"<p>最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。</p>","more":"<p>1、字节飞书EA，base杭州的很多22届校招生没过试用期。</p>\n<p>2、抖音上一商家C++基础课程卖2999一份，销量1700+。</p>\n<p>3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。</p>\n<p>4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。</p>\n<p>5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。</p>\n<p>6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。</p>\n<p>7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业saas能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业saas的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是5-7万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业saas付费呢？</p>\n<p>8、上海银行开发岗今年降薪，22年及以前很香的上银，今年风评逐渐变差。</p>\n<p>9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。</p>\n<p>10、职场pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。</p>\n<p>11、某银行：一个内部几十个人用的单体系统，还要搞devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。</p>\n<p>12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。</p>\n<p>13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。</p>\n<p>14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - <a href=\"https://www.zhihu.com/question/576438196/answer/2830715899\">宇宙区长孙连城的回答</a></p>\n<p>15、字节杭州有部门全撤转base了，虽然人不多。</p>\n<p>16、邮储研发中心总包能到30+w，很香，但是貌似要996，个人感觉还是比较香。</p>\n<p>17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？</p>\n<p>18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。</p>\n<p>19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。</p>\n<p>20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？</p>"},{"title":"江苏省考考完啦","copyright":true,"mathjax":true,"date":"2022-12-18T03:49:32.000Z","urlname":"2022-jiangsu-gwy","_content":"\n坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。\n\n<!--more-->\n\n8月底从字节回学校，本来是准备用80%的时间准备gwy考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于offer选择等问题让人心烦，备考甚至中断过一段时间。\n\n来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。\n\n昨天早上行测，135题，厚礼蟹，感觉以我目前的水平120分钟做完125题是个极限了，还有浙江省考竟然115题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。\n\n总体而言，对于我这个岗位而言，报录比80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。\n\n下个月还有国考，这几天再带着看看行测吧。\n","source":"_posts/江苏省考考完啦.md","raw":"---\ntitle: 江苏省考考完啦\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2022-12-18 11:49:32\nurlname: 2022-jiangsu-gwy\n---\n\n坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。\n\n<!--more-->\n\n8月底从字节回学校，本来是准备用80%的时间准备gwy考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于offer选择等问题让人心烦，备考甚至中断过一段时间。\n\n来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。\n\n昨天早上行测，135题，厚礼蟹，感觉以我目前的水平120分钟做完125题是个极限了，还有浙江省考竟然115题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。\n\n总体而言，对于我这个岗位而言，报录比80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。\n\n下个月还有国考，这几天再带着看看行测吧。\n","slug":"江苏省考考完啦","published":1,"updated":"2023-01-17T01:34:15.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8kfsj30010zvt874q85gky","content":"<p>坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。</p>\n<span id=\"more\"></span>\n\n<p>8月底从字节回学校，本来是准备用80%的时间准备gwy考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于offer选择等问题让人心烦，备考甚至中断过一段时间。</p>\n<p>来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。</p>\n<p>昨天早上行测，135题，厚礼蟹，感觉以我目前的水平120分钟做完125题是个极限了，还有浙江省考竟然115题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。</p>\n<p>总体而言，对于我这个岗位而言，报录比80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。</p>\n<p>下个月还有国考，这几天再带着看看行测吧。</p>\n","site":{"data":{}},"length":635,"excerpt":"<p>坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。</p>","more":"<p>8月底从字节回学校，本来是准备用80%的时间准备gwy考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于offer选择等问题让人心烦，备考甚至中断过一段时间。</p>\n<p>来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。</p>\n<p>昨天早上行测，135题，厚礼蟹，感觉以我目前的水平120分钟做完125题是个极限了，还有浙江省考竟然115题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。</p>\n<p>总体而言，对于我这个岗位而言，报录比80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。</p>\n<p>下个月还有国考，这几天再带着看看行测吧。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cld8kfsik0001zvt8co8o6kyx","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsiu000czvt892eh9w5w"},{"post_id":"cld8kfsix000hzvt8ghzo4q37","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsiz000mzvt83zmi42mp"},{"post_id":"cld8kfsir0007zvt8b5os7454","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsj0000pzvt85kxxgg70"},{"post_id":"cld8kfsiy000kzvt81s4l7d8z","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsj1000rzvt8ewdbbrq6"},{"post_id":"cld8kfsis0008zvt89obi96oc","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsj2000uzvt884lk9tj6"},{"post_id":"cld8kfsj0000ozvt8d6uhd03t","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsj2000wzvt83hho7x8t"},{"post_id":"cld8kfsit000azvt86vrhhome","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsj3000zzvt857h4fnqm"},{"post_id":"cld8kfsj1000tzvt814db9bze","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsj30011zvt869fadcdv"},{"post_id":"cld8kfsin0003zvt85kb1cvmo","category_id":"cld8kfsit0009zvt8ds7207xq","_id":"cld8kfsj40013zvt8avxhh9pl"},{"post_id":"cld8kfsin0003zvt85kb1cvmo","category_id":"cld8kfsj1000szvt8a3k007f2","_id":"cld8kfsj40014zvt8armje7l0"},{"post_id":"cld8kfsj2000vzvt8d287ba8h","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsj40016zvt880wzguk4"},{"post_id":"cld8kfsj2000yzvt8dzj3a5ca","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsj40017zvt8f2yj5ipc"},{"post_id":"cld8kfsiu000bzvt8gmhrh2x5","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsj40018zvt82uhb478q"},{"post_id":"cld8kfsj30010zvt874q85gky","category_id":"cld8kfsip0004zvt86uh15bd8","_id":"cld8kfsj5001azvt8c1agdrrb"},{"post_id":"cld8kfsiv000ezvt8dj5yb1a7","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsj5001bzvt89b4e4u2c"},{"post_id":"cld8kfsiq0006zvt8eejq2hpk","category_id":"cld8kfsit0009zvt8ds7207xq","_id":"cld8kfsj5001dzvt8cd5g40zy"},{"post_id":"cld8kfsiq0006zvt8eejq2hpk","category_id":"cld8kfsj40015zvt86m8cez11","_id":"cld8kfsj5001ezvt85ekea0k6"},{"post_id":"cld8kfsiw000fzvt8477edsy8","category_id":"cld8kfsix000gzvt8cfljb67j","_id":"cld8kfsj5001gzvt87xraaobv"},{"post_id":"cld8kfsiy000izvt850sub8d8","category_id":"cld8kfsj5001czvt86tcq7jot","_id":"cld8kfsj6001izvt8cjxnfgtz"},{"post_id":"cld8kfsiz000lzvt83151b4xq","category_id":"cld8kfsit0009zvt8ds7207xq","_id":"cld8kfsj6001jzvt8hlyj1q35"},{"post_id":"cld8kfsiz000lzvt83151b4xq","category_id":"cld8kfsj1000szvt8a3k007f2","_id":"cld8kfsj6001kzvt8b93yeep6"},{"post_id":"cld8kfsj0000qzvt83ivcd84m","category_id":"cld8kfsj5001czvt86tcq7jot","_id":"cld8kfsj6001lzvt8aup5635e"}],"PostTag":[],"Tag":[]}}