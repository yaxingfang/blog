{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/imgs/alipay.jpg","path":"imgs/alipay.jpg","modified":1,"renderable":0},{"_id":"source/imgs/wechat.jpg","path":"imgs/wechat.jpg","modified":1,"renderable":0},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/icarus/source/img/wechat.jpg","path":"img/wechat.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"15f615ee77ad314ed011d8dc83f444a0dfd3dc71","modified":1676082274704},{"_id":"source/_posts/12张图回忆我的2022.md","hash":"ac66699d1542b20ff0d399d69d6ae8029f742f4e","modified":1674736558970},{"_id":"source/_posts/2022实习总结.md","hash":"7d9c8d0c736839ccc428eee3bd5fe451eba53af4","modified":1674736558970},{"_id":"source/.DS_Store","hash":"0399c6d1283c9b975f6a52ad33d648cd0d667b55","modified":1676082274705},{"_id":"source/_posts/2022秋招总结.md","hash":"c69384d32f03fb9209d1bea2a320e59ce12c791f","modified":1674736558971},{"_id":"source/_posts/Java八股文 - Java基础.md","hash":"a7bd4e462f5fd64276698ada528131f6c71b94fb","modified":1674736830310},{"_id":"source/_posts/Java八股文 - Java异常.md","hash":"09b3b445a2df8eca69dd72f1266ce23a95d13cf3","modified":1674738030451},{"_id":"source/_posts/Java八股文 - Java集合.md","hash":"f50e06ec8bb71825b1d01baec9e37948f77b184e","modified":1674736558974},{"_id":"source/_posts/Java八股文 - MyBatis.md","hash":"40d75f0ea68a4322d1e1a826e22beaf1a3ed55ac","modified":1674736558974},{"_id":"source/_posts/Java八股文 - Spring.md","hash":"089097cb49f4ea3da654f381cd8bf4ee5a8bf72c","modified":1674736558975},{"_id":"source/_posts/Java八股文 - SpringMVC.md","hash":"80f8cb25cbf0d8674bbc6a19023c2c3d705a91a1","modified":1674736558976},{"_id":"source/_posts/Mac安装MySQL以及Sequel-Pro配置与连接.md","hash":"be34c0ff80236f96674cd15e7296b1e41712dfaa","modified":1676088608942},{"_id":"source/_posts/Java八股文-计算机网络.md","hash":"fe9669305463eab9de8de8d31aa491dbaf222534","modified":1674993624422},{"_id":"source/_posts/Typora配置阿里云OSS图床.md","hash":"c520e8e0c519bb469e214d13664bb9a4c07a6b98","modified":1674736558980},{"_id":"source/_posts/关于体制内的一些思考.md","hash":"f2bab7eea2a545a445ab5d811ab31d70f8c641dc","modified":1675840387642},{"_id":"source/_posts/字节暑期实习同组实习生秋招情况分享.md","hash":"b7474b9af9ab715279f534bc22f031da32ff9d43","modified":1674736558981},{"_id":"source/_posts/回老家的一周.md","hash":"479d7dfd0f78087f92e4bb96e1cdf4f849ecbe55","modified":1674734830270},{"_id":"source/_posts/开了个B站大会员.md","hash":"9f61e6a37fd13d272ba9ed8d33aafbda6010567f","modified":1674736558981},{"_id":"source/_posts/新年快乐！.md","hash":"a1d29f9cabd7a9f2d2a87c29c455c56726ff2487","modified":1674734830270},{"_id":"source/_posts/手把手带你搭建个人博客.md","hash":"b691bb5f1a201a402586da957145a138406f1305","modified":1674736558982},{"_id":"source/_posts/新买的小书桌.md","hash":"4a0efd2e8e60db8574697f5082d0cb149a2fdc99","modified":1674736558983},{"_id":"source/_posts/最近关于校招、互联网的一些信息.md","hash":"79de0a6e50c8e869834bf5fda957c15ed514638f","modified":1674736558983},{"_id":"source/_posts/江苏省考考完啦.md","hash":"1ecdc57336003c34041679e6bd17901d9544ea46","modified":1674736558984},{"_id":"source/about/.DS_Store","hash":"34fe290bc8d934cf4c51deea76c7ec16f3cf4d2f","modified":1675912021468},{"_id":"source/_posts/算法-排序算法.md","hash":"bd482101073452d727e1e5451b26e7cbdb49bc38","modified":1675136906886},{"_id":"source/categories/index.md","hash":"34befbcc0cb1361fe6ab629e0efcb19c0ee86647","modified":1673929754157},{"_id":"source/about/index.md","hash":"3a3332e834e0e7a899ee8d52a9d55f080f39a019","modified":1675840940099},{"_id":"source/categories/.DS_Store","hash":"34fe290bc8d934cf4c51deea76c7ec16f3cf4d2f","modified":1671761650651},{"_id":"source/tags/index.md","hash":"95d08ed3da8f867aaab215ddace25b88fbf1a14f","modified":1673931830273},{"_id":"source/_posts/Java八股文 - Java并发.md","hash":"1c4cfbe12f8e14d04c241c8feb1e30344c764dc0","modified":1674736558973},{"_id":"source/_posts/Java八股文-Linux.md","hash":"c1a7aea983da7a4203c3c0c7cf28c986aeaf8f26","modified":1674993581227},{"_id":"source/_posts/Java八股文-Redis.md","hash":"d62b84d16759ab35ac00706954d5dd59165f136f","modified":1674992709073},{"_id":"source/_posts/Java八股文-MySQL.md","hash":"76567a6d63072df2ed088e4aa9b5a36a57ccb1a4","modified":1674736558978},{"_id":"source/imgs/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1671703105000},{"_id":"source/imgs/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1671703075000},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406360},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406364},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406353},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406372},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406368},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406219},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406335},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406321},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406346},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1673879406290},{"_id":"themes/icarus/package.json","hash":"9d42eb99acdaf56afbda664adea40d8d80cdb0b0","modified":1673879406412},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1673879406442},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1673879406385},{"_id":"themes/icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1673879406442},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1673879406375},{"_id":"themes/icarus/include/dependency.js","hash":"0ca35dec92ccf383f45db905db1a5a0e92d7209e","modified":1673879406388},{"_id":"themes/icarus/include/register.js","hash":"ec6596b63bfb4349ba61792d905abe8e06fea625","modified":1673879406395},{"_id":"themes/icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1673879406471},{"_id":"themes/icarus/include/.DS_Store","hash":"4d4dfa619c5514b2386ed877e28e673be438287b","modified":1674523813595},{"_id":"themes/icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1673879406470},{"_id":"themes/icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1673879406472},{"_id":"themes/icarus/.DS_Store","hash":"d1528e36eff411e83dfcbfd19998d12857757cbf","modified":1674523813597},{"_id":"themes/icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1673879406473},{"_id":"themes/icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1673879406471},{"_id":"themes/icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1673879406474},{"_id":"themes/icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1673879406474},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1673879406475},{"_id":"themes/icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1673879406474},{"_id":"themes/icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1673879406476},{"_id":"themes/icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1673879406477},{"_id":"themes/icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1673879406478},{"_id":"themes/icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1673879406477},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1673879406479},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1673879406479},{"_id":"themes/icarus/layout/archive.jsx","hash":"99bf235042d0c57af15d2f108ba5eda77443fea8","modified":1673879406424},{"_id":"themes/icarus/layout/.DS_Store","hash":"282592d5239b152794d0c05ad8384bd7de1b9dec","modified":1674355043735},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1673879406427},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1673879406427},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1673879406433},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1673879406440},{"_id":"themes/icarus/layout/layout.jsx","hash":"a7ba430119c32bcb39a85ec0f8fa2c199b38e4c4","modified":1673962797554},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1673879406391},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1673879406440},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1673879406432},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1673879406435},{"_id":"themes/icarus/source/.DS_Store","hash":"fa38fb826dec66318c0a571326ecc579c1e0e4d1","modified":1673962237963},{"_id":"themes/icarus/include/style/article.styl","hash":"377cca6ef15e2d9d4c606ed1bbbf01e19609850c","modified":1674524075402},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1673879406448},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1673879406449},{"_id":"themes/icarus/include/style/.DS_Store","hash":"fbb73f09cb23cc4503a979c5eb94e9f963eb9d90","modified":1674527147562},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"ec54dc24eb4d9802d8fefc44c210558bc1641109","modified":1673879406450},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1673879406449},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1673879406453},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1673919825476},{"_id":"themes/icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1673879406455},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1673879406454},{"_id":"themes/icarus/include/style/plugin.styl","hash":"084843d5a522029e0f84a4fe791fbcb2cabd4c36","modified":1673879406456},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1673879406457},{"_id":"themes/icarus/include/migration/head.js","hash":"7189efe33d18927d3790e8afb06642fb293b8603","modified":1673879406390},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1673879406457},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1673879406456},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1673879406466},{"_id":"themes/icarus/include/migration/v5_v5.1.js","hash":"073f22bd16e34b56f016633b1676dab2e7d8843d","modified":1673879406398},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1673879406467},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1673879406396},{"_id":"themes/icarus/include/schema/config.json","hash":"b949c52d02d5ee520ae4666a016ce91faf6fb350","modified":1673879406409},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1673879406387},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1673879406396},{"_id":"themes/icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1673879406397},{"_id":"themes/icarus/include/schema/.DS_Store","hash":"0c99a902830c52fa5cf73bb54a4028ce3da36077","modified":1674354250279},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1673879406428},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1673879406430},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1673879406433},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1673963514188},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1673879406435},{"_id":"themes/icarus/layout/common/article.jsx","hash":"efe38d9c10d6421f142407651b6230e257a57451","modified":1674357530930},{"_id":"themes/icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1673879406431},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"4816c9099a881b5f7b13af3e42caae36edbffccd","modified":1673879406438},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1673879406440},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1673879406439},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"45f869e8cab0eb00827164a927156a30e1d29bb7","modified":1673962836208},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1673879406422},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1673879406467},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1673879406426},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1673879406437},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1673879406452},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1673879406468},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1673879406469},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1673879406444},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1673879406452},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1673879406447},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1673879406469},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1673879406465},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1673879406380},{"_id":"themes/icarus/source/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1673879406378},{"_id":"themes/icarus/source/js/main.js","hash":"ef8a0e5c80dc9cb02423fe18b142e17f99f8e9cb","modified":1674356784330},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1673879406405},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1673879406379},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"f49270b619f5d2c3decde6b0b5a0c3bbab4b54a5","modified":1673879406407},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1673879406409},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1673879406410},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1673879406411},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1673879406411},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1673879406414},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1673879406417},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1673879406417},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1673879406419},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1673879406418},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1673879406419},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1673879406416},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1673879406401},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1673879406407},{"_id":"themes/icarus/source/img/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1673963549027},{"_id":"themes/icarus/source/img/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1673963549028},{"_id":"public/baidusitemap.xml","hash":"88616931c5ec416a0c9ff623ec1745f9941a1047","modified":1676088622961},{"_id":"public/atom.xml","hash":"7b715de78402544c7925cb23a4aeab5941e56960","modified":1676088622961},{"_id":"public/search.xml","hash":"918a278493cf0f66e6e1e894f61a307c9b0b2757","modified":1676088622961},{"_id":"public/sitemap.xml","hash":"d1a2ff9d6cd94dee359175b84ec6b5194249f14e","modified":1676088622961},{"_id":"public/sitemap.txt","hash":"febd107964d9a6bdec048b8d9f5d7025a68618d9","modified":1676088622961},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1676088622961},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1676088622961},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1676088622961},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1676088622961},{"_id":"public/content.json","hash":"552f8b35258ba3c340961aa13870d47a3b64a442","modified":1676088622961},{"_id":"public/manifest.json","hash":"4a4efab11b9e9d2f34509cad49a130e06418fb6f","modified":1676088622961},{"_id":"public/about/index.html","hash":"a7e007e19473525baac3aa2c7d6cfbf4473c9c99","modified":1676088622961},{"_id":"public/categories/index.html","hash":"bfe0a73c5820d0e443f536ef67db7647726a5541","modified":1676088622961},{"_id":"public/tags/index.html","hash":"9357d5b64144cc805b435bd6bed3f2e17b2bf342","modified":1676088622961},{"_id":"public/mysql-sequel-pro.html","hash":"da56ac06ab555c30cf4de0a198cc148f132b4b3b","modified":1676088622961},{"_id":"public/2023-happy-spring-festival.html","hash":"599b14a30f2ee81b5d73bba8f9e57685a9c8aed2","modified":1676088622961},{"_id":"public/archives/index.html","hash":"9090bad8d1181d5ebe2473b66e4d951a50059a58","modified":1676088622961},{"_id":"public/archives/page/2/index.html","hash":"78b5d44de8458a4a75b08eaaeae3e05e8376393d","modified":1676088622961},{"_id":"public/archives/page/3/index.html","hash":"1ad6790bcbbdc0d93c9206545140a65afa7181ef","modified":1676088622961},{"_id":"public/archives/2022/index.html","hash":"ea2622d721bb6e975a4dad0deac43d33c0fd85ea","modified":1676088622961},{"_id":"public/archives/2022/12/index.html","hash":"d962b497aad4a519e81b1f51a421a81459cb8f6e","modified":1676088622961},{"_id":"public/archives/2023/index.html","hash":"c9703b1b8e7c3675c00cb2b1aeaf914e678e68eb","modified":1676088622961},{"_id":"public/archives/2023/page/2/index.html","hash":"15190305c77902170a50cabccba9c94bc27e1378","modified":1676088622961},{"_id":"public/archives/2023/01/index.html","hash":"0253cc281a891f584aca65266f7a6a4fc348c1f4","modified":1676088622961},{"_id":"public/archives/2023/01/page/2/index.html","hash":"a1bb6202bb5ce85bcd262b14c39ebd7725dfda9f","modified":1676088622961},{"_id":"public/archives/2023/02/index.html","hash":"f369f9fbd3436a853b9c742b66fd8c4a128cb2d7","modified":1676088622961},{"_id":"public/categories/实习秋招/index.html","hash":"7980bf97e0998e716c237000b1782f0845488b12","modified":1676088622961},{"_id":"public/categories/Java八股文/page/2/index.html","hash":"7414466f5612ce140755ce7d69545c797098a560","modified":1676088622961},{"_id":"public/categories/实习秋招/实习/index.html","hash":"27635707db96bd7130ca4a01c908d34d5a224517","modified":1676088622961},{"_id":"public/categories/实习秋招/秋招/index.html","hash":"29b3fbae1b918ed1cd5b63bfcd180ed885a81bea","modified":1676088622961},{"_id":"public/categories/Mac开发环境配置/index.html","hash":"8be9ea8ed63795ace9c9f91d6db4fd1ad1836317","modified":1676088622961},{"_id":"public/categories/技术总结/index.html","hash":"52eecbd9d87fbc66f2de401fc18fa38c0c0b57db","modified":1676088622961},{"_id":"public/categories/个人思考/index.html","hash":"1635799e0e172332968b316f5d5f9fba92ccd79b","modified":1676088622961},{"_id":"public/categories/算法/index.html","hash":"62f416dc5006a45b3060701f54fb103525ffee9c","modified":1676088622961},{"_id":"public/about-within-the-system.html","hash":"0c4a27e9e85dba83cd0c8a44d9a297a3cc70dbb0","modified":1676088622961},{"_id":"public/linux.html","hash":"d0e717a93e2f22742844806eb3c62c8be28709b1","modified":1676088622961},{"_id":"public/algorithm-sort.html","hash":"d83e0db5fe106f9f2c6cedbf8b63b37b350862eb","modified":1676088622961},{"_id":"public/computer-network.html","hash":"1181a5da5aad423a00f1d45de08f28afb843d8b7","modified":1676088622961},{"_id":"public/Redis.html","hash":"71c302f7c65d62e66919cd03c3d21667880d179e","modified":1676088622961},{"_id":"public/mysql.html","hash":"cff47c34cd9c4bc910c6384d640d149311704b20","modified":1676088622961},{"_id":"public/java-springmvc.html","hash":"7004bda4efce546cfaf079c01b778af9c2499581","modified":1676088622961},{"_id":"public/java-spring.html","hash":"c4e5ba0f731bbe44df33dc8fcafa1617944ec7d1","modified":1676088622961},{"_id":"public/java-collection.html","hash":"8ecea6bc11e4ca325912c5629d87a1a166accd64","modified":1676088622961},{"_id":"public/java-mybatis.html","hash":"d512f9d3f567599d4d774889ade5ed3314d1dc80","modified":1676088622961},{"_id":"public/java-exception-error.html","hash":"547435dfea33ac88ac0793b522690baae6984b94","modified":1676088622961},{"_id":"public/java-basic-knowledge.html","hash":"a69877b04e11ba639c6907aaa90e8d37b85f02ba","modified":1676088622961},{"_id":"public/java-concurrent-programming.html","hash":"d68f9852c4767843e2951b137e7664b1a3ca5272","modified":1676088622961},{"_id":"public/202301-it-info.html","hash":"0c41ab4089a34760fc12a23b2cbc82e5b09574ac","modified":1676088622961},{"_id":"public/2022-memory.html","hash":"63a508001e51bf5229f1dc97df29b9f700e4ae90","modified":1676088622961},{"_id":"public/week-back-home.html","hash":"2ea2cb3b0f97d4f7675bb009fb72e4f0430e7301","modified":1676088622961},{"_id":"public/2022-jiangsu-gwy.html","hash":"2079dccd25aa102423d736407b0a112baa64ea32","modified":1676088622961},{"_id":"public/bilibili-vip.html","hash":"4fce115b469da0c99964a9bd513d30e2714cc517","modified":1676088622961},{"_id":"public/new-desk.html","hash":"2b6720484c6e19f8534db8d61b43f59a04865b00","modified":1676088622961},{"_id":"public/my-bytedance-internship-friends-offer.html","hash":"3aabea8ea11de27c9ea70f412cc1ab1096c4eeb2","modified":1676088622961},{"_id":"public/image-host.html","hash":"c882703a1f2f683e399fa3eff67c26fab5d0ec6d","modified":1676088622961},{"_id":"public/build-blog.html","hash":"182237959688187c68693acad6612fd57c4f8c7b","modified":1676088622961},{"_id":"public/2022-autumn-recruitment-summary.html","hash":"bfb00a75ad6762905d2c0c62f9021dc7d2931257","modified":1676088622961},{"_id":"public/2022-internship-summary.html","hash":"c92fb1ed7f25862751085052d0c121898a2a8ca4","modified":1676088622961},{"_id":"public/categories/日常小记/index.html","hash":"1e2f8ca45f61f4d399ce8bd5f378be19d90ec293","modified":1676088622961},{"_id":"public/categories/Java八股文/index.html","hash":"c8f94c901ccb083580135fc04bba84395193cc0a","modified":1676088622961},{"_id":"public/index.html","hash":"1c006e719235c49d63f7ecfc063c55b87ebf8d59","modified":1676088622961},{"_id":"public/page/2/index.html","hash":"34823ccc614dfd13b810e51dbaeb5c4f51c90d6b","modified":1676088622961},{"_id":"public/page/3/index.html","hash":"690bd8da7b2621192a18a9545d5fe5accd1db2bb","modified":1676088622961},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1676088622961},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1676088622961},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1676088622961},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1676088622961},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1676088622961},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1676088622961},{"_id":"public/imgs/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1676088622961},{"_id":"public/imgs/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1676088622961},{"_id":"public/img/alipay.jpg","hash":"581c5ac9226be5f2e061f385780f39bc52850b47","modified":1676088622961},{"_id":"public/img/wechat.jpg","hash":"28ad8a9883ec29a49d52aeb9d8792493f56e760a","modified":1676088622961},{"_id":"public/js/animation.js","hash":"0a8e361c353daa3194f4de3d646b96025d128e1a","modified":1676088622961},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1676088622961},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1676088622961},{"_id":"public/js/main.js","hash":"ef8a0e5c80dc9cb02423fe18b142e17f99f8e9cb","modified":1676088622961},{"_id":"public/css/default.css","hash":"2f1553e3ea465f4eb742bf909c31715fdcfd2c36","modified":1676088622961},{"_id":"public/css/cyberpunk.css","hash":"42a4c9d154e2d26cfe971d56d682303d77f232a3","modified":1676088622961},{"_id":"public/css/style.css","hash":"2f1553e3ea465f4eb742bf909c31715fdcfd2c36","modified":1676088622961}],"Category":[{"name":"日常小记","_id":"cldzfw31t0004t9t86fxx7k2s"},{"name":"实习秋招","_id":"cldzfw31x0009t9t8h8hbd442"},{"name":"Java八股文","_id":"cldzfw321000gt9t82r04hnto"},{"name":"实习","parent":"cldzfw31x0009t9t8h8hbd442","_id":"cldzfw326000st9t82jv6cdlu"},{"name":"秋招","parent":"cldzfw31x0009t9t8h8hbd442","_id":"cldzfw32a0017t9t80iblfx7j"},{"name":"Mac开发环境配置","_id":"cldzfw32c001jt9t85v626a5j"},{"name":"技术总结","_id":"cldzfw32d001mt9t886rm9wo5"},{"name":"个人思考","_id":"cldzfw32d001pt9t88wpifyz5"},{"name":"算法","_id":"cldzfw32d001vt9t8h6hj1xu8"}],"Data":[],"Page":[{"_content":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n🔭 本科：苏州大学纳米科学与技术学院，半导体器件方向；硕士：苏州大学计算机科学与技术学院，计算机技术。\n\n🌱 在字节跳动飞书后端开发实习过 4 个月，秋招拿到了字节跳动、上海银行、苏州农行、高中信息老师等 offer。\n\n⚡ 编程语言熟悉 Java、Python，数据库熟悉 MySQL、Redis，框架熟悉 Spring 全家桶，常用工具熟悉 Git、Maven、Linux 等。\n\n❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 yaxingfang@163.com ～\n","source":"about/index.md","raw":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n🔭 本科：苏州大学纳米科学与技术学院，半导体器件方向；硕士：苏州大学计算机科学与技术学院，计算机技术。\n\n🌱 在字节跳动飞书后端开发实习过 4 个月，秋招拿到了字节跳动、上海银行、苏州农行、高中信息老师等 offer。\n\n⚡ 编程语言熟悉 Java、Python，数据库熟悉 MySQL、Redis，框架熟悉 Spring 全家桶，常用工具熟悉 Git、Maven、Linux 等。\n\n❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 yaxingfang@163.com ～\n","date":"2023-02-08T07:22:20.103Z","updated":"2023-02-08T07:22:20.099Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cldzfw31m0000t9t8cf6f6az3","content":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n<p>🔭 本科：苏州大学纳米科学与技术学院，半导体器件方向；硕士：苏州大学计算机科学与技术学院，计算机技术。</p>\n<p>🌱 在字节跳动飞书后端开发实习过 4 个月，秋招拿到了字节跳动、上海银行、苏州农行、高中信息老师等 offer。</p>\n<p>⚡ 编程语言熟悉 Java、Python，数据库熟悉 MySQL、Redis，框架熟悉 Spring 全家桶，常用工具熟悉 Git、Maven、Linux 等。</p>\n<p>❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 <a href=\"mailto:&#121;&#x61;&#x78;&#105;&#110;&#x67;&#102;&#x61;&#x6e;&#103;&#x40;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;\">&#121;&#x61;&#x78;&#105;&#110;&#x67;&#102;&#x61;&#x6e;&#103;&#x40;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a> ～</p>\n","site":{"data":{}},"length":312,"excerpt":"","more":"<div align=\"center\">\n<img src=\"https://rishavanand.github.io/static/images/greetings.gif\" align=\"center\" style=\"width: 100%\" />\n</div>  \n\n<p>🔭 本科：苏州大学纳米科学与技术学院，半导体器件方向；硕士：苏州大学计算机科学与技术学院，计算机技术。</p>\n<p>🌱 在字节跳动飞书后端开发实习过 4 个月，秋招拿到了字节跳动、上海银行、苏州农行、高中信息老师等 offer。</p>\n<p>⚡ 编程语言熟悉 Java、Python，数据库熟悉 MySQL、Redis，框架熟悉 Spring 全家桶，常用工具熟悉 Git、Maven、Linux 等。</p>\n<p>❓ 欢迎交流计算机考研、实习、秋招、编程、互联网等问题，我的邮箱 <a href=\"mailto:&#121;&#x61;&#x78;&#105;&#110;&#x67;&#102;&#x61;&#x6e;&#103;&#x40;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;\">&#121;&#x61;&#x78;&#105;&#110;&#x67;&#102;&#x61;&#x6e;&#103;&#x40;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a> ～</p>\n"},{"title":"Categories","type":"categories","date":"2022-12-12T02:27:11.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ntype: \"categories\"\ndate: 2022-12-12 10:27:11\n---\n","updated":"2023-01-17T04:29:14.157Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cldzfw31s0002t9t8294ufsxs","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n\n","date":"2023-01-17T05:03:50.281Z","updated":"2023-01-17T05:03:50.273Z","path":"tags/index.html","comments":1,"_id":"cldzfw31v0005t9t83y0gagvc","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"12张图回忆我的2022","copyright":true,"mathjax":true,"date":"2023-01-01T12:59:55.000Z","urlname":"2022-memory","_content":"\n2022 年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的 2022 留个回忆。\n\n<!--more-->\n\n### 1月\n\n这张照片我记得是一月份的某一天，和 lbh 去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。\n\n![1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG)\n\n### 2月\n\n2 月的第一天就是大年初一过新年，早上早起在家门口放爆竹。\n\n![2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg)\n\n### 3月\n\n3 月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。\n\n![3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG)\n\n### 4月\n\n4 月收到字节跳动的实习 offer 啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。\n\n![4](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg)\n\n### 5月\n\n5 月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。\n\n![2205](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg)\n\n### 6月\n\n这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。\n\n![6](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG)\n\n### 7月\n\n7 月和高中老同学一起约了个饭，逛了逛西湖，7 月的荷花开的很茂盛，西湖旁全是人。\n\n![7](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG)\n\n### 8月\n\n8 月离职前瞅了一眼代码量，如下是 4 个月的成果，感觉还可以，没有很水。\n\n![8](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg)\n\n### 9月\n\n9 月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。\n\n![9](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG)\n\n### 10月\n\n10 月去参加了表弟的婚礼，4 个伴郎+新郎的自拍，小帅。\n\n![10](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG)\n\n### 11月\n\n宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。\n\n![11](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG)\n\n### 12月\n\n回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。\n\n![12](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg)\n","source":"_posts/12张图回忆我的2022.md","raw":"---\ntitle: 12张图回忆我的2022\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2023-01-01 20:59:55\nurlname: 2022-memory\n---\n\n2022 年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的 2022 留个回忆。\n\n<!--more-->\n\n### 1月\n\n这张照片我记得是一月份的某一天，和 lbh 去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。\n\n![1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG)\n\n### 2月\n\n2 月的第一天就是大年初一过新年，早上早起在家门口放爆竹。\n\n![2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg)\n\n### 3月\n\n3 月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。\n\n![3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG)\n\n### 4月\n\n4 月收到字节跳动的实习 offer 啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。\n\n![4](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg)\n\n### 5月\n\n5 月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。\n\n![2205](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg)\n\n### 6月\n\n这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。\n\n![6](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG)\n\n### 7月\n\n7 月和高中老同学一起约了个饭，逛了逛西湖，7 月的荷花开的很茂盛，西湖旁全是人。\n\n![7](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG)\n\n### 8月\n\n8 月离职前瞅了一眼代码量，如下是 4 个月的成果，感觉还可以，没有很水。\n\n![8](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg)\n\n### 9月\n\n9 月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。\n\n![9](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG)\n\n### 10月\n\n10 月去参加了表弟的婚礼，4 个伴郎+新郎的自拍，小帅。\n\n![10](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG)\n\n### 11月\n\n宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。\n\n![11](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG)\n\n### 12月\n\n回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。\n\n![12](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg)\n","slug":"12张图回忆我的2022","published":1,"updated":"2023-01-26T12:35:58.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31p0001t9t8bfgybk9z","content":"<p>2022 年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的 2022 留个回忆。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"1月\"><a href=\"#1月\" class=\"headerlink\" title=\"1月\"></a>1月</h3><p>这张照片我记得是一月份的某一天，和 lbh 去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG\" alt=\"1\"></p>\n<h3 id=\"2月\"><a href=\"#2月\" class=\"headerlink\" title=\"2月\"></a>2月</h3><p>2 月的第一天就是大年初一过新年，早上早起在家门口放爆竹。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h3 id=\"3月\"><a href=\"#3月\" class=\"headerlink\" title=\"3月\"></a>3月</h3><p>3 月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG\" alt=\"3\"></p>\n<h3 id=\"4月\"><a href=\"#4月\" class=\"headerlink\" title=\"4月\"></a>4月</h3><p>4 月收到字节跳动的实习 offer 啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg\" alt=\"4\"></p>\n<h3 id=\"5月\"><a href=\"#5月\" class=\"headerlink\" title=\"5月\"></a>5月</h3><p>5 月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg\" alt=\"2205\"></p>\n<h3 id=\"6月\"><a href=\"#6月\" class=\"headerlink\" title=\"6月\"></a>6月</h3><p>这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG\" alt=\"6\"></p>\n<h3 id=\"7月\"><a href=\"#7月\" class=\"headerlink\" title=\"7月\"></a>7月</h3><p>7 月和高中老同学一起约了个饭，逛了逛西湖，7 月的荷花开的很茂盛，西湖旁全是人。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG\" alt=\"7\"></p>\n<h3 id=\"8月\"><a href=\"#8月\" class=\"headerlink\" title=\"8月\"></a>8月</h3><p>8 月离职前瞅了一眼代码量，如下是 4 个月的成果，感觉还可以，没有很水。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg\" alt=\"8\"></p>\n<h3 id=\"9月\"><a href=\"#9月\" class=\"headerlink\" title=\"9月\"></a>9月</h3><p>9 月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG\" alt=\"9\"></p>\n<h3 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h3><p>10 月去参加了表弟的婚礼，4 个伴郎+新郎的自拍，小帅。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG\" alt=\"10\"></p>\n<h3 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h3><p>宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG\" alt=\"11\"></p>\n<h3 id=\"12月\"><a href=\"#12月\" class=\"headerlink\" title=\"12月\"></a>12月</h3><p>回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg\" alt=\"12\"></p>\n","site":{"data":{}},"length":530,"excerpt":"<p>2022 年转瞬即逝，我从手机相册中每个月分别挑出一张照片，在此给我的 2022 留个回忆。</p>","more":"<h3 id=\"1月\"><a href=\"#1月\" class=\"headerlink\" title=\"1月\"></a>1月</h3><p>这张照片我记得是一月份的某一天，和 lbh 去学校南门吃完晚饭回学校拍的，记得晚饭吃的还是“西安调调”，臊子面吃的很过瘾。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/1.JPG\" alt=\"1\"></p>\n<h3 id=\"2月\"><a href=\"#2月\" class=\"headerlink\" title=\"2月\"></a>2月</h3><p>2 月的第一天就是大年初一过新年，早上早起在家门口放爆竹。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2.jpg\" alt=\"2\"></p>\n<h3 id=\"3月\"><a href=\"#3月\" class=\"headerlink\" title=\"3月\"></a>3月</h3><p>3 月基本就是在家刷题、背八股，投递实习，实习面试。每天早上煮两个白煮蛋吃。这是某天觉得自己煮的好看又好吃遂记录下。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/3.JPG\" alt=\"3\"></p>\n<h3 id=\"4月\"><a href=\"#4月\" class=\"headerlink\" title=\"4月\"></a>4月</h3><p>4 月收到字节跳动的实习 offer 啦，月底正式入职，收到寄来的电脑，疫情原因居家办公了几周。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/4.jpg\" alt=\"4\"></p>\n<h3 id=\"5月\"><a href=\"#5月\" class=\"headerlink\" title=\"5月\"></a>5月</h3><p>5 月到杭州线下实习啦，中间有朋友来玩，一起去的西湖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/2205.jpg\" alt=\"2205\"></p>\n<h3 id=\"6月\"><a href=\"#6月\" class=\"headerlink\" title=\"6月\"></a>6月</h3><p>这是公司旁边一栋设计院的楼，当时貌似是周五晚上，提前溜，当时觉得配上湛蓝的天空很好看。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/6.JPG\" alt=\"6\"></p>\n<h3 id=\"7月\"><a href=\"#7月\" class=\"headerlink\" title=\"7月\"></a>7月</h3><p>7 月和高中老同学一起约了个饭，逛了逛西湖，7 月的荷花开的很茂盛，西湖旁全是人。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/7.JPG\" alt=\"7\"></p>\n<h3 id=\"8月\"><a href=\"#8月\" class=\"headerlink\" title=\"8月\"></a>8月</h3><p>8 月离职前瞅了一眼代码量，如下是 4 个月的成果，感觉还可以，没有很水。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/8.jpg\" alt=\"8\"></p>\n<h3 id=\"9月\"><a href=\"#9月\" class=\"headerlink\" title=\"9月\"></a>9月</h3><p>9 月回校还是比较闲的，基本就是看看网课，做笔试、面试。下图和朋友出去吃饭逛街，看中了一件外套。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/9.JPG\" alt=\"9\"></p>\n<h3 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h3><p>10 月去参加了表弟的婚礼，4 个伴郎+新郎的自拍，小帅。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/10.JPG\" alt=\"10\"></p>\n<h3 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h3><p>宿舍师弟过生日一起去海底捞干饭，头一回体验下海底捞的免费手部护理。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/11.JPG\" alt=\"11\"></p>\n<h3 id=\"12月\"><a href=\"#12月\" class=\"headerlink\" title=\"12月\"></a>12月</h3><p>回老家过生日大姨妈给买的蛋糕，哈哈哈，快乐。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/12.jpg\" alt=\"12\"></p>"},{"title":"2022实习总结","date":"2022-12-12T02:40:27.000Z","urlname":"2022-internship-summary","description":null,"copyright":true,"mathjax":true,"_content":"\n> 写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，\"毕业季\"，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。\n\n<!-- more -->\n\n## 已面试\n\n### 微软\n\n3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 \n\n* 微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。\n* 尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。\n\n### 美团\n\n3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂\n\n面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。\n\n### 字节\n\n3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer 审批 →  4.11 offer 邮件\n\n* 字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。\n* 流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。\n* 综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。\n\n### 携程\n\n3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）\n\n携程一面问的比较基础，算法也比较简单。\n\n### 阿里\n\n3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试\n\n阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。\n更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题\n\n\n### 恒生\n\n3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话\n\n问的偏业务，貌似一面过了，拿了字节 offer 就拒了。\n\n## 已笔试\n\n* 360 3.19 笔试（1.9 / 2） \n\n* 贝壳 3.21 笔试（1.6 / 3）\n\n* 网易雷火 3.26 笔试（1.5 / 2）\n\n* 网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多 AK 的同学被笔试挂的，挺迷）\n\n* 便利蜂 3.31 笔试（惨）\n\n* 京东 4.2 笔试（0.7 / 2）\n\n* 百度 4.12 笔试 终止流程\n\n## 已投递简历挂\n\nOPPO、网易互娱\n\n## 已投递无后续\n\n顺丰、58 同城、联想、趋势科技\n","source":"_posts/2022实习总结.md","raw":"---\ntitle: 2022实习总结\ndate: 2022-12-12 10:40:27\ncategories: \n  - 实习秋招\n  - 实习\ntags: \nurlname: 2022-internship-summary\ndescription: \ncopyright: true\nmathjax: true\n---\n\n> 写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，\"毕业季\"，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。\n\n<!-- more -->\n\n## 已面试\n\n### 微软\n\n3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 \n\n* 微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。\n* 尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。\n\n### 美团\n\n3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂\n\n面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。\n\n### 字节\n\n3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer 审批 →  4.11 offer 邮件\n\n* 字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。\n* 流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。\n* 综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。\n\n### 携程\n\n3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）\n\n携程一面问的比较基础，算法也比较简单。\n\n### 阿里\n\n3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试\n\n阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。\n更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题\n\n\n### 恒生\n\n3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话\n\n问的偏业务，貌似一面过了，拿了字节 offer 就拒了。\n\n## 已笔试\n\n* 360 3.19 笔试（1.9 / 2） \n\n* 贝壳 3.21 笔试（1.6 / 3）\n\n* 网易雷火 3.26 笔试（1.5 / 2）\n\n* 网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多 AK 的同学被笔试挂的，挺迷）\n\n* 便利蜂 3.31 笔试（惨）\n\n* 京东 4.2 笔试（0.7 / 2）\n\n* 百度 4.12 笔试 终止流程\n\n## 已投递简历挂\n\nOPPO、网易互娱\n\n## 已投递无后续\n\n顺丰、58 同城、联想、趋势科技\n","slug":"2022实习总结","published":1,"updated":"2023-01-26T12:35:58.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31s0003t9t865h262z4","content":"<blockquote>\n<p>写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，”毕业季”，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"已面试\"><a href=\"#已面试\" class=\"headerlink\" title=\"已面试\"></a>已面试</h2><h3 id=\"微软\"><a href=\"#微软\" class=\"headerlink\" title=\"微软\"></a>微软</h3><p>3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 </p>\n<ul>\n<li>微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。</li>\n<li>尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。</li>\n</ul>\n<h3 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h3><p>3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂</p>\n<p>面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。</p>\n<h3 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h3><p>3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer 审批 →  4.11 offer 邮件</p>\n<ul>\n<li>字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。</li>\n<li>流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。</li>\n<li>综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。</li>\n</ul>\n<h3 id=\"携程\"><a href=\"#携程\" class=\"headerlink\" title=\"携程\"></a>携程</h3><p>3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）</p>\n<p>携程一面问的比较基础，算法也比较简单。</p>\n<h3 id=\"阿里\"><a href=\"#阿里\" class=\"headerlink\" title=\"阿里\"></a>阿里</h3><p>3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试</p>\n<p>阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。<br>更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题</p>\n<h3 id=\"恒生\"><a href=\"#恒生\" class=\"headerlink\" title=\"恒生\"></a>恒生</h3><p>3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话</p>\n<p>问的偏业务，貌似一面过了，拿了字节 offer 就拒了。</p>\n<h2 id=\"已笔试\"><a href=\"#已笔试\" class=\"headerlink\" title=\"已笔试\"></a>已笔试</h2><ul>\n<li><p>360 3.19 笔试（1.9 / 2） </p>\n</li>\n<li><p>贝壳 3.21 笔试（1.6 / 3）</p>\n</li>\n<li><p>网易雷火 3.26 笔试（1.5 / 2）</p>\n</li>\n<li><p>网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多 AK 的同学被笔试挂的，挺迷）</p>\n</li>\n<li><p>便利蜂 3.31 笔试（惨）</p>\n</li>\n<li><p>京东 4.2 笔试（0.7 / 2）</p>\n</li>\n<li><p>百度 4.12 笔试 终止流程</p>\n</li>\n</ul>\n<h2 id=\"已投递简历挂\"><a href=\"#已投递简历挂\" class=\"headerlink\" title=\"已投递简历挂\"></a>已投递简历挂</h2><p>OPPO、网易互娱</p>\n<h2 id=\"已投递无后续\"><a href=\"#已投递无后续\" class=\"headerlink\" title=\"已投递无后续\"></a>已投递无后续</h2><p>顺丰、58 同城、联想、趋势科技</p>\n","site":{"data":{}},"length":1022,"excerpt":"<blockquote>\n<p>写在前面：作为一名硕转码的选手，今年暑期实习貌似又格外的难，身边的朋友、脉脉、牛客上的同学都表示今年大环境很差，实习很难找。各个大厂从裁员，”毕业季”，到锁 hc、停止流程、甚至主动毁约已签的 offer，无不表现出今年大环境有多差。以下是本人二月底以来找后端开发岗的暑期实习对各个公司面试流程一个大概的回顾和总结。</p>\n</blockquote>","more":"<h2 id=\"已面试\"><a href=\"#已面试\" class=\"headerlink\" title=\"已面试\"></a>已面试</h2><h3 id=\"微软\"><a href=\"#微软\" class=\"headerlink\" title=\"微软\"></a>微软</h3><p>3.7 一面 →  3.10 （一二面平行面，一面过直达终面） → 3.16 挂 </p>\n<ul>\n<li>微软很看重算法，全程无八股，做题时没有思路可以和面试官沟通，不要自己一个人硬想，微软很看重沟通能力。</li>\n<li>尽量早投，微软今年暑期实习提前批差不多去年 12 月就开始了，身边有朋友提前批进的，相较于正式批而言难度感觉也没有更大，而且其实到了正式批剩余的 hc 就不多了。有朋友投简历有点晚连面试都没有安排到。</li>\n</ul>\n<h3 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h3><p>3.12 笔试（3.18 / 5） →  3.18 一面 →  3.18 挂</p>\n<p>面试体验很不好（当然自己面的也不好），后续脉脉牛客上看到这个部门貌似一面挂了不少人不乏顶级 985。</p>\n<h3 id=\"字节\"><a href=\"#字节\" class=\"headerlink\" title=\"字节\"></a>字节</h3><p>3.22 一面 →  3.23 二面 →  3.29 三面 →  4.2 offer 审批 →  4.11 offer 邮件</p>\n<ul>\n<li>字节比较看重基础和算法，题至少要有思路和面试官沟通，最好做出来。</li>\n<li>流程很快，一面二面都是当天晚上直接通知通过，三面过后好几天等到 HR 电话，然后 offer 审批跨了清明节，然后又过了一个周末，蛮痛苦的。</li>\n<li>综合而言，字节的面试体验很好，面试官会引导你去说，包括一些八股、场景题。</li>\n</ul>\n<h3 id=\"携程\"><a href=\"#携程\" class=\"headerlink\" title=\"携程\"></a>携程</h3><p>3.24 笔试（2.7 / 4） →  3.31 一面 →  4.13 约了二面（躺平不面了）</p>\n<p>携程一面问的比较基础，算法也比较简单。</p>\n<h3 id=\"阿里\"><a href=\"#阿里\" class=\"headerlink\" title=\"阿里\"></a>阿里</h3><p>3.24 初面 →  3.25 笔试（惨） →  4.7 二面 →  4.11 补笔试</p>\n<p>阿里一面看基础，二面看项目，项目不太熟悉了，被拷打烂了。<br>更新：4.11 晚上临时约做题，两道，一道多线程打印数据问题、一道高并发转账接口设计问题</p>\n<h3 id=\"恒生\"><a href=\"#恒生\" class=\"headerlink\" title=\"恒生\"></a>恒生</h3><p>3.31 笔试（无难度） → 4.6 一面 → 4.11 查看 已结束 → 4.12 HR 电话</p>\n<p>问的偏业务，貌似一面过了，拿了字节 offer 就拒了。</p>\n<h2 id=\"已笔试\"><a href=\"#已笔试\" class=\"headerlink\" title=\"已笔试\"></a>已笔试</h2><ul>\n<li><p>360 3.19 笔试（1.9 / 2） </p>\n</li>\n<li><p>贝壳 3.21 笔试（1.6 / 3）</p>\n</li>\n<li><p>网易雷火 3.26 笔试（1.5 / 2）</p>\n</li>\n<li><p>网易互联网 3.27 笔试（AK） → 4.2 查看 笔试未通过（今年貌似很多 AK 的同学被笔试挂的，挺迷）</p>\n</li>\n<li><p>便利蜂 3.31 笔试（惨）</p>\n</li>\n<li><p>京东 4.2 笔试（0.7 / 2）</p>\n</li>\n<li><p>百度 4.12 笔试 终止流程</p>\n</li>\n</ul>\n<h2 id=\"已投递简历挂\"><a href=\"#已投递简历挂\" class=\"headerlink\" title=\"已投递简历挂\"></a>已投递简历挂</h2><p>OPPO、网易互娱</p>\n<h2 id=\"已投递无后续\"><a href=\"#已投递无后续\" class=\"headerlink\" title=\"已投递无后续\"></a>已投递无后续</h2><p>顺丰、58 同城、联想、趋势科技</p>"},{"title":"2022秋招总结","date":"2022-12-12T03:57:22.000Z","urlname":"2022-autumn-recruitment-summary","copyright":true,"mathjax":true,"_content":"\n19 年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。\n\n研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。\n\n从 12 月到 2 月，断断续续复习 Java 后端开发所需的知识。\n\n从 2 月底找实习，4 月底入职字节跳动，8 月底离职返校，直到 11 月底（11.27）正式签订三方，过程坎坷，内心惆怅。\n\n秋招投了约 50 家公司，都是 Java 后端，主要有以下：\n\n<!--more-->\n\n蚂蚁，二面挂\n\n中移苏研，第二批次，面试走完，没有收到体检\n\n浙商银行，面试走完，没有材料审核\n\n山石网科，hr 面挂\n\n荣耀，面试走完，口头谈薪\n\n上海银行，总行苏州 base，收到 offer\n\n苏州农行，收到体检\n\n字节跳动，转正 offer，sp\n\n总体而言，今年强的人还是能拿到多个大厂 offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的 offer）。\n\n关于 offer 选择，最终是考虑字节跳动 base 杭州，还有一个江苏省某地级市 top1 高中的信息技术老师（进编）的 offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。\n\n未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。\n\n不管什么 offer 选择，有得必定有失，十全十美的工作几乎没有。所以在进行 offer 选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。\n\n做出选择就好好冲吧，未来可期。大家都有光明的未来！\n","source":"_posts/2022秋招总结.md","raw":"---\ntitle: 2022秋招总结\ndate: 2022-12-12 11:57:22\ncategories: \n  - 实习秋招\n  - 秋招\ntags: \nurlname: 2022-autumn-recruitment-summary\ncopyright: true\nmathjax: true\n---\n\n19 年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。\n\n研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。\n\n从 12 月到 2 月，断断续续复习 Java 后端开发所需的知识。\n\n从 2 月底找实习，4 月底入职字节跳动，8 月底离职返校，直到 11 月底（11.27）正式签订三方，过程坎坷，内心惆怅。\n\n秋招投了约 50 家公司，都是 Java 后端，主要有以下：\n\n<!--more-->\n\n蚂蚁，二面挂\n\n中移苏研，第二批次，面试走完，没有收到体检\n\n浙商银行，面试走完，没有材料审核\n\n山石网科，hr 面挂\n\n荣耀，面试走完，口头谈薪\n\n上海银行，总行苏州 base，收到 offer\n\n苏州农行，收到体检\n\n字节跳动，转正 offer，sp\n\n总体而言，今年强的人还是能拿到多个大厂 offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的 offer）。\n\n关于 offer 选择，最终是考虑字节跳动 base 杭州，还有一个江苏省某地级市 top1 高中的信息技术老师（进编）的 offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。\n\n未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。\n\n不管什么 offer 选择，有得必定有失，十全十美的工作几乎没有。所以在进行 offer 选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。\n\n做出选择就好好冲吧，未来可期。大家都有光明的未来！\n","slug":"2022秋招总结","published":1,"updated":"2023-01-26T12:35:58.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31v0006t9t88c4za2p0","content":"<p>19 年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。</p>\n<p>研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。</p>\n<p>从 12 月到 2 月，断断续续复习 Java 后端开发所需的知识。</p>\n<p>从 2 月底找实习，4 月底入职字节跳动，8 月底离职返校，直到 11 月底（11.27）正式签订三方，过程坎坷，内心惆怅。</p>\n<p>秋招投了约 50 家公司，都是 Java 后端，主要有以下：</p>\n<span id=\"more\"></span>\n\n<p>蚂蚁，二面挂</p>\n<p>中移苏研，第二批次，面试走完，没有收到体检</p>\n<p>浙商银行，面试走完，没有材料审核</p>\n<p>山石网科，hr 面挂</p>\n<p>荣耀，面试走完，口头谈薪</p>\n<p>上海银行，总行苏州 base，收到 offer</p>\n<p>苏州农行，收到体检</p>\n<p>字节跳动，转正 offer，sp</p>\n<p>总体而言，今年强的人还是能拿到多个大厂 offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的 offer）。</p>\n<p>关于 offer 选择，最终是考虑字节跳动 base 杭州，还有一个江苏省某地级市 top1 高中的信息技术老师（进编）的 offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。</p>\n<p>未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。</p>\n<p>不管什么 offer 选择，有得必定有失，十全十美的工作几乎没有。所以在进行 offer 选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。</p>\n<p>做出选择就好好冲吧，未来可期。大家都有光明的未来！</p>\n","site":{"data":{}},"length":646,"excerpt":"<p>19 年乘着人见人吹的计算机大热，跨考计算机一站未果，二战上岸本校计算机。</p>\n<p>研二暑期留校科研，很幸运做出来两篇文章，接下来可以去实习了。</p>\n<p>从 12 月到 2 月，断断续续复习 Java 后端开发所需的知识。</p>\n<p>从 2 月底找实习，4 月底入职字节跳动，8 月底离职返校，直到 11 月底（11.27）正式签订三方，过程坎坷，内心惆怅。</p>\n<p>秋招投了约 50 家公司，都是 Java 后端，主要有以下：</p>","more":"<p>蚂蚁，二面挂</p>\n<p>中移苏研，第二批次，面试走完，没有收到体检</p>\n<p>浙商银行，面试走完，没有材料审核</p>\n<p>山石网科，hr 面挂</p>\n<p>荣耀，面试走完，口头谈薪</p>\n<p>上海银行，总行苏州 base，收到 offer</p>\n<p>苏州农行，收到体检</p>\n<p>字节跳动，转正 offer，sp</p>\n<p>总体而言，今年强的人还是能拿到多个大厂 offer，但是大厂门槛比年高了很多。在互联网颓势的今年，芯片、嵌入式成为香饽饽，薪资高、发展好，不少人甚至直呼赶紧转行（我有朋友在零基础情况下拿了五六家嵌入式中小厂的 offer）。</p>\n<p>关于 offer 选择，最终是考虑字节跳动 base 杭州，还有一个江苏省某地级市 top1 高中的信息技术老师（进编）的 offer。在考虑家庭情况、个人卷度承受度、稳定性，最终选择了做一名教师。</p>\n<p>未来的发展，大概率就是做一名普通的信息技术教师，有卷的心还有机会尝试加入学校带竞赛的队伍。</p>\n<p>不管什么 offer 选择，有得必定有失，十全十美的工作几乎没有。所以在进行 offer 选择时，如果没有明确的爱好想做的工作的话（比如我），那就好好综合考虑以上几点进行判断得出选择了。</p>\n<p>做出选择就好好冲吧，未来可期。大家都有光明的未来！</p>"},{"title":"Java八股文 - Java基础","copyright":true,"mathjax":false,"date":"2023-01-23T02:05:51.000Z","toc":true,"urlname":"java-basic-knowledge","_content":"\n> 整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java概述\n\n### JVM、JRE和JDK的关系\n\nJVM：Java Virtual Machine，Java 虚拟机，Java 程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此 Java 语言可以实现跨平台。\n\nJRE：Java Runtime Environment，Java 运行环境，包括 Java 虚拟机和 Java 程序所需的核心类库等。\n\nJDK：Java Development Kit，Java 开发工具包，包括了 JRE 和开发工具。\n\n### 什么是跨平台性？原理是什么\n\n所谓跨平台性，是指 Java 语言编写的程序，一次编译，到处运行。\n\n实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 Java 程序。\n\n### Java语言有哪些特点\n\n面向对象（封装，继承，多态）\n\n平台无关性（Java 虚拟机实现平台无关性）\n\n### 什么是字节码？采用字节码的最大好处是什么\n\n**字节码**：Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为.class 的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld 执行程序）\n\n**编译与解释并存**\n\nJava 源代码(.Java 文件)---->编译器---->jvm 可执行的 Java 字节码(.class 文件)---->jvm---->jvm 中解释器----->机器可执行的二进制机器码---->程序运行\n\n### 什么是Java程序的主类？\n\n一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main()方法的类。\n主类是 Java 程序执行的入口。（main 方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）\n\n### Java和C++的区别\n\n相同点：都是**面向对象**的语言，都支持**封装、继承和多态**\n\n不同点：\n\n- **Java不提供指针**来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存\n\n- Java 的**类是单继承**的，C++支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\n\n\t为什么 Java 中类不支持多继承？——多重继承的钻石问题\n\t\n\t![多重继承的钻石问题](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png)\n\t类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？\n\n- Java 有**自动内存管理**机制，不需要程序员手动释放无用内存\n\n## 基础语法\n\n### 数据类型\n\n**定义**：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。\n\n**分类**\n\n- 基本数据类型\n\t- 数值型\n\t\t- 整数类型(byte,short,int,long)\n\t\t- 浮点类型(float,double)\n\t- 字符型(char)\n\t- 布尔型(boolean)\n- 引用数据类型\n\t- 类(class)\n\t- 接口(interface)\n\t- 数组([])\n\n**Java基本数据类型图**\n\n![Java基本数据类型图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png)\n\n### 类型转换\n\n自动类型转换\n\n> 两种数据类型彼此兼容\n>\n> 低级类型数据转换成高级类型数据\n\n- 数值型数据的转换：byte→short→int→long→float→double\n- 字符型转换为整型：char→int。\n\n强制类型转换\n\n> 当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换\n\n### 访问修饰符\n\n![访问修饰符](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png)\n\n### 关键字\n\n#### final 有什么用？\n\n用于修饰类、方法和变量；\n\n- 被 final 修饰的类不可以被继承\n\n- 被 final 修饰的方法不可以被重写\n\n- 被 final 修饰的变量不可以被改变，被 final 修饰**不可变的是变量的引用，而不是引用指向的内容**，引用指向的内容是可以改变\n\n\t```java\n\tfinal int[] nums = new int[]{1, 2, 3};\n\tnums[0] = 11;\n\tSystem.out.println(Arrays.toString(nums));\t// [11, 2, 3]\n\t```\n\n#### final、finally、finalize区别\n\n- final 是 Java 修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。\n- finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码放在 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\n\n- finalize 是 Object 类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的 finalize()方法，并且在该方法中对象可能可以复活。\n\n#### this关键字的用法\n\n指向对象本身的一个指针。\n\n#### super关键字的用法\n\n指向自己父类对象（最近的父类）的一个指针。\n\n#### static存在的主要意义\n\nstatic**静态变量**：和类一起加载，**以致于即使没有创建对象，也能使用属性和调用方法。**\n\nstatic**静态代码块**：在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。\n加载 → 链接（验证、准备、解析） → 初始化\n\nstatic 类型的变量在准备阶段进行默认初始化，但是有 static final 修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。\n\n#### static注意事项\n\n1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。\n\n### 初始化顺序\n\n静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数\n\n### 流程控制语句\n\n#### break 、continue、return 的区别及作用\n\nbreak 结束当前的循环体\n\ncontinue 结束正在执行的循环，进入下一个循环条件\n\nreturn 结束当前的方法，直接返回\n\n#### 跳出当前的多重嵌套循环\n\n在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如：\n\n```java\npublic static void main(String[] args) {\n    ok:\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            System.out.println(\"i=\" + i + \",j=\" + j);\n            if (j == 5) {\n                break ok;\n            }\n        }\n    }\n}\n```\n\n## 面向对象\n\n### 面向对象三大特性\n\n#### 面向对象的特征有哪些方面\n\n**抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n\n**封装**\n\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。\n\n**继承**\n\n继承是**使用已存在的类作为基础建立新类**的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。\n\n关于继承如下 3 点请记住：\n\n1. 子类拥有父类非 private 的属性和方法。\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3. 子类可以用自己的方式实现父类的方法，override 重写。\n\n**多态**\n\n所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。\n\n父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。\n\n在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n\n方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。\n\nJava 实现多态有三个必要条件：继承、重写、向上转型。\n\n> 继承：在多态中必须存在有继承关系的子类和父类。\n>\n> 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n>\n> 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n\n#### 抽象类和接口的对比\n\n抽象类是对类的抽象，用来**捕捉通用特性**。接口是**行为的抽象**，抽象方法的集合。\n\n**相同点**\n\n- 接口和抽象类都不能实例化\n- 都位于继承的顶端，用于被其他类实现或继承\n- 都包含抽象方法，其子类都必须重写这些抽象方法\n\n**不同点**\n\n| 参数       | 抽象类                             | 接口                                             |\n| ---------- | ---------------------------------- | ------------------------------------------------ |\n| 声明       | 抽象类使用abstract关键字声明       | 接口使用interface关键字声明                      |\n| 实现       | 子类使用extends关键字来继承抽象类  | 子类使用implements关键字来实现接口               |\n| 构造器     | 抽象类可以有构造器                 | 接口不能有构造器                                 |\n| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public，也可以不加访问修饰符 |\n| 多继承     | 一个类最多只能继承一个抽象类       | 一个类可以实现多个接口                           |\n\n#### 普通类和抽象类有哪些区别？\n\n- 普通类不能包含抽象方法，抽象类可以包含抽象方法。\n- 抽象类不能直接实例化，普通类可以直接实例化。\n\n#### 成员变量和局部变量的区别\n\n|              | 成员变量               | 局部变量                                     |\n| ------------ | ---------------------- | -------------------------------------------- |\n| **作用域**   | 整个类可使用           | 方法体内使用                                 |\n| **存储位置** | 属于对象，存在堆内存中 | 属于方法，存在栈帧中                         |\n| **生命周期** | 和对象同生命周期       | 和方法同生命周期                             |\n| **初始值**   | 不指定的话有默认初始值 | 必须手动初始化否则<br />不能使用（编译错误） |\n\n**使用原则**\n\n在使用变量时需要遵循的原则为：就近原则\n首先在局部范围找，有就使用；接着在成员位置找。\n\n```java\npublic class Main {\n    int a = 2;\n    public static void main(String[] args) {\n        int a = 1;\n        System.out.println(a);\t// 1\n    }\n}\n```\n\n### 内部类\n\n#### 什么是内部类？\n\n在 Java 中，可以将一个类的定义放在另外一个类的定义内部，这就是**内部类**。\n\n#### 内部类的分类有哪些\n\n内部类可以分为四种：**静态内部类、成员内部类、局部内部类、匿名内部类**。\n\n##### 静态内部类\n\n定义在类内部的静态类，就是静态内部类。\n\n静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量\n\n##### 成员内部类\n\n定义在类内部，成员位置上的非静态类，就是成员内部类。\n\n成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。\n\n##### 局部内部类\n\n定义在方法中的内部类，就是局部内部类。\n\n定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法\n\n##### 匿名内部类\n\n匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法\n\n#### 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\n\n局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上 final 呢？它内部原理是什么呢？\n\n先看这段代码：\n\n```java\npublic class Outer {\n    void outMethod(){\n        final int a =10;\n        class Inner {\n            void innerMethod(){\n                System.out.println(a);\n            }\n        }\n    }\n}\n```\n\n以上例子，为什么要加 final 呢？是因为**生命周期不一致**\n\n局部变量存储在栈中，当方法执行结束后，如果不用 final 修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。\n加了 final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。\n\n### 重写与重载\n\n#### 构造器（constructor）是否可被重写（override）\n\n构造器不能被继承，因此不能被重写，但可以被重载。\n\n#### 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n\n方法的重载和重写都是实现多态的方式，区别在于重载实现的是**编译时的多态性**，而重写实现的是**运行时的多态性**。\n\n重载：发生在**同一个类**中，**方法名相同 参数列表不同**（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关\n\n重写：发生在**父子类**中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，**访问修饰符大于等于父类**（里氏代换原则）\n\n### 对象相等判断\n\n#### == 和 equals 的区别是什么\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。\n(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n情况 1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\n情况 2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n\n#### hashCode 与 equals\n\n**hashCode()介绍**\n\nhashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个 int 整数。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都有 hashCode()方法。\n\n**为什么要有 hashCode**\n\n**我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode**：\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的 hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。\n\n**hashCode()与equals()的相关规定**\n\n- 如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。\n- 如果两个对象的 hashCode 值相等并且 equals()方法也返回 true，我们才认为这两个对象相等。\n- 如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。\n\n#### 只重写 hashCode 可以吗？\n\n如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。\n\n> 两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n> 如果定义一个 set 里面存放 Person 对象，Person 只重写了 equals 方法即可以判断对象内容是否相同。\n>\n> 如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。\n>\n> 但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。\n\n### 值传递\n\n#### 为什么 Java 中只有值传递\n\nJava 采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。\n\nexample 1\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果**：\n\n```java\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析**：\n\n![swap(int a, int b)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png)\n\n在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为 a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\nexample 2\n\n```java\n    public static void main(String[] args) {\n        int[] arr = { 1, 2, 3, 4, 5 };\n        System.out.println(arr[0]);\n        change(arr);\n        System.out.println(arr[0]);\n    }\n\n    public static void change(int[] array) {\n        // 将数组的第一个元素变为0\n        array[0] = 0;\n    }\n```\n\n**结果**：\n\n```undefined\n1\n0\n```\n\n**解析**：\n\n![change(int[] array)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\nexample 3\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Student s1 = new Student(\"小张\");\n        Student s2 = new Student(\"小李\");\n        Test.swap(s1, s2);\n        System.out.println(\"s1:\" + s1.getName());\n        System.out.println(\"s2:\" + s2.getName());\n    }\n\n    public static void swap(Student x, Student y) {\n        Student temp = x;\n        x = y;\n        y = temp;\n        System.out.println(\"x:\" + x.getName());\n        System.out.println(\"y:\" + y.getName());\n    }\n}\n```\n\n**结果**：\n\n```undefined\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析**：\n\n交换之前：\n\n![before swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png)\n\n交换之后：\n\n![after swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png)\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n#### 值传递和引用传递有什么区别\n\n值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\n\n## IO流\n\n> 参考：https://blog.csdn.net/weixin_44579258/article/details/90758359\n\n阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待\n同步和异步是指访问数据的机制，同步一般主动请求等待 IO 操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待 IO 完毕通知，这可以使进程在数据读写时也不阻塞\n\n准备数据：网卡 → 内核\n数据就绪：数据拷贝到了内核\n拷贝数据：将内核数据拷贝到用户空间\n\n### Blocking I/O\n\n**BIO 属于同步阻塞 IO 模型** 。\n\n同步阻塞 IO 模型中，应用程序**发起 read 调用**后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。\n\n![BIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png)\n\n### NIO (Non-blocking I/O)\n\n同步非阻塞 IO 模型中，用户进程会**一直发起 read 调用**（如果内核返回 error 则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。\n\n> 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png)\n\n### IO多路复用（NIO）\n\nselect/epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png)\n\nIO 复用和同步阻塞本质一样，在 NIO 中，每次用户进程进行 read 轮询数据是否准备就绪，而在 IO 多路复用中，利用了新的 select 系统调用，由内核来负责本来是请求进程该做的轮询操作。\n\n当用户线程调用 select，那么整个进程会被阻塞，而同时，kernel 内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回可读条件让用户进程发起 read 调用，用户进程发起调用 read 操作，将数据从内核空间拷贝到用户空间。\n\n\n### Asynchronous I/O\n\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n用户发起 read 调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用 read 的进程，数据已经拷贝到用户空间了。\n\n![AIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png)\n\n## 反射\n\n### 什么是反射机制？\n\nJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n\n### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。\n\n### 反射机制的应用场景有哪些？\n\n①我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；\n\n②Spring 通过 XML 配置模式装载 Bean 的过程\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入\n\n### Java获取反射的三种方法\n\n1.通过 new 对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制\n\n## 包装类\n\n#### 自动装箱与拆箱\n\n**装箱**：将基本类型用它们对应的引用类型包装起来；`Integer a = 1;`\n\n**拆箱**：将包装类型转换为基本数据类型；`int b = a;`\n\n#### int 和 Integer 有什么区别\n\n引入包装类是为了能够将这些**基本数据类型当成对象操作**\n\nJava 为每个原始类型提供了包装类型：\n\n原始类型: boolean，char，byte，short，int，long，float，double\n\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n#### Integer a = 127 与 Integer b = 127相等吗\n\n> 包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，\n>\n> 只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。\n\n对于对象引用类型：==比较的是对象的内存地址。\n对于基本数据类型：==比较的是值。\n\n```java\npublic static void main(String[] args) {\n    Integer a = new Integer(3);\n  \tInteger b = 3;\n    int c = 3;\n    Integer d = 3;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // true，包装类自动装箱且数值范围在cache范围内\n\n    Integer a = new Integer(128);\n    Integer b = 128;\n    int c = 128;\n    Integer d = 128;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // false，包装类自动装箱但是数值范围不在cache范围内\n}\n```\n\n","source":"_posts/Java八股文 - Java基础.md","raw":"---\ntitle: Java八股文 - Java基础\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 10:05:51\ntags:\ntoc: true\nurlname: java-basic-knowledge\n---\n\n> 整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java概述\n\n### JVM、JRE和JDK的关系\n\nJVM：Java Virtual Machine，Java 虚拟机，Java 程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此 Java 语言可以实现跨平台。\n\nJRE：Java Runtime Environment，Java 运行环境，包括 Java 虚拟机和 Java 程序所需的核心类库等。\n\nJDK：Java Development Kit，Java 开发工具包，包括了 JRE 和开发工具。\n\n### 什么是跨平台性？原理是什么\n\n所谓跨平台性，是指 Java 语言编写的程序，一次编译，到处运行。\n\n实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 Java 程序。\n\n### Java语言有哪些特点\n\n面向对象（封装，继承，多态）\n\n平台无关性（Java 虚拟机实现平台无关性）\n\n### 什么是字节码？采用字节码的最大好处是什么\n\n**字节码**：Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为.class 的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld 执行程序）\n\n**编译与解释并存**\n\nJava 源代码(.Java 文件)---->编译器---->jvm 可执行的 Java 字节码(.class 文件)---->jvm---->jvm 中解释器----->机器可执行的二进制机器码---->程序运行\n\n### 什么是Java程序的主类？\n\n一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main()方法的类。\n主类是 Java 程序执行的入口。（main 方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）\n\n### Java和C++的区别\n\n相同点：都是**面向对象**的语言，都支持**封装、继承和多态**\n\n不同点：\n\n- **Java不提供指针**来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存\n\n- Java 的**类是单继承**的，C++支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\n\n\t为什么 Java 中类不支持多继承？——多重继承的钻石问题\n\t\n\t![多重继承的钻石问题](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png)\n\t类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？\n\n- Java 有**自动内存管理**机制，不需要程序员手动释放无用内存\n\n## 基础语法\n\n### 数据类型\n\n**定义**：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。\n\n**分类**\n\n- 基本数据类型\n\t- 数值型\n\t\t- 整数类型(byte,short,int,long)\n\t\t- 浮点类型(float,double)\n\t- 字符型(char)\n\t- 布尔型(boolean)\n- 引用数据类型\n\t- 类(class)\n\t- 接口(interface)\n\t- 数组([])\n\n**Java基本数据类型图**\n\n![Java基本数据类型图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png)\n\n### 类型转换\n\n自动类型转换\n\n> 两种数据类型彼此兼容\n>\n> 低级类型数据转换成高级类型数据\n\n- 数值型数据的转换：byte→short→int→long→float→double\n- 字符型转换为整型：char→int。\n\n强制类型转换\n\n> 当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换\n\n### 访问修饰符\n\n![访问修饰符](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png)\n\n### 关键字\n\n#### final 有什么用？\n\n用于修饰类、方法和变量；\n\n- 被 final 修饰的类不可以被继承\n\n- 被 final 修饰的方法不可以被重写\n\n- 被 final 修饰的变量不可以被改变，被 final 修饰**不可变的是变量的引用，而不是引用指向的内容**，引用指向的内容是可以改变\n\n\t```java\n\tfinal int[] nums = new int[]{1, 2, 3};\n\tnums[0] = 11;\n\tSystem.out.println(Arrays.toString(nums));\t// [11, 2, 3]\n\t```\n\n#### final、finally、finalize区别\n\n- final 是 Java 修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。\n- finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码放在 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\n\n- finalize 是 Object 类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的 finalize()方法，并且在该方法中对象可能可以复活。\n\n#### this关键字的用法\n\n指向对象本身的一个指针。\n\n#### super关键字的用法\n\n指向自己父类对象（最近的父类）的一个指针。\n\n#### static存在的主要意义\n\nstatic**静态变量**：和类一起加载，**以致于即使没有创建对象，也能使用属性和调用方法。**\n\nstatic**静态代码块**：在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。\n加载 → 链接（验证、准备、解析） → 初始化\n\nstatic 类型的变量在准备阶段进行默认初始化，但是有 static final 修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。\n\n#### static注意事项\n\n1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。\n\n### 初始化顺序\n\n静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数\n\n### 流程控制语句\n\n#### break 、continue、return 的区别及作用\n\nbreak 结束当前的循环体\n\ncontinue 结束正在执行的循环，进入下一个循环条件\n\nreturn 结束当前的方法，直接返回\n\n#### 跳出当前的多重嵌套循环\n\n在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如：\n\n```java\npublic static void main(String[] args) {\n    ok:\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            System.out.println(\"i=\" + i + \",j=\" + j);\n            if (j == 5) {\n                break ok;\n            }\n        }\n    }\n}\n```\n\n## 面向对象\n\n### 面向对象三大特性\n\n#### 面向对象的特征有哪些方面\n\n**抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n\n**封装**\n\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。\n\n**继承**\n\n继承是**使用已存在的类作为基础建立新类**的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。\n\n关于继承如下 3 点请记住：\n\n1. 子类拥有父类非 private 的属性和方法。\n2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3. 子类可以用自己的方式实现父类的方法，override 重写。\n\n**多态**\n\n所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。\n\n父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。\n\n在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n\n方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。\n\nJava 实现多态有三个必要条件：继承、重写、向上转型。\n\n> 继承：在多态中必须存在有继承关系的子类和父类。\n>\n> 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n>\n> 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n\n#### 抽象类和接口的对比\n\n抽象类是对类的抽象，用来**捕捉通用特性**。接口是**行为的抽象**，抽象方法的集合。\n\n**相同点**\n\n- 接口和抽象类都不能实例化\n- 都位于继承的顶端，用于被其他类实现或继承\n- 都包含抽象方法，其子类都必须重写这些抽象方法\n\n**不同点**\n\n| 参数       | 抽象类                             | 接口                                             |\n| ---------- | ---------------------------------- | ------------------------------------------------ |\n| 声明       | 抽象类使用abstract关键字声明       | 接口使用interface关键字声明                      |\n| 实现       | 子类使用extends关键字来继承抽象类  | 子类使用implements关键字来实现接口               |\n| 构造器     | 抽象类可以有构造器                 | 接口不能有构造器                                 |\n| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public，也可以不加访问修饰符 |\n| 多继承     | 一个类最多只能继承一个抽象类       | 一个类可以实现多个接口                           |\n\n#### 普通类和抽象类有哪些区别？\n\n- 普通类不能包含抽象方法，抽象类可以包含抽象方法。\n- 抽象类不能直接实例化，普通类可以直接实例化。\n\n#### 成员变量和局部变量的区别\n\n|              | 成员变量               | 局部变量                                     |\n| ------------ | ---------------------- | -------------------------------------------- |\n| **作用域**   | 整个类可使用           | 方法体内使用                                 |\n| **存储位置** | 属于对象，存在堆内存中 | 属于方法，存在栈帧中                         |\n| **生命周期** | 和对象同生命周期       | 和方法同生命周期                             |\n| **初始值**   | 不指定的话有默认初始值 | 必须手动初始化否则<br />不能使用（编译错误） |\n\n**使用原则**\n\n在使用变量时需要遵循的原则为：就近原则\n首先在局部范围找，有就使用；接着在成员位置找。\n\n```java\npublic class Main {\n    int a = 2;\n    public static void main(String[] args) {\n        int a = 1;\n        System.out.println(a);\t// 1\n    }\n}\n```\n\n### 内部类\n\n#### 什么是内部类？\n\n在 Java 中，可以将一个类的定义放在另外一个类的定义内部，这就是**内部类**。\n\n#### 内部类的分类有哪些\n\n内部类可以分为四种：**静态内部类、成员内部类、局部内部类、匿名内部类**。\n\n##### 静态内部类\n\n定义在类内部的静态类，就是静态内部类。\n\n静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量\n\n##### 成员内部类\n\n定义在类内部，成员位置上的非静态类，就是成员内部类。\n\n成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。\n\n##### 局部内部类\n\n定义在方法中的内部类，就是局部内部类。\n\n定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法\n\n##### 匿名内部类\n\n匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法\n\n#### 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\n\n局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上 final 呢？它内部原理是什么呢？\n\n先看这段代码：\n\n```java\npublic class Outer {\n    void outMethod(){\n        final int a =10;\n        class Inner {\n            void innerMethod(){\n                System.out.println(a);\n            }\n        }\n    }\n}\n```\n\n以上例子，为什么要加 final 呢？是因为**生命周期不一致**\n\n局部变量存储在栈中，当方法执行结束后，如果不用 final 修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。\n加了 final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。\n\n### 重写与重载\n\n#### 构造器（constructor）是否可被重写（override）\n\n构造器不能被继承，因此不能被重写，但可以被重载。\n\n#### 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n\n方法的重载和重写都是实现多态的方式，区别在于重载实现的是**编译时的多态性**，而重写实现的是**运行时的多态性**。\n\n重载：发生在**同一个类**中，**方法名相同 参数列表不同**（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关\n\n重写：发生在**父子类**中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，**访问修饰符大于等于父类**（里氏代换原则）\n\n### 对象相等判断\n\n#### == 和 equals 的区别是什么\n\n**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。\n(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)\n\n**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n情况 1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。\n\n情况 2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n\n#### hashCode 与 equals\n\n**hashCode()介绍**\n\nhashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个 int 整数。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都有 hashCode()方法。\n\n**为什么要有 hashCode**\n\n**我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode**：\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的 hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。\n\n**hashCode()与equals()的相关规定**\n\n- 如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。\n- 如果两个对象的 hashCode 值相等并且 equals()方法也返回 true，我们才认为这两个对象相等。\n- 如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。\n\n#### 只重写 hashCode 可以吗？\n\n如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。\n\n> 两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n> 如果定义一个 set 里面存放 Person 对象，Person 只重写了 equals 方法即可以判断对象内容是否相同。\n>\n> 如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。\n>\n> 但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。\n\n### 值传递\n\n#### 为什么 Java 中只有值传递\n\nJava 采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。\n\nexample 1\n\n```java\npublic static void main(String[] args) {\n    int num1 = 10;\n    int num2 = 20;\n\n    swap(num1, num2);\n\n    System.out.println(\"num1 = \" + num1);\n    System.out.println(\"num2 = \" + num2);\n}\n\npublic static void swap(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n\n    System.out.println(\"a = \" + a);\n    System.out.println(\"b = \" + b);\n}\n```\n\n**结果**：\n\n```java\na = 20\nb = 10\nnum1 = 10\nnum2 = 20\n```\n\n**解析**：\n\n![swap(int a, int b)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png)\n\n在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为 a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n**通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.**\n\nexample 2\n\n```java\n    public static void main(String[] args) {\n        int[] arr = { 1, 2, 3, 4, 5 };\n        System.out.println(arr[0]);\n        change(arr);\n        System.out.println(arr[0]);\n    }\n\n    public static void change(int[] array) {\n        // 将数组的第一个元素变为0\n        array[0] = 0;\n    }\n```\n\n**结果**：\n\n```undefined\n1\n0\n```\n\n**解析**：\n\n![change(int[] array)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png)\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n**通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。**\n\nexample 3\n\n```java\npublic class Test {\n\n    public static void main(String[] args) {\n        Student s1 = new Student(\"小张\");\n        Student s2 = new Student(\"小李\");\n        Test.swap(s1, s2);\n        System.out.println(\"s1:\" + s1.getName());\n        System.out.println(\"s2:\" + s2.getName());\n    }\n\n    public static void swap(Student x, Student y) {\n        Student temp = x;\n        x = y;\n        y = temp;\n        System.out.println(\"x:\" + x.getName());\n        System.out.println(\"y:\" + y.getName());\n    }\n}\n```\n\n**结果**：\n\n```undefined\nx:小李\ny:小张\ns1:小张\ns2:小李\n```\n\n**解析**：\n\n交换之前：\n\n![before swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png)\n\n交换之后：\n\n![after swap(Student x, Student y)](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png)\n\n通过上面两张图可以很清晰的看出： **方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝**\n\n#### 值传递和引用传递有什么区别\n\n值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\n\n## IO流\n\n> 参考：https://blog.csdn.net/weixin_44579258/article/details/90758359\n\n阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待\n同步和异步是指访问数据的机制，同步一般主动请求等待 IO 操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待 IO 完毕通知，这可以使进程在数据读写时也不阻塞\n\n准备数据：网卡 → 内核\n数据就绪：数据拷贝到了内核\n拷贝数据：将内核数据拷贝到用户空间\n\n### Blocking I/O\n\n**BIO 属于同步阻塞 IO 模型** 。\n\n同步阻塞 IO 模型中，应用程序**发起 read 调用**后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。\n\n![BIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png)\n\n### NIO (Non-blocking I/O)\n\n同步非阻塞 IO 模型中，用户进程会**一直发起 read 调用**（如果内核返回 error 则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。\n\n> 相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png)\n\n### IO多路复用（NIO）\n\nselect/epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。\n\n![NIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png)\n\nIO 复用和同步阻塞本质一样，在 NIO 中，每次用户进程进行 read 轮询数据是否准备就绪，而在 IO 多路复用中，利用了新的 select 系统调用，由内核来负责本来是请求进程该做的轮询操作。\n\n当用户线程调用 select，那么整个进程会被阻塞，而同时，kernel 内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回可读条件让用户进程发起 read 调用，用户进程发起调用 read 操作，将数据从内核空间拷贝到用户空间。\n\n\n### Asynchronous I/O\n\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n用户发起 read 调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用 read 的进程，数据已经拷贝到用户空间了。\n\n![AIO](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png)\n\n## 反射\n\n### 什么是反射机制？\n\nJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。\n\n### 反射机制优缺点\n\n- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。\n- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。\n\n### 反射机制的应用场景有哪些？\n\n①我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；\n\n②Spring 通过 XML 配置模式装载 Bean 的过程\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入\n\n### Java获取反射的三种方法\n\n1.通过 new 对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制\n\n## 包装类\n\n#### 自动装箱与拆箱\n\n**装箱**：将基本类型用它们对应的引用类型包装起来；`Integer a = 1;`\n\n**拆箱**：将包装类型转换为基本数据类型；`int b = a;`\n\n#### int 和 Integer 有什么区别\n\n引入包装类是为了能够将这些**基本数据类型当成对象操作**\n\nJava 为每个原始类型提供了包装类型：\n\n原始类型: boolean，char，byte，short，int，long，float，double\n\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n#### Integer a = 127 与 Integer b = 127相等吗\n\n> 包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，\n>\n> 只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。\n\n对于对象引用类型：==比较的是对象的内存地址。\n对于基本数据类型：==比较的是值。\n\n```java\npublic static void main(String[] args) {\n    Integer a = new Integer(3);\n  \tInteger b = 3;\n    int c = 3;\n    Integer d = 3;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // true，包装类自动装箱且数值范围在cache范围内\n\n    Integer a = new Integer(128);\n    Integer b = 128;\n    int c = 128;\n    Integer d = 128;\n    System.out.println(a == b); // false，两个对象比较\n    System.out.println(a == c); // true，a自动拆箱\n    System.out.println(b == c); // true，b自动拆箱\n    System.out.println(b == d); // false，包装类自动装箱但是数值范围不在cache范围内\n}\n```\n\n","slug":"Java八股文 - Java基础","published":1,"updated":"2023-01-26T12:40:30.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31w0007t9t8f86m5nb0","content":"<blockquote>\n<p>整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Java概述\"><a href=\"#Java概述\" class=\"headerlink\" title=\"Java概述\"></a>Java概述</h2><h3 id=\"JVM、JRE和JDK的关系\"><a href=\"#JVM、JRE和JDK的关系\" class=\"headerlink\" title=\"JVM、JRE和JDK的关系\"></a>JVM、JRE和JDK的关系</h3><p>JVM：Java Virtual Machine，Java 虚拟机，Java 程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此 Java 语言可以实现跨平台。</p>\n<p>JRE：Java Runtime Environment，Java 运行环境，包括 Java 虚拟机和 Java 程序所需的核心类库等。</p>\n<p>JDK：Java Development Kit，Java 开发工具包，包括了 JRE 和开发工具。</p>\n<h3 id=\"什么是跨平台性？原理是什么\"><a href=\"#什么是跨平台性？原理是什么\" class=\"headerlink\" title=\"什么是跨平台性？原理是什么\"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指 Java 语言编写的程序，一次编译，到处运行。</p>\n<p>实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 Java 程序。</p>\n<h3 id=\"Java语言有哪些特点\"><a href=\"#Java语言有哪些特点\" class=\"headerlink\" title=\"Java语言有哪些特点\"></a>Java语言有哪些特点</h3><p>面向对象（封装，继承，多态）</p>\n<p>平台无关性（Java 虚拟机实现平台无关性）</p>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么\"><a href=\"#什么是字节码？采用字节码的最大好处是什么\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么\"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码</strong>：Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为.class 的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld 执行程序）</p>\n<p><strong>编译与解释并存</strong></p>\n<p>Java 源代码(.Java 文件)—-&gt;编译器—-&gt;jvm 可执行的 Java 字节码(.class 文件)—-&gt;jvm—-&gt;jvm 中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行</p>\n<h3 id=\"什么是Java程序的主类？\"><a href=\"#什么是Java程序的主类？\" class=\"headerlink\" title=\"什么是Java程序的主类？\"></a>什么是Java程序的主类？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main()方法的类。<br>主类是 Java 程序执行的入口。（main 方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>相同点：都是<strong>面向对象</strong>的语言，都支持<strong>封装、继承和多态</strong></p>\n<p>不同点：</p>\n<ul>\n<li><p><strong>Java不提供指针</strong>来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存</p>\n</li>\n<li><p>Java 的<strong>类是单继承</strong>的，C++支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p>\n<p>  为什么 Java 中类不支持多继承？——多重继承的钻石问题</p>\n<p>  <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png\" alt=\"多重继承的钻石问题\"><br>  类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？</p>\n</li>\n<li><p>Java 有<strong>自动内存管理</strong>机制，不需要程序员手动释放无用内存</p>\n</li>\n</ul>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><strong>定义</strong>：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>\n<p><strong>分类</strong></p>\n<ul>\n<li>基本数据类型<ul>\n<li>数值型<ul>\n<li>整数类型(byte,short,int,long)</li>\n<li>浮点类型(float,double)</li>\n</ul>\n</li>\n<li>字符型(char)</li>\n<li>布尔型(boolean)</li>\n</ul>\n</li>\n<li>引用数据类型<ul>\n<li>类(class)</li>\n<li>接口(interface)</li>\n<li>数组([])</li>\n</ul>\n</li>\n</ul>\n<p><strong>Java基本数据类型图</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png\" alt=\"Java基本数据类型图\"></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>自动类型转换</p>\n<blockquote>\n<p>两种数据类型彼此兼容</p>\n<p>低级类型数据转换成高级类型数据</p>\n</blockquote>\n<ul>\n<li>数值型数据的转换：byte→short→int→long→float→double</li>\n<li>字符型转换为整型：char→int。</li>\n</ul>\n<p>强制类型转换</p>\n<blockquote>\n<p>当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换</p>\n</blockquote>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png\" alt=\"访问修饰符\"></p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><h4 id=\"final-有什么用？\"><a href=\"#final-有什么用？\" class=\"headerlink\" title=\"final 有什么用？\"></a>final 有什么用？</h4><p>用于修饰类、方法和变量；</p>\n<ul>\n<li><p>被 final 修饰的类不可以被继承</p>\n</li>\n<li><p>被 final 修饰的方法不可以被重写</p>\n</li>\n<li><p>被 final 修饰的变量不可以被改变，被 final 修饰<strong>不可变的是变量的引用，而不是引用指向的内容</strong>，引用指向的内容是可以改变</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">nums[<span class=\"number\">0</span>] = <span class=\"number\">11</span>;</span><br><span class=\"line\">System.out.println(Arrays.toString(nums));\t<span class=\"comment\">// [11, 2, 3]</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"final、finally、finalize区别\"><a href=\"#final、finally、finalize区别\" class=\"headerlink\" title=\"final、finally、finalize区别\"></a>final、finally、finalize区别</h4><ul>\n<li><p>final 是 Java 修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。</p>\n</li>\n<li><p>finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码放在 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p>\n</li>\n<li><p>finalize 是 Object 类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的 finalize()方法，并且在该方法中对象可能可以复活。</p>\n</li>\n</ul>\n<h4 id=\"this关键字的用法\"><a href=\"#this关键字的用法\" class=\"headerlink\" title=\"this关键字的用法\"></a>this关键字的用法</h4><p>指向对象本身的一个指针。</p>\n<h4 id=\"super关键字的用法\"><a href=\"#super关键字的用法\" class=\"headerlink\" title=\"super关键字的用法\"></a>super关键字的用法</h4><p>指向自己父类对象（最近的父类）的一个指针。</p>\n<h4 id=\"static存在的主要意义\"><a href=\"#static存在的主要意义\" class=\"headerlink\" title=\"static存在的主要意义\"></a>static存在的主要意义</h4><p>static<strong>静态变量</strong>：和类一起加载，<strong>以致于即使没有创建对象，也能使用属性和调用方法。</strong></p>\n<p>static<strong>静态代码块</strong>：在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。<br>加载 → 链接（验证、准备、解析） → 初始化</p>\n<p>static 类型的变量在准备阶段进行默认初始化，但是有 static final 修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。</p>\n<h4 id=\"static注意事项\"><a href=\"#static注意事项\" class=\"headerlink\" title=\"static注意事项\"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>\n<h3 id=\"初始化顺序\"><a href=\"#初始化顺序\" class=\"headerlink\" title=\"初始化顺序\"></a>初始化顺序</h3><p>静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数</p>\n<h3 id=\"流程控制语句\"><a href=\"#流程控制语句\" class=\"headerlink\" title=\"流程控制语句\"></a>流程控制语句</h3><h4 id=\"break-、continue、return-的区别及作用\"><a href=\"#break-、continue、return-的区别及作用\" class=\"headerlink\" title=\"break 、continue、return 的区别及作用\"></a>break 、continue、return 的区别及作用</h4><p>break 结束当前的循环体</p>\n<p>continue 结束正在执行的循环，进入下一个循环条件</p>\n<p>return 结束当前的方法，直接返回</p>\n<h4 id=\"跳出当前的多重嵌套循环\"><a href=\"#跳出当前的多重嵌套循环\" class=\"headerlink\" title=\"跳出当前的多重嵌套循环\"></a>跳出当前的多重嵌套循环</h4><p>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    ok:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + i + <span class=\"string\">&quot;,j=&quot;</span> + j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> ok;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"面向对象三大特性\"><a href=\"#面向对象三大特性\" class=\"headerlink\" title=\"面向对象三大特性\"></a>面向对象三大特性</h3><h4 id=\"面向对象的特征有哪些方面\"><a href=\"#面向对象的特征有哪些方面\" class=\"headerlink\" title=\"面向对象的特征有哪些方面\"></a>面向对象的特征有哪些方面</h4><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>\n<p><strong>封装</strong></p>\n<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。</p>\n<p><strong>继承</strong></p>\n<p>继承是<strong>使用已存在的类作为基础建立新类</strong>的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。</p>\n<p>关于继承如下 3 点请记住：</p>\n<ol>\n<li>子类拥有父类非 private 的属性和方法。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法，override 重写。</li>\n</ol>\n<p><strong>多态</strong></p>\n<p>所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。</p>\n<p>父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。</p>\n<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>\n<p>方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。</p>\n<p>Java 实现多态有三个必要条件：继承、重写、向上转型。</p>\n<blockquote>\n<p>继承：在多态中必须存在有继承关系的子类和父类。</p>\n<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>\n<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>\n</blockquote>\n<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>\n<h4 id=\"抽象类和接口的对比\"><a href=\"#抽象类和接口的对比\" class=\"headerlink\" title=\"抽象类和接口的对比\"></a>抽象类和接口的对比</h4><p>抽象类是对类的抽象，用来<strong>捕捉通用特性</strong>。接口是<strong>行为的抽象</strong>，抽象方法的集合。</p>\n<p><strong>相同点</strong></p>\n<ul>\n<li>接口和抽象类都不能实例化</li>\n<li>都位于继承的顶端，用于被其他类实现或继承</li>\n<li>都包含抽象方法，其子类都必须重写这些抽象方法</li>\n</ul>\n<p><strong>不同点</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>抽象类</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>声明</td>\n<td>抽象类使用abstract关键字声明</td>\n<td>接口使用interface关键字声明</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>子类使用extends关键字来继承抽象类</td>\n<td>子类使用implements关键字来实现接口</td>\n</tr>\n<tr>\n<td>构造器</td>\n<td>抽象类可以有构造器</td>\n<td>接口不能有构造器</td>\n</tr>\n<tr>\n<td>访问修饰符</td>\n<td>抽象类中的方法可以是任意访问修饰符</td>\n<td>接口方法默认修饰符是public，也可以不加访问修饰符</td>\n</tr>\n<tr>\n<td>多继承</td>\n<td>一个类最多只能继承一个抽象类</td>\n<td>一个类可以实现多个接口</td>\n</tr>\n</tbody></table>\n<h4 id=\"普通类和抽象类有哪些区别？\"><a href=\"#普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"普通类和抽象类有哪些区别？\"></a>普通类和抽象类有哪些区别？</h4><ul>\n<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化。</li>\n</ul>\n<h4 id=\"成员变量和局部变量的区别\"><a href=\"#成员变量和局部变量的区别\" class=\"headerlink\" title=\"成员变量和局部变量的区别\"></a>成员变量和局部变量的区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>作用域</strong></td>\n<td>整个类可使用</td>\n<td>方法体内使用</td>\n</tr>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>属于对象，存在堆内存中</td>\n<td>属于方法，存在栈帧中</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>和对象同生命周期</td>\n<td>和方法同生命周期</td>\n</tr>\n<tr>\n<td><strong>初始值</strong></td>\n<td>不指定的话有默认初始值</td>\n<td>必须手动初始化否则<br />不能使用（编译错误）</td>\n</tr>\n</tbody></table>\n<p><strong>使用原则</strong></p>\n<p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(a);\t<span class=\"comment\">// 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><h4 id=\"什么是内部类？\"><a href=\"#什么是内部类？\" class=\"headerlink\" title=\"什么是内部类？\"></a>什么是内部类？</h4><p>在 Java 中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</p>\n<h4 id=\"内部类的分类有哪些\"><a href=\"#内部类的分类有哪些\" class=\"headerlink\" title=\"内部类的分类有哪些\"></a>内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>静态内部类、成员内部类、局部内部类、匿名内部类</strong>。</p>\n<h5 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p>\n<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量</p>\n<h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>\n<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。</p>\n<h5 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p>\n<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法</p>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法</p>\n<h4 id=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"><a href=\"#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\" class=\"headerlink\" title=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上 final 呢？它内部原理是什么呢？</p>\n<p>先看这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">outMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上例子，为什么要加 final 呢？是因为<strong>生命周期不一致</strong></p>\n<p>局部变量存储在栈中，当方法执行结束后，如果不用 final 修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。<br>加了 final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>\n<h3 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a>重写与重载</h3><h4 id=\"构造器（constructor）是否可被重写（override）\"><a href=\"#构造器（constructor）是否可被重写（override）\" class=\"headerlink\" title=\"构造器（constructor）是否可被重写（override）\"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>\n<h4 id=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"><a href=\"#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\" class=\"headerlink\" title=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的是<strong>编译时的多态性</strong>，而重写实现的是<strong>运行时的多态性</strong>。</p>\n<p>重载：发生在<strong>同一个类</strong>中，<strong>方法名相同 参数列表不同</strong>（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关</p>\n<p>重写：发生在<strong>父子类</strong>中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，<strong>访问修饰符大于等于父类</strong>（里氏代换原则）</p>\n<h3 id=\"对象相等判断\"><a href=\"#对象相等判断\" class=\"headerlink\" title=\"对象相等判断\"></a>对象相等判断</h3><h4 id=\"x3D-x3D-和-equals-的区别是什么\"><a href=\"#x3D-x3D-和-equals-的区别是什么\" class=\"headerlink\" title=\"&#x3D;&#x3D; 和 equals 的区别是什么\"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<p>情况 1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>\n<p>情况 2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>\n<h4 id=\"hashCode-与-equals\"><a href=\"#hashCode-与-equals\" class=\"headerlink\" title=\"hashCode 与 equals\"></a>hashCode 与 equals</h4><p><strong>hashCode()介绍</strong></p>\n<p>hashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个 int 整数。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都有 hashCode()方法。</p>\n<p><strong>为什么要有 hashCode</strong></p>\n<p><strong>我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p>\n<p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的 hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>\n<p><strong>hashCode()与equals()的相关规定</strong></p>\n<ul>\n<li>如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li>\n<li>如果两个对象的 hashCode 值相等并且 equals()方法也返回 true，我们才认为这两个对象相等。</li>\n<li>如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li>\n</ul>\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。</p>\n<blockquote>\n<p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n</blockquote>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<blockquote>\n<p>如果定义一个 set 里面存放 Person 对象，Person 只重写了 equals 方法即可以判断对象内容是否相同。</p>\n<p>如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。</p>\n<p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。</p>\n</blockquote>\n<h3 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h3><h4 id=\"为什么-Java-中只有值传递\"><a href=\"#为什么-Java-中只有值传递\" class=\"headerlink\" title=\"为什么 Java 中只有值传递\"></a>为什么 Java 中只有值传递</h4><p>Java 采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>\n<p>example 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num1 = &quot;</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num2 = &quot;</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a = &quot;</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b = &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">20</span></span><br><span class=\"line\">b = <span class=\"number\">10</span></span><br><span class=\"line\">num1 = <span class=\"number\">10</span></span><br><span class=\"line\">num2 = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png\" alt=\"swap(int a, int b)\"></p>\n<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为 a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<p>example 2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    change(arr);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png\" alt=\"change(int[] array)\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p>example 3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小张&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小李&quot;</span>);</span><br><span class=\"line\">        Test.swap(s1, s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s1:&quot;</span> + s1.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s2:&quot;</span> + s2.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Student x, Student y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        x = y;</span><br><span class=\"line\">        y = temp;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x:&quot;</span> + x.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y:&quot;</span> + y.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p>交换之前：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png\" alt=\"before swap(Student x, Student y)\"></p>\n<p>交换之后：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png\" alt=\"after swap(Student x, Student y)\"></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h4 id=\"值传递和引用传递有什么区别\"><a href=\"#值传递和引用传递有什么区别\" class=\"headerlink\" title=\"值传递和引用传递有什么区别\"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>\n<h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_44579258/article/details/90758359\">https://blog.csdn.net/weixin_44579258/article/details/90758359</a></p>\n</blockquote>\n<p>阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待<br>同步和异步是指访问数据的机制，同步一般主动请求等待 IO 操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待 IO 完毕通知，这可以使进程在数据读写时也不阻塞</p>\n<p>准备数据：网卡 → 内核<br>数据就绪：数据拷贝到了内核<br>拷贝数据：将内核数据拷贝到用户空间</p>\n<h3 id=\"Blocking-I-x2F-O\"><a href=\"#Blocking-I-x2F-O\" class=\"headerlink\" title=\"Blocking I&#x2F;O\"></a>Blocking I&#x2F;O</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序<strong>发起 read 调用</strong>后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png\" alt=\"BIO\"></p>\n<h3 id=\"NIO-Non-blocking-I-x2F-O\"><a href=\"#NIO-Non-blocking-I-x2F-O\" class=\"headerlink\" title=\"NIO (Non-blocking I&#x2F;O)\"></a>NIO (Non-blocking I&#x2F;O)</h3><p>同步非阻塞 IO 模型中，用户进程会<strong>一直发起 read 调用</strong>（如果内核返回 error 则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。</p>\n<blockquote>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png\" alt=\"NIO\"></p>\n<h3 id=\"IO多路复用（NIO）\"><a href=\"#IO多路复用（NIO）\" class=\"headerlink\" title=\"IO多路复用（NIO）\"></a>IO多路复用（NIO）</h3><p>select&#x2F;epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png\" alt=\"NIO\"></p>\n<p>IO 复用和同步阻塞本质一样，在 NIO 中，每次用户进程进行 read 轮询数据是否准备就绪，而在 IO 多路复用中，利用了新的 select 系统调用，由内核来负责本来是请求进程该做的轮询操作。</p>\n<p>当用户线程调用 select，那么整个进程会被阻塞，而同时，kernel 内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回可读条件让用户进程发起 read 调用，用户进程发起调用 read 操作，将数据从内核空间拷贝到用户空间。</p>\n<h3 id=\"Asynchronous-I-x2F-O\"><a href=\"#Asynchronous-I-x2F-O\" class=\"headerlink\" title=\"Asynchronous I&#x2F;O\"></a>Asynchronous I&#x2F;O</h3><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p>用户发起 read 调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用 read 的进程，数据已经拷贝到用户空间了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png\" alt=\"AIO\"></p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"什么是反射机制？\"><a href=\"#什么是反射机制？\" class=\"headerlink\" title=\"什么是反射机制？\"></a>什么是反射机制？</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<h3 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h3><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。</li>\n</ul>\n<h3 id=\"反射机制的应用场景有哪些？\"><a href=\"#反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"反射机制的应用场景有哪些？\"></a>反射机制的应用场景有哪些？</h3><p>①我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；</p>\n<p>②Spring 通过 XML 配置模式装载 Bean 的过程</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入</li>\n</ol>\n<h3 id=\"Java获取反射的三种方法\"><a href=\"#Java获取反射的三种方法\" class=\"headerlink\" title=\"Java获取反射的三种方法\"></a>Java获取反射的三种方法</h3><p>1.通过 new 对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>\n<h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><h4 id=\"自动装箱与拆箱\"><a href=\"#自动装箱与拆箱\" class=\"headerlink\" title=\"自动装箱与拆箱\"></a>自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；<code>Integer a = 1;</code></p>\n<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；<code>int b = a;</code></p>\n<h4 id=\"int-和-Integer-有什么区别\"><a href=\"#int-和-Integer-有什么区别\" class=\"headerlink\" title=\"int 和 Integer 有什么区别\"></a>int 和 Integer 有什么区别</h4><p>引入包装类是为了能够将这些<strong>基本数据类型当成对象操作</strong></p>\n<p>Java 为每个原始类型提供了包装类型：</p>\n<p>原始类型: boolean，char，byte，short，int，long，float，double</p>\n<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>\n<h4 id=\"Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\"><a href=\"#Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\" class=\"headerlink\" title=\"Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗\"></a>Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗</h4><blockquote>\n<p>包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，</p>\n<p>只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。</p>\n</blockquote>\n<p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">  \t<span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// true，包装类自动装箱且数值范围在cache范围内</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// false，包装类自动装箱但是数值范围不在cache范围内</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":10743,"excerpt":"<blockquote>\n<p>整理的Java基础相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Java概述\"><a href=\"#Java概述\" class=\"headerlink\" title=\"Java概述\"></a>Java概述</h2><h3 id=\"JVM、JRE和JDK的关系\"><a href=\"#JVM、JRE和JDK的关系\" class=\"headerlink\" title=\"JVM、JRE和JDK的关系\"></a>JVM、JRE和JDK的关系</h3><p>JVM：Java Virtual Machine，Java 虚拟机，Java 程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此 Java 语言可以实现跨平台。</p>\n<p>JRE：Java Runtime Environment，Java 运行环境，包括 Java 虚拟机和 Java 程序所需的核心类库等。</p>\n<p>JDK：Java Development Kit，Java 开发工具包，包括了 JRE 和开发工具。</p>\n<h3 id=\"什么是跨平台性？原理是什么\"><a href=\"#什么是跨平台性？原理是什么\" class=\"headerlink\" title=\"什么是跨平台性？原理是什么\"></a>什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指 Java 语言编写的程序，一次编译，到处运行。</p>\n<p>实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 Java 程序。</p>\n<h3 id=\"Java语言有哪些特点\"><a href=\"#Java语言有哪些特点\" class=\"headerlink\" title=\"Java语言有哪些特点\"></a>Java语言有哪些特点</h3><p>面向对象（封装，继承，多态）</p>\n<p>平台无关性（Java 虚拟机实现平台无关性）</p>\n<h3 id=\"什么是字节码？采用字节码的最大好处是什么\"><a href=\"#什么是字节码？采用字节码的最大好处是什么\" class=\"headerlink\" title=\"什么是字节码？采用字节码的最大好处是什么\"></a>什么是字节码？采用字节码的最大好处是什么</h3><p><strong>字节码</strong>：Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为.class 的文件），它不面向任何特定的处理器，只面向虚拟机。（javac HelloWorld.Java → HelloWorld.class → Java HelloWorld 执行程序）</p>\n<p><strong>编译与解释并存</strong></p>\n<p>Java 源代码(.Java 文件)—-&gt;编译器—-&gt;jvm 可执行的 Java 字节码(.class 文件)—-&gt;jvm—-&gt;jvm 中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行</p>\n<h3 id=\"什么是Java程序的主类？\"><a href=\"#什么是Java程序的主类？\" class=\"headerlink\" title=\"什么是Java程序的主类？\"></a>什么是Java程序的主类？</h3><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main()方法的类。<br>主类是 Java 程序执行的入口。（main 方法除了是个主方法以外，和普通的静态方法没有区别，都可以重载、调用、继承）</p>\n<h3 id=\"Java和C-的区别\"><a href=\"#Java和C-的区别\" class=\"headerlink\" title=\"Java和C++的区别\"></a>Java和C++的区别</h3><p>相同点：都是<strong>面向对象</strong>的语言，都支持<strong>封装、继承和多态</strong></p>\n<p>不同点：</p>\n<ul>\n<li><p><strong>Java不提供指针</strong>来直接访问内存，程序内存更加安全，有自动内存管理；C++用指针管理内存</p>\n</li>\n<li><p>Java 的<strong>类是单继承</strong>的，C++支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p>\n<p>  为什么 Java 中类不支持多继承？——多重继承的钻石问题</p>\n<p>  <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190622142003813.png\" alt=\"多重继承的钻石问题\"><br>  类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C（多继承)，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？</p>\n</li>\n<li><p>Java 有<strong>自动内存管理</strong>机制，不需要程序员手动释放无用内存</p>\n</li>\n</ul>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p><strong>定义</strong>：Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>\n<p><strong>分类</strong></p>\n<ul>\n<li>基本数据类型<ul>\n<li>数值型<ul>\n<li>整数类型(byte,short,int,long)</li>\n<li>浮点类型(float,double)</li>\n</ul>\n</li>\n<li>字符型(char)</li>\n<li>布尔型(boolean)</li>\n</ul>\n</li>\n<li>引用数据类型<ul>\n<li>类(class)</li>\n<li>接口(interface)</li>\n<li>数组([])</li>\n</ul>\n</li>\n</ul>\n<p><strong>Java基本数据类型图</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png\" alt=\"Java基本数据类型图\"></p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>自动类型转换</p>\n<blockquote>\n<p>两种数据类型彼此兼容</p>\n<p>低级类型数据转换成高级类型数据</p>\n</blockquote>\n<ul>\n<li>数值型数据的转换：byte→short→int→long→float→double</li>\n<li>字符型转换为整型：char→int。</li>\n</ul>\n<p>强制类型转换</p>\n<blockquote>\n<p>当两种数据类型不兼容，或高级类型数据转换成低级类型数据时，自动转换将无法进行（编译错误），这时就需要进行强制类型转换</p>\n</blockquote>\n<h3 id=\"访问修饰符\"><a href=\"#访问修饰符\" class=\"headerlink\" title=\"访问修饰符\"></a>访问修饰符</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png\" alt=\"访问修饰符\"></p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><h4 id=\"final-有什么用？\"><a href=\"#final-有什么用？\" class=\"headerlink\" title=\"final 有什么用？\"></a>final 有什么用？</h4><p>用于修饰类、方法和变量；</p>\n<ul>\n<li><p>被 final 修饰的类不可以被继承</p>\n</li>\n<li><p>被 final 修饰的方法不可以被重写</p>\n</li>\n<li><p>被 final 修饰的变量不可以被改变，被 final 修饰<strong>不可变的是变量的引用，而不是引用指向的内容</strong>，引用指向的内容是可以改变</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">nums[<span class=\"number\">0</span>] = <span class=\"number\">11</span>;</span><br><span class=\"line\">System.out.println(Arrays.toString(nums));\t<span class=\"comment\">// [11, 2, 3]</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"final、finally、finalize区别\"><a href=\"#final、finally、finalize区别\" class=\"headerlink\" title=\"final、finally、finalize区别\"></a>final、finally、finalize区别</h4><ul>\n<li><p>final 是 Java 修饰符，可以修饰类、方法、变量，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量不可以被改变。</p>\n</li>\n<li><p>finally 一般作用在 try-catch 代码块中，在处理异常的时候，通常我们将一定要执行的代码放在 finally 代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</p>\n</li>\n<li><p>finalize 是 Object 类的一个方法，该方法一般由垃圾回收器来调用，在执行垃圾回收前，由垃圾回收器调用对象的 finalize()方法，并且在该方法中对象可能可以复活。</p>\n</li>\n</ul>\n<h4 id=\"this关键字的用法\"><a href=\"#this关键字的用法\" class=\"headerlink\" title=\"this关键字的用法\"></a>this关键字的用法</h4><p>指向对象本身的一个指针。</p>\n<h4 id=\"super关键字的用法\"><a href=\"#super关键字的用法\" class=\"headerlink\" title=\"super关键字的用法\"></a>super关键字的用法</h4><p>指向自己父类对象（最近的父类）的一个指针。</p>\n<h4 id=\"static存在的主要意义\"><a href=\"#static存在的主要意义\" class=\"headerlink\" title=\"static存在的主要意义\"></a>static存在的主要意义</h4><p>static<strong>静态变量</strong>：和类一起加载，<strong>以致于即使没有创建对象，也能使用属性和调用方法。</strong></p>\n<p>static<strong>静态代码块</strong>：在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。<br>加载 → 链接（验证、准备、解析） → 初始化</p>\n<p>static 类型的变量在准备阶段进行默认初始化，但是有 static final 修饰的会在准备阶段直接赋值， 在初始化阶段进行显式初始化。</p>\n<h4 id=\"static注意事项\"><a href=\"#static注意事项\" class=\"headerlink\" title=\"static注意事项\"></a>static注意事项</h4><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>\n<h3 id=\"初始化顺序\"><a href=\"#初始化顺序\" class=\"headerlink\" title=\"初始化顺序\"></a>初始化顺序</h3><p>静态属性 → 静态方法块 → 普通属性 → 普通方法块 → 构造函数</p>\n<h3 id=\"流程控制语句\"><a href=\"#流程控制语句\" class=\"headerlink\" title=\"流程控制语句\"></a>流程控制语句</h3><h4 id=\"break-、continue、return-的区别及作用\"><a href=\"#break-、continue、return-的区别及作用\" class=\"headerlink\" title=\"break 、continue、return 的区别及作用\"></a>break 、continue、return 的区别及作用</h4><p>break 结束当前的循环体</p>\n<p>continue 结束正在执行的循环，进入下一个循环条件</p>\n<p>return 结束当前的方法，直接返回</p>\n<h4 id=\"跳出当前的多重嵌套循环\"><a href=\"#跳出当前的多重嵌套循环\" class=\"headerlink\" title=\"跳出当前的多重嵌套循环\"></a>跳出当前的多重嵌套循环</h4><p>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    ok:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;i=&quot;</span> + i + <span class=\"string\">&quot;,j=&quot;</span> + j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> ok;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><h3 id=\"面向对象三大特性\"><a href=\"#面向对象三大特性\" class=\"headerlink\" title=\"面向对象三大特性\"></a>面向对象三大特性</h3><h4 id=\"面向对象的特征有哪些方面\"><a href=\"#面向对象的特征有哪些方面\" class=\"headerlink\" title=\"面向对象的特征有哪些方面\"></a>面向对象的特征有哪些方面</h4><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>\n<p><strong>封装</strong></p>\n<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。</p>\n<p><strong>继承</strong></p>\n<p>继承是<strong>使用已存在的类作为基础建立新类</strong>的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。通过使用继承我们能够非常方便地复用以前的代码。</p>\n<p>关于继承如下 3 点请记住：</p>\n<ol>\n<li>子类拥有父类非 private 的属性和方法。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法，override 重写。</li>\n</ol>\n<p><strong>多态</strong></p>\n<p>所谓多态就是指一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在程序运行期间才能确定，编译期无法确定。</p>\n<p>父类的引用指向子类实例对象、接口指向实现类实例对象。提高了程序的拓展性。</p>\n<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>\n<p>方法重载（overload）实现编译时的多态性（也称为前绑定），方法重写（override）实现运行时的多态性（也称为后绑定）。</p>\n<p>Java 实现多态有三个必要条件：继承、重写、向上转型。</p>\n<blockquote>\n<p>继承：在多态中必须存在有继承关系的子类和父类。</p>\n<p>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</p>\n<p>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>\n</blockquote>\n<p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>\n<h4 id=\"抽象类和接口的对比\"><a href=\"#抽象类和接口的对比\" class=\"headerlink\" title=\"抽象类和接口的对比\"></a>抽象类和接口的对比</h4><p>抽象类是对类的抽象，用来<strong>捕捉通用特性</strong>。接口是<strong>行为的抽象</strong>，抽象方法的集合。</p>\n<p><strong>相同点</strong></p>\n<ul>\n<li>接口和抽象类都不能实例化</li>\n<li>都位于继承的顶端，用于被其他类实现或继承</li>\n<li>都包含抽象方法，其子类都必须重写这些抽象方法</li>\n</ul>\n<p><strong>不同点</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>抽象类</th>\n<th>接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>声明</td>\n<td>抽象类使用abstract关键字声明</td>\n<td>接口使用interface关键字声明</td>\n</tr>\n<tr>\n<td>实现</td>\n<td>子类使用extends关键字来继承抽象类</td>\n<td>子类使用implements关键字来实现接口</td>\n</tr>\n<tr>\n<td>构造器</td>\n<td>抽象类可以有构造器</td>\n<td>接口不能有构造器</td>\n</tr>\n<tr>\n<td>访问修饰符</td>\n<td>抽象类中的方法可以是任意访问修饰符</td>\n<td>接口方法默认修饰符是public，也可以不加访问修饰符</td>\n</tr>\n<tr>\n<td>多继承</td>\n<td>一个类最多只能继承一个抽象类</td>\n<td>一个类可以实现多个接口</td>\n</tr>\n</tbody></table>\n<h4 id=\"普通类和抽象类有哪些区别？\"><a href=\"#普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"普通类和抽象类有哪些区别？\"></a>普通类和抽象类有哪些区别？</h4><ul>\n<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>\n<li>抽象类不能直接实例化，普通类可以直接实例化。</li>\n</ul>\n<h4 id=\"成员变量和局部变量的区别\"><a href=\"#成员变量和局部变量的区别\" class=\"headerlink\" title=\"成员变量和局部变量的区别\"></a>成员变量和局部变量的区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>作用域</strong></td>\n<td>整个类可使用</td>\n<td>方法体内使用</td>\n</tr>\n<tr>\n<td><strong>存储位置</strong></td>\n<td>属于对象，存在堆内存中</td>\n<td>属于方法，存在栈帧中</td>\n</tr>\n<tr>\n<td><strong>生命周期</strong></td>\n<td>和对象同生命周期</td>\n<td>和方法同生命周期</td>\n</tr>\n<tr>\n<td><strong>初始值</strong></td>\n<td>不指定的话有默认初始值</td>\n<td>必须手动初始化否则<br />不能使用（编译错误）</td>\n</tr>\n</tbody></table>\n<p><strong>使用原则</strong></p>\n<p>在使用变量时需要遵循的原则为：就近原则<br>首先在局部范围找，有就使用；接着在成员位置找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(a);\t<span class=\"comment\">// 1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><h4 id=\"什么是内部类？\"><a href=\"#什么是内部类？\" class=\"headerlink\" title=\"什么是内部类？\"></a>什么是内部类？</h4><p>在 Java 中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。</p>\n<h4 id=\"内部类的分类有哪些\"><a href=\"#内部类的分类有哪些\" class=\"headerlink\" title=\"内部类的分类有哪些\"></a>内部类的分类有哪些</h4><p>内部类可以分为四种：<strong>静态内部类、成员内部类、局部内部类、匿名内部类</strong>。</p>\n<h5 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h5><p>定义在类内部的静态类，就是静态内部类。</p>\n<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量</p>\n<h5 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h5><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>\n<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。</p>\n<h5 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。</p>\n<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法</p>\n<h5 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。匿名内部类必须继承或实现一个已有的接口 ，匿名内部类不能定义任何静态成员和静态方法</p>\n<h4 id=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"><a href=\"#局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\" class=\"headerlink\" title=\"局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\"></a>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上 final 呢？它内部原理是什么呢？</p>\n<p>先看这段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">outMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">Inner</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上例子，为什么要加 final 呢？是因为<strong>生命周期不一致</strong></p>\n<p>局部变量存储在栈中，当方法执行结束后，如果不用 final 修饰那么该局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。<br>加了 final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>\n<h3 id=\"重写与重载\"><a href=\"#重写与重载\" class=\"headerlink\" title=\"重写与重载\"></a>重写与重载</h3><h4 id=\"构造器（constructor）是否可被重写（override）\"><a href=\"#构造器（constructor）是否可被重写（override）\" class=\"headerlink\" title=\"构造器（constructor）是否可被重写（override）\"></a>构造器（constructor）是否可被重写（override）</h4><p>构造器不能被继承，因此不能被重写，但可以被重载。</p>\n<h4 id=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"><a href=\"#重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\" class=\"headerlink\" title=\"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\"></a>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><p>方法的重载和重写都是实现多态的方式，区别在于重载实现的是<strong>编译时的多态性</strong>，而重写实现的是<strong>运行时的多态性</strong>。</p>\n<p>重载：发生在<strong>同一个类</strong>中，<strong>方法名相同 参数列表不同</strong>（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关</p>\n<p>重写：发生在<strong>父子类</strong>中，方法名、参数列表必须相同，返回值类型小于等于父类，抛出的异常小于等于父类，<strong>访问修饰符大于等于父类</strong>（里氏代换原则）</p>\n<h3 id=\"对象相等判断\"><a href=\"#对象相等判断\" class=\"headerlink\" title=\"对象相等判断\"></a>对象相等判断</h3><h4 id=\"x3D-x3D-和-equals-的区别是什么\"><a href=\"#x3D-x3D-和-equals-的区别是什么\" class=\"headerlink\" title=\"&#x3D;&#x3D; 和 equals 的区别是什么\"></a>&#x3D;&#x3D; 和 equals 的区别是什么</h4><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)</p>\n<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>\n<p>情况 1：类没有重写 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。</p>\n<p>情况 2：类重写了 equals() 方法。一般，我们都重写 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>\n<h4 id=\"hashCode-与-equals\"><a href=\"#hashCode-与-equals\" class=\"headerlink\" title=\"hashCode 与 equals\"></a>hashCode 与 equals</h4><p><strong>hashCode()介绍</strong></p>\n<p>hashCode() 的作用是获取哈希码（本地方法），也称为散列码；它实际上是返回一个 int 整数。hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都有 hashCode()方法。</p>\n<p><strong>为什么要有 hashCode</strong></p>\n<p><strong>我们以“hashSet 如何检查重复”为例子来说明为什么要有 hashCode</strong>：</p>\n<p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果没有相符的 hashcode，hashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p>\n<p><strong>hashCode()与equals()的相关规定</strong></p>\n<ul>\n<li>如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li>\n<li>如果两个对象的 hashCode 值相等并且 equals()方法也返回 true，我们才认为这两个对象相等。</li>\n<li>如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li>\n</ul>\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>如果只重写 hashCode，不重写 equals，那么如果两个对象判断 hashCode 相同了，以为这俩对象相同，那么只会插入一次到 set 里面，而实际上这两个不一样一个是 A 一个是 B，都需要插入。</p>\n<blockquote>\n<p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n</blockquote>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<blockquote>\n<p>如果定义一个 set 里面存放 Person 对象，Person 只重写了 equals 方法即可以判断对象内容是否相同。</p>\n<p>如果只重写了 equals 方法，那么默认情况下，Set 进行去重操作时，会先判断两个对象的 hashCode 是否相同，此时因为没有重写 hashCode 方法，所以会直接执行 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法对比的是两个不同引用地址的对象，所以结果是 false，那么 equals 方法就不用执行了，直接返回的结果就是 false：两个对象不是相等的，于是就在 Set 集合中插入了两个相同的对象。</p>\n<p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode 是否相同，于是调用 hashCode 返回的结果就是 true，再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个一模一样的数据了，于是整个程序的执行就正常了。</p>\n</blockquote>\n<h3 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h3><h4 id=\"为什么-Java-中只有值传递\"><a href=\"#为什么-Java-中只有值传递\" class=\"headerlink\" title=\"为什么 Java 中只有值传递\"></a>为什么 Java 中只有值传递</h4><p>Java 采用按值调用，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p>\n<p>example 1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    swap(num1, num2);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num1 = &quot;</span> + num1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;num2 = &quot;</span> + num2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> a;</span><br><span class=\"line\">    a = b;</span><br><span class=\"line\">    b = temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;a = &quot;</span> + a);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;b = &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">20</span></span><br><span class=\"line\">b = <span class=\"number\">10</span></span><br><span class=\"line\">num1 = <span class=\"number\">10</span></span><br><span class=\"line\">num2 = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi00ZWQyZjQ0NTlmN2MyYzkwLmpwZw.png\" alt=\"swap(int a, int b)\"></p>\n<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为 a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p>\n<p>example 2</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    change(arr);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi1kYWI5Mzg5ZWRmMjIxNmIzLmpwZw.png\" alt=\"change(int[] array)\"></p>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p><strong>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>\n<p>example 3</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小张&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小李&quot;</span>);</span><br><span class=\"line\">        Test.swap(s1, s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s1:&quot;</span> + s1.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s2:&quot;</span> + s2.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Student x, Student y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        x = y;</span><br><span class=\"line\">        y = temp;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x:&quot;</span> + x.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y:&quot;</span> + y.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析</strong>：</p>\n<p>交换之前：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi03MmIwYzFmYjlmM2IwNzc2LmpwZw.png\" alt=\"before swap(Student x, Student y)\"></p>\n<p>交换之后：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDAyMzk3Mi0zYWUzNzY4NGNiMzg2Njc4LmpwZw.png\" alt=\"after swap(Student x, Student y)\"></p>\n<p>通过上面两张图可以很清晰的看出： <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>\n<h4 id=\"值传递和引用传递有什么区别\"><a href=\"#值传递和引用传递有什么区别\" class=\"headerlink\" title=\"值传递和引用传递有什么区别\"></a>值传递和引用传递有什么区别</h4><p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>\n<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>\n<h2 id=\"IO流\"><a href=\"#IO流\" class=\"headerlink\" title=\"IO流\"></a>IO流</h2><blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/weixin_44579258/article/details/90758359\">https://blog.csdn.net/weixin_44579258/article/details/90758359</a></p>\n</blockquote>\n<p>阻塞和非阻塞是指进程访问的数据如果尚未准备就绪，进程是否需要等待<br>同步和异步是指访问数据的机制，同步一般主动请求等待 IO 操作完毕的方式。当数据就绪后，再读写的时候必须阻塞，异步则主动请求数据后便可以继续处理其他任务，随后等待 IO 完毕通知，这可以使进程在数据读写时也不阻塞</p>\n<p>准备数据：网卡 → 内核<br>数据就绪：数据拷贝到了内核<br>拷贝数据：将内核数据拷贝到用户空间</p>\n<h3 id=\"Blocking-I-x2F-O\"><a href=\"#Blocking-I-x2F-O\" class=\"headerlink\" title=\"Blocking I&#x2F;O\"></a>Blocking I&#x2F;O</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p>\n<p>同步阻塞 IO 模型中，应用程序<strong>发起 read 调用</strong>后，会一直阻塞，直到内核准备数据、数据就绪，数据从内核拷贝到用户空间。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201109632.png\" alt=\"BIO\"></p>\n<h3 id=\"NIO-Non-blocking-I-x2F-O\"><a href=\"#NIO-Non-blocking-I-x2F-O\" class=\"headerlink\" title=\"NIO (Non-blocking I&#x2F;O)\"></a>NIO (Non-blocking I&#x2F;O)</h3><p>同步非阻塞 IO 模型中，用户进程会<strong>一直发起 read 调用</strong>（如果内核返回 error 则说明数据未准备就绪），直到数据准备就绪，用户发起 read 调用时，数据从内核空间拷贝到用户空间（用户进程是阻塞的）。</p>\n<blockquote>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190603201218527.png\" alt=\"NIO\"></p>\n<h3 id=\"IO多路复用（NIO）\"><a href=\"#IO多路复用（NIO）\" class=\"headerlink\" title=\"IO多路复用（NIO）\"></a>IO多路复用（NIO）</h3><p>select&#x2F;epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320125821.png\" alt=\"NIO\"></p>\n<p>IO 复用和同步阻塞本质一样，在 NIO 中，每次用户进程进行 read 轮询数据是否准备就绪，而在 IO 多路复用中，利用了新的 select 系统调用，由内核来负责本来是请求进程该做的轮询操作。</p>\n<p>当用户线程调用 select，那么整个进程会被阻塞，而同时，kernel 内核会“监视”所有 select 负责的 socket，当任何一个 socket 中的数据准备好了，select 就会返回可读条件让用户进程发起 read 调用，用户进程发起调用 read 操作，将数据从内核空间拷贝到用户空间。</p>\n<h3 id=\"Asynchronous-I-x2F-O\"><a href=\"#Asynchronous-I-x2F-O\" class=\"headerlink\" title=\"Asynchronous I&#x2F;O\"></a>Asynchronous I&#x2F;O</h3><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p>用户发起 read 调用，此时用户进程不会阻塞。内核将数据准备就绪并将其从内核拷贝到用户空间后，内核给用户进程发送一个信号给之前调用 read 的进程，数据已经拷贝到用户空间了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2019060320135956.png\" alt=\"AIO\"></p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"什么是反射机制？\"><a href=\"#什么是反射机制？\" class=\"headerlink\" title=\"什么是反射机制？\"></a>什么是反射机制？</h3><p>JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<h3 id=\"反射机制优缺点\"><a href=\"#反射机制优缺点\" class=\"headerlink\" title=\"反射机制优缺点\"></a>反射机制优缺点</h3><ul>\n<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>\n<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 Java 代码要慢很多。</li>\n</ul>\n<h3 id=\"反射机制的应用场景有哪些？\"><a href=\"#反射机制的应用场景有哪些？\" class=\"headerlink\" title=\"反射机制的应用场景有哪些？\"></a>反射机制的应用场景有哪些？</h3><p>①我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；</p>\n<p>②Spring 通过 XML 配置模式装载 Bean 的过程</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入</li>\n</ol>\n<h3 id=\"Java获取反射的三种方法\"><a href=\"#Java获取反射的三种方法\" class=\"headerlink\" title=\"Java获取反射的三种方法\"></a>Java获取反射的三种方法</h3><p>1.通过 new 对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>\n<h2 id=\"包装类\"><a href=\"#包装类\" class=\"headerlink\" title=\"包装类\"></a>包装类</h2><h4 id=\"自动装箱与拆箱\"><a href=\"#自动装箱与拆箱\" class=\"headerlink\" title=\"自动装箱与拆箱\"></a>自动装箱与拆箱</h4><p><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；<code>Integer a = 1;</code></p>\n<p><strong>拆箱</strong>：将包装类型转换为基本数据类型；<code>int b = a;</code></p>\n<h4 id=\"int-和-Integer-有什么区别\"><a href=\"#int-和-Integer-有什么区别\" class=\"headerlink\" title=\"int 和 Integer 有什么区别\"></a>int 和 Integer 有什么区别</h4><p>引入包装类是为了能够将这些<strong>基本数据类型当成对象操作</strong></p>\n<p>Java 为每个原始类型提供了包装类型：</p>\n<p>原始类型: boolean，char，byte，short，int，long，float，double</p>\n<p>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p>\n<h4 id=\"Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\"><a href=\"#Integer-a-x3D-127-与-Integer-b-x3D-127相等吗\" class=\"headerlink\" title=\"Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗\"></a>Integer a &#x3D; 127 与 Integer b &#x3D; 127相等吗</h4><blockquote>\n<p>包装类和基本数据类型比较，会将包装类拆箱成基本数据类型然后比较，</p>\n<p>只有当包装类是自动装箱，并且数值范围在 [-128, 127] 时，才会使用 cache 中的对象。</p>\n</blockquote>\n<p>对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。<br>对于基本数据类型：&#x3D;&#x3D;比较的是值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">  \t<span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// true，包装类自动装箱且数值范围在cache范围内</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">128</span>);</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">    System.out.println(a == b); <span class=\"comment\">// false，两个对象比较</span></span><br><span class=\"line\">    System.out.println(a == c); <span class=\"comment\">// true，a自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == c); <span class=\"comment\">// true，b自动拆箱</span></span><br><span class=\"line\">    System.out.println(b == d); <span class=\"comment\">// false，包装类自动装箱但是数值范围不在cache范围内</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java八股文 - Java异常","copyright":true,"mathjax":false,"date":"2023-01-23T02:06:31.000Z","toc":true,"urlname":"java-exception-error","_content":"\n> 整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java异常架构\n\n![Java异常架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png)\n\n### 1. Throwable\n\nThrowable 是 Java 语言中所有错误与异常的超类。\n\nThrowable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\n\n### 2. Error（错误）\n\nError 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\n\n非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\n\n### 3. Exception（异常）\n\n程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\n\n#### 运行时异常\n\nException 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）\n\n#### 编译时异常\n\nException 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）\n\n## Java异常关键字\n\n• **try** – 用于监听。将要被监听的代（可能抛出异常的代码）放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。\n• **catch** – 用于捕获异常。catch 用来捕获 try 语句块中发生的异常。\n• **finally** – finally 语句块总是会被执行。它主要用于回收在 try 块里打开的资源(如数据库连接、网络连接和磁盘文件)。\n• **throw** – 用于手动抛出 catch 到的异常。\n• **throws** – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意 catch 这个可能跑出的异常。\n\n## Java异常处理\n\n### 直接抛出异常\n\n通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 **throws** 关键字声明可能会抛出的异常。调用该方法的方法需要注意 catch 这个可能抛出的异常。\n\n```java\nprivate static void readFile(String filePath) throws IOException {\n    File file = new File(filePath);\n    String result;\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    while((result = reader.readLine())!=null) {\n        System.out.println(result);\n    }\n    reader.close();\n}\n```\n\n### 封装异常再抛出\n\n有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\n\n```java\nprivate static void readFile(String filePath) throws MyException {    \n    try {\n        // code\n    } catch (IOException e) {\n        MyException ex = new MyException(\"read file failed.\");\n        ex.initCause(e);\n        throw ex;\n    }\n}\n```\n\n### 捕获异常\n\n在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException e) {\n        // handle FileNotFoundException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n同一个 catch 也可以捕获多种类型异常，用 | 隔开\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException | UnknownHostException e) {\n        // handle FileNotFoundException or UnknownHostException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n### 自定义异常\n\n习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）\n\n```java\npublic class MyException extends Exception {\n    public MyException(){ }\n    public MyException(String msg){\n        super(msg);\n    }\n    // ...\n}\n```\n\n## Java异常常见面试题\n\n### 1. Error 和 Exception 区别是什么？\n\nError 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；\n\nException 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。\n\n### 2. 运行时异常和一般异常(受检异常)区别是什么？\n\n运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。\n\n受检异常是 Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。\n\n**RuntimeException异常和受检异常之间的区别**：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用 RuntimeException 异常。\n\n### 3. JVM 是如何处理异常的？\n\n在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。\n\nJVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。\n\n### 4. throw 和 throws 的区别是什么？\n\nJava 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。\n\n**throws 关键字和 throw 关键字在使用上的几点区别如下**：\n\n- throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\n- throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\n\n### 5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n\n**答：会执行，在 return 前执行。**\n\n**代码示例1：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally，finally执行过后回来执行return a\n    } finally {\n        a = 40;\n    }\n\treturn a;\n}\n```\n\n执行结果：30\n\n**代码示例2：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally\n    } finally {\n        a = 40;\n        return a;\t// finally中有return就直接return了\n    }\n}\n```\n\n执行结果：40\n\n### 6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\n\n```java\npublic class ExceptionA extends Exception {\n    public ExceptionA(String message) {\n        super(message);\n    }\n}\npublic class ExceptionB extends ExceptionA {\n    public ExceptionB(String message) {\n        super(message);\n    }\n}\n\ntry {\n  throw new ExceptionB(\"a\");\n} catch (ExceptionA ea) {\n  System.out.println(\"ExceptionA\");\n} catch (Exception e) {\n  System.out.println(\"Exception\");\n}\n```\n\n输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）\n\n```java\ntry {\n  throw new ExceptionB(\"b\");\n} catch (Exception e) {\n  System.out.println(\"Exception: \" + e);\n}\n```\n\n输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。\n\n面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）\n\n```java\nclass Annoyance extends Exception {\n}\nclass Sneeze extends Annoyance {\n}\nclass Human {\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tthrow new Sneeze();\n\t\t\t} catch ( Annoyance a ) {\n\t\t\t\tSystem.out.println(\"Caught Annoyance\");\n\t\t\t\tthrow a;\n\t\t\t}\n\t\t} catch ( Sneeze s ) {\n\t\t\tSystem.out.println(\"Caught Sneeze\");\n\t\t\treturn ;\n\t\t} finally {\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t}\n\t}\n}\n```\n\n结果\n\n```java\nCaught Annoyance\nCaught Sneeze\nHello World!\n```\n\n","source":"_posts/Java八股文 - Java异常.md","raw":"---\ntitle: Java八股文 - Java异常\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 10:06:31\ntags:\ntoc: true\nurlname: java-exception-error\n---\n\n> 整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Java异常架构\n\n![Java异常架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png)\n\n### 1. Throwable\n\nThrowable 是 Java 语言中所有错误与异常的超类。\n\nThrowable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。\n\n### 2. Error（错误）\n\nError 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。\n\n非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。\n\n### 3. Exception（异常）\n\n程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。\n\n#### 运行时异常\n\nException 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）\n\n#### 编译时异常\n\nException 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）\n\n## Java异常关键字\n\n• **try** – 用于监听。将要被监听的代（可能抛出异常的代码）放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。\n• **catch** – 用于捕获异常。catch 用来捕获 try 语句块中发生的异常。\n• **finally** – finally 语句块总是会被执行。它主要用于回收在 try 块里打开的资源(如数据库连接、网络连接和磁盘文件)。\n• **throw** – 用于手动抛出 catch 到的异常。\n• **throws** – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意 catch 这个可能跑出的异常。\n\n## Java异常处理\n\n### 直接抛出异常\n\n通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 **throws** 关键字声明可能会抛出的异常。调用该方法的方法需要注意 catch 这个可能抛出的异常。\n\n```java\nprivate static void readFile(String filePath) throws IOException {\n    File file = new File(filePath);\n    String result;\n    BufferedReader reader = new BufferedReader(new FileReader(file));\n    while((result = reader.readLine())!=null) {\n        System.out.println(result);\n    }\n    reader.close();\n}\n```\n\n### 封装异常再抛出\n\n有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。\n\n```java\nprivate static void readFile(String filePath) throws MyException {    \n    try {\n        // code\n    } catch (IOException e) {\n        MyException ex = new MyException(\"read file failed.\");\n        ex.initCause(e);\n        throw ex;\n    }\n}\n```\n\n### 捕获异常\n\n在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException e) {\n        // handle FileNotFoundException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n同一个 catch 也可以捕获多种类型异常，用 | 隔开\n\n```java\nprivate static void readFile(String filePath) {\n    try {\n        // code\n    } catch (FileNotFoundException | UnknownHostException e) {\n        // handle FileNotFoundException or UnknownHostException\n    } catch (IOException e){\n        // handle IOException\n    }\n}\n```\n\n### 自定义异常\n\n习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）\n\n```java\npublic class MyException extends Exception {\n    public MyException(){ }\n    public MyException(String msg){\n        super(msg);\n    }\n    // ...\n}\n```\n\n## Java异常常见面试题\n\n### 1. Error 和 Exception 区别是什么？\n\nError 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；\n\nException 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。\n\n### 2. 运行时异常和一般异常(受检异常)区别是什么？\n\n运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。\n\n受检异常是 Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。\n\n**RuntimeException异常和受检异常之间的区别**：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用 RuntimeException 异常。\n\n### 3. JVM 是如何处理异常的？\n\n在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。\n\nJVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。\n\n### 4. throw 和 throws 的区别是什么？\n\nJava 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。\n\n**throws 关键字和 throw 关键字在使用上的几点区别如下**：\n\n- throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。\n- throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。\n\n### 5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n\n**答：会执行，在 return 前执行。**\n\n**代码示例1：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally，finally执行过后回来执行return a\n    } finally {\n        a = 40;\n    }\n\treturn a;\n}\n```\n\n执行结果：30\n\n**代码示例2：**\n\n```java\npublic static int getInt() {\n    int a = 10;\n    try {\n        System.out.println(a / 0);\n        a = 20;\n    } catch (ArithmeticException e) {\n        a = 30;\n        return a;\t// 不会直接return，先执行finally\n    } finally {\n        a = 40;\n        return a;\t// finally中有return就直接return了\n    }\n}\n```\n\n执行结果：40\n\n### 6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\n\n```java\npublic class ExceptionA extends Exception {\n    public ExceptionA(String message) {\n        super(message);\n    }\n}\npublic class ExceptionB extends ExceptionA {\n    public ExceptionB(String message) {\n        super(message);\n    }\n}\n\ntry {\n  throw new ExceptionB(\"a\");\n} catch (ExceptionA ea) {\n  System.out.println(\"ExceptionA\");\n} catch (Exception e) {\n  System.out.println(\"Exception\");\n}\n```\n\n输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）\n\n```java\ntry {\n  throw new ExceptionB(\"b\");\n} catch (Exception e) {\n  System.out.println(\"Exception: \" + e);\n}\n```\n\n输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。\n\n面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）\n\n```java\nclass Annoyance extends Exception {\n}\nclass Sneeze extends Annoyance {\n}\nclass Human {\n\tpublic static void main(String[] args) throws Exception {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tthrow new Sneeze();\n\t\t\t} catch ( Annoyance a ) {\n\t\t\t\tSystem.out.println(\"Caught Annoyance\");\n\t\t\t\tthrow a;\n\t\t\t}\n\t\t} catch ( Sneeze s ) {\n\t\t\tSystem.out.println(\"Caught Sneeze\");\n\t\t\treturn ;\n\t\t} finally {\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t}\n\t}\n}\n```\n\n结果\n\n```java\nCaught Annoyance\nCaught Sneeze\nHello World!\n```\n\n","slug":"Java八股文 - Java异常","published":1,"updated":"2023-01-26T13:00:30.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31w0008t9t883lmba4k","content":"<blockquote>\n<p>整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Java异常架构\"><a href=\"#Java异常架构\" class=\"headerlink\" title=\"Java异常架构\"></a>Java异常架构</h2><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png\" alt=\"Java异常架构\"></p>\n<h3 id=\"1-Throwable\"><a href=\"#1-Throwable\" class=\"headerlink\" title=\"1. Throwable\"></a>1. Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>\n<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>\n<h3 id=\"2-Error（错误）\"><a href=\"#2-Error（错误）\" class=\"headerlink\" title=\"2. Error（错误）\"></a>2. Error（错误）</h3><p>Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>\n<p>非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>\n<h3 id=\"3-Exception（异常）\"><a href=\"#3-Exception（异常）\" class=\"headerlink\" title=\"3. Exception（异常）\"></a>3. Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>Exception 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）</p>\n<h4 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h4><p>Exception 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）</p>\n<h2 id=\"Java异常关键字\"><a href=\"#Java异常关键字\" class=\"headerlink\" title=\"Java异常关键字\"></a>Java异常关键字</h2><p>• <strong>try</strong> – 用于监听。将要被监听的代（可能抛出异常的代码）放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。<br>• <strong>catch</strong> – 用于捕获异常。catch 用来捕获 try 语句块中发生的异常。<br>• <strong>finally</strong> – finally 语句块总是会被执行。它主要用于回收在 try 块里打开的资源(如数据库连接、网络连接和磁盘文件)。<br>• <strong>throw</strong> – 用于手动抛出 catch 到的异常。<br>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意 catch 这个可能跑出的异常。</p>\n<h2 id=\"Java异常处理\"><a href=\"#Java异常处理\" class=\"headerlink\" title=\"Java异常处理\"></a>Java异常处理</h2><h3 id=\"直接抛出异常\"><a href=\"#直接抛出异常\" class=\"headerlink\" title=\"直接抛出异常\"></a>直接抛出异常</h3><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。调用该方法的方法需要注意 catch 这个可能抛出的异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filePath);</span><br><span class=\"line\">    String result;</span><br><span class=\"line\">    <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(file));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((result = reader.readLine())!=<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装异常再抛出\"><a href=\"#封装异常再抛出\" class=\"headerlink\" title=\"封装异常再抛出\"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> MyException &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"type\">MyException</span> <span class=\"variable\">ex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyException</span>(<span class=\"string\">&quot;read file failed.&quot;</span>);</span><br><span class=\"line\">        ex.initCause(e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException or UnknownHostException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">()</span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java异常常见面试题\"><a href=\"#Java异常常见面试题\" class=\"headerlink\" title=\"Java异常常见面试题\"></a>Java异常常见面试题</h2><h3 id=\"1-Error-和-Exception-区别是什么？\"><a href=\"#1-Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"1. Error 和 Exception 区别是什么？\"></a>1. Error 和 Exception 区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>\n<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>\n<h3 id=\"2-运行时异常和一般异常-受检异常-区别是什么？\"><a href=\"#2-运行时异常和一般异常-受检异常-区别是什么？\" class=\"headerlink\" title=\"2. 运行时异常和一般异常(受检异常)区别是什么？\"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h3><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>\n<p>受检异常是 Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>\n<p><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用 RuntimeException 异常。</p>\n<h3 id=\"3-JVM-是如何处理异常的？\"><a href=\"#3-JVM-是如何处理异常的？\" class=\"headerlink\" title=\"3. JVM 是如何处理异常的？\"></a>3. JVM 是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>\n<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>\n<h3 id=\"4-throw-和-throws-的区别是什么？\"><a href=\"#4-throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"4. throw 和 throws 的区别是什么？\"></a>4. throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>\n<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>\n<ul>\n<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>\n<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>\n</ul>\n<h3 id=\"5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><strong>答：会执行，在 return 前执行。</strong></p>\n<p><strong>代码示例1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally，finally执行过后回来执行return a</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：30</p>\n<p><strong>代码示例2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// finally中有return就直接return了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：40</p>\n<h3 id=\"6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\"><a href=\"#6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\" class=\"headerlink\" title=\"6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\"></a>6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionA</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExceptionA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionB</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExceptionA ea) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;ExceptionA&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception: &quot;</span> + e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。</p>\n<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Annoyance</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sneeze</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Annoyance</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Human</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Sneeze</span>();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> ( Annoyance a ) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Annoyance&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> a;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> ( Sneeze s ) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Sneeze&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caught Annoyance</span><br><span class=\"line\">Caught Sneeze</span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":5179,"excerpt":"<blockquote>\n<p>整理的Java异常相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Java异常架构\"><a href=\"#Java异常架构\" class=\"headerlink\" title=\"Java异常架构\"></a>Java异常架构</h2><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200314173417278.png\" alt=\"Java异常架构\"></p>\n<h3 id=\"1-Throwable\"><a href=\"#1-Throwable\" class=\"headerlink\" title=\"1. Throwable\"></a>1. Throwable</h3><p>Throwable 是 Java 语言中所有错误与异常的超类。</p>\n<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>\n<h3 id=\"2-Error（错误）\"><a href=\"#2-Error（错误）\" class=\"headerlink\" title=\"2. Error（错误）\"></a>2. Error（错误）</h3><p>Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>\n<p>非受检异常，一般表示代码运行时 JVM 出现问题。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>\n<h3 id=\"3-Exception（异常）\"><a href=\"#3-Exception（异常）\" class=\"headerlink\" title=\"3. Exception（异常）\"></a>3. Exception（异常）</h3><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>\n<h4 id=\"运行时异常\"><a href=\"#运行时异常\" class=\"headerlink\" title=\"运行时异常\"></a>运行时异常</h4><p>Exception 中 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。（非受检异常，编译时不会检查出异常，运行时会发生异常，需要对异常进行特殊处理，否则会发生逻辑错误）</p>\n<h4 id=\"编译时异常\"><a href=\"#编译时异常\" class=\"headerlink\" title=\"编译时异常\"></a>编译时异常</h4><p>Exception 中除 RuntimeException 及其子类之外的异常。（受检异常，编译时会检查到该异常 ）</p>\n<h2 id=\"Java异常关键字\"><a href=\"#Java异常关键字\" class=\"headerlink\" title=\"Java异常关键字\"></a>Java异常关键字</h2><p>• <strong>try</strong> – 用于监听。将要被监听的代（可能抛出异常的代码）放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。<br>• <strong>catch</strong> – 用于捕获异常。catch 用来捕获 try 语句块中发生的异常。<br>• <strong>finally</strong> – finally 语句块总是会被执行。它主要用于回收在 try 块里打开的资源(如数据库连接、网络连接和磁盘文件)。<br>• <strong>throw</strong> – 用于手动抛出 catch 到的异常。<br>• <strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常，调用该方法的方法需要注意 catch 这个可能跑出的异常。</p>\n<h2 id=\"Java异常处理\"><a href=\"#Java异常处理\" class=\"headerlink\" title=\"Java异常处理\"></a>Java异常处理</h2><h3 id=\"直接抛出异常\"><a href=\"#直接抛出异常\" class=\"headerlink\" title=\"直接抛出异常\"></a>直接抛出异常</h3><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 <strong>throws</strong> 关键字声明可能会抛出的异常。调用该方法的方法需要注意 catch 这个可能抛出的异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(filePath);</span><br><span class=\"line\">    String result;</span><br><span class=\"line\">    <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(file));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((result = reader.readLine())!=<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装异常再抛出\"><a href=\"#封装异常再抛出\" class=\"headerlink\" title=\"封装异常再抛出\"></a>封装异常再抛出</h3><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> MyException &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"type\">MyException</span> <span class=\"variable\">ex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyException</span>(<span class=\"string\">&quot;read file failed.&quot;</span>);</span><br><span class=\"line\">        ex.initCause(e);</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">readFile</span><span class=\"params\">(String filePath)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// code</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle FileNotFoundException or UnknownHostException</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle IOException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h3><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">()</span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyException</span><span class=\"params\">(String msg)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Java异常常见面试题\"><a href=\"#Java异常常见面试题\" class=\"headerlink\" title=\"Java异常常见面试题\"></a>Java异常常见面试题</h2><h3 id=\"1-Error-和-Exception-区别是什么？\"><a href=\"#1-Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"1. Error 和 Exception 区别是什么？\"></a>1. Error 和 Exception 区别是什么？</h3><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，Java 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p>\n<p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>\n<h3 id=\"2-运行时异常和一般异常-受检异常-区别是什么？\"><a href=\"#2-运行时异常和一般异常-受检异常-区别是什么？\" class=\"headerlink\" title=\"2. 运行时异常和一般异常(受检异常)区别是什么？\"></a>2. 运行时异常和一般异常(受检异常)区别是什么？</h3><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p>\n<p>受检异常是 Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p>\n<p><strong>RuntimeException异常和受检异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用 RuntimeException 异常。</p>\n<h3 id=\"3-JVM-是如何处理异常的？\"><a href=\"#3-JVM-是如何处理异常的？\" class=\"headerlink\" title=\"3. JVM 是如何处理异常的？\"></a>3. JVM 是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>\n<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p>\n<h3 id=\"4-throw-和-throws-的区别是什么？\"><a href=\"#4-throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"4. throw 和 throws 的区别是什么？\"></a>4. throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。</p>\n<p><strong>throws 关键字和 throw 关键字在使用上的几点区别如下</strong>：</p>\n<ul>\n<li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>\n<li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>\n</ul>\n<h3 id=\"5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#5-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>5. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><strong>答：会执行，在 return 前执行。</strong></p>\n<p><strong>代码示例1：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally，finally执行过后回来执行return a</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：30</p>\n<p><strong>代码示例2：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(a / <span class=\"number\">0</span>);</span><br><span class=\"line\">        a = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ArithmeticException e) &#123;</span><br><span class=\"line\">        a = <span class=\"number\">30</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// 不会直接return，先执行finally</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">40</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;\t<span class=\"comment\">// finally中有return就直接return了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：40</p>\n<h3 id=\"6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\"><a href=\"#6-类-ExampleA-继承-Exception，类-ExampleB-继承ExampleA。\" class=\"headerlink\" title=\"6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。\"></a>6. 类 ExampleA 继承 Exception，类 ExampleB 继承ExampleA。</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionA</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionA</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExceptionB</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ExceptionA</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ExceptionB</span><span class=\"params\">(String message)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExceptionA ea) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;ExceptionA&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExceptionA 类型异常的 catch 块能够抓住 try 块中抛出的 ExceptionB 类型的异常）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionB</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">&quot;Exception: &quot;</span> + e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：Exception: com.yaxing.demo.exceptiondemo.ExceptionB: b，仍会使用子类型。</p>\n<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Annoyance</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sneeze</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Annoyance</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Human</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Sneeze</span>();</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> ( Annoyance a ) &#123;</span><br><span class=\"line\">\t\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Annoyance&quot;</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> a;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> ( Sneeze s ) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Caught Sneeze&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">&quot;Hello World!&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Caught Annoyance</span><br><span class=\"line\">Caught Sneeze</span><br><span class=\"line\">Hello World!</span><br></pre></td></tr></table></figure>"},{"title":"Java八股文 - Java并发","copyright":true,"mathjax":false,"date":"2023-01-23T07:29:48.000Z","toc":true,"urlname":"java-concurrent-programming","_content":"\n> 整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 基础知识\n\n### 并发编程的优缺点\n\n优点：为了能提高程序的执行效率，提高程序运行速度；\n\n缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。\n\n#### 并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\n\n并发编程三要素（线程的安全性问题体现在）：\n\n**原子性**：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）\n\n**可见性**：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）\n\n**有序性**：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）\n\n> volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用`atomicInteger.getAndSet()`原子操作。\n\n### 线程和进程\n\n#### 进程间的通信方式\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；\n2. **有名管道(Names Pipes)**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；\n3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**；\n5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件；\n6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式；\n7. **套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n#### 线程间的同步方式\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；\n2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；\n3. **事件(Event)** ：wait/notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\n\n#### 什么是线程和进程?\n\n**进程**：进程是应用程序的一次运行，每个进程都有自己独立的内存空间，是操作系统资源分配的基本单位；\n\n**线程**：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。\n\n#### 什么是上下文切换?\n\n多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。\n\n当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n#### 守护线程和用户线程有什么区别呢？\n\n- **用户 (User) 线程**：运行在前台，执行具体的任务\n- **守护 (Daemon) 线程**：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作\n\n**注意事项：**\n\n1. `setDaemon(true)`必须在`start()`方法前执行，否则会抛出 `IllegalThreadStateException` 异常；\n2. 在守护线程中产生的新线程也是守护线程；\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；\n4. 守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。\n\n#### 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\n\nWindows 下用任务管理器看，Linux 下可以用 top 这个命令看。\n\n#### 什么是线程死锁\n\n死锁是指两个或两个以上的线程在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。\n\n如图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，这两个线程就会互相等待而进入死锁状态。\n\n![线程死锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png)\n\n下面通过代码模拟了上图的死锁的情况（代码来源于《并发编程之美》）：\n\n```java\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();\t//资源 1\n    private static Object resource2 = new Object();\t//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过`Thread.sleep(1000)`；让线程 A 休眠 1s 为的是让线程 B 得到 CPU 执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。\n\n#### 形成死锁的四个必要条件是什么\n\n1. 互斥条件：一个资源只能被一个线程占用，直到被该线程释放；\n2. 请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；\n3. 不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；\n4. 循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞。\n\n#### 如何避免线程死锁\n\n我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n**破坏互斥条件**：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；\n\n**破坏请求与保持条件**：一次性申请所有的资源；\n\n**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，**如果申请不到，可以主动释放它占有的资源**；\n\n**破坏循环等待条件**：靠**按序申请**资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n我们对线程 2 的代码修改成下面这样就不会产生死锁了。\n\n```java\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n```\n\n我们分析一下上面的代码为什么避免了死锁的发生?\n\n线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。\n\n#### 创建线程有哪几种方式？\n\n创建线程有四种方式：\n\n- 继承 Thread 类\n- 实现 Runnable 接口\n- 实现 Callable 接口\n- 使用 Executors 工具类创建线程池\n\n**继承 Thread 类**\n\n1. 定义一个 Thread 类的子类，重写 run 方法；\n2. 创建自定义的线程子类对象；\n3. 调用子类实例的 start() 方法来启动线程。\n\n```java\npublic class Main {\n    static class MyThread extends Thread {\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n    }\n    public static void main(String[] args) {\n        new MyThread().start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Runnable 接口**\n\n1. 定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法；\n2. 创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 实例，**该Thread对象才是真正的线程对象**；\n3. 调用线程实例的 start() 方法。\n\n```java\npublic class Main {\n    static class MyRunnable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n\n    }\n    public static void main(String[] args) {\n        new Thread(new MyRunnable()).start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Callable 接口**\n\n1. 创建实现 Callable 接口的类 myCallable；\n2. 以 myCallable 为参数创建 FutureTask 对象；\n3. 将 FutureTask 作为参数创建 Thread 对象；\n4. 调用线程对象的 start() 方法。\n\n```java\npublic class Main {\n    static class MyCallable implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(Thread.currentThread().getName() + \" call()方法执行中...\");\n            return 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\n        new Thread(futureTask).start();\n        try {\n            Thread.sleep(10);\n            System.out.println(futureTask.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行完成\");\n    }\n}\n```\n\n**使用 Executors 工具类创建线程池**\n\nExecutors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。\n\n主要有 new[Single/Fixed/Cached/Scheduled]ThreadPool 这四种线程池\n\n```java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" run()方法执行中...\");\n    }\n}\n\npublic class SingleThreadExecutorTest {n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        MyRunnable myRunnable = new MyRunnable();\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(myRunnable);\n        }\n\n        System.out.println(\"线程任务开始执行\");\n        executorService.shutdown();\n    }\n}\n```\n\n#### 说一下 runnable 和 callable 有什么区别？\n\n相同点\n\n- 都是接口\n- 都可以用来实现多线程\n- 都创建 Thread 实例并调用其 start() 方法启动线程\n\n主要区别\n\n- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果\n- Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常\n\n#### 线程的 run()和 start()有什么区别？\n\n> start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。\n\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用 run()，其实就相当于是调用了一个普通函数而已。\nstart() 只能调用一次，run() 可以重复调用。\n\n#### 什么是 Callable 和 Future?\n\n```java\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nnew Thread(futureTask).start();\n```\n\n将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，\n之后可以用 future 来获取 callable  中 call() 的返回结果。\n\n#### 线程的状态和基本操作\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n#### Java 中用到的线程调度算法是什么？\n\n线程调度是指按照特定机制为多个线程分配 CPU 的使用权。\n\n有两种调度模型：**时间片轮转**模型和**优先级调度**模型。\n\n**Java 虚拟机采用优先级调度模型**，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。\n\n#### 请说出与线程同步以及线程调度相关的方法。\n\n（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；\n\n（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；\n\n（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\n\n（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n#### wait() 和 sleep() 有什么区别？\n\n两者都可以暂停线程的执行\n\n- 类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。\n- 释放锁：wait() 释放锁，sleep() 不释放锁。\n- 用途不同：wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。\n- 自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。\n\n#### 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\n\n> 使用 while 判断条件是否得到满足\n\n使用 if 来判断会存在以下问题：\n\n1. 另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。\n\n2. 存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。\n\n\t```java\n\tsynchronized (monitor) {\n\t    //  判断条件谓词是否得到满足\n\t    while(!locked) {\n\t        //  等待唤醒\n\t        monitor.wait();\n\t    }\n\t    //  处理其他的业务逻辑\n\t}\n\t```\n\n#### 为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\n\nJava 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。\n\n#### Thread 类中的 yield 方法有什么作用？\n\n使当前线程从运行状态变为就绪状态。\n\n#### 线程的 sleep()方法和 yield()方法有什么区别？\n\n1. sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；\n\n\tyield() 方法只会给**相同或更高优先级**的线程以运行的机会；\n\n2. 线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；\n\n#### 如何停止一个正在运行的线程？\n\n1. 当 run 方法完成后线程终止；\n2. 使用 interrupt 方法中断线程。\n\n#### notify() 和 notifyAll() 有什么区别？\n\n如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n\nnotifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。\n\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n\n#### 如何在两个线程间共享数据？\n\nJava 线程之间的通信由 Java 内存模型（简称 JMM）控制：\n\n1. 所有的共享变量都存在主内存中\n2. 每个线程都保存了一份该线程使用到的共享变量的副本\n3. 如果线程 A 与线程 B 之间要通信：\n\t1. 线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去\n\t2. 线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。\n\n#### Java 如何实现多线程之间的通讯和协作？\n\nJava 中线程通信协作的最常见的两种方式：\n\n1. synchronized 加锁的线程 + Object 类的 wait()/notify()/notifyAll()\n\n2. ReentrantLock 类加锁的线程 + Condition 类的 await()/signal()/signalAll()\n\n#### 同步方法和同步块，哪个是更好的选择？\n\n同步的范围越小越好。\n\n因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。\n\n#### 什么是线程同步和线程互斥，有哪几种实现方式？\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。\n\n实现线程同步的方法：\n\n- 同步代码方法 / 方法块：sychronized 关键字修饰的方法 / 代码块\n- 使用特殊变量域 volatile 实现线程同步：volatile 关键字为域变量的访问提供了一种免锁机制\n- 使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义\n\n#### 在监视器(Monitor)内部，是如何做线程同步的？\n\n在 Java 虚拟机中，每个对象关联一个**监视器**，为了实现监视器的互斥功能，**每个对象都关联着一把锁**。\n\n一旦方法或者代码块被 **synchronized** 修饰，那么这个部分就放入了监视器的监视区域，**确保一次只能有一个线程执行该部分的代码**，线程在获取锁之前不允许执行该部分的代码\n\n另外 Java 还提供了显式监视器 (Lock) 和隐式监视器 (synchronized) 两种锁方案\n\n#### Java 线程数过多会造成什么问题？\n\n- 消耗过多的 CPU 资源\n\n\t如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。\n\n- 降低 JVM 稳定性\n\n\t在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。\n\n## 并发关键字\n\n### synchronized\n\n#### synchronized 的作用？\n\n在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。\n\n#### 怎么使用 synchronized 关键字\n\n**synchronized关键字最主要的三种使用方式：**\n\n- **修饰实例方法：** 给当前对象实例加锁；\n- **修饰静态方法：** 给当前类加锁；\n- **修饰代码块：**给指定对象加锁，进入同步代码块前要获得指定对象的锁。\n\n**总结：** synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。\n\n#### 双重校验锁实现对象单例（线程安全）\n\n```java\npublic class Singleton {\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        // 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例\n        if (uniqueInstance == null) {\t// 线程1、2、3有可能都进来了\n            //类对象加锁\n            synchronized (Singleton.class) {\t// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化\n                if (uniqueInstance == null) {\t// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n\n}\n```\n\n另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。\n\ninstance 采用 volatile 关键字修饰也是很有必要的，instance = new Singleton() 这段代码其实是分为三步执行：\n\n1. 为 instance 分配内存空间\n2. 初始化 instance\n3. 将 instance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此**返回 T1 实例化但未初始化**的 instance。\n\n#### synchronized 底层实现原理？（监视器monitor）\n\nsynchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。\n\nsynchronized 同步语句块的情况\n\n```java\npublic class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n```\n\n通过 JDK 反汇编指令 javap -c -v SynchronizedDemo\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开 monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。\n\n为什么会有两个 monitorexit 呢？（line 19）\n\n这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。**因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。**\n\n#### synchronized 可重入的原理\n\n重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。\n底层原理维护一个**计数器**，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为 0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。\n\n#### 什么是自旋\n\n> 不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环\n\n很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为**线程阻塞涉及到用户态和内核态切换的问题开销很大**，而是**在 synchronized 的边界做忙循环**，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n\n#### 多线程中 synchronized 锁升级的原理是什么？\n\n> 目的：锁升级是为了减低了锁带来的性能消耗。\n\nJava 的锁都是基于对象的，Java 对象有对象头，内容包括：\n\n1. Mark Word，存储对象的 hashCode、锁信息等；\n2. Class Metadata Address，存储到对象类型数据的指针；\n3. 数组的长度（如果是数组）\n\n每一个线程在准备获取共享资源时： \n\n第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “**偏向锁**” ；\n\n第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：\n\n- CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；\n- CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。\n\n第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；\n\n第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；\n\n第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 **轻量级锁**的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；\n\n第六步，进入**重量级锁**的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。\n\n#### 线程 B 怎么知道线程 A 修改了变量\n\n* volatile 修饰变量\n\n* synchronized 修饰修改变量的方法\n* lock 对修改变量的代码块加锁\n\n#### synchronized 和 Lock 有什么区别？\n\n- synchronized 是 Java 关键字，而 Lock 是个接口；\n- synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；\n- synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；\n- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\n#### synchronized 和 ReentrantLock 区别是什么？\n\n**相同点：**\n\n两者都是可重入锁\n\n“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，**如果不可锁重入的话，就会造成死锁**。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。\n\n**不同点：**\n\n* synchronized 是关键字，ReentrantLock 是类；\n* ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；\n\n- ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\n- 二者的锁机制其实也是不一样的：\n\tReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word\n\n### volatile\n\n#### 为什么代码会重排序？\n\n在执行程序时，为了**提高性能**，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：\n\n- **在单线程环境下不能改变程序运行的结果；**\n- **存在数据依赖关系的不允许重排序**\n\n需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。\n\n#### as-if-serial 规则和 happens-before 规则的区别\n\n- as-if-serial 规则保证 **单线程** 内程序的执行结果不被改变，happens-before 规则保证 **正确同步的多线程** 程序的执行结果不被改变。\n- as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n\n#### volatile 关键字的作用\n\n对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n#### JMM内存屏障插入策略\n\n**插入屏障**\n\nStoreStore 屏障 - volatile 写 - StoreLoad 屏障\n\nvolatile 读 - LoadLoad 屏障 - LoadStore 屏障\n\n**volatile 与普通变量的重排序规则**\n\n1. 如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；\n2. 如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；\n3. 如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。\n\n#### volatile 能使得一个非原子操作变成原子操作吗？\n\nvolatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。\n\n#### volatile 修饰符的有过什么实践？\n\n单例模式-双重锁检验里面用 volatile 修饰实例变量。\n\n#### volatile 和 synchronized 的区别是什么？\n\n- volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；\n- volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，\n\t而 synchronized 则可以保证变量的修改原子性和可见性；\n- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；\n- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。synchronized 关键字在 JavaSE1.6 之后进行了主要包括为了**减少获得锁和释放锁带来的性能消耗**而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。\n\n## Lock 体系\n\n### Lock 简介\n\n#### Lock 接口是什么？对比同步它有什么优势？\n\nLock 接口比同步方法和同步块提供了更具扩展性的锁操作。\n\n（1）可以使锁更**公平**\n\n（2）可以使线程在**等待锁的时候响应中断**\n\n（3）可以**让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间**\n\n#### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\n\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。\n\t传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。\n\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n\t乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\n\n#### 什么是 CAS\n\nCAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。\n\n如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。\n\n####  Java实现CAS的原理 - Unsafe类\n\n在 Java 中，有一个`Unsafe`类，它在`sun.misc`包中。它里面是一些`native`方法（由底层的 JVM 使用 C 或者 C++去实现），其中就有几个关于 CAS 的：\n\n```java\nboolean compareAndSwapObject(Object o, long offset,Object expected, Object x);\nboolean compareAndSwapInt(Object o, long offset,int expected,int x);\nboolean compareAndSwapLong(Object o, long offset,long expected,long x);\n```\n\n当然，他们都是`public native`的。\n\nUnsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。\n\nLinux 的 X86 下主要是通过`cmpxchgl`这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用`lock`指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。\n\n当然，Unsafe 类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的`park`和`unpark`， LockSupport 类底层就是调用了这两个方法。还有支持反射操作的`allocateInstance()`方法。\n\n#### CAS 会产生什么问题？\n\n1、**ABA 问题**：\n\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。\n\n2、**循环时间长开销大**：\n\n对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。\n\n3、**只能保证一个共享变量的原子操作**：\n\n当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是**对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁**。\n\n#### 死锁与活锁的区别，死锁与饥饿的区别？\n\n> 区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。\n\n死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n\n活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致**一直重复尝试，失败，尝试，失败**。\n\n活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。\n\n饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。\n\nJava 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。\n\n### AQS详解\n\n#### AQS 介绍\n\nAQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。\n\n使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。\n\n#### AQS 原理分析\n\n**如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。\n如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。**\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。\n\n看个 AQS(AbstractQueuedSynchronizer)原理图：\n\n![AQS原理图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png)\n\nAQS 使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\n```java\nprivate volatile int state;\t// 共享变量，使用volatile修饰保证线程可见性\n```\n\n状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作\n\n```java\n// 返回同步状态的当前值\nprotected final int getState() {  \n    return state;\n}\n// 设置同步状态的值\nprotected final void setState(int newState) { \n    state = newState;\n}\n// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n**AQS 对资源的共享方式**\n\nAQS 定义两种资源共享方式\n\n- **Exclusive**（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：\n\t- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n\t- 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\n- **Share**（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\n**AQS底层使用了模板方法模式**\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器（**模板方法模式**很经典的一个应用）：\n\n1. 使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）\n2. 调用 AQS 的模板方法，会进一步调用使用者重写的方法。\n\n**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**\n\n```java\nisHeldExclusively()\t// 该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)\t// 独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)\t// 独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)\t// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)\t// 共享方式。尝试释放资源，成功则返回true，失败则返回false。\n```\n\n以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。\n\n以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即 state=0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\n\n### 读写锁\n\n首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。\n\nReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，**实现了读写的分离，读锁是共享的，写锁是独占的**，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n\n## 并发容器\n\n### ConcurrentHashMap\n\n#### 什么是ConcurrentHashMap？\n\nConcurrentHashMap 是 Java 中的一个**线程安全且高效的HashMap实现**。\n\n那么它到底是如何实现线程安全的？\n\nJDK 1.6 版本关键要素：\n\n- segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；\n- segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。\n\nJDK1.8 后，ConcurrentHashMap 抛弃了原有的 Segment 分段锁，而**采用了 CAS + synchronized 来保证并发安全性**。\n\n插入元素过程：\n\n如果相应位置的 Node 还没有初始化，则调用 CAS 插入相应的数据；\n\n如果相应位置的 Node 不为空，则对该节点加 synchronized 锁进行插入或更新操作。\n\n### CopyOnWriteArrayList\n\nCopyOnWrite 容器即**写时复制的容器**，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。\n\n**CopyOnWriteArrayList 的使用场景**\n\n通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。\n\n**CopyOnWriteArrayList 的缺点**\n\n1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。\n2. **不能用于实时读的场景**，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，**读取到数据可能还是旧的**，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。\n\n### ThreadLocal\n\n#### ThreadLocal的数据结构\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry 为 <threadLocal 的弱引用，value 为强引用> 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。\n\n```java\npublic class ThreadLocalDemo {\n    // private static final ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>(){\n    //     @Override\n    //     protected Integer initialValue() {\n    //         return 0;\n    //     }\n    // };\n\n    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++) {\n            new Thread(() -> {\n                for (int j = 0; j < 5; j++) {\n                    Integer val = threadLocal.get();\n                    threadLocal.set(++val);\n                    System.out.println(Thread.currentThread().getName() + \" ---- \" + val);\n                }\n            }, \"Thread-\" + i).start();\n        }\n\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(Thread.currentThread().getName() + \" ---- \" + threadLocal.get());\n    }\n}\n```\n\n打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后 threadLocal.get 仍然是 0\n\n```java\nThread-1 ---- 1\nThread-0 ---- 1\nThread-1 ---- 2\nThread-0 ---- 2\nThread-1 ---- 3\nThread-1 ---- 4\nThread-1 ---- 5\nThread-0 ---- 3\nThread-0 ---- 4\nThread-0 ---- 5\nmain ---- 0\n```\n\n### ThreadLocal内存泄漏\n\n#### ThreadLocal造成内存泄漏的原因？\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的 remove()方法，清理掉 key 为 null 的记录。\n\n### BlockingQueue\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。\n\n在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n\n阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\nJDK7 提供了 7 个阻塞队列。分别是：\n\n> ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\n> LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\n> PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\n> DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n> SynchronousQueue：一个不存储元素的阻塞队列。\n> LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n> LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\nJava 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。\n\nBlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，**当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞**，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。\n\n## 线程池\n\n### Executors 创建四种常见线程池\n\n#### 什么是线程池？有哪几种创建方式？\n\n> 池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是**尽可能减少创建和销毁对象的次数**，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。\n\n线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\n\n（1）Executors.newSingleThreadExecutor：`1, 1, new LinkedBlockingQueue`。所有任务按照**先来先执行**的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）\n\n（2）Executors.newFixedThreadPool：`nCoreThreads, nCoreThreads, new LinkedBlockingQueue`，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）\n\n（3） Executors.newCachedThreadPool：`0, Integer.MAX_VALUE`，不创建核心线程，线程池最大为 Integer.MAX_VALUE。（线程池太大导致 OOM）\n\nnewCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。\nFixedThreadPool 是因为阻塞队列可以很大（最大为 Integer 最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为 Integer 最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。\n\n（4）Executors.newScheduledThreadPool：`nCoreThreads, Integer.MAX_VALUE`创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n#### 线程池有什么优点？\n\n- 降低资源消耗：重用存在的线程，减少对象创建销毁的开销；\n- 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；\n- 提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。\n\n#### 线程池都有哪些状态？\n\n- RUNNING：接受新的任务提交，处理等待队列中的任务；\n- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；\n- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；\n- TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；\n- TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n#### 在 Java 中 Executor 和 Executors 的区别？\n\n- **Executors 工具类**的不同方法按照我们的需求**创建了不同的线程池**，来满足业务的需求；\n- **Executor 接口对象执行我们的线程任务**，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。\n\n#### 线程池中 submit() 和 execute() 方法有什么区别？\n\n接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而 execute()只能执行 Runnable 类型的任务；\n\n返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；\n\n异常处理：submit() 方便 Exception 处理。\n\n### ThreadPoolExecutor 自定义线程池\n\n#### Executors\n\n《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是**通过 ThreadPoolExecutor 的方式**，这样的处理方式让写的同学**更加明确线程池的运行规则，规避资源耗尽的风险**\n\nExecutors 各个方法的弊端：\n\n- newSingleThreadExecutor 和 newFixedThreadPool :\n\t`0, 0`和 `n, n` ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE\n\n\t主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。\n\n- newCachedThreadPool 和 newScheduledThreadPool:\n\t`0, Integer.MAX_VALUE` 和 `n, Integer.MAX_VALUE`\n\n\t主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM\n\nThreaPoolExecutor 创建线程池方式只有一种，就是走它的构造函数，参数自己指定\n\n#### ThreaPoolExecutor \n\n创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。\n\nThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。\n\n#### ThreadPoolExecutor构造函数重要参数分析\n\n**`ThreadPoolExecutor`** **3 个最重要的参数：**\n\n- **`corePoolSize`** ：核心线程数，线程数定义了最小可以同时运行的线程数量\n- **`maximumPoolSize`** ：线程池中允许存在的工作线程的最大数量\n- **`workQueue`**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中\n\n`ThreadPoolExecutor`其他常见参数:\n\n1. **`keepAliveTime`**：非核心线程如果处于闲置状态超过该值，就会被销毁。\n2. **`unit`** ：`keepAliveTime` 闲置销毁时长的时间单位\n3. **`threadFactory`**：为线程池提供创建新线程的线程工厂\n4. **`handler`** ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略\n\n#### ThreadPoolExecutor拒绝策略\n\n**`ThreadPoolExecutor`** **拒绝策略定义:**\n\n如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，`ThreadPoolTaskExecutor` 定义一些策略:\n\n- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。\n- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务。\n- **`ThreadPoolExecutor.DiscardPolicy`**：不处理新任务，直接丢弃掉。\n- **`ThreadPoolExecutor.DiscardOldestPolicy`**： 此策略将丢弃最早的未处理的任务请求。\n\n#### 一个简单的线程池Demo:`Runnable` + `ThreadPoolExecutor`\n\n线程池实现原理\n\n![线程池实现原理](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png)\n\n**总结一下处理流程**\n\n1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到 corePoolSize，在核心线程数量 < corePoolSize 时）。**注意，这一步需要获得全局锁。**\n2. 线程总数量 >= corePoolSize 时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了**线程复用**）。 \n3. 当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**\n4. 缓存队列之前满了， 现在加非核心线程且总线程数达到了 maximumPoolSize，则会采取上面提到的拒绝策略进行处理。\n\n整个过程如图所示：\n\n为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。\n\n首先创建一个 `Runnable` 接口的实现类（当然也可以是 `Callable` 接口，我们上面也说了两者的区别。）\n\n```java\nimport Java.util.Date;\n\n/**\n * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n */\npublic class MyRunnable implements Runnable {\n\n    private String command;\n\n    public MyRunnable(String s) {\n        this.command = s;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n        processCommand();\n        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n    }\n\n    private void processCommand() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return this.command;\n    }\n}\n```\n\n编写测试程序，我们这里以阿里巴巴推荐的使用 `ThreadPoolExecutor` 构造函数自定义参数的方式来创建线程池。\n\n```java\nimport Java.util.concurrent.ArrayBlockingQueue;\nimport Java.util.concurrent.ThreadPoolExecutor;\nimport Java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolExecutorDemo {\n\n    private static final int CORE_POOL_SIZE = 5;\n    private static final int MAX_POOL_SIZE = 10;\n    private static final int QUEUE_CAPACITY = 100;\n    private static final Long KEEP_ALIVE_TIME = 1L;\n    public static void main(String[] args) {\n\n        //使用阿里巴巴推荐的创建线程池的方式\n        //通过ThreadPoolExecutor构造函数自定义参数创建\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE,\n                MAX_POOL_SIZE,\n                KEEP_ALIVE_TIME,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n                new ThreadPoolExecutor.CallerRunsPolicy());\n\n        for (int i = 0; i < 10; i++) {\n            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n            Runnable worker = new MyRunnable(\"\" + i);\n            //执行Runnable\n            executor.execute(worker);\n        }\n        //终止线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n        }\n        System.out.println(\"Finished all threads\");\n    }\n}\n```\n\n可以看到我们上面的代码指定了：\n\n1. `corePoolSize`: 核心线程数为 5。\n2. `maximumPoolSize` ：最大线程数 10\n3. `keepAliveTime` : 等待时间为 1L。\n4. `unit`: 等待时间的单位为 TimeUnit.SECONDS。\n5. `workQueue`：任务队列为 `ArrayBlockingQueue`，并且容量为 100;\n6. `handler`:饱和策略为 `CallerRunsPolicy`。\n\n**Output：**\n\n```java\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:54 CST 2019\n```\n\n## 并发工具\n\n### CountDownLatch 与 CyclicBarrier\n\nCountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n\n- CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；\n- 调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；\n- CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。\n\n### Semaphore\n\n**Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\n\nSemaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。\n\n## 模拟\n\n### 死锁\n\n```java\npublic class DeadLock {\n    private static Object A = new Object();\n    private static Object B = new Object();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (A) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源B\");\n                synchronized (B) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                }\n            }\n        }, \"线程1\").start();\n\n        new Thread(() -> {\n            synchronized (B) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源A\");\n                synchronized (A) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                }\n            }\n        }, \"线程2\").start();\n    }\n}\n```\n\n> 线程1 已获得资源A\n> 线程2 已获得资源B\n> 线程1 等待获得资源B\n> 线程2 等待获得资源A\n\n### run方法和start方法\n\n```java\npublic class DiffStartRun {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程A\").run();\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程B\").start();\n    }\n}\n```\n\n> main\n> 线程B\n>\n> new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。\n>\n> **总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。**\n\n### 两个线程，交替加减\n\n1. synchronized\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithSync {\n\t    private static int value = 0;\n\t\n\t    private static final Object lock = new Object();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 0) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 1) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t\n\t}\n\t```\n\n2. lock + condition\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithLock {\n\t    private static int value = 0;\n\t\n\t    private static final Lock lock = new ReentrantLock();\n\t\n\t    static Condition a = lock.newCondition();\n\t\n\t    static Condition b = lock.newCondition();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 0) {\n\t                        a.await();\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    b.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 1) {\n\t                        b.await();\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    a.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t}\n\t```\n\n### 三个线程，循环打印\n\n```java\npublic class Demo5 {\n    private int value = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition a = lock.newCondition();\n    private Condition b = lock.newCondition();\n    private Condition c = lock.newCondition();\n\n    public void outputA(int round) {\n        try {\n            lock.lock();\n            while (value != 0) {\n                a.await();\n            }\n            value = 1;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出A\");\n            b.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputB(int round) {\n        try {\n            lock.lock();\n            while (value != 1) {\n                b.await();\n            }\n            value = 2;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出B\");\n            c.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputC(int round) {\n        try {\n            lock.lock();\n            while (value != 2) {\n                c.await();\n            }\n            value = 0;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出C\");\n            a.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo5 s = new Demo5();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputA(i);\n            }\n        }, \"Thread-A\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputB(i);\n            }\n        }, \"Thread-B\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputC(i);\n            }\n        }, \"Thread-C\").start();\n\n    }\n}\n```\n","source":"_posts/Java八股文 - Java并发.md","raw":"---\ntitle: Java八股文 - Java并发\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 15:29:48\ntags:\ntoc: true\nurlname: java-concurrent-programming\n---\n\n> 整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 基础知识\n\n### 并发编程的优缺点\n\n优点：为了能提高程序的执行效率，提高程序运行速度；\n\n缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。\n\n#### 并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\n\n并发编程三要素（线程的安全性问题体现在）：\n\n**原子性**：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）\n\n**可见性**：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）\n\n**有序性**：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）\n\n> volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用`atomicInteger.getAndSet()`原子操作。\n\n### 线程和进程\n\n#### 进程间的通信方式\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；\n2. **有名管道(Names Pipes)**：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；\n3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n4. **消息队列(Message Queuing)** ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**；\n5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件；\n6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式；\n7. **套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n#### 线程间的同步方式\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；\n2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；\n3. **事件(Event)** ：wait/notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\n\n#### 什么是线程和进程?\n\n**进程**：进程是应用程序的一次运行，每个进程都有自己独立的内存空间，是操作系统资源分配的基本单位；\n\n**线程**：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。\n\n#### 什么是上下文切换?\n\n多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。\n\n当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。\n\n#### 守护线程和用户线程有什么区别呢？\n\n- **用户 (User) 线程**：运行在前台，执行具体的任务\n- **守护 (Daemon) 线程**：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作\n\n**注意事项：**\n\n1. `setDaemon(true)`必须在`start()`方法前执行，否则会抛出 `IllegalThreadStateException` 异常；\n2. 在守护线程中产生的新线程也是守护线程；\n3. 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；\n4. 守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。\n\n#### 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\n\nWindows 下用任务管理器看，Linux 下可以用 top 这个命令看。\n\n#### 什么是线程死锁\n\n死锁是指两个或两个以上的线程在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。\n\n如图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，这两个线程就会互相等待而进入死锁状态。\n\n![线程死锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png)\n\n下面通过代码模拟了上图的死锁的情况（代码来源于《并发编程之美》）：\n\n```java\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();\t//资源 1\n    private static Object resource2 = new Object();\t//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过`Thread.sleep(1000)`；让线程 A 休眠 1s 为的是让线程 B 得到 CPU 执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。\n\n#### 形成死锁的四个必要条件是什么\n\n1. 互斥条件：一个资源只能被一个线程占用，直到被该线程释放；\n2. 请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；\n3. 不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；\n4. 循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞。\n\n#### 如何避免线程死锁\n\n我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n\n**破坏互斥条件**：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；\n\n**破坏请求与保持条件**：一次性申请所有的资源；\n\n**破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，**如果申请不到，可以主动释放它占有的资源**；\n\n**破坏循环等待条件**：靠**按序申请**资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n我们对线程 2 的代码修改成下面这样就不会产生死锁了。\n\n```java\nnew Thread(() -> {\n    synchronized (resource1) {\n        System.out.println(Thread.currentThread() + \"get resource1\");\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread() + \"waiting get resource2\");\n        synchronized (resource2) {\n            System.out.println(Thread.currentThread() + \"get resource2\");\n        }\n    }\n}, \"线程 2\").start();\n```\n\n输出结果\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 1,5,main]waiting get resource2\nThread[线程 1,5,main]get resource2\nThread[线程 2,5,main]get resource1\nThread[线程 2,5,main]waiting get resource2\nThread[线程 2,5,main]get resource2\n```\n\n我们分析一下上面的代码为什么避免了死锁的发生?\n\n线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。\n\n#### 创建线程有哪几种方式？\n\n创建线程有四种方式：\n\n- 继承 Thread 类\n- 实现 Runnable 接口\n- 实现 Callable 接口\n- 使用 Executors 工具类创建线程池\n\n**继承 Thread 类**\n\n1. 定义一个 Thread 类的子类，重写 run 方法；\n2. 创建自定义的线程子类对象；\n3. 调用子类实例的 start() 方法来启动线程。\n\n```java\npublic class Main {\n    static class MyThread extends Thread {\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n    }\n    public static void main(String[] args) {\n        new MyThread().start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Runnable 接口**\n\n1. 定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法；\n2. 创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 实例，**该Thread对象才是真正的线程对象**；\n3. 调用线程实例的 start() 方法。\n\n```java\npublic class Main {\n    static class MyRunnable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getName() + \" run()方法正在执行...\");\n        }\n\n    }\n    public static void main(String[] args) {\n        new Thread(new MyRunnable()).start();\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行结束\");\n    }\n}\n```\n\n**实现 Callable 接口**\n\n1. 创建实现 Callable 接口的类 myCallable；\n2. 以 myCallable 为参数创建 FutureTask 对象；\n3. 将 FutureTask 作为参数创建 Thread 对象；\n4. 调用线程对象的 start() 方法。\n\n```java\npublic class Main {\n    static class MyCallable implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(Thread.currentThread().getName() + \" call()方法执行中...\");\n            return 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\n        new Thread(futureTask).start();\n        try {\n            Thread.sleep(10);\n            System.out.println(futureTask.get());\n        } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \" main()方法执行完成\");\n    }\n}\n```\n\n**使用 Executors 工具类创建线程池**\n\nExecutors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。\n\n主要有 new[Single/Fixed/Cached/Scheduled]ThreadPool 这四种线程池\n\n```java\npublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" run()方法执行中...\");\n    }\n}\n\npublic class SingleThreadExecutorTest {n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        MyRunnable myRunnable = new MyRunnable();\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(myRunnable);\n        }\n\n        System.out.println(\"线程任务开始执行\");\n        executorService.shutdown();\n    }\n}\n```\n\n#### 说一下 runnable 和 callable 有什么区别？\n\n相同点\n\n- 都是接口\n- 都可以用来实现多线程\n- 都创建 Thread 实例并调用其 start() 方法启动线程\n\n主要区别\n\n- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果\n- Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常\n\n#### 线程的 run()和 start()有什么区别？\n\n> start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。\n\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用 run()，其实就相当于是调用了一个普通函数而已。\nstart() 只能调用一次，run() 可以重复调用。\n\n#### 什么是 Callable 和 Future?\n\n```java\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nnew Thread(futureTask).start();\n```\n\n将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，\n之后可以用 future 来获取 callable  中 call() 的返回结果。\n\n#### 线程的状态和基本操作\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n#### Java 中用到的线程调度算法是什么？\n\n线程调度是指按照特定机制为多个线程分配 CPU 的使用权。\n\n有两种调度模型：**时间片轮转**模型和**优先级调度**模型。\n\n**Java 虚拟机采用优先级调度模型**，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。\n\n#### 请说出与线程同步以及线程调度相关的方法。\n\n（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；\n\n（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；\n\n（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\n\n（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n#### wait() 和 sleep() 有什么区别？\n\n两者都可以暂停线程的执行\n\n- 类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。\n- 释放锁：wait() 释放锁，sleep() 不释放锁。\n- 用途不同：wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。\n- 自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。\n\n#### 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\n\n> 使用 while 判断条件是否得到满足\n\n使用 if 来判断会存在以下问题：\n\n1. 另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。\n\n2. 存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。\n\n\t```java\n\tsynchronized (monitor) {\n\t    //  判断条件谓词是否得到满足\n\t    while(!locked) {\n\t        //  等待唤醒\n\t        monitor.wait();\n\t    }\n\t    //  处理其他的业务逻辑\n\t}\n\t```\n\n#### 为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\n\nJava 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。\n\n#### Thread 类中的 yield 方法有什么作用？\n\n使当前线程从运行状态变为就绪状态。\n\n#### 线程的 sleep()方法和 yield()方法有什么区别？\n\n1. sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；\n\n\tyield() 方法只会给**相同或更高优先级**的线程以运行的机会；\n\n2. 线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；\n\n#### 如何停止一个正在运行的线程？\n\n1. 当 run 方法完成后线程终止；\n2. 使用 interrupt 方法中断线程。\n\n#### notify() 和 notifyAll() 有什么区别？\n\n如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n\nnotifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。\n\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n\n#### 如何在两个线程间共享数据？\n\nJava 线程之间的通信由 Java 内存模型（简称 JMM）控制：\n\n1. 所有的共享变量都存在主内存中\n2. 每个线程都保存了一份该线程使用到的共享变量的副本\n3. 如果线程 A 与线程 B 之间要通信：\n\t1. 线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去\n\t2. 线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。\n\n#### Java 如何实现多线程之间的通讯和协作？\n\nJava 中线程通信协作的最常见的两种方式：\n\n1. synchronized 加锁的线程 + Object 类的 wait()/notify()/notifyAll()\n\n2. ReentrantLock 类加锁的线程 + Condition 类的 await()/signal()/signalAll()\n\n#### 同步方法和同步块，哪个是更好的选择？\n\n同步的范围越小越好。\n\n因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。\n\n#### 什么是线程同步和线程互斥，有哪几种实现方式？\n\n线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\n\n线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。\n\n实现线程同步的方法：\n\n- 同步代码方法 / 方法块：sychronized 关键字修饰的方法 / 代码块\n- 使用特殊变量域 volatile 实现线程同步：volatile 关键字为域变量的访问提供了一种免锁机制\n- 使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义\n\n#### 在监视器(Monitor)内部，是如何做线程同步的？\n\n在 Java 虚拟机中，每个对象关联一个**监视器**，为了实现监视器的互斥功能，**每个对象都关联着一把锁**。\n\n一旦方法或者代码块被 **synchronized** 修饰，那么这个部分就放入了监视器的监视区域，**确保一次只能有一个线程执行该部分的代码**，线程在获取锁之前不允许执行该部分的代码\n\n另外 Java 还提供了显式监视器 (Lock) 和隐式监视器 (synchronized) 两种锁方案\n\n#### Java 线程数过多会造成什么问题？\n\n- 消耗过多的 CPU 资源\n\n\t如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。\n\n- 降低 JVM 稳定性\n\n\t在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。\n\n## 并发关键字\n\n### synchronized\n\n#### synchronized 的作用？\n\n在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。\n\n#### 怎么使用 synchronized 关键字\n\n**synchronized关键字最主要的三种使用方式：**\n\n- **修饰实例方法：** 给当前对象实例加锁；\n- **修饰静态方法：** 给当前类加锁；\n- **修饰代码块：**给指定对象加锁，进入同步代码块前要获得指定对象的锁。\n\n**总结：** synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。\n\n#### 双重校验锁实现对象单例（线程安全）\n\n```java\npublic class Singleton {\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        // 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例\n        if (uniqueInstance == null) {\t// 线程1、2、3有可能都进来了\n            //类对象加锁\n            synchronized (Singleton.class) {\t// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化\n                if (uniqueInstance == null) {\t// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n\n}\n```\n\n另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。\n\ninstance 采用 volatile 关键字修饰也是很有必要的，instance = new Singleton() 这段代码其实是分为三步执行：\n\n1. 为 instance 分配内存空间\n2. 初始化 instance\n3. 将 instance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此**返回 T1 实例化但未初始化**的 instance。\n\n#### synchronized 底层实现原理？（监视器monitor）\n\nsynchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。\n\nsynchronized 同步语句块的情况\n\n```java\npublic class SynchronizedDemo {\n    public void method() {\n        synchronized (this) {\n            System.out.println(\"synchronized 代码块\");\n        }\n    }\n}\n```\n\n通过 JDK 反汇编指令 javap -c -v SynchronizedDemo\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开 monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。\n\n为什么会有两个 monitorexit 呢？（line 19）\n\n这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。**因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。**\n\n#### synchronized 可重入的原理\n\n重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。\n底层原理维护一个**计数器**，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为 0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。\n\n#### 什么是自旋\n\n> 不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环\n\n很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为**线程阻塞涉及到用户态和内核态切换的问题开销很大**，而是**在 synchronized 的边界做忙循环**，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n\n#### 多线程中 synchronized 锁升级的原理是什么？\n\n> 目的：锁升级是为了减低了锁带来的性能消耗。\n\nJava 的锁都是基于对象的，Java 对象有对象头，内容包括：\n\n1. Mark Word，存储对象的 hashCode、锁信息等；\n2. Class Metadata Address，存储到对象类型数据的指针；\n3. 数组的长度（如果是数组）\n\n每一个线程在准备获取共享资源时： \n\n第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “**偏向锁**” ；\n\n第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：\n\n- CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；\n- CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。\n\n第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；\n\n第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；\n\n第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 **轻量级锁**的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；\n\n第六步，进入**重量级锁**的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。\n\n#### 线程 B 怎么知道线程 A 修改了变量\n\n* volatile 修饰变量\n\n* synchronized 修饰修改变量的方法\n* lock 对修改变量的代码块加锁\n\n#### synchronized 和 Lock 有什么区别？\n\n- synchronized 是 Java 关键字，而 Lock 是个接口；\n- synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；\n- synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；\n- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n\n#### synchronized 和 ReentrantLock 区别是什么？\n\n**相同点：**\n\n两者都是可重入锁\n\n“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，**如果不可锁重入的话，就会造成死锁**。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。\n\n**不同点：**\n\n* synchronized 是关键字，ReentrantLock 是类；\n* ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；\n\n- ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\n- 二者的锁机制其实也是不一样的：\n\tReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word\n\n### volatile\n\n#### 为什么代码会重排序？\n\n在执行程序时，为了**提高性能**，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：\n\n- **在单线程环境下不能改变程序运行的结果；**\n- **存在数据依赖关系的不允许重排序**\n\n需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。\n\n#### as-if-serial 规则和 happens-before 规则的区别\n\n- as-if-serial 规则保证 **单线程** 内程序的执行结果不被改变，happens-before 规则保证 **正确同步的多线程** 程序的执行结果不被改变。\n- as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n\n#### volatile 关键字的作用\n\n对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n\n#### JMM内存屏障插入策略\n\n**插入屏障**\n\nStoreStore 屏障 - volatile 写 - StoreLoad 屏障\n\nvolatile 读 - LoadLoad 屏障 - LoadStore 屏障\n\n**volatile 与普通变量的重排序规则**\n\n1. 如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；\n2. 如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；\n3. 如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。\n\n#### volatile 能使得一个非原子操作变成原子操作吗？\n\nvolatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。\n\n#### volatile 修饰符的有过什么实践？\n\n单例模式-双重锁检验里面用 volatile 修饰实例变量。\n\n#### volatile 和 synchronized 的区别是什么？\n\n- volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；\n- volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，\n\t而 synchronized 则可以保证变量的修改原子性和可见性；\n- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；\n- **volatile关键字**是线程同步的**轻量级实现**，所以**volatile性能肯定比synchronized关键字要好**。synchronized 关键字在 JavaSE1.6 之后进行了主要包括为了**减少获得锁和释放锁带来的性能消耗**而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，**实际开发中使用 synchronized 关键字的场景还是更多一些**。\n\n## Lock 体系\n\n### Lock 简介\n\n#### Lock 接口是什么？对比同步它有什么优势？\n\nLock 接口比同步方法和同步块提供了更具扩展性的锁操作。\n\n（1）可以使锁更**公平**\n\n（2）可以使线程在**等待锁的时候响应中断**\n\n（3）可以**让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间**\n\n#### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\n\n悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。\n\t传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。\n\n乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。\n\t乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\n\n#### 什么是 CAS\n\nCAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。\n\nCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。\n\n如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。\n\n####  Java实现CAS的原理 - Unsafe类\n\n在 Java 中，有一个`Unsafe`类，它在`sun.misc`包中。它里面是一些`native`方法（由底层的 JVM 使用 C 或者 C++去实现），其中就有几个关于 CAS 的：\n\n```java\nboolean compareAndSwapObject(Object o, long offset,Object expected, Object x);\nboolean compareAndSwapInt(Object o, long offset,int expected,int x);\nboolean compareAndSwapLong(Object o, long offset,long expected,long x);\n```\n\n当然，他们都是`public native`的。\n\nUnsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。\n\nLinux 的 X86 下主要是通过`cmpxchgl`这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用`lock`指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。\n\n当然，Unsafe 类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的`park`和`unpark`， LockSupport 类底层就是调用了这两个方法。还有支持反射操作的`allocateInstance()`方法。\n\n#### CAS 会产生什么问题？\n\n1、**ABA 问题**：\n\n比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。\n\n2、**循环时间长开销大**：\n\n对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。\n\n3、**只能保证一个共享变量的原子操作**：\n\n当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是**对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁**。\n\n#### 死锁与活锁的区别，死锁与饥饿的区别？\n\n> 区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。\n\n死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。\n\n活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致**一直重复尝试，失败，尝试，失败**。\n\n活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。\n\n饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。\n\nJava 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。\n\n### AQS详解\n\n#### AQS 介绍\n\nAQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。\n\n使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。\n\n#### AQS 原理分析\n\n**如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。\n如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。**\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。\n\n看个 AQS(AbstractQueuedSynchronizer)原理图：\n\n![AQS原理图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png)\n\nAQS 使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\n```java\nprivate volatile int state;\t// 共享变量，使用volatile修饰保证线程可见性\n```\n\n状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作\n\n```java\n// 返回同步状态的当前值\nprotected final int getState() {  \n    return state;\n}\n// 设置同步状态的值\nprotected final void setState(int newState) { \n    state = newState;\n}\n// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n**AQS 对资源的共享方式**\n\nAQS 定义两种资源共享方式\n\n- **Exclusive**（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：\n\t- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n\t- 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的\n- **Share**（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\n**AQS底层使用了模板方法模式**\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器（**模板方法模式**很经典的一个应用）：\n\n1. 使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）\n2. 调用 AQS 的模板方法，会进一步调用使用者重写的方法。\n\n**AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：**\n\n```java\nisHeldExclusively()\t// 该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)\t// 独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)\t// 独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)\t// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)\t// 共享方式。尝试释放资源，成功则返回true，失败则返回false。\n```\n\n以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。\n\n以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即 state=0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\n\n### 读写锁\n\n首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。\n\nReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，**实现了读写的分离，读锁是共享的，写锁是独占的**，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n\n## 并发容器\n\n### ConcurrentHashMap\n\n#### 什么是ConcurrentHashMap？\n\nConcurrentHashMap 是 Java 中的一个**线程安全且高效的HashMap实现**。\n\n那么它到底是如何实现线程安全的？\n\nJDK 1.6 版本关键要素：\n\n- segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；\n- segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。\n\nJDK1.8 后，ConcurrentHashMap 抛弃了原有的 Segment 分段锁，而**采用了 CAS + synchronized 来保证并发安全性**。\n\n插入元素过程：\n\n如果相应位置的 Node 还没有初始化，则调用 CAS 插入相应的数据；\n\n如果相应位置的 Node 不为空，则对该节点加 synchronized 锁进行插入或更新操作。\n\n### CopyOnWriteArrayList\n\nCopyOnWrite 容器即**写时复制的容器**，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。\n\n**CopyOnWriteArrayList 的使用场景**\n\n通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。\n\n**CopyOnWriteArrayList 的缺点**\n\n1. 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。\n2. **不能用于实时读的场景**，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，**读取到数据可能还是旧的**，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。\n\n### ThreadLocal\n\n#### ThreadLocal的数据结构\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry 为 <threadLocal 的弱引用，value 为强引用> 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。\n\n```java\npublic class ThreadLocalDemo {\n    // private static final ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>(){\n    //     @Override\n    //     protected Integer initialValue() {\n    //         return 0;\n    //     }\n    // };\n\n    private static final ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 2; i++) {\n            new Thread(() -> {\n                for (int j = 0; j < 5; j++) {\n                    Integer val = threadLocal.get();\n                    threadLocal.set(++val);\n                    System.out.println(Thread.currentThread().getName() + \" ---- \" + val);\n                }\n            }, \"Thread-\" + i).start();\n        }\n\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(Thread.currentThread().getName() + \" ---- \" + threadLocal.get());\n    }\n}\n```\n\n打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后 threadLocal.get 仍然是 0\n\n```java\nThread-1 ---- 1\nThread-0 ---- 1\nThread-1 ---- 2\nThread-0 ---- 2\nThread-1 ---- 3\nThread-1 ---- 4\nThread-1 ---- 5\nThread-0 ---- 3\nThread-0 ---- 4\nThread-0 ---- 5\nmain ---- 0\n```\n\n### ThreadLocal内存泄漏\n\n#### ThreadLocal造成内存泄漏的原因？\n\nThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的 remove()方法，清理掉 key 为 null 的记录。\n\n### BlockingQueue\n\n阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。\n\n在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n\n阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\nJDK7 提供了 7 个阻塞队列。分别是：\n\n> ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\n> LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\n> PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\n> DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n> SynchronousQueue：一个不存储元素的阻塞队列。\n> LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n> LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\nJava 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。\n\nBlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，**当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞**，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。\n\n## 线程池\n\n### Executors 创建四种常见线程池\n\n#### 什么是线程池？有哪几种创建方式？\n\n> 池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是**尽可能减少创建和销毁对象的次数**，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。\n\n线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：\n\n（1）Executors.newSingleThreadExecutor：`1, 1, new LinkedBlockingQueue`。所有任务按照**先来先执行**的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）\n\n（2）Executors.newFixedThreadPool：`nCoreThreads, nCoreThreads, new LinkedBlockingQueue`，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）\n\n（3） Executors.newCachedThreadPool：`0, Integer.MAX_VALUE`，不创建核心线程，线程池最大为 Integer.MAX_VALUE。（线程池太大导致 OOM）\n\nnewCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。\nFixedThreadPool 是因为阻塞队列可以很大（最大为 Integer 最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为 Integer 最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。\n\n（4）Executors.newScheduledThreadPool：`nCoreThreads, Integer.MAX_VALUE`创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n\n#### 线程池有什么优点？\n\n- 降低资源消耗：重用存在的线程，减少对象创建销毁的开销；\n- 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；\n- 提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。\n\n#### 线程池都有哪些状态？\n\n- RUNNING：接受新的任务提交，处理等待队列中的任务；\n- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；\n- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；\n- TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；\n- TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n\n#### 在 Java 中 Executor 和 Executors 的区别？\n\n- **Executors 工具类**的不同方法按照我们的需求**创建了不同的线程池**，来满足业务的需求；\n- **Executor 接口对象执行我们的线程任务**，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。\n\n#### 线程池中 submit() 和 execute() 方法有什么区别？\n\n接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而 execute()只能执行 Runnable 类型的任务；\n\n返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；\n\n异常处理：submit() 方便 Exception 处理。\n\n### ThreadPoolExecutor 自定义线程池\n\n#### Executors\n\n《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是**通过 ThreadPoolExecutor 的方式**，这样的处理方式让写的同学**更加明确线程池的运行规则，规避资源耗尽的风险**\n\nExecutors 各个方法的弊端：\n\n- newSingleThreadExecutor 和 newFixedThreadPool :\n\t`0, 0`和 `n, n` ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE\n\n\t主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。\n\n- newCachedThreadPool 和 newScheduledThreadPool:\n\t`0, Integer.MAX_VALUE` 和 `n, Integer.MAX_VALUE`\n\n\t主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM\n\nThreaPoolExecutor 创建线程池方式只有一种，就是走它的构造函数，参数自己指定\n\n#### ThreaPoolExecutor \n\n创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。\n\nThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。\n\n#### ThreadPoolExecutor构造函数重要参数分析\n\n**`ThreadPoolExecutor`** **3 个最重要的参数：**\n\n- **`corePoolSize`** ：核心线程数，线程数定义了最小可以同时运行的线程数量\n- **`maximumPoolSize`** ：线程池中允许存在的工作线程的最大数量\n- **`workQueue`**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中\n\n`ThreadPoolExecutor`其他常见参数:\n\n1. **`keepAliveTime`**：非核心线程如果处于闲置状态超过该值，就会被销毁。\n2. **`unit`** ：`keepAliveTime` 闲置销毁时长的时间单位\n3. **`threadFactory`**：为线程池提供创建新线程的线程工厂\n4. **`handler`** ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略\n\n#### ThreadPoolExecutor拒绝策略\n\n**`ThreadPoolExecutor`** **拒绝策略定义:**\n\n如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，`ThreadPoolTaskExecutor` 定义一些策略:\n\n- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。\n- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务。\n- **`ThreadPoolExecutor.DiscardPolicy`**：不处理新任务，直接丢弃掉。\n- **`ThreadPoolExecutor.DiscardOldestPolicy`**： 此策略将丢弃最早的未处理的任务请求。\n\n#### 一个简单的线程池Demo:`Runnable` + `ThreadPoolExecutor`\n\n线程池实现原理\n\n![线程池实现原理](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png)\n\n**总结一下处理流程**\n\n1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到 corePoolSize，在核心线程数量 < corePoolSize 时）。**注意，这一步需要获得全局锁。**\n2. 线程总数量 >= corePoolSize 时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了**线程复用**）。 \n3. 当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**\n4. 缓存队列之前满了， 现在加非核心线程且总线程数达到了 maximumPoolSize，则会采取上面提到的拒绝策略进行处理。\n\n整个过程如图所示：\n\n为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。\n\n首先创建一个 `Runnable` 接口的实现类（当然也可以是 `Callable` 接口，我们上面也说了两者的区别。）\n\n```java\nimport Java.util.Date;\n\n/**\n * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。\n */\npublic class MyRunnable implements Runnable {\n\n    private String command;\n\n    public MyRunnable(String s) {\n        this.command = s;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" Start. Time = \" + new Date());\n        processCommand();\n        System.out.println(Thread.currentThread().getName() + \" End. Time = \" + new Date());\n    }\n\n    private void processCommand() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public String toString() {\n        return this.command;\n    }\n}\n```\n\n编写测试程序，我们这里以阿里巴巴推荐的使用 `ThreadPoolExecutor` 构造函数自定义参数的方式来创建线程池。\n\n```java\nimport Java.util.concurrent.ArrayBlockingQueue;\nimport Java.util.concurrent.ThreadPoolExecutor;\nimport Java.util.concurrent.TimeUnit;\n\npublic class ThreadPoolExecutorDemo {\n\n    private static final int CORE_POOL_SIZE = 5;\n    private static final int MAX_POOL_SIZE = 10;\n    private static final int QUEUE_CAPACITY = 100;\n    private static final Long KEEP_ALIVE_TIME = 1L;\n    public static void main(String[] args) {\n\n        //使用阿里巴巴推荐的创建线程池的方式\n        //通过ThreadPoolExecutor构造函数自定义参数创建\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(\n                CORE_POOL_SIZE,\n                MAX_POOL_SIZE,\n                KEEP_ALIVE_TIME,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(QUEUE_CAPACITY),\n                new ThreadPoolExecutor.CallerRunsPolicy());\n\n        for (int i = 0; i < 10; i++) {\n            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）\n            Runnable worker = new MyRunnable(\"\" + i);\n            //执行Runnable\n            executor.execute(worker);\n        }\n        //终止线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n        }\n        System.out.println(\"Finished all threads\");\n    }\n}\n```\n\n可以看到我们上面的代码指定了：\n\n1. `corePoolSize`: 核心线程数为 5。\n2. `maximumPoolSize` ：最大线程数 10\n3. `keepAliveTime` : 等待时间为 1L。\n4. `unit`: 等待时间的单位为 TimeUnit.SECONDS。\n5. `workQueue`：任务队列为 `ArrayBlockingQueue`，并且容量为 100;\n6. `handler`:饱和策略为 `CallerRunsPolicy`。\n\n**Output：**\n\n```java\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:44 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-1 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-4 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-3 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-5 Start. Time = Tue Nov 12 20:59:49 CST 2019\npool-1-thread-2 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-3 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-4 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-5 End. Time = Tue Nov 12 20:59:54 CST 2019\npool-1-thread-1 End. Time = Tue Nov 12 20:59:54 CST 2019\n```\n\n## 并发工具\n\n### CountDownLatch 与 CyclicBarrier\n\nCountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n\n- CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；\n- 调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；\n- CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。\n\n### Semaphore\n\n**Semaphore(信号量)-允许多个线程同时访问：** synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。\n\nSemaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n=1，相当于变成了一个 synchronized 了。\n\n## 模拟\n\n### 死锁\n\n```java\npublic class DeadLock {\n    private static Object A = new Object();\n    private static Object B = new Object();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (A) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源B\");\n                synchronized (B) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                }\n            }\n        }, \"线程1\").start();\n\n        new Thread(() -> {\n            synchronized (B) {\n                System.out.println(Thread.currentThread().getName() + \" 已获得资源B\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \" 等待获得资源A\");\n                synchronized (A) {\n                    System.out.println(Thread.currentThread().getName() + \" 已获得资源A\");\n                }\n            }\n        }, \"线程2\").start();\n    }\n}\n```\n\n> 线程1 已获得资源A\n> 线程2 已获得资源B\n> 线程1 等待获得资源B\n> 线程2 等待获得资源A\n\n### run方法和start方法\n\n```java\npublic class DiffStartRun {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程A\").run();\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName());\n        }, \"线程B\").start();\n    }\n}\n```\n\n> main\n> 线程B\n>\n> new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。\n>\n> **总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。**\n\n### 两个线程，交替加减\n\n1. synchronized\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithSync {\n\t    private static int value = 0;\n\t\n\t    private static final Object lock = new Object();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 0) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                synchronized (lock) {\n\t                    while (value != 1) {\n\t                        try {\n\t                            lock.wait();\n\t                        } catch (InterruptedException e) {\n\t                            e.printStackTrace();\n\t                        }\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    lock.notifyAll();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t\n\t}\n\t```\n\n2. lock + condition\n\n\t```java\n\t/**\n\t * @author fangyaxing\n\t * @date 2022/9/12\n\t */\n\tpublic class TwoThreadWithLock {\n\t    private static int value = 0;\n\t\n\t    private static final Lock lock = new ReentrantLock();\n\t\n\t    static Condition a = lock.newCondition();\n\t\n\t    static Condition b = lock.newCondition();\n\t\n\t    public static void main(String[] args) {\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 0) {\n\t                        a.await();\n\t                    }\n\t                    value++;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    b.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-A\").start();\n\t\n\t        new Thread(() -> {\n\t            for (int i = 0; i < 5; i++) {\n\t                try {\n\t                    lock.lock();\n\t                    while (value != 1) {\n\t                        b.await();\n\t                    }\n\t                    value--;\n\t                    System.out.println(Thread.currentThread().getName() + \" ---- \" + value);\n\t                    a.signal();\n\t                } catch (InterruptedException e) {\n\t                    e.printStackTrace();\n\t                } finally {\n\t                    lock.unlock();\n\t                }\n\t            }\n\t        }, \"Thread-B\").start();\n\t    }\n\t}\n\t```\n\n### 三个线程，循环打印\n\n```java\npublic class Demo5 {\n    private int value = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition a = lock.newCondition();\n    private Condition b = lock.newCondition();\n    private Condition c = lock.newCondition();\n\n    public void outputA(int round) {\n        try {\n            lock.lock();\n            while (value != 0) {\n                a.await();\n            }\n            value = 1;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出A\");\n            b.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputB(int round) {\n        try {\n            lock.lock();\n            while (value != 1) {\n                b.await();\n            }\n            value = 2;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出B\");\n            c.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void outputC(int round) {\n        try {\n            lock.lock();\n            while (value != 2) {\n                c.await();\n            }\n            value = 0;\n            System.out.println(\"第\" + round + \"轮，\" + Thread.currentThread().getName() + \"输出C\");\n            a.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        Demo5 s = new Demo5();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputA(i);\n            }\n        }, \"Thread-A\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputB(i);\n            }\n        }, \"Thread-B\").start();\n\n        new Thread(() -> {\n            for (int i = 0; i < 3; i++) {\n                s.outputC(i);\n            }\n        }, \"Thread-C\").start();\n\n    }\n}\n```\n","slug":"Java八股文 - Java并发","published":1,"updated":"2023-01-26T12:35:58.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31y000at9t8hzfmcqld","content":"<blockquote>\n<p>整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"并发编程的优缺点\"><a href=\"#并发编程的优缺点\" class=\"headerlink\" title=\"并发编程的优缺点\"></a>并发编程的优缺点</h3><p>优点：为了能提高程序的执行效率，提高程序运行速度；</p>\n<p>缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。</p>\n<h4 id=\"并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\"><a href=\"#并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\"></a>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h4><p>并发编程三要素（线程的安全性问题体现在）：</p>\n<p><strong>原子性</strong>：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）</p>\n<p><strong>可见性</strong>：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）</p>\n<p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）</p>\n<blockquote>\n<p>volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用<code>atomicInteger.getAndSet()</code>原子操作。</p>\n</blockquote>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"进程间的通信方式\"><a href=\"#进程间的通信方式\" class=\"headerlink\" title=\"进程间的通信方式\"></a>进程间的通信方式</h4><ol>\n<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；</li>\n<li>**有名管道(Names Pipes)<strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循</strong>先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；</li>\n<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>\n<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</strong>；</li>\n<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件；</li>\n<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式；</li>\n<li>**套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h4 id=\"线程间的同步方式\"><a href=\"#线程间的同步方式\" class=\"headerlink\" title=\"线程间的同步方式\"></a>线程间的同步方式</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<ol>\n<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</li>\n<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；</li>\n<li><strong>事件(Event)</strong> ：wait&#x2F;notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>\n</ol>\n<h4 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程?\"></a>什么是线程和进程?</h4><p><strong>进程</strong>：进程是应用程序的一次运行，每个进程都有自己独立的内存空间，是操作系统资源分配的基本单位；</p>\n<p><strong>线程</strong>：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。</p>\n<h4 id=\"什么是上下文切换\"><a href=\"#什么是上下文切换\" class=\"headerlink\" title=\"什么是上下文切换?\"></a>什么是上下文切换?</h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<h4 id=\"守护线程和用户线程有什么区别呢？\"><a href=\"#守护线程和用户线程有什么区别呢？\" class=\"headerlink\" title=\"守护线程和用户线程有什么区别呢？\"></a>守护线程和用户线程有什么区别呢？</h4><ul>\n<li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务</li>\n<li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常；</li>\n<li>在守护线程中产生的新线程也是守护线程；</li>\n<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；</li>\n<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li>\n</ol>\n<h4 id=\"如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\"><a href=\"#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\" class=\"headerlink\" title=\"如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h4><p>Windows 下用任务管理器看，Linux 下可以用 top 这个命令看。</p>\n<h4 id=\"什么是线程死锁\"><a href=\"#什么是线程死锁\" class=\"headerlink\" title=\"什么是线程死锁\"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>如图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，这两个线程就会互相等待而进入死锁状态。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png\" alt=\"线程死锁\"></p>\n<p>下面通过代码模拟了上图的死锁的情况（代码来源于《并发编程之美》）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLockDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n\n<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000)</code>；让线程 A 休眠 1s 为的是让线程 B 得到 CPU 执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>\n<h4 id=\"形成死锁的四个必要条件是什么\"><a href=\"#形成死锁的四个必要条件是什么\" class=\"headerlink\" title=\"形成死锁的四个必要条件是什么\"></a>形成死锁的四个必要条件是什么</h4><ol>\n<li>互斥条件：一个资源只能被一个线程占用，直到被该线程释放；</li>\n<li>请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；</li>\n<li>不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；</li>\n<li>循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞。</li>\n</ol>\n<h4 id=\"如何避免线程死锁\"><a href=\"#如何避免线程死锁\" class=\"headerlink\" title=\"如何避免线程死锁\"></a>如何避免线程死锁</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<p><strong>破坏互斥条件</strong>：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；</p>\n<p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源；</p>\n<p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，<strong>如果申请不到，可以主动释放它占有的资源</strong>；</p>\n<p><strong>破坏循环等待条件</strong>：靠<strong>按序申请</strong>资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>\n<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br></pre></td></tr></table></figure>\n\n<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>\n<p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>\n<h4 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h4><p>创建线程有四种方式：</p>\n<ul>\n<li>继承 Thread 类</li>\n<li>实现 Runnable 接口</li>\n<li>实现 Callable 接口</li>\n<li>使用 Executors 工具类创建线程池</li>\n</ul>\n<p><strong>继承 Thread 类</strong></p>\n<ol>\n<li>定义一个 Thread 类的子类，重写 run 方法；</li>\n<li>创建自定义的线程子类对象；</li>\n<li>调用子类实例的 start() 方法来启动线程。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>().start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Runnable 接口</strong></p>\n<ol>\n<li>定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法；</li>\n<li>创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 实例，<strong>该Thread对象才是真正的线程对象</strong>；</li>\n<li>调用线程实例的 start() 方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Callable 接口</strong></p>\n<ol>\n<li>创建实现 Callable 接口的类 myCallable；</li>\n<li>以 myCallable 为参数创建 FutureTask 对象；</li>\n<li>将 FutureTask 作为参数创建 Thread 对象；</li>\n<li>调用线程对象的 start() 方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;Integer&gt; &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Integer <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; call()方法执行中...&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            System.out.println(futureTask.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 Executors 工具类创建线程池</strong></p>\n<p>Executors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。</p>\n<p>主要有 new[Single&#x2F;Fixed&#x2F;Cached&#x2F;Scheduled]ThreadPool 这四种线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法执行中...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingleThreadExecutorTest</span> &#123;n</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\">        <span class=\"type\">MyRunnable</span> <span class=\"variable\">myRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(myRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程任务开始执行&quot;</span>);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h4><p>相同点</p>\n<ul>\n<li>都是接口</li>\n<li>都可以用来实现多线程</li>\n<li>都创建 Thread 实例并调用其 start() 方法启动线程</li>\n</ul>\n<p>主要区别</p>\n<ul>\n<li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果</li>\n<li>Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常</li>\n</ul>\n<h4 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h4><blockquote>\n<p>start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>\n</blockquote>\n<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用 run()，其实就相当于是调用了一个普通函数而已。<br>start() 只能调用一次，run() 可以重复调用。</p>\n<h4 id=\"什么是-Callable-和-Future\"><a href=\"#什么是-Callable-和-Future\" class=\"headerlink\" title=\"什么是 Callable 和 Future?\"></a>什么是 Callable 和 Future?</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br></pre></td></tr></table></figure>\n\n<p>将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，<br>之后可以用 future 来获取 callable  中 call() 的返回结果。</p>\n<h4 id=\"线程的状态和基本操作\"><a href=\"#线程的状态和基本操作\" class=\"headerlink\" title=\"线程的状态和基本操作\"></a>线程的状态和基本操作</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n<h4 id=\"Java-中用到的线程调度算法是什么？\"><a href=\"#Java-中用到的线程调度算法是什么？\" class=\"headerlink\" title=\"Java 中用到的线程调度算法是什么？\"></a>Java 中用到的线程调度算法是什么？</h4><p>线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p>\n<p>有两种调度模型：<strong>时间片轮转</strong>模型和<strong>优先级调度</strong>模型。</p>\n<p><strong>Java 虚拟机采用优先级调度模型</strong>，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p>\n<h4 id=\"请说出与线程同步以及线程调度相关的方法。\"><a href=\"#请说出与线程同步以及线程调度相关的方法。\" class=\"headerlink\" title=\"请说出与线程同步以及线程调度相关的方法。\"></a>请说出与线程同步以及线程调度相关的方法。</h4><p>（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；</p>\n<p>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；</p>\n<p>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>\n<p>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>\n<h4 id=\"wait-和-sleep-有什么区别？\"><a href=\"#wait-和-sleep-有什么区别？\" class=\"headerlink\" title=\"wait() 和 sleep() 有什么区别？\"></a>wait() 和 sleep() 有什么区别？</h4><p>两者都可以暂停线程的执行</p>\n<ul>\n<li>类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。</li>\n<li>释放锁：wait() 释放锁，sleep() 不释放锁。</li>\n<li>用途不同：wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li>\n<li>自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>\n</ul>\n<h4 id=\"你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\"><a href=\"#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\" class=\"headerlink\" title=\"你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><blockquote>\n<p>使用 while 判断条件是否得到满足</p>\n</blockquote>\n<p>使用 if 来判断会存在以下问题：</p>\n<ol>\n<li><p>另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。</p>\n</li>\n<li><p>存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (monitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  判断条件谓词是否得到满足</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!locked) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  等待唤醒</span></span><br><span class=\"line\">        monitor.wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  处理其他的业务逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\"><a href=\"#为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\" class=\"headerlink\" title=\"为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\"></a>为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？</h4><p>Java 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。</p>\n<h4 id=\"Thread-类中的-yield-方法有什么作用？\"><a href=\"#Thread-类中的-yield-方法有什么作用？\" class=\"headerlink\" title=\"Thread 类中的 yield 方法有什么作用？\"></a>Thread 类中的 yield 方法有什么作用？</h4><p>使当前线程从运行状态变为就绪状态。</p>\n<h4 id=\"线程的-sleep-方法和-yield-方法有什么区别？\"><a href=\"#线程的-sleep-方法和-yield-方法有什么区别？\" class=\"headerlink\" title=\"线程的 sleep()方法和 yield()方法有什么区别？\"></a>线程的 sleep()方法和 yield()方法有什么区别？</h4><ol>\n<li><p>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p>\n<p> yield() 方法只会给<strong>相同或更高优先级</strong>的线程以运行的机会；</p>\n</li>\n<li><p>线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；</p>\n</li>\n</ol>\n<h4 id=\"如何停止一个正在运行的线程？\"><a href=\"#如何停止一个正在运行的线程？\" class=\"headerlink\" title=\"如何停止一个正在运行的线程？\"></a>如何停止一个正在运行的线程？</h4><ol>\n<li>当 run 方法完成后线程终止；</li>\n<li>使用 interrupt 方法中断线程。</li>\n</ol>\n<h4 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify() 和 notifyAll() 有什么区别？\"></a>notify() 和 notifyAll() 有什么区别？</h4><p>如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>\n<p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p>\n<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>\n<h4 id=\"如何在两个线程间共享数据？\"><a href=\"#如何在两个线程间共享数据？\" class=\"headerlink\" title=\"如何在两个线程间共享数据？\"></a>如何在两个线程间共享数据？</h4><p>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制：</p>\n<ol>\n<li>所有的共享变量都存在主内存中</li>\n<li>每个线程都保存了一份该线程使用到的共享变量的副本</li>\n<li>如果线程 A 与线程 B 之间要通信：<ol>\n<li>线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去</li>\n<li>线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"Java-如何实现多线程之间的通讯和协作？\"><a href=\"#Java-如何实现多线程之间的通讯和协作？\" class=\"headerlink\" title=\"Java 如何实现多线程之间的通讯和协作？\"></a>Java 如何实现多线程之间的通讯和协作？</h4><p>Java 中线程通信协作的最常见的两种方式：</p>\n<ol>\n<li><p>synchronized 加锁的线程 + Object 类的 wait()&#x2F;notify()&#x2F;notifyAll()</p>\n</li>\n<li><p>ReentrantLock 类加锁的线程 + Condition 类的 await()&#x2F;signal()&#x2F;signalAll()</p>\n</li>\n</ol>\n<h4 id=\"同步方法和同步块，哪个是更好的选择？\"><a href=\"#同步方法和同步块，哪个是更好的选择？\" class=\"headerlink\" title=\"同步方法和同步块，哪个是更好的选择？\"></a>同步方法和同步块，哪个是更好的选择？</h4><p>同步的范围越小越好。</p>\n<p>因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。</p>\n<h4 id=\"什么是线程同步和线程互斥，有哪几种实现方式？\"><a href=\"#什么是线程同步和线程互斥，有哪几种实现方式？\" class=\"headerlink\" title=\"什么是线程同步和线程互斥，有哪几种实现方式？\"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<p>线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>\n<p>实现线程同步的方法：</p>\n<ul>\n<li>同步代码方法 &#x2F; 方法块：sychronized 关键字修饰的方法 &#x2F; 代码块</li>\n<li>使用特殊变量域 volatile 实现线程同步：volatile 关键字为域变量的访问提供了一种免锁机制</li>\n<li>使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义</li>\n</ul>\n<h4 id=\"在监视器-Monitor-内部，是如何做线程同步的？\"><a href=\"#在监视器-Monitor-内部，是如何做线程同步的？\" class=\"headerlink\" title=\"在监视器(Monitor)内部，是如何做线程同步的？\"></a>在监视器(Monitor)内部，是如何做线程同步的？</h4><p>在 Java 虚拟机中，每个对象关联一个<strong>监视器</strong>，为了实现监视器的互斥功能，<strong>每个对象都关联着一把锁</strong>。</p>\n<p>一旦方法或者代码块被 <strong>synchronized</strong> 修饰，那么这个部分就放入了监视器的监视区域，<strong>确保一次只能有一个线程执行该部分的代码</strong>，线程在获取锁之前不允许执行该部分的代码</p>\n<p>另外 Java 还提供了显式监视器 (Lock) 和隐式监视器 (synchronized) 两种锁方案</p>\n<h4 id=\"Java-线程数过多会造成什么问题？\"><a href=\"#Java-线程数过多会造成什么问题？\" class=\"headerlink\" title=\"Java 线程数过多会造成什么问题？\"></a>Java 线程数过多会造成什么问题？</h4><ul>\n<li><p>消耗过多的 CPU 资源</p>\n<p>  如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。</p>\n</li>\n<li><p>降低 JVM 稳定性</p>\n<p>  在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>\n</li>\n</ul>\n<h2 id=\"并发关键字\"><a href=\"#并发关键字\" class=\"headerlink\" title=\"并发关键字\"></a>并发关键字</h2><h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><h4 id=\"synchronized-的作用？\"><a href=\"#synchronized-的作用？\" class=\"headerlink\" title=\"synchronized 的作用？\"></a>synchronized 的作用？</h4><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。</p>\n<h4 id=\"怎么使用-synchronized-关键字\"><a href=\"#怎么使用-synchronized-关键字\" class=\"headerlink\" title=\"怎么使用 synchronized 关键字\"></a>怎么使用 synchronized 关键字</h4><p><strong>synchronized关键字最主要的三种使用方式：</strong></p>\n<ul>\n<li><strong>修饰实例方法：</strong> 给当前对象实例加锁；</li>\n<li><strong>修饰静态方法：</strong> 给当前类加锁；</li>\n<li><strong>修饰代码块：</strong>给指定对象加锁，进入同步代码块前要获得指定对象的锁。</li>\n</ul>\n<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。</p>\n<h4 id=\"双重校验锁实现对象单例（线程安全）\"><a href=\"#双重校验锁实现对象单例（线程安全）\" class=\"headerlink\" title=\"双重校验锁实现对象单例（线程安全）\"></a>双重校验锁实现对象单例（线程安全）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 线程1、2、3有可能都进来了</span></span><br><span class=\"line\">            <span class=\"comment\">//类对象加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;\t<span class=\"comment\">// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。</span></span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。</p>\n<p>instance 采用 volatile 关键字修饰也是很有必要的，instance &#x3D; new Singleton() 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 instance 分配内存空间</li>\n<li>初始化 instance</li>\n<li>将 instance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此<strong>返回 T1 实例化但未初始化</strong>的 instance。</p>\n<h4 id=\"synchronized-底层实现原理？（监视器monitor）\"><a href=\"#synchronized-底层实现原理？（监视器monitor）\" class=\"headerlink\" title=\"synchronized 底层实现原理？（监视器monitor）\"></a>synchronized 底层实现原理？（监视器monitor）</h4><p>synchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。</p>\n<p>synchronized 同步语句块的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SynchronizedDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;synchronized 代码块&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 JDK 反汇编指令 javap -c -v SynchronizedDemo</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n<p>可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开 monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。</p>\n<p>为什么会有两个 monitorexit 呢？（line 19）</p>\n<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<strong>因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</strong></p>\n<h4 id=\"synchronized-可重入的原理\"><a href=\"#synchronized-可重入的原理\" class=\"headerlink\" title=\"synchronized 可重入的原理\"></a>synchronized 可重入的原理</h4><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。<br>底层原理维护一个<strong>计数器</strong>，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为 0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>\n<h4 id=\"什么是自旋\"><a href=\"#什么是自旋\" class=\"headerlink\" title=\"什么是自旋\"></a>什么是自旋</h4><blockquote>\n<p>不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环</p>\n</blockquote>\n<p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为<strong>线程阻塞涉及到用户态和内核态切换的问题开销很大</strong>，而是<strong>在 synchronized 的边界做忙循环</strong>，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<h4 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h4><blockquote>\n<p>目的：锁升级是为了减低了锁带来的性能消耗。</p>\n</blockquote>\n<p>Java 的锁都是基于对象的，Java 对象有对象头，内容包括：</p>\n<ol>\n<li>Mark Word，存储对象的 hashCode、锁信息等；</li>\n<li>Class Metadata Address，存储到对象类型数据的指针；</li>\n<li>数组的长度（如果是数组）</li>\n</ol>\n<p>每一个线程在准备获取共享资源时： </p>\n<p>第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “<strong>偏向锁</strong>” ；</p>\n<p>第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p>\n<ul>\n<li>CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li>\n<li>CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li>\n</ul>\n<p>第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；</p>\n<p>第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；</p>\n<p>第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 <strong>轻量级锁</strong>的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；</p>\n<p>第六步，进入<strong>重量级锁</strong>的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。</p>\n<h4 id=\"线程-B-怎么知道线程-A-修改了变量\"><a href=\"#线程-B-怎么知道线程-A-修改了变量\" class=\"headerlink\" title=\"线程 B 怎么知道线程 A 修改了变量\"></a>线程 B 怎么知道线程 A 修改了变量</h4><ul>\n<li><p>volatile 修饰变量</p>\n</li>\n<li><p>synchronized 修饰修改变量的方法</p>\n</li>\n<li><p>lock 对修改变量的代码块加锁</p>\n</li>\n</ul>\n<h4 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h4><ul>\n<li>synchronized 是 Java 关键字，而 Lock 是个接口；</li>\n<li>synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；</li>\n<li>synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h4 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p><strong>相同点：</strong></p>\n<p>两者都是可重入锁</p>\n<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果不可锁重入的话，就会造成死锁</strong>。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>\n<p><strong>不同点：</strong></p>\n<ul>\n<li>synchronized 是关键字，ReentrantLock 是类；</li>\n<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；</li>\n</ul>\n<ul>\n<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>\n<li>二者的锁机制其实也是不一样的：<br>  ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word</li>\n</ul>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h4 id=\"为什么代码会重排序？\"><a href=\"#为什么代码会重排序？\" class=\"headerlink\" title=\"为什么代码会重排序？\"></a>为什么代码会重排序？</h4><p>在执行程序时，为了<strong>提高性能</strong>，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>\n<ul>\n<li><strong>在单线程环境下不能改变程序运行的结果；</strong></li>\n<li><strong>存在数据依赖关系的不允许重排序</strong></li>\n</ul>\n<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>\n<h4 id=\"as-if-serial-规则和-happens-before-规则的区别\"><a href=\"#as-if-serial-规则和-happens-before-规则的区别\" class=\"headerlink\" title=\"as-if-serial 规则和 happens-before 规则的区别\"></a>as-if-serial 规则和 happens-before 规则的区别</h4><ul>\n<li>as-if-serial 规则保证 <strong>单线程</strong> 内程序的执行结果不被改变，happens-before 规则保证 <strong>正确同步的多线程</strong> 程序的执行结果不被改变。</li>\n<li>as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li>\n</ul>\n<h4 id=\"volatile-关键字的作用\"><a href=\"#volatile-关键字的作用\" class=\"headerlink\" title=\"volatile 关键字的作用\"></a>volatile 关键字的作用</h4><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<h4 id=\"JMM内存屏障插入策略\"><a href=\"#JMM内存屏障插入策略\" class=\"headerlink\" title=\"JMM内存屏障插入策略\"></a>JMM内存屏障插入策略</h4><p><strong>插入屏障</strong></p>\n<p>StoreStore 屏障 - volatile 写 - StoreLoad 屏障</p>\n<p>volatile 读 - LoadLoad 屏障 - LoadStore 屏障</p>\n<p><strong>volatile 与普通变量的重排序规则</strong></p>\n<ol>\n<li>如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；</li>\n<li>如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；</li>\n<li>如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。</li>\n</ol>\n<h4 id=\"volatile-能使得一个非原子操作变成原子操作吗？\"><a href=\"#volatile-能使得一个非原子操作变成原子操作吗？\" class=\"headerlink\" title=\"volatile 能使得一个非原子操作变成原子操作吗？\"></a>volatile 能使得一个非原子操作变成原子操作吗？</h4><p>volatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。</p>\n<h4 id=\"volatile-修饰符的有过什么实践？\"><a href=\"#volatile-修饰符的有过什么实践？\" class=\"headerlink\" title=\"volatile 修饰符的有过什么实践？\"></a>volatile 修饰符的有过什么实践？</h4><p>单例模式-双重锁检验里面用 volatile 修饰实例变量。</p>\n<h4 id=\"volatile-和-synchronized-的区别是什么？\"><a href=\"#volatile-和-synchronized-的区别是什么？\" class=\"headerlink\" title=\"volatile 和 synchronized 的区别是什么？\"></a>volatile 和 synchronized 的区别是什么？</h4><ul>\n<li>volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；</li>\n<li>volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，<br>  而 synchronized 则可以保证变量的修改原子性和可见性；</li>\n<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li>\n<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。synchronized 关键字在 JavaSE1.6 之后进行了主要包括为了<strong>减少获得锁和释放锁带来的性能消耗</strong>而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>\n</ul>\n<h2 id=\"Lock-体系\"><a href=\"#Lock-体系\" class=\"headerlink\" title=\"Lock 体系\"></a>Lock 体系</h2><h3 id=\"Lock-简介\"><a href=\"#Lock-简介\" class=\"headerlink\" title=\"Lock 简介\"></a>Lock 简介</h3><h4 id=\"Lock-接口是什么？对比同步它有什么优势？\"><a href=\"#Lock-接口是什么？对比同步它有什么优势？\" class=\"headerlink\" title=\"Lock 接口是什么？对比同步它有什么优势？\"></a>Lock 接口是什么？对比同步它有什么优势？</h4><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。</p>\n<p>（1）可以使锁更<strong>公平</strong></p>\n<p>（2）可以使线程在<strong>等待锁的时候响应中断</strong></p>\n<p>（3）可以<strong>让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</strong></p>\n<h4 id=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"><a href=\"#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\" class=\"headerlink\" title=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<br>    传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>\n<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<br>    乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>\n<h4 id=\"什么是-CAS\"><a href=\"#什么是-CAS\" class=\"headerlink\" title=\"什么是 CAS\"></a>什么是 CAS</h4><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。</p>\n<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。</p>\n<p>如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。</p>\n<h4 id=\"Java实现CAS的原理-Unsafe类\"><a href=\"#Java实现CAS的原理-Unsafe类\" class=\"headerlink\" title=\"Java实现CAS的原理 - Unsafe类\"></a>Java实现CAS的原理 - Unsafe类</h4><p>在 Java 中，有一个<code>Unsafe</code>类，它在<code>sun.misc</code>包中。它里面是一些<code>native</code>方法（由底层的 JVM 使用 C 或者 C++去实现），其中就有几个关于 CAS 的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapObject</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,Object expected, Object x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapInt</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">int</span> expected,<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapLong</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">long</span> expected,<span class=\"type\">long</span> x)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然，他们都是<code>public native</code>的。</p>\n<p>Unsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。</p>\n<p>Linux 的 X86 下主要是通过<code>cmpxchgl</code>这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p>\n<p>当然，Unsafe 类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport 类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p>\n<h4 id=\"CAS-会产生什么问题？\"><a href=\"#CAS-会产生什么问题？\" class=\"headerlink\" title=\"CAS 会产生什么问题？\"></a>CAS 会产生什么问题？</h4><p>1、<strong>ABA 问题</strong>：</p>\n<p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>\n<p>2、<strong>循环时间长开销大</strong>：</p>\n<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p>\n<p>3、<strong>只能保证一个共享变量的原子操作</strong>：</p>\n<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是<strong>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁</strong>。</p>\n<h4 id=\"死锁与活锁的区别，死锁与饥饿的区别？\"><a href=\"#死锁与活锁的区别，死锁与饥饿的区别？\" class=\"headerlink\" title=\"死锁与活锁的区别，死锁与饥饿的区别？\"></a>死锁与活锁的区别，死锁与饥饿的区别？</h4><blockquote>\n<p>区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。</p>\n</blockquote>\n<p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致<strong>一直重复尝试，失败，尝试，失败</strong>。</p>\n<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>\n<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>\n<p>Java 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>\n<h3 id=\"AQS详解\"><a href=\"#AQS详解\" class=\"headerlink\" title=\"AQS详解\"></a>AQS详解</h3><h4 id=\"AQS-介绍\"><a href=\"#AQS-介绍\" class=\"headerlink\" title=\"AQS 介绍\"></a>AQS 介绍</h4><p>AQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。</p>\n<p>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>\n<h4 id=\"AQS-原理分析\"><a href=\"#AQS-原理分析\" class=\"headerlink\" title=\"AQS 原理分析\"></a>AQS 原理分析</h4><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。</strong></p>\n<blockquote>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。</p>\n</blockquote>\n<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png\" alt=\"AQS原理图\"></p>\n<p>AQS 使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;\t<span class=\"comment\">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>\n\n<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回同步状态的当前值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置同步状态的值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(<span class=\"type\">int</span> newState)</span> &#123; </span><br><span class=\"line\">    state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetState</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AQS 对资源的共享方式</strong></p>\n<p>AQS 定义两种资源共享方式</p>\n<ul>\n<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>\n</ul>\n</li>\n<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>\n</ul>\n<p><strong>AQS底层使用了模板方法模式</strong></p>\n<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器（<strong>模板方法模式</strong>很经典的一个应用）：</p>\n<ol>\n<li>使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）</li>\n<li>调用 AQS 的模板方法，会进一步调用使用者重写的方法。</li>\n</ol>\n<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isHeldExclusively()\t<span class=\"comment\">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class=\"line\">tryAcquire(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>\n\n<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。</p>\n<p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即 state&#x3D;0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p>\n<p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，<strong>实现了读写的分离，读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><h4 id=\"什么是ConcurrentHashMap？\"><a href=\"#什么是ConcurrentHashMap？\" class=\"headerlink\" title=\"什么是ConcurrentHashMap？\"></a>什么是ConcurrentHashMap？</h4><p>ConcurrentHashMap 是 Java 中的一个<strong>线程安全且高效的HashMap实现</strong>。</p>\n<p>那么它到底是如何实现线程安全的？</p>\n<p>JDK 1.6 版本关键要素：</p>\n<ul>\n<li>segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；</li>\n<li>segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。</li>\n</ul>\n<p>JDK1.8 后，ConcurrentHashMap 抛弃了原有的 Segment 分段锁，而<strong>采用了 CAS + synchronized 来保证并发安全性</strong>。</p>\n<p>插入元素过程：</p>\n<p>如果相应位置的 Node 还没有初始化，则调用 CAS 插入相应的数据；</p>\n<p>如果相应位置的 Node 不为空，则对该节点加 synchronized 锁进行插入或更新操作。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>CopyOnWrite 容器即<strong>写时复制的容器</strong>，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>\n<p><strong>CopyOnWriteArrayList 的使用场景</strong></p>\n<p>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p>\n<p><strong>CopyOnWriteArrayList 的缺点</strong></p>\n<ol>\n<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li>\n<li><strong>不能用于实时读的场景</strong>，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，<strong>读取到数据可能还是旧的</strong>，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>\n</ol>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><h4 id=\"ThreadLocal的数据结构\"><a href=\"#ThreadLocal的数据结构\" class=\"headerlink\" title=\"ThreadLocal的数据结构\"></a>ThreadLocal的数据结构</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n<p>每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry 为 &lt;threadLocal 的弱引用，value 为强引用&gt; 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// private static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     @Override</span></span><br><span class=\"line\">    <span class=\"comment\">//     protected Integer initialValue() &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         return 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"type\">Integer</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> threadLocal.get();</span><br><span class=\"line\">                    threadLocal.set(++val);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;Thread-&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + threadLocal.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后 threadLocal.get 仍然是 0</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">main ---- <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><h4 id=\"ThreadLocal造成内存泄漏的原因？\"><a href=\"#ThreadLocal造成内存泄漏的原因？\" class=\"headerlink\" title=\"ThreadLocal造成内存泄漏的原因？\"></a>ThreadLocal造成内存泄漏的原因？</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的 remove()方法，清理掉 key 为 null 的记录。</p>\n<h3 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>\n<p>在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>\n<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>\n<p>JDK7 提供了 7 个阻塞队列。分别是：</p>\n<blockquote>\n<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n</blockquote>\n<p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>\n<p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，<strong>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞</strong>，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"Executors-创建四种常见线程池\"><a href=\"#Executors-创建四种常见线程池\" class=\"headerlink\" title=\"Executors 创建四种常见线程池\"></a>Executors 创建四种常见线程池</h3><h4 id=\"什么是线程池？有哪几种创建方式？\"><a href=\"#什么是线程池？有哪几种创建方式？\" class=\"headerlink\" title=\"什么是线程池？有哪几种创建方式？\"></a>什么是线程池？有哪几种创建方式？</h4><blockquote>\n<p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是<strong>尽可能减少创建和销毁对象的次数</strong>，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>\n<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>\n<p>（1）Executors.newSingleThreadExecutor：<code>1, 1, new LinkedBlockingQueue</code>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）</p>\n<p>（2）Executors.newFixedThreadPool：<code>nCoreThreads, nCoreThreads, new LinkedBlockingQueue</code>，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）</p>\n<p>（3） Executors.newCachedThreadPool：<code>0, Integer.MAX_VALUE</code>，不创建核心线程，线程池最大为 Integer.MAX_VALUE。（线程池太大导致 OOM）</p>\n<p>newCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。<br>FixedThreadPool 是因为阻塞队列可以很大（最大为 Integer 最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为 Integer 最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</p>\n<p>（4）Executors.newScheduledThreadPool：<code>nCoreThreads, Integer.MAX_VALUE</code>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<h4 id=\"线程池有什么优点？\"><a href=\"#线程池有什么优点？\" class=\"headerlink\" title=\"线程池有什么优点？\"></a>线程池有什么优点？</h4><ul>\n<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销；</li>\n<li>提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；</li>\n<li>提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h4 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h4><ul>\n<li>RUNNING：接受新的任务提交，处理等待队列中的任务；</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；</li>\n<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>\n</ul>\n<h4 id=\"在-Java-中-Executor-和-Executors-的区别？\"><a href=\"#在-Java-中-Executor-和-Executors-的区别？\" class=\"headerlink\" title=\"在 Java 中 Executor 和 Executors 的区别？\"></a>在 Java 中 Executor 和 Executors 的区别？</h4><ul>\n<li><strong>Executors 工具类</strong>的不同方法按照我们的需求<strong>创建了不同的线程池</strong>，来满足业务的需求；</li>\n<li><strong>Executor 接口对象执行我们的线程任务</strong>，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>\n</ul>\n<h4 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit() 和 execute() 方法有什么区别？\"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><p>接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而 execute()只能执行 Runnable 类型的任务；</p>\n<p>返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；</p>\n<p>异常处理：submit() 方便 Exception 处理。</p>\n<h3 id=\"ThreadPoolExecutor-自定义线程池\"><a href=\"#ThreadPoolExecutor-自定义线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 自定义线程池\"></a>ThreadPoolExecutor 自定义线程池</h3><h4 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h4><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是<strong>通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让写的同学<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<p>Executors 各个方法的弊端：</p>\n<ul>\n<li><p>newSingleThreadExecutor 和 newFixedThreadPool :<br>  <code>0, 0</code>和 <code>n, n</code> ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE</p>\n<p>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</p>\n</li>\n<li><p>newCachedThreadPool 和 newScheduledThreadPool:<br>  <code>0, Integer.MAX_VALUE</code> 和 <code>n, Integer.MAX_VALUE</code></p>\n<p>  主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM</p>\n</li>\n</ul>\n<p>ThreaPoolExecutor 创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>\n<h4 id=\"ThreaPoolExecutor\"><a href=\"#ThreaPoolExecutor\" class=\"headerlink\" title=\"ThreaPoolExecutor\"></a>ThreaPoolExecutor</h4><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p>\n<p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p>\n<h4 id=\"ThreadPoolExecutor构造函数重要参数分析\"><a href=\"#ThreadPoolExecutor构造函数重要参数分析\" class=\"headerlink\" title=\"ThreadPoolExecutor构造函数重要参数分析\"></a>ThreadPoolExecutor构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code></strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量</li>\n<li><strong><code>maximumPoolSize</code></strong> ：线程池中允许存在的工作线程的最大数量</li>\n<li>**<code>workQueue</code>**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数:</p>\n<ol>\n<li>**<code>keepAliveTime</code>**：非核心线程如果处于闲置状态超过该值，就会被销毁。</li>\n<li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 闲置销毁时长的时间单位</li>\n<li>**<code>threadFactory</code>**：为线程池提供创建新线程的线程工厂</li>\n<li><strong><code>handler</code></strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li>\n</ol>\n<h4 id=\"ThreadPoolExecutor拒绝策略\"><a href=\"#ThreadPoolExecutor拒绝策略\" class=\"headerlink\" title=\"ThreadPoolExecutor拒绝策略\"></a>ThreadPoolExecutor拒绝策略</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>拒绝策略定义:</strong></p>\n<p>如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>\n<ul>\n<li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：调用执行自己的线程运行任务。</li>\n<li>**<code>ThreadPoolExecutor.DiscardPolicy</code>**：不处理新任务，直接丢弃掉。</li>\n<li>**<code>ThreadPoolExecutor.DiscardOldestPolicy</code>**： 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<h4 id=\"一个简单的线程池Demo-Runnable-ThreadPoolExecutor\"><a href=\"#一个简单的线程池Demo-Runnable-ThreadPoolExecutor\" class=\"headerlink\" title=\"一个简单的线程池Demo:Runnable + ThreadPoolExecutor\"></a>一个简单的线程池Demo:<code>Runnable</code> + <code>ThreadPoolExecutor</code></h4><p>线程池实现原理</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png\" alt=\"线程池实现原理\"></p>\n<p><strong>总结一下处理流程</strong></p>\n<ol>\n<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到 corePoolSize，在核心线程数量 &lt; corePoolSize 时）。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>线程总数量 &gt;&#x3D; corePoolSize 时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。 </li>\n<li>当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>缓存队列之前满了， 现在加非核心线程且总线程数达到了 maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>\n</ol>\n<p>整个过程如图所示：</p>\n<p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>\n<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String command;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyRunnable</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.command = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; Start. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">        processCommand();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; End. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processCommand</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.command;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolExecutorDemo</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CORE_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">QUEUE_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">KEEP_ALIVE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class=\"line\">        <span class=\"comment\">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class=\"line\">        <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                CORE_POOL_SIZE,</span><br><span class=\"line\">                MAX_POOL_SIZE,</span><br><span class=\"line\">                KEEP_ALIVE_TIME,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class=\"line\">            <span class=\"type\">Runnable</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>(<span class=\"string\">&quot;&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">//执行Runnable</span></span><br><span class=\"line\">            executor.execute(worker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//终止线程池</span></span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!executor.isTerminated()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Finished all threads&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们上面的代码指定了：</p>\n<ol>\n<li><code>corePoolSize</code>: 核心线程数为 5。</li>\n<li><code>maximumPoolSize</code> ：最大线程数 10</li>\n<li><code>keepAliveTime</code> : 等待时间为 1L。</li>\n<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>\n<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>\n<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>\n</ol>\n<p><strong>Output：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><h3 id=\"CountDownLatch-与-CyclicBarrier\"><a href=\"#CountDownLatch-与-CyclicBarrier\" class=\"headerlink\" title=\"CountDownLatch 与 CyclicBarrier\"></a>CountDownLatch 与 CyclicBarrier</h3><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>\n<ul>\n<li>CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；</li>\n<li>调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>\n<li>CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。</li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</p>\n<p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。</p>\n<h2 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h2><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">A</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">B</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>线程1 已获得资源A<br>线程2 已获得资源B<br>线程1 等待获得资源B<br>线程2 等待获得资源A</p>\n</blockquote>\n<h3 id=\"run方法和start方法\"><a href=\"#run方法和start方法\" class=\"headerlink\" title=\"run方法和start方法\"></a>run方法和start方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DiffStartRun</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程A&quot;</span>).run();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>main<br>线程B</p>\n<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>\n</blockquote>\n<h3 id=\"两个线程，交替加减\"><a href=\"#两个线程，交替加减\" class=\"headerlink\" title=\"两个线程，交替加减\"></a>两个线程，交替加减</h3><ol>\n<li><p>synchronized</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithSync</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lock + condition</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        a.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    b.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        b.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    a.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"三个线程，循环打印\"><a href=\"#三个线程，循环打印\" class=\"headerlink\" title=\"三个线程，循环打印\"></a>三个线程，循环打印</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo5</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputA</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                a.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">1</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出A&quot;</span>);</span><br><span class=\"line\">            b.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputB</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                b.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">2</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出B&quot;</span>);</span><br><span class=\"line\">            c.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputC</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                c.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">0</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出C&quot;</span>);</span><br><span class=\"line\">            a.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Demo5</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo5</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputA(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputB(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputC(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-C&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"length":35745,"excerpt":"<blockquote>\n<p>整理的Java并发相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"并发编程的优缺点\"><a href=\"#并发编程的优缺点\" class=\"headerlink\" title=\"并发编程的优缺点\"></a>并发编程的优缺点</h3><p>优点：为了能提高程序的执行效率，提高程序运行速度；</p>\n<p>缺点：存在内存泄漏、上下文切换、线程安全、死锁等问题。</p>\n<h4 id=\"并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\"><a href=\"#并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？\"></a>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h4><p>并发编程三要素（线程的安全性问题体现在）：</p>\n<p><strong>原子性</strong>：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。（synchronized，Lock）（线程切换引起的原子性问题）</p>\n<p><strong>可见性</strong>：一个线程对共享变量的修改，另一个线程能够立刻看到。（synchronized，Lock，volatile）（JMM 内存模型导致的可见性问题）</p>\n<p><strong>有序性</strong>：程序执行的顺序按照代码的先后顺序执行。（synchronized，Lock，volatile）（指令重排序带来的有序性问题）</p>\n<blockquote>\n<p>volatile不能保证并发安全，比如多线程对一个volatile的int变量进行加1操作，最终得到的数字可能比预期小，就是因为++操作不是原子性的，而volatile也不能保证原子性，所以就会有这个问题，可以使用<code>atomicInteger.getAndSet()</code>原子操作。</p>\n</blockquote>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><h4 id=\"进程间的通信方式\"><a href=\"#进程间的通信方式\" class=\"headerlink\" title=\"进程间的通信方式\"></a>进程间的通信方式</h4><ol>\n<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信；</li>\n<li>**有名管道(Names Pipes)<strong>：匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循</strong>先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信；</li>\n<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>\n<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点</strong>；</li>\n<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件；</li>\n<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式；</li>\n<li>**套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>\n</ol>\n<h4 id=\"线程间的同步方式\"><a href=\"#线程间的同步方式\" class=\"headerlink\" title=\"线程间的同步方式\"></a>线程间的同步方式</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<ol>\n<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制；</li>\n<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；</li>\n<li><strong>事件(Event)</strong> ：wait&#x2F;notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>\n</ol>\n<h4 id=\"什么是线程和进程\"><a href=\"#什么是线程和进程\" class=\"headerlink\" title=\"什么是线程和进程?\"></a>什么是线程和进程?</h4><p><strong>进程</strong>：进程是应用程序的一次运行，每个进程都有自己独立的内存空间，是操作系统资源分配的基本单位；</p>\n<p><strong>线程</strong>：线程是处理器调度和执行的基本单位，一个进程中可以有多个线程，线程共享进程的内存空间和资源。</p>\n<h4 id=\"什么是上下文切换\"><a href=\"#什么是上下文切换\" class=\"headerlink\" title=\"什么是上下文切换?\"></a>什么是上下文切换?</h4><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。</p>\n<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>\n<p>上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>\n<h4 id=\"守护线程和用户线程有什么区别呢？\"><a href=\"#守护线程和用户线程有什么区别呢？\" class=\"headerlink\" title=\"守护线程和用户线程有什么区别呢？\"></a>守护线程和用户线程有什么区别呢？</h4><ul>\n<li><strong>用户 (User) 线程</strong>：运行在前台，执行具体的任务</li>\n<li><strong>守护 (Daemon) 线程</strong>：运行在后台，为其他前台线程服务。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li><code>setDaemon(true)</code>必须在<code>start()</code>方法前执行，否则会抛出 <code>IllegalThreadStateException</code> 异常；</li>\n<li>在守护线程中产生的新线程也是守护线程；</li>\n<li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑；</li>\n<li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li>\n</ol>\n<h4 id=\"如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\"><a href=\"#如何在-Windows-和-Linux-上查找哪个线程cpu利用率最高？\" class=\"headerlink\" title=\"如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？\"></a>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</h4><p>Windows 下用任务管理器看，Linux 下可以用 top 这个命令看。</p>\n<h4 id=\"什么是线程死锁\"><a href=\"#什么是线程死锁\" class=\"headerlink\" title=\"什么是线程死锁\"></a>什么是线程死锁</h4><p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>如图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，这两个线程就会互相等待而进入死锁状态。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/202206152131355.png\" alt=\"线程死锁\"></p>\n<p>下面通过代码模拟了上图的死锁的情况（代码来源于《并发编程之美》）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLockDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">resource2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();\t<span class=\"comment\">//资源 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource1&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n\n<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000)</code>；让线程 A 休眠 1s 为的是让线程 B 得到 CPU 执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>\n<h4 id=\"形成死锁的四个必要条件是什么\"><a href=\"#形成死锁的四个必要条件是什么\" class=\"headerlink\" title=\"形成死锁的四个必要条件是什么\"></a>形成死锁的四个必要条件是什么</h4><ol>\n<li>互斥条件：一个资源只能被一个线程占用，直到被该线程释放；</li>\n<li>请求与保持条件：一个线程因请求被占用资源而发生阻塞时，对已获得的资源保持不放；</li>\n<li>不剥夺条件：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源；</li>\n<li>循环等待条件：当发生死锁时，所等待的线程必定会形成一个环路（类似于死循环），造成永久阻塞。</li>\n</ol>\n<h4 id=\"如何避免线程死锁\"><a href=\"#如何避免线程死锁\" class=\"headerlink\" title=\"如何避免线程死锁\"></a>如何避免线程死锁</h4><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>\n<p><strong>破坏互斥条件</strong>：无法破坏，因为我们用锁本来就是想实现互斥访问临界资源；</p>\n<p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源；</p>\n<p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，<strong>如果申请不到，可以主动释放它占有的资源</strong>；</p>\n<p><strong>破坏循环等待条件</strong>：靠<strong>按序申请</strong>资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>\n<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource1&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread() + <span class=\"string\">&quot;waiting get resource2&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread() + <span class=\"string\">&quot;get resource2&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>\n\n<p>输出结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br></pre></td></tr></table></figure>\n\n<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>\n<p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>\n<h4 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h4><p>创建线程有四种方式：</p>\n<ul>\n<li>继承 Thread 类</li>\n<li>实现 Runnable 接口</li>\n<li>实现 Callable 接口</li>\n<li>使用 Executors 工具类创建线程池</li>\n</ul>\n<p><strong>继承 Thread 类</strong></p>\n<ol>\n<li>定义一个 Thread 类的子类，重写 run 方法；</li>\n<li>创建自定义的线程子类对象；</li>\n<li>调用子类实例的 start() 方法来启动线程。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>().start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Runnable 接口</strong></p>\n<ol>\n<li>定义 Runnable 接口实现类 MyRunnable，并重写 run() 方法；</li>\n<li>创建 MyRunnable 实例 myRunnable，以 myRunnable 作为 target 创建 Thread 实例，<strong>该Thread对象才是真正的线程对象</strong>；</li>\n<li>调用线程实例的 start() 方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法正在执行...&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行结束&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现 Callable 接口</strong></p>\n<ol>\n<li>创建实现 Callable 接口的类 myCallable；</li>\n<li>以 myCallable 为参数创建 FutureTask 对象；</li>\n<li>将 FutureTask 作为参数创建 Thread 对象；</li>\n<li>调用线程对象的 start() 方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;Integer&gt; &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> Integer <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; call()方法执行中...&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            System.out.println(futureTask.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; main()方法执行完成&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>使用 Executors 工具类创建线程池</strong></p>\n<p>Executors 提供了一系列工厂方法用于创建线程池，返回的线程池都实现了 ExecutorService 接口。</p>\n<p>主要有 new[Single&#x2F;Fixed&#x2F;Cached&#x2F;Scheduled]ThreadPool 这四种线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; run()方法执行中...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingleThreadExecutorTest</span> &#123;n</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newSingleThreadExecutor();</span><br><span class=\"line\">        <span class=\"type\">MyRunnable</span> <span class=\"variable\">myRunnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(myRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;线程任务开始执行&quot;</span>);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h4><p>相同点</p>\n<ul>\n<li>都是接口</li>\n<li>都可以用来实现多线程</li>\n<li>都创建 Thread 实例并调用其 start() 方法启动线程</li>\n</ul>\n<p>主要区别</p>\n<ul>\n<li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，和 FutureTask 配合可以用来获取异步执行的结果</li>\n<li>Runnable 接口 run 方法无法捕获并处理异常；Callable 接口 call 方法可以捕获并处理异常</li>\n</ul>\n<h4 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h4><blockquote>\n<p>start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>\n</blockquote>\n<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码，直接调用 run()，其实就相当于是调用了一个普通函数而已。<br>start() 只能调用一次，run() 可以重复调用。</p>\n<h4 id=\"什么是-Callable-和-Future\"><a href=\"#什么是-Callable-和-Future\" class=\"headerlink\" title=\"什么是 Callable 和 Future?\"></a>什么是 Callable 和 Future?</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FutureTask&lt;Integer&gt; futureTask = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">MyCallable</span>());</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(futureTask).start();</span><br></pre></td></tr></table></figure>\n\n<p>将 callable 实例传入 future，然后将 future 实例传入 Thread 创建线程，<br>之后可以用 future 来获取 callable  中 call() 的返回结果。</p>\n<h4 id=\"线程的状态和基本操作\"><a href=\"#线程的状态和基本操作\" class=\"headerlink\" title=\"线程的状态和基本操作\"></a>线程的状态和基本操作</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650518197279.png\" alt=\"线程的状态\" style=\"zoom:67%;\" />\n\n<h4 id=\"Java-中用到的线程调度算法是什么？\"><a href=\"#Java-中用到的线程调度算法是什么？\" class=\"headerlink\" title=\"Java 中用到的线程调度算法是什么？\"></a>Java 中用到的线程调度算法是什么？</h4><p>线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p>\n<p>有两种调度模型：<strong>时间片轮转</strong>模型和<strong>优先级调度</strong>模型。</p>\n<p><strong>Java 虚拟机采用优先级调度模型</strong>，是指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p>\n<h4 id=\"请说出与线程同步以及线程调度相关的方法。\"><a href=\"#请说出与线程同步以及线程调度相关的方法。\" class=\"headerlink\" title=\"请说出与线程同步以及线程调度相关的方法。\"></a>请说出与线程同步以及线程调度相关的方法。</h4><p>（1）wait()：使一个线程处于等待状态，并且释放所持有的对象的锁；</p>\n<p>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法；</p>\n<p>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>\n<p>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>\n<h4 id=\"wait-和-sleep-有什么区别？\"><a href=\"#wait-和-sleep-有什么区别？\" class=\"headerlink\" title=\"wait() 和 sleep() 有什么区别？\"></a>wait() 和 sleep() 有什么区别？</h4><p>两者都可以暂停线程的执行</p>\n<ul>\n<li>类的不同：wait() 是 Object 类的方法，sleep() 是 Thread 线程类的静态方法。</li>\n<li>释放锁：wait() 释放锁，sleep() 不释放锁。</li>\n<li>用途不同：wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li>\n<li>自动苏醒：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</li>\n</ul>\n<h4 id=\"你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\"><a href=\"#你是如何调用-wait-方法的？使用-if-块还是循环？为什么？\" class=\"headerlink\" title=\"你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？\"></a>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</h4><blockquote>\n<p>使用 while 判断条件是否得到满足</p>\n</blockquote>\n<p>使用 if 来判断会存在以下问题：</p>\n<ol>\n<li><p>另一个线程可能已经被唤醒并改变了条件状态。例如 notifyAll 会唤醒多个等待的线程。</p>\n</li>\n<li><p>存在“伪唤醒”的情况，即在没有通知的情况下，线程也可能会苏醒过来，而此时是不应该唤醒的。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (monitor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  判断条件谓词是否得到满足</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!locked) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//  等待唤醒</span></span><br><span class=\"line\">        monitor.wait();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  处理其他的业务逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\"><a href=\"#为什么线程通信的方法-wait-，notify-和-notifyAll-被定义在-Object-类里？\" class=\"headerlink\" title=\"为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？\"></a>为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里？</h4><p>Java 中，任何对象都可以作为锁，并且线程通信的方法 wait()，notify() 等方法用于等待对象的锁或者是唤醒线程，那么要找一个可供任何对象使用的锁，因此将这些方法定义在 Object 中，Object 是所有类的父类。</p>\n<h4 id=\"Thread-类中的-yield-方法有什么作用？\"><a href=\"#Thread-类中的-yield-方法有什么作用？\" class=\"headerlink\" title=\"Thread 类中的 yield 方法有什么作用？\"></a>Thread 类中的 yield 方法有什么作用？</h4><p>使当前线程从运行状态变为就绪状态。</p>\n<h4 id=\"线程的-sleep-方法和-yield-方法有什么区别？\"><a href=\"#线程的-sleep-方法和-yield-方法有什么区别？\" class=\"headerlink\" title=\"线程的 sleep()方法和 yield()方法有什么区别？\"></a>线程的 sleep()方法和 yield()方法有什么区别？</h4><ol>\n<li><p>sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；</p>\n<p> yield() 方法只会给<strong>相同或更高优先级</strong>的线程以运行的机会；</p>\n</li>\n<li><p>线程执行 sleep() 方法后转入等待（waiting）状态，而执行 yield() 方法后转入就绪（ready）状态；</p>\n</li>\n</ol>\n<h4 id=\"如何停止一个正在运行的线程？\"><a href=\"#如何停止一个正在运行的线程？\" class=\"headerlink\" title=\"如何停止一个正在运行的线程？\"></a>如何停止一个正在运行的线程？</h4><ol>\n<li>当 run 方法完成后线程终止；</li>\n<li>使用 interrupt 方法中断线程。</li>\n</ol>\n<h4 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify() 和 notifyAll() 有什么区别？\"></a>notify() 和 notifyAll() 有什么区别？</h4><p>如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>\n<p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p>\n<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>\n<h4 id=\"如何在两个线程间共享数据？\"><a href=\"#如何在两个线程间共享数据？\" class=\"headerlink\" title=\"如何在两个线程间共享数据？\"></a>如何在两个线程间共享数据？</h4><p>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制：</p>\n<ol>\n<li>所有的共享变量都存在主内存中</li>\n<li>每个线程都保存了一份该线程使用到的共享变量的副本</li>\n<li>如果线程 A 与线程 B 之间要通信：<ol>\n<li>线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去</li>\n<li>线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"Java-如何实现多线程之间的通讯和协作？\"><a href=\"#Java-如何实现多线程之间的通讯和协作？\" class=\"headerlink\" title=\"Java 如何实现多线程之间的通讯和协作？\"></a>Java 如何实现多线程之间的通讯和协作？</h4><p>Java 中线程通信协作的最常见的两种方式：</p>\n<ol>\n<li><p>synchronized 加锁的线程 + Object 类的 wait()&#x2F;notify()&#x2F;notifyAll()</p>\n</li>\n<li><p>ReentrantLock 类加锁的线程 + Condition 类的 await()&#x2F;signal()&#x2F;signalAll()</p>\n</li>\n</ol>\n<h4 id=\"同步方法和同步块，哪个是更好的选择？\"><a href=\"#同步方法和同步块，哪个是更好的选择？\" class=\"headerlink\" title=\"同步方法和同步块，哪个是更好的选择？\"></a>同步方法和同步块，哪个是更好的选择？</h4><p>同步的范围越小越好。</p>\n<p>因此，同步块是更好的选择，因为它不会锁住整个对象，而同步方法会锁住整个对象。</p>\n<h4 id=\"什么是线程同步和线程互斥，有哪几种实现方式？\"><a href=\"#什么是线程同步和线程互斥，有哪几种实现方式？\" class=\"headerlink\" title=\"什么是线程同步和线程互斥，有哪几种实现方式？\"></a>什么是线程同步和线程互斥，有哪几种实现方式？</h4><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>\n<p>线程互斥是对某一共享资源而言，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p>\n<p>实现线程同步的方法：</p>\n<ul>\n<li>同步代码方法 &#x2F; 方法块：sychronized 关键字修饰的方法 &#x2F; 代码块</li>\n<li>使用特殊变量域 volatile 实现线程同步：volatile 关键字为域变量的访问提供了一种免锁机制</li>\n<li>使用重入锁实现线程同步：reentrantlock 类是可重入、互斥、实现了 lock 接口的锁，与 sychronized 方法具有相同的基本行为和语义</li>\n</ul>\n<h4 id=\"在监视器-Monitor-内部，是如何做线程同步的？\"><a href=\"#在监视器-Monitor-内部，是如何做线程同步的？\" class=\"headerlink\" title=\"在监视器(Monitor)内部，是如何做线程同步的？\"></a>在监视器(Monitor)内部，是如何做线程同步的？</h4><p>在 Java 虚拟机中，每个对象关联一个<strong>监视器</strong>，为了实现监视器的互斥功能，<strong>每个对象都关联着一把锁</strong>。</p>\n<p>一旦方法或者代码块被 <strong>synchronized</strong> 修饰，那么这个部分就放入了监视器的监视区域，<strong>确保一次只能有一个线程执行该部分的代码</strong>，线程在获取锁之前不允许执行该部分的代码</p>\n<p>另外 Java 还提供了显式监视器 (Lock) 和隐式监视器 (synchronized) 两种锁方案</p>\n<h4 id=\"Java-线程数过多会造成什么问题？\"><a href=\"#Java-线程数过多会造成什么问题？\" class=\"headerlink\" title=\"Java 线程数过多会造成什么问题？\"></a>Java 线程数过多会造成什么问题？</h4><ul>\n<li><p>消耗过多的 CPU 资源</p>\n<p>  如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力。</p>\n</li>\n<li><p>降低 JVM 稳定性</p>\n<p>  在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>\n</li>\n</ul>\n<h2 id=\"并发关键字\"><a href=\"#并发关键字\" class=\"headerlink\" title=\"并发关键字\"></a>并发关键字</h2><h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><h4 id=\"synchronized-的作用？\"><a href=\"#synchronized-的作用？\" class=\"headerlink\" title=\"synchronized 的作用？\"></a>synchronized 的作用？</h4><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰静态方法、实例方法、代码块。</p>\n<h4 id=\"怎么使用-synchronized-关键字\"><a href=\"#怎么使用-synchronized-关键字\" class=\"headerlink\" title=\"怎么使用 synchronized 关键字\"></a>怎么使用 synchronized 关键字</h4><p><strong>synchronized关键字最主要的三种使用方式：</strong></p>\n<ul>\n<li><strong>修饰实例方法：</strong> 给当前对象实例加锁；</li>\n<li><strong>修饰静态方法：</strong> 给当前类加锁；</li>\n<li><strong>修饰代码块：</strong>给指定对象加锁，进入同步代码块前要获得指定对象的锁。</li>\n</ul>\n<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(xxx.class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。</p>\n<h4 id=\"双重校验锁实现对象单例（线程安全）\"><a href=\"#双重校验锁实现对象单例（线程安全）\" class=\"headerlink\" title=\"双重校验锁实现对象单例（线程安全）\"></a>双重校验锁实现对象单例（线程安全）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次假如线程1，线程2，线程3到达这，都判断到null未实例化，加这个判断是为了让除了第一次实例化之后的其他线程判断到非空表明已经实例化过了，直接返回单例</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 线程1、2、3有可能都进来了</span></span><br><span class=\"line\">            <span class=\"comment\">//类对象加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;\t<span class=\"comment\">// 如果多个线程都判断到未实例化，那么只会有一个线程锁住类并进行实例化</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"literal\">null</span>) &#123;\t<span class=\"comment\">// 如果不加这个判断，线程1拿到锁进行实例化之后，线程2拿到锁，进来直接进行实例化，这就产生多次实例化操作。如果加这个判断，线程2拿到锁之后，判断到已经实例化了，就不会再进行实例化了。</span></span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，需要注意 instance 采用 volatile 关键字修饰也是很有必要。</p>\n<p>instance 采用 volatile 关键字修饰也是很有必要的，instance &#x3D; new Singleton() 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 instance 分配内存空间</li>\n<li>初始化 instance</li>\n<li>将 instance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getInstance() 后发现 instance 不为空，因此<strong>返回 T1 实例化但未初始化</strong>的 instance。</p>\n<h4 id=\"synchronized-底层实现原理？（监视器monitor）\"><a href=\"#synchronized-底层实现原理？（监视器monitor）\" class=\"headerlink\" title=\"synchronized 底层实现原理？（监视器monitor）\"></a>synchronized 底层实现原理？（监视器monitor）</h4><p>synchronized 是 Java 中的一个关键字，通过 javap 命令，查看相应的字节码文件。</p>\n<p>synchronized 同步语句块的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SynchronizedDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;synchronized 代码块&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过 JDK 反汇编指令 javap -c -v SynchronizedDemo</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20220912212554623.png\" alt=\"monitorenter&monitorexit\" style=\"zoom:50%;\" />\n\n<p>可以看出在执行同步代码块之前之后都有一个 monitor 字样，其中前面的是 monitorenter，后面的是离开 monitorexit，不难想象一个线程执行同步代码块，首先要获取锁，而获取锁的过程就是 monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行 monitorexit 指令。</p>\n<p>为什么会有两个 monitorexit 呢？（line 19）</p>\n<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。<strong>因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</strong></p>\n<h4 id=\"synchronized-可重入的原理\"><a href=\"#synchronized-可重入的原理\" class=\"headerlink\" title=\"synchronized 可重入的原理\"></a>synchronized 可重入的原理</h4><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。<br>底层原理维护一个<strong>计数器</strong>，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为 0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>\n<h4 id=\"什么是自旋\"><a href=\"#什么是自旋\" class=\"headerlink\" title=\"什么是自旋\"></a>什么是自旋</h4><blockquote>\n<p>不要遇到 synchronized 就让等待锁的线程进入阻塞状态，而是让这个线程在 synchronized 边界做忙循环</p>\n</blockquote>\n<p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，因为<strong>线程阻塞涉及到用户态和内核态切换的问题开销很大</strong>，而是<strong>在 synchronized 的边界做忙循环</strong>，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<h4 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h4><blockquote>\n<p>目的：锁升级是为了减低了锁带来的性能消耗。</p>\n</blockquote>\n<p>Java 的锁都是基于对象的，Java 对象有对象头，内容包括：</p>\n<ol>\n<li>Mark Word，存储对象的 hashCode、锁信息等；</li>\n<li>Class Metadata Address，存储到对象类型数据的指针；</li>\n<li>数组的长度（如果是数组）</li>\n</ol>\n<p>每一个线程在准备获取共享资源时： </p>\n<p>第一步，检查锁的 MarkWord 里面是不是放的自己的 ThreadId，如果是，表示当前线程是处于 “<strong>偏向锁</strong>” ；</p>\n<p>第二步，如果锁的 MarkWord 存放的不是自己的 ThreadId，这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p>\n<ul>\n<li>CAS 替换成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li>\n<li>CAS 替换失败，表示之前的线程仍然存在，根据锁的 MarkWord 里面的 ThreadId，通知该 ThreadId 的线程暂停，之前线程将 Markword 的内容置为空，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li>\n</ul>\n<p>第三步，两个线程都把锁对象的 hashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarkWord 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord；</p>\n<p>第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 ；</p>\n<p>第五步，自旋的线程在自旋过程中，如果成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 <strong>轻量级锁</strong>的状态；如果自旋失败 （这边的自旋方式可以采用适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少）；</p>\n<p>第六步，进入<strong>重量级锁</strong>的状态，这个时候，自旋的线程进入阻塞，等待竞争线程执行完成并唤醒自己。</p>\n<h4 id=\"线程-B-怎么知道线程-A-修改了变量\"><a href=\"#线程-B-怎么知道线程-A-修改了变量\" class=\"headerlink\" title=\"线程 B 怎么知道线程 A 修改了变量\"></a>线程 B 怎么知道线程 A 修改了变量</h4><ul>\n<li><p>volatile 修饰变量</p>\n</li>\n<li><p>synchronized 修饰修改变量的方法</p>\n</li>\n<li><p>lock 对修改变量的代码块加锁</p>\n</li>\n</ul>\n<h4 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h4><ul>\n<li>synchronized 是 Java 关键字，而 Lock 是个接口；</li>\n<li>synchronized 可以给静态方法、实例方法、代码块加锁，而 lock 只能给代码块加锁；</li>\n<li>synchronized 不需要手动获取锁和释放锁，而 lock 需要自己加锁和释放锁；</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h4 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p><strong>相同点：</strong></p>\n<p>两者都是可重入锁</p>\n<p>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，<strong>如果不可锁重入的话，就会造成死锁</strong>。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>\n<p><strong>不同点：</strong></p>\n<ul>\n<li>synchronized 是关键字，ReentrantLock 是类；</li>\n<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等；</li>\n</ul>\n<ul>\n<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>\n<li>二者的锁机制其实也是不一样的：<br>  ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word</li>\n</ul>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><h4 id=\"为什么代码会重排序？\"><a href=\"#为什么代码会重排序？\" class=\"headerlink\" title=\"为什么代码会重排序？\"></a>为什么代码会重排序？</h4><p>在执行程序时，为了<strong>提高性能</strong>，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>\n<ul>\n<li><strong>在单线程环境下不能改变程序运行的结果；</strong></li>\n<li><strong>存在数据依赖关系的不允许重排序</strong></li>\n</ul>\n<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>\n<h4 id=\"as-if-serial-规则和-happens-before-规则的区别\"><a href=\"#as-if-serial-规则和-happens-before-规则的区别\" class=\"headerlink\" title=\"as-if-serial 规则和 happens-before 规则的区别\"></a>as-if-serial 规则和 happens-before 规则的区别</h4><ul>\n<li>as-if-serial 规则保证 <strong>单线程</strong> 内程序的执行结果不被改变，happens-before 规则保证 <strong>正确同步的多线程</strong> 程序的执行结果不被改变。</li>\n<li>as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li>\n</ul>\n<h4 id=\"volatile-关键字的作用\"><a href=\"#volatile-关键字的作用\" class=\"headerlink\" title=\"volatile 关键字的作用\"></a>volatile 关键字的作用</h4><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和有序性（禁止指令重排），但不能保证原子性。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>\n<h4 id=\"JMM内存屏障插入策略\"><a href=\"#JMM内存屏障插入策略\" class=\"headerlink\" title=\"JMM内存屏障插入策略\"></a>JMM内存屏障插入策略</h4><p><strong>插入屏障</strong></p>\n<p>StoreStore 屏障 - volatile 写 - StoreLoad 屏障</p>\n<p>volatile 读 - LoadLoad 屏障 - LoadStore 屏障</p>\n<p><strong>volatile 与普通变量的重排序规则</strong></p>\n<ol>\n<li>如果第一个操作是 volatile 读，那无论第二个操作是什么，都不能重排序；</li>\n<li>如果第二个操作是 volatile 写，那无论第一个操作是什么，都不能重排序；</li>\n<li>如果第一个操作是 volatile 写，第二个操作是 volatile 读，那不能重排序。</li>\n</ol>\n<h4 id=\"volatile-能使得一个非原子操作变成原子操作吗？\"><a href=\"#volatile-能使得一个非原子操作变成原子操作吗？\" class=\"headerlink\" title=\"volatile 能使得一个非原子操作变成原子操作吗？\"></a>volatile 能使得一个非原子操作变成原子操作吗？</h4><p>volatile 只能保证可见性和有序性而不能保证原子性，但用 volatile 修饰 long 和 double 可以保证其操作原子性。</p>\n<h4 id=\"volatile-修饰符的有过什么实践？\"><a href=\"#volatile-修饰符的有过什么实践？\" class=\"headerlink\" title=\"volatile 修饰符的有过什么实践？\"></a>volatile 修饰符的有过什么实践？</h4><p>单例模式-双重锁检验里面用 volatile 修饰实例变量。</p>\n<h4 id=\"volatile-和-synchronized-的区别是什么？\"><a href=\"#volatile-和-synchronized-的区别是什么？\" class=\"headerlink\" title=\"volatile 和 synchronized 的区别是什么？\"></a>volatile 和 synchronized 的区别是什么？</h4><ul>\n<li>volatile 是变量修饰符；synchronized 可以修饰类、方法、代码块；</li>\n<li>volatile 仅能实现变量的修改可见性和有序性，不能保证原子性，<br>  而 synchronized 则可以保证变量的修改原子性和可见性；</li>\n<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞；</li>\n<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。synchronized 关键字在 JavaSE1.6 之后进行了主要包括为了<strong>减少获得锁和释放锁带来的性能消耗</strong>而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>\n</ul>\n<h2 id=\"Lock-体系\"><a href=\"#Lock-体系\" class=\"headerlink\" title=\"Lock 体系\"></a>Lock 体系</h2><h3 id=\"Lock-简介\"><a href=\"#Lock-简介\" class=\"headerlink\" title=\"Lock 简介\"></a>Lock 简介</h3><h4 id=\"Lock-接口是什么？对比同步它有什么优势？\"><a href=\"#Lock-接口是什么？对比同步它有什么优势？\" class=\"headerlink\" title=\"Lock 接口是什么？对比同步它有什么优势？\"></a>Lock 接口是什么？对比同步它有什么优势？</h4><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。</p>\n<p>（1）可以使锁更<strong>公平</strong></p>\n<p>（2）可以使线程在<strong>等待锁的时候响应中断</strong></p>\n<p>（3）可以<strong>让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</strong></p>\n<h4 id=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"><a href=\"#乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\" class=\"headerlink\" title=\"乐观锁和悲观锁的理解及如何实现，有哪些实现方式？\"></a>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<br>    传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p>\n<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<br>    乐观锁适用于多读的应用类型，这样可以提高吞吐量，比如 atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>\n<h4 id=\"什么是-CAS\"><a href=\"#什么是-CAS\" class=\"headerlink\" title=\"什么是 CAS\"></a>什么是 CAS</h4><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换，是一种乐观锁操作。</p>\n<p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值（B）。</p>\n<p>如果内存地址 V 里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。</p>\n<h4 id=\"Java实现CAS的原理-Unsafe类\"><a href=\"#Java实现CAS的原理-Unsafe类\" class=\"headerlink\" title=\"Java实现CAS的原理 - Unsafe类\"></a>Java实现CAS的原理 - Unsafe类</h4><p>在 Java 中，有一个<code>Unsafe</code>类，它在<code>sun.misc</code>包中。它里面是一些<code>native</code>方法（由底层的 JVM 使用 C 或者 C++去实现），其中就有几个关于 CAS 的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapObject</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,Object expected, Object x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapInt</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">int</span> expected,<span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSwapLong</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,<span class=\"type\">long</span> expected,<span class=\"type\">long</span> x)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然，他们都是<code>public native</code>的。</p>\n<p>Unsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。</p>\n<p>Linux 的 X86 下主要是通过<code>cmpxchgl</code>这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p>\n<p>当然，Unsafe 类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport 类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p>\n<h4 id=\"CAS-会产生什么问题？\"><a href=\"#CAS-会产生什么问题？\" class=\"headerlink\" title=\"CAS 会产生什么问题？\"></a>CAS 会产生什么问题？</h4><p>1、<strong>ABA 问题</strong>：</p>\n<p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。可以在变量上加一个版本戳。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>\n<p>2、<strong>循环时间长开销大</strong>：</p>\n<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p>\n<p>3、<strong>只能保证一个共享变量的原子操作</strong>：</p>\n<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是<strong>对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁</strong>。</p>\n<h4 id=\"死锁与活锁的区别，死锁与饥饿的区别？\"><a href=\"#死锁与活锁的区别，死锁与饥饿的区别？\" class=\"headerlink\" title=\"死锁与活锁的区别，死锁与饥饿的区别？\"></a>死锁与活锁的区别，死锁与饥饿的区别？</h4><blockquote>\n<p>区别：死锁动不了了；活锁一直重复尝试、失败、尝试、失败。</p>\n</blockquote>\n<p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>\n<p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致<strong>一直重复尝试，失败，尝试，失败</strong>。</p>\n<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>\n<p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>\n<p>Java 中导致饥饿的原因：高优先级线程吞噬所有的低优先级线程的 CPU 时间。</p>\n<h3 id=\"AQS详解\"><a href=\"#AQS详解\" class=\"headerlink\" title=\"AQS详解\"></a>AQS详解</h3><h4 id=\"AQS-介绍\"><a href=\"#AQS-介绍\" class=\"headerlink\" title=\"AQS 介绍\"></a>AQS 介绍</h4><p>AQS 的全称为（AbstractQueuedSynchronizer），抽象队列同步器。</p>\n<p>使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>\n<h4 id=\"AQS-原理分析\"><a href=\"#AQS-原理分析\" class=\"headerlink\" title=\"AQS 原理分析\"></a>AQS 原理分析</h4><p><strong>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。<br>如果被请求的共享资源被占用，那么就使用 CLH 队列，将暂时获取不到锁的线程加入到队列中。</strong></p>\n<blockquote>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 队列的一个结点（Node）来实现锁的分配。</p>\n</blockquote>\n<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-c906e727d699fa9c.png\" alt=\"AQS原理图\"></p>\n<p>AQS 使用一个 volatile int 类型的成员变量 state 来表示同步状态，通过内置的 CLH 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;\t<span class=\"comment\">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>\n\n<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回同步状态的当前值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">getState</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 设置同步状态的值</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(<span class=\"type\">int</span> newState)</span> &#123; </span><br><span class=\"line\">    state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetState</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>AQS 对资源的共享方式</strong></p>\n<p>AQS 定义两种资源共享方式</p>\n<ul>\n<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>\n</ul>\n</li>\n<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>\n</ul>\n<p><strong>AQS底层使用了模板方法模式</strong></p>\n<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器（<strong>模板方法模式</strong>很经典的一个应用）：</p>\n<ol>\n<li>使用者继承 AQS 并重写指定的方法。（对共享资源 state 的获取和释放）</li>\n<li>调用 AQS 的模板方法，会进一步调用使用者重写的方法。</li>\n</ol>\n<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isHeldExclusively()\t<span class=\"comment\">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class=\"line\">tryAcquire(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"type\">int</span>)\t<span class=\"comment\">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"type\">int</span>)\t<span class=\"comment\">// 共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>\n\n<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock( )到 state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。</p>\n<p>以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS 减 1。等到所有子线程都执行完后（即 state&#x3D;0），会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后续动作。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>\n<h3 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h3><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p>\n<p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，<strong>实现了读写的分离，读锁是共享的，写锁是独占的</strong>，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<h2 id=\"并发容器\"><a href=\"#并发容器\" class=\"headerlink\" title=\"并发容器\"></a>并发容器</h2><h3 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h3><h4 id=\"什么是ConcurrentHashMap？\"><a href=\"#什么是ConcurrentHashMap？\" class=\"headerlink\" title=\"什么是ConcurrentHashMap？\"></a>什么是ConcurrentHashMap？</h4><p>ConcurrentHashMap 是 Java 中的一个<strong>线程安全且高效的HashMap实现</strong>。</p>\n<p>那么它到底是如何实现线程安全的？</p>\n<p>JDK 1.6 版本关键要素：</p>\n<ul>\n<li>segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障；</li>\n<li>segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。</li>\n</ul>\n<p>JDK1.8 后，ConcurrentHashMap 抛弃了原有的 Segment 分段锁，而<strong>采用了 CAS + synchronized 来保证并发安全性</strong>。</p>\n<p>插入元素过程：</p>\n<p>如果相应位置的 Node 还没有初始化，则调用 CAS 插入相应的数据；</p>\n<p>如果相应位置的 Node 不为空，则对该节点加 synchronized 锁进行插入或更新操作。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>CopyOnWrite 容器即<strong>写时复制的容器</strong>，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>\n<p><strong>CopyOnWriteArrayList 的使用场景</strong></p>\n<p>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p>\n<p><strong>CopyOnWriteArrayList 的缺点</strong></p>\n<ol>\n<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li>\n<li><strong>不能用于实时读的场景</strong>，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，<strong>读取到数据可能还是旧的</strong>，虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>\n</ol>\n<h3 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h3><h4 id=\"ThreadLocal的数据结构\"><a href=\"#ThreadLocal的数据结构\" class=\"headerlink\" title=\"ThreadLocal的数据结构\"></a>ThreadLocal的数据结构</h4><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesthreadlocal%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.a0bfadf8.png\" alt=\"ThreadLocal数据结构\" style=\"zoom: 67%;\" />\n\n<p>每个线程 Thread 中有一个类型为 ThreadLocal.ThreadLocalMap 的实例变量 threadLocals，该实例变量中每个 entry 为 &lt;threadLocal 的弱引用，value 为强引用&gt; 的映射，每个线程往 threadLocal 中对 value 进行操作时，都是在自己线程私有的 threadLocalMap 中进行操作，从而达到线程隔离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// private static final ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;()&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     @Override</span></span><br><span class=\"line\">    <span class=\"comment\">//     protected Integer initialValue() &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         return 0;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++) &#123;</span><br><span class=\"line\">                    <span class=\"type\">Integer</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> threadLocal.get();</span><br><span class=\"line\">                    threadLocal.set(++val);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"string\">&quot;Thread-&quot;</span> + i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + threadLocal.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：启动了 2 个线程，每个线程最后都打印到 5， 最后 threadLocal.get 仍然是 0</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">1</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">2</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">1</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">3</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">4</span></span><br><span class=\"line\">Thread-<span class=\"number\">0</span> ---- <span class=\"number\">5</span></span><br><span class=\"line\">main ---- <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h3><h4 id=\"ThreadLocal造成内存泄漏的原因？\"><a href=\"#ThreadLocal造成内存泄漏的原因？\" class=\"headerlink\" title=\"ThreadLocal造成内存泄漏的原因？\"></a>ThreadLocal造成内存泄漏的原因？</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，每次使用完 ThreadLocal 后，都调用它的 remove()方法，清理掉 key 为 null 的记录。</p>\n<h3 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h3><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>\n<p>在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>\n<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>\n<p>JDK7 提供了 7 个阻塞队列。分别是：</p>\n<blockquote>\n<p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。<br>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n</blockquote>\n<p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait，notify，notifyAll，synchronized 这些关键字。而在 Java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>\n<p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，<strong>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞</strong>，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><h3 id=\"Executors-创建四种常见线程池\"><a href=\"#Executors-创建四种常见线程池\" class=\"headerlink\" title=\"Executors 创建四种常见线程池\"></a>Executors 创建四种常见线程池</h3><h4 id=\"什么是线程池？有哪几种创建方式？\"><a href=\"#什么是线程池？有哪几种创建方式？\" class=\"headerlink\" title=\"什么是线程池？有哪几种创建方式？\"></a>什么是线程池？有哪几种创建方式？</h4><blockquote>\n<p>池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>\n</blockquote>\n<p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是<strong>尽可能减少创建和销毁对象的次数</strong>，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p>\n<p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p>\n<p>（1）Executors.newSingleThreadExecutor：<code>1, 1, new LinkedBlockingQueue</code>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）</p>\n<p>（2）Executors.newFixedThreadPool：<code>nCoreThreads, nCoreThreads, new LinkedBlockingQueue</code>，所以只能创建核心线程，不能创建非核心线程。因为 LinkedBlockingQueue 的默认大小是 Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。（由于阻塞队列默认大小为 Integer.MAX_VALUE，因此可能 OOM）</p>\n<p>（3） Executors.newCachedThreadPool：<code>0, Integer.MAX_VALUE</code>，不创建核心线程，线程池最大为 Integer.MAX_VALUE。（线程池太大导致 OOM）</p>\n<p>newCachedThreadPool 和 newFixedThreadPool 都几乎不会触发拒绝策略，但是原理不同。<br>FixedThreadPool 是因为阻塞队列可以很大（最大为 Integer 最大值），故几乎不会触发拒绝策略；CachedThreadPool 是因为线程池很大（最大为 Integer 最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</p>\n<p>（4）Executors.newScheduledThreadPool：<code>nCoreThreads, Integer.MAX_VALUE</code>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<h4 id=\"线程池有什么优点？\"><a href=\"#线程池有什么优点？\" class=\"headerlink\" title=\"线程池有什么优点？\"></a>线程池有什么优点？</h4><ul>\n<li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销；</li>\n<li>提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；</li>\n<li>提高线程的可管理性：使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h4 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h4><ul>\n<li>RUNNING：接受新的任务提交，处理等待队列中的任务；</li>\n<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务；</li>\n<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；</li>\n<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()；</li>\n<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>\n</ul>\n<h4 id=\"在-Java-中-Executor-和-Executors-的区别？\"><a href=\"#在-Java-中-Executor-和-Executors-的区别？\" class=\"headerlink\" title=\"在 Java 中 Executor 和 Executors 的区别？\"></a>在 Java 中 Executor 和 Executors 的区别？</h4><ul>\n<li><strong>Executors 工具类</strong>的不同方法按照我们的需求<strong>创建了不同的线程池</strong>，来满足业务的需求；</li>\n<li><strong>Executor 接口对象执行我们的线程任务</strong>，ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li>\n</ul>\n<h4 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit() 和 execute() 方法有什么区别？\"></a>线程池中 submit() 和 execute() 方法有什么区别？</h4><p>接收参数：submit() 可以执行 Runnable 和 Callable 类型的任务，而 execute()只能执行 Runnable 类型的任务；</p>\n<p>返回值：submit() 方法可以返回持有计算结果的 Future 对象，而 execute() 没有；</p>\n<p>异常处理：submit() 方便 Exception 处理。</p>\n<h3 id=\"ThreadPoolExecutor-自定义线程池\"><a href=\"#ThreadPoolExecutor-自定义线程池\" class=\"headerlink\" title=\"ThreadPoolExecutor 自定义线程池\"></a>ThreadPoolExecutor 自定义线程池</h3><h4 id=\"Executors\"><a href=\"#Executors\" class=\"headerlink\" title=\"Executors\"></a>Executors</h4><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是<strong>通过 ThreadPoolExecutor 的方式</strong>，这样的处理方式让写的同学<strong>更加明确线程池的运行规则，规避资源耗尽的风险</strong></p>\n<p>Executors 各个方法的弊端：</p>\n<ul>\n<li><p>newSingleThreadExecutor 和 newFixedThreadPool :<br>  <code>0, 0</code>和 <code>n, n</code> ，但是使用 LinkedBlockingQueue，最大可以为 Integer.MAX_VALUE</p>\n<p>  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</p>\n</li>\n<li><p>newCachedThreadPool 和 newScheduledThreadPool:<br>  <code>0, Integer.MAX_VALUE</code> 和 <code>n, Integer.MAX_VALUE</code></p>\n<p>  主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM</p>\n</li>\n</ul>\n<p>ThreaPoolExecutor 创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>\n<h4 id=\"ThreaPoolExecutor\"><a href=\"#ThreaPoolExecutor\" class=\"headerlink\" title=\"ThreaPoolExecutor\"></a>ThreaPoolExecutor</h4><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p>\n<p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p>\n<h4 id=\"ThreadPoolExecutor构造函数重要参数分析\"><a href=\"#ThreadPoolExecutor构造函数重要参数分析\" class=\"headerlink\" title=\"ThreadPoolExecutor构造函数重要参数分析\"></a>ThreadPoolExecutor构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p>\n<ul>\n<li><strong><code>corePoolSize</code></strong> ：核心线程数，线程数定义了最小可以同时运行的线程数量</li>\n<li><strong><code>maximumPoolSize</code></strong> ：线程池中允许存在的工作线程的最大数量</li>\n<li>**<code>workQueue</code>**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在等待队列中</li>\n</ul>\n<p><code>ThreadPoolExecutor</code>其他常见参数:</p>\n<ol>\n<li>**<code>keepAliveTime</code>**：非核心线程如果处于闲置状态超过该值，就会被销毁。</li>\n<li><strong><code>unit</code></strong> ：<code>keepAliveTime</code> 闲置销毁时长的时间单位</li>\n<li>**<code>threadFactory</code>**：为线程池提供创建新线程的线程工厂</li>\n<li><strong><code>handler</code></strong> ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li>\n</ol>\n<h4 id=\"ThreadPoolExecutor拒绝策略\"><a href=\"#ThreadPoolExecutor拒绝策略\" class=\"headerlink\" title=\"ThreadPoolExecutor拒绝策略\"></a>ThreadPoolExecutor拒绝策略</h4><p><strong><code>ThreadPoolExecutor</code></strong> <strong>拒绝策略定义:</strong></p>\n<p>如果当前同时运行的线程数量达到最大线程数量并且等待队列也已经被放满时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>\n<ul>\n<li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>\n<li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：调用执行自己的线程运行任务。</li>\n<li>**<code>ThreadPoolExecutor.DiscardPolicy</code>**：不处理新任务，直接丢弃掉。</li>\n<li>**<code>ThreadPoolExecutor.DiscardOldestPolicy</code>**： 此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<h4 id=\"一个简单的线程池Demo-Runnable-ThreadPoolExecutor\"><a href=\"#一个简单的线程池Demo-Runnable-ThreadPoolExecutor\" class=\"headerlink\" title=\"一个简单的线程池Demo:Runnable + ThreadPoolExecutor\"></a>一个简单的线程池Demo:<code>Runnable</code> + <code>ThreadPoolExecutor</code></h4><p>线程池实现原理</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNS8xNmVhMDQ3NjEyOTVlNzY2.png\" alt=\"线程池实现原理\"></p>\n<p><strong>总结一下处理流程</strong></p>\n<ol>\n<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到 corePoolSize，在核心线程数量 &lt; corePoolSize 时）。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>线程总数量 &gt;&#x3D; corePoolSize 时，新来的线程任务会进入等待队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。 </li>\n<li>当等待队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>\n<li>缓存队列之前满了， 现在加非核心线程且总线程数达到了 maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>\n</ol>\n<p>整个过程如图所示：</p>\n<p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>\n<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String command;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyRunnable</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.command = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; Start. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">        processCommand();</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; End. Time = &quot;</span> + <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processCommand</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.command;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadPoolExecutorDemo</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CORE_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_POOL_SIZE</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">QUEUE_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Long</span> <span class=\"variable\">KEEP_ALIVE_TIME</span> <span class=\"operator\">=</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class=\"line\">        <span class=\"comment\">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class=\"line\">        <span class=\"type\">ThreadPoolExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">                CORE_POOL_SIZE,</span><br><span class=\"line\">                MAX_POOL_SIZE,</span><br><span class=\"line\">                KEEP_ALIVE_TIME,</span><br><span class=\"line\">                TimeUnit.SECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class=\"line\">            <span class=\"type\">Runnable</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyRunnable</span>(<span class=\"string\">&quot;&quot;</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">//执行Runnable</span></span><br><span class=\"line\">            executor.execute(worker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//终止线程池</span></span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!executor.isTerminated()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Finished all threads&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们上面的代码指定了：</p>\n<ol>\n<li><code>corePoolSize</code>: 核心线程数为 5。</li>\n<li><code>maximumPoolSize</code> ：最大线程数 10</li>\n<li><code>keepAliveTime</code> : 等待时间为 1L。</li>\n<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>\n<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>\n<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>\n</ol>\n<p><strong>Output：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">44</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> Start. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">49</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> End. Time = Tue Nov <span class=\"number\">12</span> <span class=\"number\">20</span>:<span class=\"number\">59</span>:<span class=\"number\">54</span> CST <span class=\"number\">2019</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><h3 id=\"CountDownLatch-与-CyclicBarrier\"><a href=\"#CountDownLatch-与-CyclicBarrier\" class=\"headerlink\" title=\"CountDownLatch 与 CyclicBarrier\"></a>CountDownLatch 与 CyclicBarrier</h3><p>CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>\n<ul>\n<li>CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进；</li>\n<li>调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>\n<li>CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。</li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</p>\n<p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore 有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。</p>\n<h2 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h2><h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">A</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Object</span> <span class=\"variable\">B</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程1&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (B) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源B&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 等待获得资源A&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (A) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已获得资源A&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>线程1 已获得资源A<br>线程2 已获得资源B<br>线程1 等待获得资源B<br>线程2 等待获得资源A</p>\n</blockquote>\n<h3 id=\"run方法和start方法\"><a href=\"#run方法和start方法\" class=\"headerlink\" title=\"run方法和start方法\"></a>run方法和start方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DiffStartRun</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程A&quot;</span>).run();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;线程B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>main<br>线程B</p>\n<p>new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，第一个所谓的线程A只是 main 线程的一个方法，也就是说其所在线程还是 main 线程，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>\n</blockquote>\n<h3 id=\"两个线程，交替加减\"><a href=\"#两个线程，交替加减\" class=\"headerlink\" title=\"两个线程，交替加减\"></a>两个线程，交替加减</h3><ol>\n<li><p>synchronized</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithSync</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            lock.wait();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    lock.notifyAll();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>lock + condition</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> fangyaxing</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2022/9/12</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TwoThreadWithLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        a.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value++;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    b.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lock.lock();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        b.await();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    value--;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; ---- &quot;</span> + value);</span><br><span class=\"line\">                    a.signal();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"三个线程，循环打印\"><a href=\"#三个线程，循环打印\" class=\"headerlink\" title=\"三个线程，循环打印\"></a>三个线程，循环打印</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo5</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Condition</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputA</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                a.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">1</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出A&quot;</span>);</span><br><span class=\"line\">            b.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputB</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                b.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">2</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出B&quot;</span>);</span><br><span class=\"line\">            c.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outputC</span><span class=\"params\">(<span class=\"type\">int</span> round)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (value != <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                c.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            value = <span class=\"number\">0</span>;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;第&quot;</span> + round + <span class=\"string\">&quot;轮，&quot;</span> + Thread.currentThread().getName() + <span class=\"string\">&quot;输出C&quot;</span>);</span><br><span class=\"line\">            a.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Demo5</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Demo5</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputA(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-A&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputB(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-B&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">                s.outputC(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;Thread-C&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java八股文 - MyBatis","copyright":true,"mathjax":false,"date":"2023-01-23T07:30:00.000Z","toc":true,"urlname":"java-mybatis","_content":"\n> 整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n\n### 什么是MyBatis？\n\n1. MyBatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理**加载驱动、创建连接、创建statement**等繁杂的过程。\n2. 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 mybatis 框架执行 SQL 并将结果映射为 java 对象并返回。（从执行 SQL 到返回 result 的过程）。\n\n### ORM是什么\n\nORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来\n\n让我们可以操作实体类就实现操作数据库表。\n\n### 为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\n\nMyBatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，称之为半自动 ORM 映射工具。\n\n### JDBC编程有哪些不足之处，MyBatis是如何解决的？\n\n1. 数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能\n2. SQL 语句写在代码中造成代码**不易维护**\n3. 向 SQL 语句**传参**麻烦\n4. 对**结果集解析**麻烦\n\n### MyBatis编程步骤是什么样的？\n\n1. 读取配置文件，创建 SqlSessionFactory 工厂\n2. 通过 SqlSessionFactory 工厂创建 SqlSession 对象\n3. 使用 SqlSession 创建 Dao 接口的代理对象\n4. 使用代理对象执行方法\n5. 调用 session.commit()提交事务\n6. 调用 session.close()关闭会话\n\n### \\#{}和\\${}的区别是什么？\n\nmybatis 在处理 \\#{} 时，会将 SQL 中的 \\#{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值。\n这是**预编译处理**，可以提高 SQL 执行效率，更重要的是**可以防止SQL注入**；\n\nmybatis 在处理 \\${} 时，就是把 \\${} 使用**字符串替换**。使用该方式如果传入 id 的话，会把 id=1 转换为 id=\"1\"字符串形式，而数据库中 id 实际为数值型这样就不匹配了，查询失败。（\\${}是字符串替换，通常在 EL 表达式中使用，用来展示后端传递到前端的值）。\n\n### 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\n\n1. 通过在查询的 SQL 语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。\n2. 通过 `<resultMap>`来映射字段名和实体类属性名的一一对应的关系。\n\n### 模糊查询like语句该怎么写?\n\n1. 在 Java 代码中添加 SQL 通配符。\n\n\t```xml\n\tstring wildcardname = “%smi%”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like #{value}\n\t</select>\n\t```\n\n2. 在 SQL 语句中拼接通配符%，会引起 SQL 注入\n\n\t```xml\n\tstring wildcardname = “smi”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like \"%\"#{value}\"%\"\n\t</select>\n\t```\n\n### MyBatis都有哪些Executor执行器？它们之间的区别是什么？\n\nMyBatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。\n\n- **SimpleExecutor** ：每次开启一个 Statement 对象，用完立刻关闭 Statement 对象。\n- **ReuseExecutor** ：重复使用创建的 Statement 对象。\n- **BatchExecutor** ：缓存了多个 Statement 对象，一起执行批量更新。\n\n### 通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\n\nDao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 SQL 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.yaxing.dao.IUserDao.findAll`，可以唯一找到 namespace 为`com.yaxing.dao.IUserDao`下面`id = findAll`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象，然后执行后续的操作。\n\n```xml\n<mapper namespace=\"com.yaxing.dao.IUserDao\">\n    <select id=\"findAll\" resultType=\"com.yaxing.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\nDao 接口里的方法可以重载，但是 MyBatis 的 XML 里面的 ID 不允许重复，也就是说对于同一个接口方法名，mapper 文件中只能有一个该 id。\n可以使用动态 SQL 实现接口重载对应的 maper。\n\n```java\n/**\n * Mapper接口里面方法重载\n */\npublic interface StuMapper {\n    List<Student> getAllStu();\n    List<Student> getAllStu(@Param(\"id\") Integer id);\n}\n```\n\n然后在 `StuMapper.xml` 中利用 MyBatis 的动态 SQL 就可以实现。\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。\n\n**MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。**\n\n### MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n1. 使用 `<resultMap>`标签，逐一定义数据库列名和对象属性名之间的映射关系。\n\n2. 使用 SQL 列的别名功能，将列的别名属性对应为对象属性名。\n\n有了列名与属性名的映射关系后，MyBatis**通过反射创建对象**，同时**使用反射给对象的属性逐一赋值**并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n### 在mapper中如何传递多个参数?\n\n1. 顺序传参法，\\#{} 里面的数字代表传入参数的顺序\n2. @Param 注解传参法，\\#{} 里面的名称对应的是注解@Param 括号里面修饰的名称\n3. map 传参，\\#{} 里面的名称对应的是 Map 里面的 key 名称。\n4. Java Bean 传参法，\\#{} 里面的名称对应的是 User 类里面的成员属性。\n\n### MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\n\nMyBatis 动态 SQL 可以在 xml 映射文件内，以标签的形式编写动态 SQL.\n\n执行原理是根据表达式的值 完成逻辑判断并动态拼接 SQL。\n\nMyBatis 提供了 9 种动态 SQL 标签： 常用的有 `if|where|foreach`\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n### MyBatis实现一对多有几种方式,怎么操作的？\n\n有**联合查询**和**嵌套查询**。\n\n联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面的 collection 节点配置一对多的类就可以完成；\n\n嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。\n\n### MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\n\nMyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。\nassociation 指的就是一对一，collection 指的就是一对多查询。\n在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。\n\n它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n### MyBatis的一级、二级缓存\n\n**一级缓存**：一级缓存是 SqlSession 范围的缓存\n\n当我们执行查询之后，查询的结果会同时存入到 SqlSession 为我们提供的一块区域中。该区域的结构是一个 Map。\n当我们再次查询同样的数据时，MyBatis 会先去 SqlSession 中查询是否有，有的话直接拿出来用。\n\n当调用 SqlSession 的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。\n\n> 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。 \n> 得到用户信息，将用户信息存储到一级缓存中。 \n> 如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 \n> 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。\n\n**二级缓存**：二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 SQL 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。\n\nMyBatis 中 SqlSessionFactory 对象的缓存\n\n​\t由同一个 SqlSessionFactory 对象创建的 SqlSession 共享其缓存。\n\n​\t二级缓存存放的是数据，而不是对象。\n\n> SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。\n> 如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。 \n> SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。\n\n1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；\n\n2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 `<cache/>` ；\n\n3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 \n\n### 什么是MyBatis的接口绑定？有哪些实现方式？\n\n接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。\n\n接口绑定有两种实现方式：\n\n1. 通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含 Sql 语句来绑定；\n2. 通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。\n","source":"_posts/Java八股文 - MyBatis.md","raw":"---\ntitle: Java八股文 - MyBatis\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 15:30:00\ntags:\ntoc: true\nurlname: java-mybatis\n---\n\n> 整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n\n### 什么是MyBatis？\n\n1. MyBatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理**加载驱动、创建连接、创建statement**等繁杂的过程。\n2. 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 mybatis 框架执行 SQL 并将结果映射为 java 对象并返回。（从执行 SQL 到返回 result 的过程）。\n\n### ORM是什么\n\nORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来\n\n让我们可以操作实体类就实现操作数据库表。\n\n### 为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\n\nMyBatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，称之为半自动 ORM 映射工具。\n\n### JDBC编程有哪些不足之处，MyBatis是如何解决的？\n\n1. 数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能\n2. SQL 语句写在代码中造成代码**不易维护**\n3. 向 SQL 语句**传参**麻烦\n4. 对**结果集解析**麻烦\n\n### MyBatis编程步骤是什么样的？\n\n1. 读取配置文件，创建 SqlSessionFactory 工厂\n2. 通过 SqlSessionFactory 工厂创建 SqlSession 对象\n3. 使用 SqlSession 创建 Dao 接口的代理对象\n4. 使用代理对象执行方法\n5. 调用 session.commit()提交事务\n6. 调用 session.close()关闭会话\n\n### \\#{}和\\${}的区别是什么？\n\nmybatis 在处理 \\#{} 时，会将 SQL 中的 \\#{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值。\n这是**预编译处理**，可以提高 SQL 执行效率，更重要的是**可以防止SQL注入**；\n\nmybatis 在处理 \\${} 时，就是把 \\${} 使用**字符串替换**。使用该方式如果传入 id 的话，会把 id=1 转换为 id=\"1\"字符串形式，而数据库中 id 实际为数值型这样就不匹配了，查询失败。（\\${}是字符串替换，通常在 EL 表达式中使用，用来展示后端传递到前端的值）。\n\n### 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\n\n1. 通过在查询的 SQL 语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。\n2. 通过 `<resultMap>`来映射字段名和实体类属性名的一一对应的关系。\n\n### 模糊查询like语句该怎么写?\n\n1. 在 Java 代码中添加 SQL 通配符。\n\n\t```xml\n\tstring wildcardname = “%smi%”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like #{value}\n\t</select>\n\t```\n\n2. 在 SQL 语句中拼接通配符%，会引起 SQL 注入\n\n\t```xml\n\tstring wildcardname = “smi”;\n\tlist<name> names = mapper.selectlike(wildcardname);\n\t\n\t<select id=”selectlike”>\n\t\tselect * from foo where bar like \"%\"#{value}\"%\"\n\t</select>\n\t```\n\n### MyBatis都有哪些Executor执行器？它们之间的区别是什么？\n\nMyBatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。\n\n- **SimpleExecutor** ：每次开启一个 Statement 对象，用完立刻关闭 Statement 对象。\n- **ReuseExecutor** ：重复使用创建的 Statement 对象。\n- **BatchExecutor** ：缓存了多个 Statement 对象，一起执行批量更新。\n\n### 通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\n\nDao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 SQL 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.yaxing.dao.IUserDao.findAll`，可以唯一找到 namespace 为`com.yaxing.dao.IUserDao`下面`id = findAll`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象，然后执行后续的操作。\n\n```xml\n<mapper namespace=\"com.yaxing.dao.IUserDao\">\n    <select id=\"findAll\" resultType=\"com.yaxing.domain.User\">\n        select * from user;\n    </select>\n</mapper>\n```\n\nDao 接口里的方法可以重载，但是 MyBatis 的 XML 里面的 ID 不允许重复，也就是说对于同一个接口方法名，mapper 文件中只能有一个该 id。\n可以使用动态 SQL 实现接口重载对应的 maper。\n\n```java\n/**\n * Mapper接口里面方法重载\n */\npublic interface StuMapper {\n    List<Student> getAllStu();\n    List<Student> getAllStu(@Param(\"id\") Integer id);\n}\n```\n\n然后在 `StuMapper.xml` 中利用 MyBatis 的动态 SQL 就可以实现。\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。\n\n**MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。**\n\n### MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n1. 使用 `<resultMap>`标签，逐一定义数据库列名和对象属性名之间的映射关系。\n\n2. 使用 SQL 列的别名功能，将列的别名属性对应为对象属性名。\n\n有了列名与属性名的映射关系后，MyBatis**通过反射创建对象**，同时**使用反射给对象的属性逐一赋值**并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n### 在mapper中如何传递多个参数?\n\n1. 顺序传参法，\\#{} 里面的数字代表传入参数的顺序\n2. @Param 注解传参法，\\#{} 里面的名称对应的是注解@Param 括号里面修饰的名称\n3. map 传参，\\#{} 里面的名称对应的是 Map 里面的 key 名称。\n4. Java Bean 传参法，\\#{} 里面的名称对应的是 User 类里面的成员属性。\n\n### MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\n\nMyBatis 动态 SQL 可以在 xml 映射文件内，以标签的形式编写动态 SQL.\n\n执行原理是根据表达式的值 完成逻辑判断并动态拼接 SQL。\n\nMyBatis 提供了 9 种动态 SQL 标签： 常用的有 `if|where|foreach`\n\n```xml\n<select id=\"getAllStu\" resultType=\"com.pojo.Student\">\n    select * from student\n    <where>\n        <if test=\"id != null\">\n            id = #{id}\n        </if>\n    </where>\n</select>\n```\n\n### MyBatis实现一对多有几种方式,怎么操作的？\n\n有**联合查询**和**嵌套查询**。\n\n联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面的 collection 节点配置一对多的类就可以完成；\n\n嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。\n\n### MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\n\nMyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。\nassociation 指的就是一对一，collection 指的就是一对多查询。\n在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。\n\n它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n### MyBatis的一级、二级缓存\n\n**一级缓存**：一级缓存是 SqlSession 范围的缓存\n\n当我们执行查询之后，查询的结果会同时存入到 SqlSession 为我们提供的一块区域中。该区域的结构是一个 Map。\n当我们再次查询同样的数据时，MyBatis 会先去 SqlSession 中查询是否有，有的话直接拿出来用。\n\n当调用 SqlSession 的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。\n\n> 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。 \n> 得到用户信息，将用户信息存储到一级缓存中。 \n> 如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 \n> 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。\n\n**二级缓存**：二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 SQL 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。\n\nMyBatis 中 SqlSessionFactory 对象的缓存\n\n​\t由同一个 SqlSessionFactory 对象创建的 SqlSession 共享其缓存。\n\n​\t二级缓存存放的是数据，而不是对象。\n\n> SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。\n> 如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。 \n> SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。\n\n1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；\n\n2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 `<cache/>` ；\n\n3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存 Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 \n\n### 什么是MyBatis的接口绑定？有哪些实现方式？\n\n接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。\n\n接口绑定有两种实现方式：\n\n1. 通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含 Sql 语句来绑定；\n2. 通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。\n","slug":"Java八股文 - MyBatis","published":1,"updated":"2023-01-26T12:35:58.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw31y000bt9t8d77e6f6g","content":"<blockquote>\n<p>整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<span id=\"more\"></span></p>\n</blockquote>\n<h3 id=\"什么是MyBatis？\"><a href=\"#什么是MyBatis？\" class=\"headerlink\" title=\"什么是MyBatis？\"></a>什么是MyBatis？</h3><ol>\n<li>MyBatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理<strong>加载驱动、创建连接、创建statement</strong>等繁杂的过程。</li>\n<li>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 mybatis 框架执行 SQL 并将结果映射为 java 对象并返回。（从执行 SQL 到返回 result 的过程）。</li>\n</ol>\n<h3 id=\"ORM是什么\"><a href=\"#ORM是什么\" class=\"headerlink\" title=\"ORM是什么\"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来</p>\n<p>让我们可以操作实体类就实现操作数据库表。</p>\n<h3 id=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"><a href=\"#为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\" class=\"headerlink\" title=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"></a>为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>MyBatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，称之为半自动 ORM 映射工具。</p>\n<h3 id=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"><a href=\"#JDBC编程有哪些不足之处，MyBatis是如何解决的？\" class=\"headerlink\" title=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h3><ol>\n<li>数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能</li>\n<li>SQL 语句写在代码中造成代码<strong>不易维护</strong></li>\n<li>向 SQL 语句<strong>传参</strong>麻烦</li>\n<li>对<strong>结果集解析</strong>麻烦</li>\n</ol>\n<h3 id=\"MyBatis编程步骤是什么样的？\"><a href=\"#MyBatis编程步骤是什么样的？\" class=\"headerlink\" title=\"MyBatis编程步骤是什么样的？\"></a>MyBatis编程步骤是什么样的？</h3><ol>\n<li>读取配置文件，创建 SqlSessionFactory 工厂</li>\n<li>通过 SqlSessionFactory 工厂创建 SqlSession 对象</li>\n<li>使用 SqlSession 创建 Dao 接口的代理对象</li>\n<li>使用代理对象执行方法</li>\n<li>调用 session.commit()提交事务</li>\n<li>调用 session.close()关闭会话</li>\n</ol>\n<h3 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h3><p>mybatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值。<br>这是<strong>预编译处理</strong>，可以提高 SQL 执行效率，更重要的是<strong>可以防止SQL注入</strong>；</p>\n<p>mybatis 在处理 ${} 时，就是把 ${} 使用<strong>字符串替换</strong>。使用该方式如果传入 id 的话，会把 id&#x3D;1 转换为 id&#x3D;”1”字符串形式，而数据库中 id 实际为数值型这样就不匹配了，查询失败。（${}是字符串替换，通常在 EL 表达式中使用，用来展示后端传递到前端的值）。</p>\n<h3 id=\"当实体类中的属性名和表中的字段名不一样-，怎么办-？\"><a href=\"#当实体类中的属性名和表中的字段名不一样-，怎么办-？\" class=\"headerlink\" title=\"当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><ol>\n<li>通过在查询的 SQL 语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。</li>\n<li>通过 <code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</li>\n</ol>\n<h3 id=\"模糊查询like语句该怎么写\"><a href=\"#模糊查询like语句该怎么写\" class=\"headerlink\" title=\"模糊查询like语句该怎么写?\"></a>模糊查询like语句该怎么写?</h3><ol>\n<li><p>在 Java 代码中添加 SQL 通配符。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “%smi%”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like #&#123;value&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 SQL 语句中拼接通配符%，会引起 SQL 注入</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “smi”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"><a href=\"#MyBatis都有哪些Executor执行器？它们之间的区别是什么？\" class=\"headerlink\" title=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"></a>MyBatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>MyBatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>\n<ul>\n<li><strong>SimpleExecutor</strong> ：每次开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li>\n<li><strong>ReuseExecutor</strong> ：重复使用创建的 Statement 对象。</li>\n<li><strong>BatchExecutor</strong> ：缓存了多个 Statement 对象，一起执行批量更新。</li>\n</ul>\n<h3 id=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"><a href=\"#通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\" class=\"headerlink\" title=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"></a>通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 SQL 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.yaxing.dao.IUserDao.findAll</code>，可以唯一找到 namespace 为<code>com.yaxing.dao.IUserDao</code>下面<code>id = findAll</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象，然后执行后续的操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.yaxing.dao.IUserDao&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findAll&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.yaxing.domain.User&quot;</span>&gt;</span></span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Dao 接口里的方法可以重载，但是 MyBatis 的 XML 里面的 ID 不允许重复，也就是说对于同一个接口方法名，mapper 文件中只能有一个该 id。<br>可以使用动态 SQL 实现接口重载对应的 maper。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Mapper接口里面方法重载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StuMapper</span> &#123;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>StuMapper.xml</code> 中利用 MyBatis 的动态 SQL 就可以实现。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。</p>\n<p><strong>MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>\n<h3 id=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><ol>\n<li><p>使用 <code>&lt;resultMap&gt;</code>标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>\n</li>\n<li><p>使用 SQL 列的别名功能，将列的别名属性对应为对象属性名。</p>\n</li>\n</ol>\n<p>有了列名与属性名的映射关系后，MyBatis<strong>通过反射创建对象</strong>，同时<strong>使用反射给对象的属性逐一赋值</strong>并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h3 id=\"在mapper中如何传递多个参数\"><a href=\"#在mapper中如何传递多个参数\" class=\"headerlink\" title=\"在mapper中如何传递多个参数?\"></a>在mapper中如何传递多个参数?</h3><ol>\n<li>顺序传参法，#{} 里面的数字代表传入参数的顺序</li>\n<li>@Param 注解传参法，#{} 里面的名称对应的是注解@Param 括号里面修饰的名称</li>\n<li>map 传参，#{} 里面的名称对应的是 Map 里面的 key 名称。</li>\n<li>Java Bean 传参法，#{} 里面的名称对应的是 User 类里面的成员属性。</li>\n</ol>\n<h3 id=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"><a href=\"#MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\" class=\"headerlink\" title=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"></a>MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？</h3><p>MyBatis 动态 SQL 可以在 xml 映射文件内，以标签的形式编写动态 SQL.</p>\n<p>执行原理是根据表达式的值 完成逻辑判断并动态拼接 SQL。</p>\n<p>MyBatis 提供了 9 种动态 SQL 标签： 常用的有 <code>if|where|foreach</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MyBatis实现一对多有几种方式-怎么操作的？\"><a href=\"#MyBatis实现一对多有几种方式-怎么操作的？\" class=\"headerlink\" title=\"MyBatis实现一对多有几种方式,怎么操作的？\"></a>MyBatis实现一对多有几种方式,怎么操作的？</h3><p>有<strong>联合查询</strong>和<strong>嵌套查询</strong>。</p>\n<p>联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面的 collection 节点配置一对多的类就可以完成；</p>\n<p>嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</p>\n<h3 id=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。<br>association 指的就是一对一，collection 指的就是一对多查询。<br>在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</p>\n<p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>\n<h3 id=\"MyBatis的一级、二级缓存\"><a href=\"#MyBatis的一级、二级缓存\" class=\"headerlink\" title=\"MyBatis的一级、二级缓存\"></a>MyBatis的一级、二级缓存</h3><p><strong>一级缓存</strong>：一级缓存是 SqlSession 范围的缓存</p>\n<p>当我们执行查询之后，查询的结果会同时存入到 SqlSession 为我们提供的一块区域中。该区域的结构是一个 Map。<br>当我们再次查询同样的数据时，MyBatis 会先去 SqlSession 中查询是否有，有的话直接拿出来用。</p>\n<p>当调用 SqlSession 的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。</p>\n<blockquote>\n<p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。<br>得到用户信息，将用户信息存储到一级缓存中。<br>如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。<br>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p>\n</blockquote>\n<p><strong>二级缓存</strong>：二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 SQL 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</p>\n<p>MyBatis 中 SqlSessionFactory 对象的缓存</p>\n<p>​\t由同一个 SqlSessionFactory 对象创建的 SqlSession 共享其缓存。</p>\n<p>​\t二级缓存存放的是数据，而不是对象。</p>\n<blockquote>\n<p>SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。<br>如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。<br>SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p>\n</blockquote>\n<p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；</p>\n<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p>\n<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存 Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 </p>\n<h3 id=\"什么是MyBatis的接口绑定？有哪些实现方式？\"><a href=\"#什么是MyBatis的接口绑定？有哪些实现方式？\" class=\"headerlink\" title=\"什么是MyBatis的接口绑定？有哪些实现方式？\"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p>\n<p>接口绑定有两种实现方式：</p>\n<ol>\n<li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含 Sql 语句来绑定；</li>\n<li>通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。</li>\n</ol>\n","site":{"data":{}},"length":5628,"excerpt":"<blockquote>\n<p>整理的MyBatis框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h3 id=\"什么是MyBatis？\"><a href=\"#什么是MyBatis？\" class=\"headerlink\" title=\"什么是MyBatis？\"></a>什么是MyBatis？</h3><ol>\n<li>MyBatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理<strong>加载驱动、创建连接、创建statement</strong>等繁杂的过程。</li>\n<li>通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 mybatis 框架执行 SQL 并将结果映射为 java 对象并返回。（从执行 SQL 到返回 result 的过程）。</li>\n</ol>\n<h3 id=\"ORM是什么\"><a href=\"#ORM是什么\" class=\"headerlink\" title=\"ORM是什么\"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，就是把数据库表和实体类及实体类的属性对应起来</p>\n<p>让我们可以操作实体类就实现操作数据库表。</p>\n<h3 id=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"><a href=\"#为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\" class=\"headerlink\" title=\"为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？\"></a>为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>MyBatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，称之为半自动 ORM 映射工具。</p>\n<h3 id=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"><a href=\"#JDBC编程有哪些不足之处，MyBatis是如何解决的？\" class=\"headerlink\" title=\"JDBC编程有哪些不足之处，MyBatis是如何解决的？\"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h3><ol>\n<li>数据库连接创建、释放频繁，造成系统资源浪费从而影响系统性能</li>\n<li>SQL 语句写在代码中造成代码<strong>不易维护</strong></li>\n<li>向 SQL 语句<strong>传参</strong>麻烦</li>\n<li>对<strong>结果集解析</strong>麻烦</li>\n</ol>\n<h3 id=\"MyBatis编程步骤是什么样的？\"><a href=\"#MyBatis编程步骤是什么样的？\" class=\"headerlink\" title=\"MyBatis编程步骤是什么样的？\"></a>MyBatis编程步骤是什么样的？</h3><ol>\n<li>读取配置文件，创建 SqlSessionFactory 工厂</li>\n<li>通过 SqlSessionFactory 工厂创建 SqlSession 对象</li>\n<li>使用 SqlSession 创建 Dao 接口的代理对象</li>\n<li>使用代理对象执行方法</li>\n<li>调用 session.commit()提交事务</li>\n<li>调用 session.close()关闭会话</li>\n</ol>\n<h3 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h3><p>mybatis 在处理 #{} 时，会将 SQL 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值。<br>这是<strong>预编译处理</strong>，可以提高 SQL 执行效率，更重要的是<strong>可以防止SQL注入</strong>；</p>\n<p>mybatis 在处理 ${} 时，就是把 ${} 使用<strong>字符串替换</strong>。使用该方式如果传入 id 的话，会把 id&#x3D;1 转换为 id&#x3D;”1”字符串形式，而数据库中 id 实际为数值型这样就不匹配了，查询失败。（${}是字符串替换，通常在 EL 表达式中使用，用来展示后端传递到前端的值）。</p>\n<h3 id=\"当实体类中的属性名和表中的字段名不一样-，怎么办-？\"><a href=\"#当实体类中的属性名和表中的字段名不一样-，怎么办-？\" class=\"headerlink\" title=\"当实体类中的属性名和表中的字段名不一样 ，怎么办 ？\"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办 ？</h3><ol>\n<li>通过在查询的 SQL 语句中定义数据库字段名的别名，让数据库字段名的别名和实体类的属性名一致。</li>\n<li>通过 <code>&lt;resultMap&gt;</code>来映射字段名和实体类属性名的一一对应的关系。</li>\n</ol>\n<h3 id=\"模糊查询like语句该怎么写\"><a href=\"#模糊查询like语句该怎么写\" class=\"headerlink\" title=\"模糊查询like语句该怎么写?\"></a>模糊查询like语句该怎么写?</h3><ol>\n<li><p>在 Java 代码中添加 SQL 通配符。</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “%smi%”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like #&#123;value&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 SQL 语句中拼接通配符%，会引起 SQL 注入</p>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string wildcardname = “smi”;</span><br><span class=\"line\">list<span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span> names = mapper.selectlike(wildcardname);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">”selectlike”</span>&gt;</span></span><br><span class=\"line\">\tselect * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"><a href=\"#MyBatis都有哪些Executor执行器？它们之间的区别是什么？\" class=\"headerlink\" title=\"MyBatis都有哪些Executor执行器？它们之间的区别是什么？\"></a>MyBatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>MyBatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>\n<ul>\n<li><strong>SimpleExecutor</strong> ：每次开启一个 Statement 对象，用完立刻关闭 Statement 对象。</li>\n<li><strong>ReuseExecutor</strong> ：重复使用创建的 Statement 对象。</li>\n<li><strong>BatchExecutor</strong> ：缓存了多个 Statement 对象，一起执行批量更新。</li>\n</ul>\n<h3 id=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"><a href=\"#通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\" class=\"headerlink\" title=\"通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？\"></a>通常一个xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h3><p>Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 SQL 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.yaxing.dao.IUserDao.findAll</code>，可以唯一找到 namespace 为<code>com.yaxing.dao.IUserDao</code>下面<code>id = findAll</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象，然后执行后续的操作。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;com.yaxing.dao.IUserDao&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;findAll&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.yaxing.domain.User&quot;</span>&gt;</span></span><br><span class=\"line\">        select * from user;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Dao 接口里的方法可以重载，但是 MyBatis 的 XML 里面的 ID 不允许重复，也就是说对于同一个接口方法名，mapper 文件中只能有一个该 id。<br>可以使用动态 SQL 实现接口重载对应的 maper。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Mapper接口里面方法重载</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">StuMapper</span> &#123;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    List&lt;Student&gt; <span class=\"title function_\">getAllStu</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>StuMapper.xml</code> 中利用 MyBatis 的动态 SQL 就可以实现。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>能正常运行，并能得到相应的结果，这样就实现了在 Dao 接口中写重载方法。</p>\n<p><strong>MyBatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>\n<h3 id=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>MyBatis是如何将SQL执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><ol>\n<li><p>使用 <code>&lt;resultMap&gt;</code>标签，逐一定义数据库列名和对象属性名之间的映射关系。</p>\n</li>\n<li><p>使用 SQL 列的别名功能，将列的别名属性对应为对象属性名。</p>\n</li>\n</ol>\n<p>有了列名与属性名的映射关系后，MyBatis<strong>通过反射创建对象</strong>，同时<strong>使用反射给对象的属性逐一赋值</strong>并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h3 id=\"在mapper中如何传递多个参数\"><a href=\"#在mapper中如何传递多个参数\" class=\"headerlink\" title=\"在mapper中如何传递多个参数?\"></a>在mapper中如何传递多个参数?</h3><ol>\n<li>顺序传参法，#{} 里面的数字代表传入参数的顺序</li>\n<li>@Param 注解传参法，#{} 里面的名称对应的是注解@Param 括号里面修饰的名称</li>\n<li>map 传参，#{} 里面的名称对应的是 Map 里面的 key 名称。</li>\n<li>Java Bean 传参法，#{} 里面的名称对应的是 User 类里面的成员属性。</li>\n</ol>\n<h3 id=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"><a href=\"#MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\" class=\"headerlink\" title=\"MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？\"></a>MyBatis动态SQL有什么用？执行原理？有哪些动态SQL？</h3><p>MyBatis 动态 SQL 可以在 xml 映射文件内，以标签的形式编写动态 SQL.</p>\n<p>执行原理是根据表达式的值 完成逻辑判断并动态拼接 SQL。</p>\n<p>MyBatis 提供了 9 种动态 SQL 标签： 常用的有 <code>if|where|foreach</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getAllStu&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;com.pojo.Student&quot;</span>&gt;</span></span><br><span class=\"line\">    select * from student</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">&quot;id != null&quot;</span>&gt;</span></span><br><span class=\"line\">            id = #&#123;id&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">where</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MyBatis实现一对多有几种方式-怎么操作的？\"><a href=\"#MyBatis实现一对多有几种方式-怎么操作的？\" class=\"headerlink\" title=\"MyBatis实现一对多有几种方式,怎么操作的？\"></a>MyBatis实现一对多有几种方式,怎么操作的？</h3><p>有<strong>联合查询</strong>和<strong>嵌套查询</strong>。</p>\n<p>联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面的 collection 节点配置一对多的类就可以完成；</p>\n<p>嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</p>\n<h3 id=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>MyBatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。<br>association 指的就是一对一，collection 指的就是一对多查询。<br>在 MyBatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled&#x3D;true|false。</p>\n<p>它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 SQL，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>\n<h3 id=\"MyBatis的一级、二级缓存\"><a href=\"#MyBatis的一级、二级缓存\" class=\"headerlink\" title=\"MyBatis的一级、二级缓存\"></a>MyBatis的一级、二级缓存</h3><p><strong>一级缓存</strong>：一级缓存是 SqlSession 范围的缓存</p>\n<p>当我们执行查询之后，查询的结果会同时存入到 SqlSession 为我们提供的一块区域中。该区域的结构是一个 Map。<br>当我们再次查询同样的数据时，MyBatis 会先去 SqlSession 中查询是否有，有的话直接拿出来用。</p>\n<p>当调用 SqlSession 的添加，修改，删除，commit()，close()、clearCache()等方法时，就会清空一级缓存。</p>\n<blockquote>\n<p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。<br>得到用户信息，将用户信息存储到一级缓存中。<br>如果SQLSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。<br>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p>\n</blockquote>\n<p><strong>二级缓存</strong>：二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 SQL 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</p>\n<p>MyBatis 中 SqlSessionFactory 对象的缓存</p>\n<p>​\t由同一个 SqlSessionFactory 对象创建的 SqlSession 共享其缓存。</p>\n<p>​\t二级缓存存放的是数据，而不是对象。</p>\n<blockquote>\n<p>SQLSession1去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。<br>如果SqlSession3去执行相同 mapper映射下SQL，执行commit提交，将会清空该 mapper映射下的二级缓存区域的数据。<br>SQLSession2去查询与SQLSession1相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p>\n</blockquote>\n<p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存；</p>\n<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置 <code>&lt;cache/&gt;</code> ；</p>\n<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存 Namespaces)的进行了 C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 </p>\n<h3 id=\"什么是MyBatis的接口绑定？有哪些实现方式？\"><a href=\"#什么是MyBatis的接口绑定？有哪些实现方式？\" class=\"headerlink\" title=\"什么是MyBatis的接口绑定？有哪些实现方式？\"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定, 我们直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。</p>\n<p>接口绑定有两种实现方式：</p>\n<ol>\n<li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update 等注解，里面包含 Sql 语句来绑定；</li>\n<li>通过 xml 里面写 SQL 来绑定, 在这种情况下,要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。当 Sql 语句比较简单时候,用注解绑定, 当 SQL 语句比较复杂时候,用 xml 绑定,一般用 xml 绑定的比较多。</li>\n</ol>"},{"title":"Java八股文 - Java集合","copyright":true,"mathjax":false,"date":"2023-01-23T02:06:52.000Z","toc":true,"urlname":"java-collection","_content":"\n> 整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 集合容器概述\n\n### 什么是集合\n\n用于存储数据的容器。\n\n### 集合和数组的区别\n\n- 数组是固定长度的；集合可变长度的。\n- 数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n\n### 常用的集合类有哪些？\n\nCollection 接口和 Map 接口是所有集合框架的父接口。\n\nCollection 接口：子接口包括 Set 接口和 List 接口\n\n1. Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；\n2. List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。\n\nMap 接口：实现类主要有 HashMap、TreeMap、HashTable、ConcurrentHashMap 以及 Properties 等。\n\n### List、Set、Map三者的区别？\n\n![Collection架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png)\n\nList 和 Set 两大接口是 Collection 的子接口\n\n- List：有序容器，元素可以重复，可以插入多个 null 元素，元素都有索引；\n\t常用实现类：ArrayList、LinkedList 和 Vector。\n\t\n- Set：无序容器，不可以存储重复元素，只允许存入一个 null 元素，必须保证元素唯一性；\n\n\t常用实现类：HashSet、LinkedHashSet 以及 TreeSet。\n\n* Map 是一个键值对集合，存储键、值和之间的映射。 key 无序，唯一；value 不要求有序，允许重复；\n\n\t常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。\n\n### 集合框架底层数据结构\n\n#### Collection\n\n1. List\n\n- Arraylist： Object 数组\n- Vector： Object 数组\n- LinkedList： 双向链表\n\n2. Set\n\n- HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素\n- LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。\n- TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)\n\n#### Map\n\n- HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。\n- LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\n- HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\n- TreeMap： 红黑树（自平衡的排序二叉树）\n\n### 哪些集合类是线程安全的？\n\nvector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全\n\n### Java集合的快速失败机制 “fail-fast”？\n\nfail-fast 是 Java 集合的一种**错误检测机制**，当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。\n\n例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（add、remove、clear 等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 **ConcurrentModificationException** 异常，从而产生 fail-fast 事件。\n\n原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值，从而 modCount 不等于 expectedmodCount 值抛出异常，也就是产生了 fail-fast 事件。\n\n解决办法：\n\n1. 在遍历过程中，所有涉及到改变 modCount 值的地方全部加上 synchronized；\n2. 使用 Java.util.concurrent 下的 CopyOnWriteArrayList 来替换 ArrayList；\n3. 使用 Java.util.concurrent 下的 ConcurrentHashMap 来替换 HashMap。\n\n### 怎么确保一个集合不能被修改？\n\n可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n\n```Java\nList<String> list = new ArrayList<>();\nlist. add(\"x\");\nCollection<String> clist = Collections. unmodifiableCollection(list);\nclist.add(\"y\"); // 运行时此行报错\nSystem.out.println(list. size());\n```\n\n## Collection接口\n\n### List接口\n\n#### 迭代器 Iterator 是什么？\n\nCollection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作。\n\n#### Iterator 怎么使用？有什么特点？\n\n```Java\nList<String> list = new ArrayList<>();\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String obj = it.next();\n    System.out.println(obj);\n}\n```\n\nIterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。\n\n#### 如何边遍历边移除 Collection 中的元素？\n\n边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：\n\n```java\nIterator<Integer> it = list.iterator();\nwhile(it.hasNext()){\n   // do something\n   it.remove();\n}\n```\n\n一种最常见的**错误**代码如下：\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nlist.add(\"3\");\nlist.add(\"4\");\nlist.add(\"5\");\nint cnt = 0;\nfor (String item : list) {\n  System.out.println(++cnt);\n  list.remove(item);\n}\nSystem.out.println(Arrays.toString(list.toArray()));\n```\n\n运行以上错误代码会报 **ConcurrentModificationException 异常**。\n这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个 iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据 fail-fast 机制，会抛异常。\n\n#### 遍历一个 List 有哪些不同的方式？\n\n1. for 循环，维护一个计数器；\n2. 迭代器，Iterator。Collection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作；\n3. 增强 for 循环。增强 for 循环 foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。\n\t优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。\n\n#### 说一下 ArrayList 的优缺点\n\n**ArrayList 比较适合顺序添加、随机访问的场景。**\n\nArrayList 的优点如下：\n\n- ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。\n- ArrayList 在顺序添加一个元素的时候非常方便。\n\nArrayList 的缺点如下：\n\n- 向**中间某个位置删除**元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；\n- 向**中间某个位置插入**元素的时候，也需要做元素复制操作，缺点同上。\n\n#### 如何实现数组和 List 之间的转换？\n\n- 数组转 List：使用 Arrays. asList(array) 进行转换。\n- List 转数组：使用 List 自带的 toArray() 方法。\n\n```Java\n// list to array\nList<String> list = new ArrayList<String>();\nlist.add(\"123\");\nlist.add(\"456\");\nlist.toArray(new String[0]);\n\n// array to list\nString[] array = new String[]{\"123\", \"456\"};\nArrays.asList(array);\n```\n\n#### ArrayList 和 LinkedList 的区别是什么？\n\n- 底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；\n- 访问和增删元素效率：ArrayList 随机访问和顺序插入/删除元素效率更高；\n- 内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；\n- 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。\n\n综合来说，在需要**频繁读取**集合中的元素时，更推荐使用 ArrayList，而在**插入和删除操作较多**时，更推荐使用 LinkedList。\n\n#### ArrayList 和 Vector 的区别是什么？\n\n主要区别是线程安全问题：\nVector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。\n\n#### 多线程场景下如何使用 ArrayList？\n\n可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。\n\n#### 为什么 ArrayList 的 elementData 加上 transient 修饰？\n\nArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。\n对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成 1.5 倍大小，扩容之后除了新加\n的元素以外还有多的空间没有放元素，比如现在容量是 15，而集合里面只存了 11 个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11 个元素），而不是整个数组，从而节省空间和时间。\n\n### ⭐ArrayList扩容机制\n\n> **总结：**\n>\n> * 初始化如果使用无参构造器的话：\n>\n> \t在第一次添加元素的时候，将数组容量设置为10，然后进行添加。\n>\n> \t一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。\n>\n> * 初始化如果使用有参构造器的话：\n>\n> \t那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。\n\n#### 1. 先从 ArrayList 的构造函数说起\n\n**（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：**\n\n```java\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\n**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** \n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 elementData 。\n\n#### 2. 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n##### 2.1.  `add` \n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n   // 添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n##### 2.2. `ensureCapacityInternal()` \n\n（JDK7）可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n\n**当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。**\n\n> 此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。\n\n##### 2.3. `ensureExplicitCapacity()` \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进入（执行）这个方法\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。\n\n##### 2.4. `grow()` \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）** \n\n**我们再来通过例子探究一下grow() 方法 ：**\n\n- 当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，add 方法中 return true,size 增为 1。\n- 当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n##### 2.5. `hugeCapacity()` \n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n### Set接口\n\n#### HashSet 的实现原理？\n\nHashSet 是基于 HashMap 实现的，HashSet 的值存放于 HashMap 的 key 上，HashMap 的 value 统一为 Object 常量 PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。\n\n#### HashSet是如何保证数据不可重复的？\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 \n\n```java\n// Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT = new Object();\nprivate transient HashMap<E,Object> map;\n\npublic HashSet() {\n    map = new HashMap<>();\n}\n\npublic boolean add(E e) {\n    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值\n\treturn map.put(e, PRESENT)==null;\n}\n```\n\n#### 只重写 hashCode 可以吗？\n\n两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n## Map接口\n\n### HashMap线程不安全的主要体现？\n\n1. 在 jdk1.7 中，在多线程环境下，**扩容**时会造成死链。\n\n\t> 作者：磊哥\n\t> 链接：https://www.zhihu.com/question/394039290/answer/2314917909\n\t> 来源：知乎\n\n\t1.1、\n\n\t死循环是因为并发 HashMap 扩容导致的，并发扩容的第一步，线程 T1 和线程 T2 要对 HashMap 进行扩容操作，此时 T1 和 T2 指向的是链表的头结点元素 A，而 T1 和 T2 的下一个节点，也就是 T1.next 和 T2.next 指向的是 B 节点，如下图所示： \n\n\t![多线程扩容导致死循环问题-1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg)\n\n\t1.2、\n\n\t死循环的第二步操作是，线程 T2 时间片用完进入休眠状态，而线程 T1 开始执行扩容操作，一直到线程 T1 扩容完成后，线程 T2 才被唤醒，扩容之后的场景如下图所示： \n\n\t![多线程扩容导致死循环问题-2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg)\n\n\t 从上图可知线程 T1 执行之后，**因为是头插法，所以HashMap的顺序已经发生了改变**，但线程 T2 对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2 指向的是 A 元素，T2.next 指向的节点是 B 元素。\n\n\t1.3、\n\n\t当线程 T1 执行完，而线程 T2 恢复执行时，死循环就建立了，如下图所示： \n\n\t![多线程扩容导致死循环问题-3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg)\n\n\t 因为 T1 执行完扩容之后 B 节点的下一个节点是 A，而 T2 线程指向的首节点是 A，第二个节点是 B，这个顺序刚好和 T1 扩完容完之后的节点顺序是相反的。**T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了**，这就是 HashMap 死循环导致的原因。\n\n2. 在 jdk1.8 中，在多线程环境下，**插入**时会发生数据覆盖的情况（**尾插法**）。\n\n### HashMap在JDK1.7和JDK1.8中有哪些不同？\n\n| 不同                         | JDK 1.7                                                      | JDK 1.8                                                      |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **存储结构**                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |\n| **hash值计算方式**           | 扰动处理 = 4次位运算 + 5次异或运算                           | 扰动处理 = 1次位运算 + 1次异或运算                           |\n| **存放数据的规则**           | 无冲突时，存放数组；<br />冲突时，存放链表                   | 无冲突时，存放数组；<br />冲突 & 链表长度 < 8：插入单链表；<br />链表长度>8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树 |\n| **插入数据方式**             | 头插法                                                       | 尾插法                                                       |\n| **扩容后存储位置的计算方式** | 按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&length-1 | 根据元素的hash值进行判断 <br />扩容后的位置=原位置 or 原位置 + 旧容量 |\n\n### HashMap的hash算法\n\n#### 什么是哈希？\n\nHash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；\n\nhash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）\n\n#### 什么是哈希冲突？\n\n当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞/冲突。\n\n#### HashMap的数据结构\n\n底层数据结构：数组+链表\n**数组的特点是：方便查找；链表的特点是：方便插入删除**\n所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**链地址法**的方式可以解决哈希冲突\n\n> 解决哈希冲突的其他方法：\n> 开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；\n> 再哈希法（构造多个不同的哈希函数）。\n\n![HashMap数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png)\n\n#### 扰动处理\n\n由于计算下标时，通过 h & (length - 1)，由于 hash 值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有 hash 值的低位，**高位是没有起到任何作用的**，这将会大大增加哈希碰撞的概率。所以我们的思路就是让 hashCode 值的高位也参与运算，进一步降低 hash 碰撞的概率，使得**数据分布更平均**，我们把这样的操作称为**扰动**，在**JDK 1.8**中的 hash()函数如下：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    // 与自己右移16位进行异或运算（高低位异或）\n}\n```\n\n这比在**JDK 1.7**中，更为简洁，**相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）**；\n\n#### 下标计算\n\n在得到 hash 值之后，我们要把这些 hash 值映射到相应的数组下标上，那么就可以考虑使用 hash % length\n\n而 hash % length==hash & (length-1) 并且前提是 length 是 2 的 n 次方。\n由于采用二进制位操作 &，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为 16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）\n\n```java\nstatic int indexFor(int h, int length){\n     return h & (length - 1);\n}\n```\n\n#### 为什么要将数组长度设置为 2 的n次幂呢？\n\n当数组长度为 2 的 n 次幂的时候，不同的 key 与 1111（n 个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 \n\n#### JDK1.8新增红黑树\n\n为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至 O(logn)；\n\n#### HashMap是使用了哪些方法来有效解决哈希冲突的？\n\n1. 使用链地址法（使用散列表）来链接拥有相同 hash 值的数据；\n2. 使用 2 次扰动函数（1 次位运算和 1 次异或运算）来降低哈希冲突的概率，使得数据分布更平均；\n3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。\n\n### HashMap的get方法的具体流程？\n\n1. 先使用 key 的 hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；\n2. 判断首结点，如果首结点和 key 的 **hash值** （hashCode 值经过扰动函数处理后的值）相等，并且两者的 **key值地址相等、equals相等**，则返回首结点；\n3. 否则，则红黑树或者链表中进行查找，查找时判断两个 key 的 hash 值、key 值地址相等、equals 是否都相等。\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    //Node数组不为空，数组长度大于0，数组对应下标的Node不为空\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        //也是通过 hash & (length - 1) 来替代 hash % length 的\n        (first = tab[(n - 1) & hash]) != null) {\n        \n        //先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等\n        //则返回第一个结点\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null\n        if ((e = first.next) != null) {\n            //如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //是链表结构的话就一个一个遍历，直到找到key对应的结点，\n            //或者e的下一个结点为null退出循环\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### HashMap的put方法的具体流程？\n\n1. 如果 table 未初始化或者长度为 0 空则执行 resize()进行扩容，转向②\n2. 根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果 table[i]不为空，转向③；\n3. 判断 table[i]的首个元素是否和 key 一样，如果相同（hashCode 相同、key 地址相同、equals 相同）直接覆盖 value，否则转向④；\n4. 判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；\n5. 遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；\n6. 插入成功后，判断实际存在的键值对数量 size 是否超出当前最大容量 threshold，如果超过，进行扩容。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n//实现Map.put和相关方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 步骤①：tab为空则创建 \n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 步骤②：计算index，并对null做处理  \n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 步骤③：节点key存在，直接覆盖value \n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // 步骤④：判断该链为红黑树 \n        // hash值不相等，即key不相等；为红黑树结点\n        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 步骤⑤：该链为链表 \n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                \n                //判断该链表尾部指针是不是空的\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    //判断链表的长度是否达到转化红黑树的临界值，临界值为8\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //链表结构转树形结构\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 步骤⑥：超过最大容量就扩容 \n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n### HashMap的扩容操作是怎么实现的？\n\n①.在 jdk1.8 中，resize 方法是在 hashmap 中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的 2 倍，或者初始化时（扩容为 16），就调用 resize 方法进行扩容；\n\n②.在 1.7 中，扩容之后需要重新去计算其 Hash 值，根据 Hash 值对其进行分发，但在 1.8 版本中，则是根据在同一个桶的位置中进行判断(e.hash & oldCap)是否为 0，重新进行 hash 分配后，该元素 hash 值与旧容量与运算为 0 则留在原始位置，hash 值与旧容量与运算为 1 则移动到 原位置 + oldCap 这个位置上\n\n![HashMap的resize操作](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png)\n\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;//oldTab指向hash桶数组\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {//如果oldCap不为空的话，就是hash桶数组不为空\n        if (oldCap >= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值\n            threshold = Integer.MAX_VALUE;\n            return oldTab;//返回\n        }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold 双倍扩容阀值threshold\n    }\n    // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂\n    // 直接将该值赋给新的容量\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 新的threshold = 新的cap * 0.75\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    // 计算出新的数组长度后赋给当前成员变量table\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//新建hash桶数组\n    table = newTab;//将新数组的值复制给旧的hash桶数组\n    // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散\n    if (oldTab != null) {\n        // 遍历新数组的所有桶下标\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收\n                oldTab[j] = null;\n                // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树\n                if (e.next == null)\n                    // 用同样的hash映射算法把该元素加入新的数组\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                // e是链表的头并且e.next!=null，那么处理链表中元素重排\n                else { // preserve order\n                    // loHead,loTail 代表扩容后不用变换下标，见注1\n                    Node<K,V> loHead = null, loTail = null;\n                    // hiHead,hiTail 代表扩容后变换下标，见注1\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    // 遍历链表\n                    do {             \n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead\n                                // 代表下标保持不变的链表的头元素\n                                loHead = e;\n                            else                                \n                                // loTail.next指向当前e\n                                loTail.next = e;\n                            // loTail指向当前的元素e\n                            // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，\n                            // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....\n                            // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。\n                            loTail = e;                           \n                        }\n                        else {\n                            if (hiTail == null)\n                                // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n### HashMap负载因子为什么设置为 0.75?\n\nhashmap 的源码中有一段注释解释了为什么设置为 0.75，是**空间和时间效率的折中考虑**。\n\n### 能否使用任何类作为 Map 的 key？\n\n可以使用任何类作为 Map 的 key，前提是该类重写了 hashCode 和 equals 方法。重写 hashCode() 是为了计算数据的存储位置，重写 equals 方法是为了确保 key 在哈希表中的唯一性。最终目的是为了保证 Map 中键 key 的唯一性。\n\n### 为什么HashMap中String、Integer这样的包装类适合作为key？\n\n重写了 hashCode 和 equals 方法，保证了 Map 中键**key的唯一性**。并且他们都不可变，可以将它们的 hash 值**缓存下来，提高效率**。\n\n### HashMap 与 HashTable 有什么区别？\n\n1. **线程安全**： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 `synchronized` 修饰；\n2. **效率**： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；\n3. **对Null key 和Null value的支持**： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛 NullPointerException；\n4. **初始容量大小和每次扩充容量大小的不同 **： \n\t①创建时如果不指定容量初始值，HashTable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍；\n\t②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小；\n5. **底层数据结构**： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。\n\n### ConcurrentHashMap 和 HashTable 的区别？\n\nConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。\n\n- **底层数据结构**： \n\tJDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。\n\tHashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- **实现线程安全的方式（重要）**： \n\t① **在JDK1.7的时候，ConcurrentHashMap使用分段锁** 对整个桶数组进行了分割分段(Segment 锁继承 ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 HashTable 效率提高 16 倍。）\n\t**到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap\n\t② **HashTable(全表锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n- ⭐**Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。**\n\n**两者的对比图**：\n\nHashTable:\n\n![HashTable全表锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png)\n\nJDK1.7 的 ConcurrentHashMap：\n\n![JDK1.7的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png)\n\nJDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：\n\n![JDK1.8的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png)\n","source":"_posts/Java八股文 - Java集合.md","raw":"---\ntitle: Java八股文 - Java集合\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 10:06:52\ntags:\ntoc: true\nurlname: java-collection\n---\n\n> 整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 集合容器概述\n\n### 什么是集合\n\n用于存储数据的容器。\n\n### 集合和数组的区别\n\n- 数组是固定长度的；集合可变长度的。\n- 数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n\n### 常用的集合类有哪些？\n\nCollection 接口和 Map 接口是所有集合框架的父接口。\n\nCollection 接口：子接口包括 Set 接口和 List 接口\n\n1. Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；\n2. List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。\n\nMap 接口：实现类主要有 HashMap、TreeMap、HashTable、ConcurrentHashMap 以及 Properties 等。\n\n### List、Set、Map三者的区别？\n\n![Collection架构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png)\n\nList 和 Set 两大接口是 Collection 的子接口\n\n- List：有序容器，元素可以重复，可以插入多个 null 元素，元素都有索引；\n\t常用实现类：ArrayList、LinkedList 和 Vector。\n\t\n- Set：无序容器，不可以存储重复元素，只允许存入一个 null 元素，必须保证元素唯一性；\n\n\t常用实现类：HashSet、LinkedHashSet 以及 TreeSet。\n\n* Map 是一个键值对集合，存储键、值和之间的映射。 key 无序，唯一；value 不要求有序，允许重复；\n\n\t常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。\n\n### 集合框架底层数据结构\n\n#### Collection\n\n1. List\n\n- Arraylist： Object 数组\n- Vector： Object 数组\n- LinkedList： 双向链表\n\n2. Set\n\n- HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素\n- LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。\n- TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)\n\n#### Map\n\n- HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。\n- LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\n- HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\n- TreeMap： 红黑树（自平衡的排序二叉树）\n\n### 哪些集合类是线程安全的？\n\nvector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全\n\n### Java集合的快速失败机制 “fail-fast”？\n\nfail-fast 是 Java 集合的一种**错误检测机制**，当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。\n\n例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（add、remove、clear 等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 **ConcurrentModificationException** 异常，从而产生 fail-fast 事件。\n\n原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值，从而 modCount 不等于 expectedmodCount 值抛出异常，也就是产生了 fail-fast 事件。\n\n解决办法：\n\n1. 在遍历过程中，所有涉及到改变 modCount 值的地方全部加上 synchronized；\n2. 使用 Java.util.concurrent 下的 CopyOnWriteArrayList 来替换 ArrayList；\n3. 使用 Java.util.concurrent 下的 ConcurrentHashMap 来替换 HashMap。\n\n### 怎么确保一个集合不能被修改？\n\n可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n\n```Java\nList<String> list = new ArrayList<>();\nlist. add(\"x\");\nCollection<String> clist = Collections. unmodifiableCollection(list);\nclist.add(\"y\"); // 运行时此行报错\nSystem.out.println(list. size());\n```\n\n## Collection接口\n\n### List接口\n\n#### 迭代器 Iterator 是什么？\n\nCollection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作。\n\n#### Iterator 怎么使用？有什么特点？\n\n```Java\nList<String> list = new ArrayList<>();\nIterator<String> it = list.iterator();\nwhile(it.hasNext()){\n    String obj = it.next();\n    System.out.println(obj);\n}\n```\n\nIterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。\n\n#### 如何边遍历边移除 Collection 中的元素？\n\n边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：\n\n```java\nIterator<Integer> it = list.iterator();\nwhile(it.hasNext()){\n   // do something\n   it.remove();\n}\n```\n\n一种最常见的**错误**代码如下：\n\n```java\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nlist.add(\"3\");\nlist.add(\"4\");\nlist.add(\"5\");\nint cnt = 0;\nfor (String item : list) {\n  System.out.println(++cnt);\n  list.remove(item);\n}\nSystem.out.println(Arrays.toString(list.toArray()));\n```\n\n运行以上错误代码会报 **ConcurrentModificationException 异常**。\n这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个 iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据 fail-fast 机制，会抛异常。\n\n#### 遍历一个 List 有哪些不同的方式？\n\n1. for 循环，维护一个计数器；\n2. 迭代器，Iterator。Collection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作；\n3. 增强 for 循环。增强 for 循环 foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。\n\t优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。\n\n#### 说一下 ArrayList 的优缺点\n\n**ArrayList 比较适合顺序添加、随机访问的场景。**\n\nArrayList 的优点如下：\n\n- ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。\n- ArrayList 在顺序添加一个元素的时候非常方便。\n\nArrayList 的缺点如下：\n\n- 向**中间某个位置删除**元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；\n- 向**中间某个位置插入**元素的时候，也需要做元素复制操作，缺点同上。\n\n#### 如何实现数组和 List 之间的转换？\n\n- 数组转 List：使用 Arrays. asList(array) 进行转换。\n- List 转数组：使用 List 自带的 toArray() 方法。\n\n```Java\n// list to array\nList<String> list = new ArrayList<String>();\nlist.add(\"123\");\nlist.add(\"456\");\nlist.toArray(new String[0]);\n\n// array to list\nString[] array = new String[]{\"123\", \"456\"};\nArrays.asList(array);\n```\n\n#### ArrayList 和 LinkedList 的区别是什么？\n\n- 底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；\n- 访问和增删元素效率：ArrayList 随机访问和顺序插入/删除元素效率更高；\n- 内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；\n- 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。\n\n综合来说，在需要**频繁读取**集合中的元素时，更推荐使用 ArrayList，而在**插入和删除操作较多**时，更推荐使用 LinkedList。\n\n#### ArrayList 和 Vector 的区别是什么？\n\n主要区别是线程安全问题：\nVector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。\n\n#### 多线程场景下如何使用 ArrayList？\n\n可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。\n\n#### 为什么 ArrayList 的 elementData 加上 transient 修饰？\n\nArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。\n对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成 1.5 倍大小，扩容之后除了新加\n的元素以外还有多的空间没有放元素，比如现在容量是 15，而集合里面只存了 11 个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11 个元素），而不是整个数组，从而节省空间和时间。\n\n### ⭐ArrayList扩容机制\n\n> **总结：**\n>\n> * 初始化如果使用无参构造器的话：\n>\n> \t在第一次添加元素的时候，将数组容量设置为10，然后进行添加。\n>\n> \t一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。\n>\n> * 初始化如果使用有参构造器的话：\n>\n> \t那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。\n\n#### 1. 先从 ArrayList 的构造函数说起\n\n**（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：**\n\n```java\n    /**\n     * 默认初始容量大小\n     */\n    private static final int DEFAULT_CAPACITY = 10;\n\n\n    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n    /**\n     *默认构造函数，使用初始容量10构造一个空列表(无参数构造)\n     */\n    public ArrayList() {\n        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n    }\n\n    /**\n     * 带初始容量参数的构造函数。（用户自己指定容量）\n     */\n    public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {//初始容量大于0\n            //创建initialCapacity大小的数组\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {//初始容量等于0\n            //创建空数组\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {//初始容量小于0，抛出异常\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n\n\n   /**\n    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回\n    *如果指定的集合为null，throws NullPointerException。\n    */\n     public ArrayList(Collection<? extends E> c) {\n        elementData = c.toArray();\n        if ((size = elementData.length) != 0) {\n            // c.toArray might (incorrectly) not return Object[] (see 6260652)\n            if (elementData.getClass() != Object[].class)\n                elementData = Arrays.copyOf(elementData, size, Object[].class);\n        } else {\n            // replace with empty array.\n            this.elementData = EMPTY_ELEMENTDATA;\n        }\n    }\n```\n\n**以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。** \n\n> 补充：JDK6 new 无参构造的 `ArrayList` 对象时，直接创建了长度是 10 的 `Object[]` 数组 elementData 。\n\n#### 2. 一步一步分析 ArrayList 扩容机制\n\n这里以无参构造函数创建的 ArrayList 为例分析\n\n##### 2.1.  `add` \n\n```java\n    /**\n     * 将指定的元素追加到此列表的末尾。\n     */\n    public boolean add(E e) {\n   // 添加元素之前，先调用ensureCapacityInternal方法\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        // 这里看到ArrayList添加元素的实质就相当于为数组赋值\n        elementData[size++] = e;\n        return true;\n    }\n```\n\n##### 2.2. `ensureCapacityInternal()` \n\n（JDK7）可以看到 `add` 方法 首先调用了`ensureCapacityInternal(size + 1)`\n\n```java\n   //得到最小扩容量\n    private void ensureCapacityInternal(int minCapacity) {\n        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n            // 获取默认的容量和传入参数的较大值\n            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n        }\n\n        ensureExplicitCapacity(minCapacity);\n    }\n```\n\n**当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。**\n\n> 此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。\n\n##### 2.3. `ensureExplicitCapacity()` \n\n如果调用 `ensureCapacityInternal()` 方法就一定会进入（执行）这个方法\n\n```java\n  //判断是否需要扩容\n    private void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n\n        // overflow-conscious code\n        if (minCapacity - elementData.length > 0)\n            //调用grow方法进行扩容，调用此方法代表已经开始扩容了\n            grow(minCapacity);\n    }\n```\n\n我们来仔细分析一下：\n\n- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。\n- 当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。\n- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。\n\n直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。\n\n##### 2.4. `grow()` \n\n```java\n    /**\n     * 要分配的最大数组大小\n     */\n    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * ArrayList扩容的核心方法。\n     */\n    private void grow(int minCapacity) {\n        // oldCapacity为旧容量，newCapacity为新容量\n        int oldCapacity = elementData.length;\n        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，\n        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n        if (newCapacity - minCapacity < 0)\n            newCapacity = minCapacity;\n       // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，\n       //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n        if (newCapacity - MAX_ARRAY_SIZE > 0)\n            newCapacity = hugeCapacity(minCapacity);\n        // minCapacity is usually close to size, so this is a win:\n        elementData = Arrays.copyOf(elementData, newCapacity);\n    }\n```\n\n**int newCapacity = oldCapacity + (oldCapacity >> 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）** \n\n**我们再来通过例子探究一下grow() 方法 ：**\n\n- 当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 `hugeCapacity` 方法。数组容量为 10，add 方法中 return true,size 增为 1。\n- 当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。\n- 以此类推······\n\n##### 2.5. `hugeCapacity()` \n\n从上面 `grow()` 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。\n\n```java\n    private static int hugeCapacity(int minCapacity) {\n        if (minCapacity < 0) // overflow\n            throw new OutOfMemoryError();\n        //对minCapacity和MAX_ARRAY_SIZE进行比较\n        //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小\n        //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小\n        //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n        return (minCapacity > MAX_ARRAY_SIZE) ?\n            Integer.MAX_VALUE :\n            MAX_ARRAY_SIZE;\n    }\n```\n\n### Set接口\n\n#### HashSet 的实现原理？\n\nHashSet 是基于 HashMap 实现的，HashSet 的值存放于 HashMap 的 key 上，HashMap 的 value 统一为 Object 常量 PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。\n\n#### HashSet是如何保证数据不可重复的？\n\n当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 \n\n```java\n// Dummy value to associate with an Object in the backing Map\nprivate static final Object PRESENT = new Object();\nprivate transient HashMap<E,Object> map;\n\npublic HashSet() {\n    map = new HashMap<>();\n}\n\npublic boolean add(E e) {\n    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值\n\treturn map.put(e, PRESENT)==null;\n}\n```\n\n#### 只重写 hashCode 可以吗？\n\n两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。\n\n#### 只重写 equals可以吗？\n\n如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）\n\n## Map接口\n\n### HashMap线程不安全的主要体现？\n\n1. 在 jdk1.7 中，在多线程环境下，**扩容**时会造成死链。\n\n\t> 作者：磊哥\n\t> 链接：https://www.zhihu.com/question/394039290/answer/2314917909\n\t> 来源：知乎\n\n\t1.1、\n\n\t死循环是因为并发 HashMap 扩容导致的，并发扩容的第一步，线程 T1 和线程 T2 要对 HashMap 进行扩容操作，此时 T1 和 T2 指向的是链表的头结点元素 A，而 T1 和 T2 的下一个节点，也就是 T1.next 和 T2.next 指向的是 B 节点，如下图所示： \n\n\t![多线程扩容导致死循环问题-1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg)\n\n\t1.2、\n\n\t死循环的第二步操作是，线程 T2 时间片用完进入休眠状态，而线程 T1 开始执行扩容操作，一直到线程 T1 扩容完成后，线程 T2 才被唤醒，扩容之后的场景如下图所示： \n\n\t![多线程扩容导致死循环问题-2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg)\n\n\t 从上图可知线程 T1 执行之后，**因为是头插法，所以HashMap的顺序已经发生了改变**，但线程 T2 对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2 指向的是 A 元素，T2.next 指向的节点是 B 元素。\n\n\t1.3、\n\n\t当线程 T1 执行完，而线程 T2 恢复执行时，死循环就建立了，如下图所示： \n\n\t![多线程扩容导致死循环问题-3](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg)\n\n\t 因为 T1 执行完扩容之后 B 节点的下一个节点是 A，而 T2 线程指向的首节点是 A，第二个节点是 B，这个顺序刚好和 T1 扩完容完之后的节点顺序是相反的。**T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了**，这就是 HashMap 死循环导致的原因。\n\n2. 在 jdk1.8 中，在多线程环境下，**插入**时会发生数据覆盖的情况（**尾插法**）。\n\n### HashMap在JDK1.7和JDK1.8中有哪些不同？\n\n| 不同                         | JDK 1.7                                                      | JDK 1.8                                                      |\n| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **存储结构**                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |\n| **hash值计算方式**           | 扰动处理 = 4次位运算 + 5次异或运算                           | 扰动处理 = 1次位运算 + 1次异或运算                           |\n| **存放数据的规则**           | 无冲突时，存放数组；<br />冲突时，存放链表                   | 无冲突时，存放数组；<br />冲突 & 链表长度 < 8：插入单链表；<br />链表长度>8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树 |\n| **插入数据方式**             | 头插法                                                       | 尾插法                                                       |\n| **扩容后存储位置的计算方式** | 按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&length-1 | 根据元素的hash值进行判断 <br />扩容后的位置=原位置 or 原位置 + 旧容量 |\n\n### HashMap的hash算法\n\n#### 什么是哈希？\n\nHash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；\n\nhash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）\n\n#### 什么是哈希冲突？\n\n当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞/冲突。\n\n#### HashMap的数据结构\n\n底层数据结构：数组+链表\n**数组的特点是：方便查找；链表的特点是：方便插入删除**\n所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**链地址法**的方式可以解决哈希冲突\n\n> 解决哈希冲突的其他方法：\n> 开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；\n> 再哈希法（构造多个不同的哈希函数）。\n\n![HashMap数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png)\n\n#### 扰动处理\n\n由于计算下标时，通过 h & (length - 1)，由于 hash 值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有 hash 值的低位，**高位是没有起到任何作用的**，这将会大大增加哈希碰撞的概率。所以我们的思路就是让 hashCode 值的高位也参与运算，进一步降低 hash 碰撞的概率，使得**数据分布更平均**，我们把这样的操作称为**扰动**，在**JDK 1.8**中的 hash()函数如下：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    // 与自己右移16位进行异或运算（高低位异或）\n}\n```\n\n这比在**JDK 1.7**中，更为简洁，**相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）**；\n\n#### 下标计算\n\n在得到 hash 值之后，我们要把这些 hash 值映射到相应的数组下标上，那么就可以考虑使用 hash % length\n\n而 hash % length==hash & (length-1) 并且前提是 length 是 2 的 n 次方。\n由于采用二进制位操作 &，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为 16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）\n\n```java\nstatic int indexFor(int h, int length){\n     return h & (length - 1);\n}\n```\n\n#### 为什么要将数组长度设置为 2 的n次幂呢？\n\n当数组长度为 2 的 n 次幂的时候，不同的 key 与 1111（n 个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 \n\n#### JDK1.8新增红黑树\n\n为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至 O(logn)；\n\n#### HashMap是使用了哪些方法来有效解决哈希冲突的？\n\n1. 使用链地址法（使用散列表）来链接拥有相同 hash 值的数据；\n2. 使用 2 次扰动函数（1 次位运算和 1 次异或运算）来降低哈希冲突的概率，使得数据分布更平均；\n3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。\n\n### HashMap的get方法的具体流程？\n\n1. 先使用 key 的 hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；\n2. 判断首结点，如果首结点和 key 的 **hash值** （hashCode 值经过扰动函数处理后的值）相等，并且两者的 **key值地址相等、equals相等**，则返回首结点；\n3. 否则，则红黑树或者链表中进行查找，查找时判断两个 key 的 hash 值、key 值地址相等、equals 是否都相等。\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    //Node数组不为空，数组长度大于0，数组对应下标的Node不为空\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        //也是通过 hash & (length - 1) 来替代 hash % length 的\n        (first = tab[(n - 1) & hash]) != null) {\n        \n        //先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等\n        //则返回第一个结点\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null\n        if ((e = first.next) != null) {\n            //如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //是链表结构的话就一个一个遍历，直到找到key对应的结点，\n            //或者e的下一个结点为null退出循环\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### HashMap的put方法的具体流程？\n\n1. 如果 table 未初始化或者长度为 0 空则执行 resize()进行扩容，转向②\n2. 根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果 table[i]不为空，转向③；\n3. 判断 table[i]的首个元素是否和 key 一样，如果相同（hashCode 相同、key 地址相同、equals 相同）直接覆盖 value，否则转向④；\n4. 判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；\n5. 遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；\n6. 插入成功后，判断实际存在的键值对数量 size 是否超出当前最大容量 threshold，如果超过，进行扩容。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n//实现Map.put和相关方法\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    // 步骤①：tab为空则创建 \n    // table未初始化或者长度为0，进行扩容\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    // 步骤②：计算index，并对null做处理  \n    // (n - 1) & hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        tab[i] = newNode(hash, key, value, null);\n    // 桶中已经存在元素\n    else {\n        Node<K,V> e; K k;\n        // 步骤③：节点key存在，直接覆盖value \n        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n                // 将第一个元素赋值给e，用e来记录\n                e = p;\n        // 步骤④：判断该链为红黑树 \n        // hash值不相等，即key不相等；为红黑树结点\n        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null\n        else if (p instanceof TreeNode)\n            // 放入树中\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        // 步骤⑤：该链为链表 \n        // 为链表结点\n        else {\n            // 在链表最末插入结点\n            for (int binCount = 0; ; ++binCount) {\n                // 到达链表的尾部\n                \n                //判断该链表尾部指针是不是空的\n                if ((e = p.next) == null) {\n                    // 在尾部插入新结点\n                    p.next = newNode(hash, key, value, null);\n                    //判断链表的长度是否达到转化红黑树的临界值，临界值为8\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //链表结构转树形结构\n                        treeifyBin(tab, hash);\n                    // 跳出循环\n                    break;\n                }\n                // 判断链表中结点的key值与插入的元素的key值是否相等\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    // 相等，跳出循环\n                    break;\n                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表\n                p = e;\n            }\n        }\n        //判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值\n        if (e != null) { \n            // 记录e的value\n            V oldValue = e.value;\n            // onlyIfAbsent为false或者旧值为null\n            if (!onlyIfAbsent || oldValue == null)\n                //用新值替换旧值\n                e.value = value;\n            // 访问后回调\n            afterNodeAccess(e);\n            // 返回旧值\n            return oldValue;\n        }\n    }\n    // 结构性修改\n    ++modCount;\n    // 步骤⑥：超过最大容量就扩容 \n    // 实际大小大于阈值则扩容\n    if (++size > threshold)\n        resize();\n    // 插入后回调\n    afterNodeInsertion(evict);\n    return null;\n}\n```\n\n### HashMap的扩容操作是怎么实现的？\n\n①.在 jdk1.8 中，resize 方法是在 hashmap 中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的 2 倍，或者初始化时（扩容为 16），就调用 resize 方法进行扩容；\n\n②.在 1.7 中，扩容之后需要重新去计算其 Hash 值，根据 Hash 值对其进行分发，但在 1.8 版本中，则是根据在同一个桶的位置中进行判断(e.hash & oldCap)是否为 0，重新进行 hash 分配后，该元素 hash 值与旧容量与运算为 0 则留在原始位置，hash 值与旧容量与运算为 1 则移动到 原位置 + oldCap 这个位置上\n\n![HashMap的resize操作](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png)\n\n```java\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;//oldTab指向hash桶数组\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    if (oldCap > 0) {//如果oldCap不为空的话，就是hash桶数组不为空\n        if (oldCap >= MAXIMUM_CAPACITY) {//如果大于最大容量了，就赋值为整数最大的阀值\n            threshold = Integer.MAX_VALUE;\n            return oldTab;//返回\n        }//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold 双倍扩容阀值threshold\n    }\n    // 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂\n    // 直接将该值赋给新的容量\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    // 新的threshold = 新的cap * 0.75\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    // 计算出新的数组长度后赋给当前成员变量table\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];//新建hash桶数组\n    table = newTab;//将新数组的值复制给旧的hash桶数组\n    // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散\n    if (oldTab != null) {\n        // 遍历新数组的所有桶下标\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收\n                oldTab[j] = null;\n                // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树\n                if (e.next == null)\n                    // 用同样的hash映射算法把该元素加入新的数组\n                    newTab[e.hash & (newCap - 1)] = e;\n                // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                // e是链表的头并且e.next!=null，那么处理链表中元素重排\n                else { // preserve order\n                    // loHead,loTail 代表扩容后不用变换下标，见注1\n                    Node<K,V> loHead = null, loTail = null;\n                    // hiHead,hiTail 代表扩容后变换下标，见注1\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    // 遍历链表\n                    do {             \n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                // 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead\n                                // 代表下标保持不变的链表的头元素\n                                loHead = e;\n                            else                                \n                                // loTail.next指向当前e\n                                loTail.next = e;\n                            // loTail指向当前的元素e\n                            // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，\n                            // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....\n                            // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。\n                            loTail = e;                           \n                        }\n                        else {\n                            if (hiTail == null)\n                                // 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    // 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n### HashMap负载因子为什么设置为 0.75?\n\nhashmap 的源码中有一段注释解释了为什么设置为 0.75，是**空间和时间效率的折中考虑**。\n\n### 能否使用任何类作为 Map 的 key？\n\n可以使用任何类作为 Map 的 key，前提是该类重写了 hashCode 和 equals 方法。重写 hashCode() 是为了计算数据的存储位置，重写 equals 方法是为了确保 key 在哈希表中的唯一性。最终目的是为了保证 Map 中键 key 的唯一性。\n\n### 为什么HashMap中String、Integer这样的包装类适合作为key？\n\n重写了 hashCode 和 equals 方法，保证了 Map 中键**key的唯一性**。并且他们都不可变，可以将它们的 hash 值**缓存下来，提高效率**。\n\n### HashMap 与 HashTable 有什么区别？\n\n1. **线程安全**： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 `synchronized` 修饰；\n2. **效率**： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；\n3. **对Null key 和Null value的支持**： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛 NullPointerException；\n4. **初始容量大小和每次扩充容量大小的不同 **： \n\t①创建时如果不指定容量初始值，HashTable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍；\n\t②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小；\n5. **底层数据结构**： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。\n\n### ConcurrentHashMap 和 HashTable 的区别？\n\nConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。\n\n- **底层数据结构**： \n\tJDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。\n\tHashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- **实现线程安全的方式（重要）**： \n\t① **在JDK1.7的时候，ConcurrentHashMap使用分段锁** 对整个桶数组进行了分割分段(Segment 锁继承 ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 HashTable 效率提高 16 倍。）\n\t**到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）** 整个看起来就像是优化过且线程安全的 HashMap\n\t② **HashTable(全表锁)** :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n- ⭐**Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。**\n\n**两者的对比图**：\n\nHashTable:\n\n![HashTable全表锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png)\n\nJDK1.7 的 ConcurrentHashMap：\n\n![JDK1.7的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png)\n\nJDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：\n\n![JDK1.8的ConcurrentHashMap分段锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png)\n","slug":"Java八股文 - Java集合","published":1,"updated":"2023-01-26T12:35:58.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw320000et9t827tqb6pj","content":"<blockquote>\n<p>整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"集合容器概述\"><a href=\"#集合容器概述\" class=\"headerlink\" title=\"集合容器概述\"></a>集合容器概述</h2><h3 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h3><p>用于存储数据的容器。</p>\n<h3 id=\"集合和数组的区别\"><a href=\"#集合和数组的区别\" class=\"headerlink\" title=\"集合和数组的区别\"></a>集合和数组的区别</h3><ul>\n<li>数组是固定长度的；集合可变长度的。</li>\n<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>\n</ul>\n<h3 id=\"常用的集合类有哪些？\"><a href=\"#常用的集合类有哪些？\" class=\"headerlink\" title=\"常用的集合类有哪些？\"></a>常用的集合类有哪些？</h3><p>Collection 接口和 Map 接口是所有集合框架的父接口。</p>\n<p>Collection 接口：子接口包括 Set 接口和 List 接口</p>\n<ol>\n<li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li>\n<li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</li>\n</ol>\n<p>Map 接口：实现类主要有 HashMap、TreeMap、HashTable、ConcurrentHashMap 以及 Properties 等。</p>\n<h3 id=\"List、Set、Map三者的区别？\"><a href=\"#List、Set、Map三者的区别？\" class=\"headerlink\" title=\"List、Set、Map三者的区别？\"></a>List、Set、Map三者的区别？</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png\" alt=\"Collection架构\"></p>\n<p>List 和 Set 两大接口是 Collection 的子接口</p>\n<ul>\n<li><p>List：有序容器，元素可以重复，可以插入多个 null 元素，元素都有索引；<br>  常用实现类：ArrayList、LinkedList 和 Vector。</p>\n</li>\n<li><p>Set：无序容器，不可以存储重复元素，只允许存入一个 null 元素，必须保证元素唯一性；</p>\n<p>  常用实现类：HashSet、LinkedHashSet 以及 TreeSet。</p>\n</li>\n</ul>\n<ul>\n<li><p>Map 是一个键值对集合，存储键、值和之间的映射。 key 无序，唯一；value 不要求有序，允许重复；</p>\n<p>  常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。</p>\n</li>\n</ul>\n<h3 id=\"集合框架底层数据结构\"><a href=\"#集合框架底层数据结构\" class=\"headerlink\" title=\"集合框架底层数据结构\"></a>集合框架底层数据结构</h3><h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><ol>\n<li>List</li>\n</ol>\n<ul>\n<li>Arraylist： Object 数组</li>\n<li>Vector： Object 数组</li>\n<li>LinkedList： 双向链表</li>\n</ul>\n<ol start=\"2\">\n<li>Set</li>\n</ol>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>\n</ul>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><ul>\n<li>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。</li>\n<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>\n<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><p>vector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全</p>\n<h3 id=\"Java集合的快速失败机制-“fail-fast”？\"><a href=\"#Java集合的快速失败机制-“fail-fast”？\" class=\"headerlink\" title=\"Java集合的快速失败机制 “fail-fast”？\"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>fail-fast 是 Java 集合的一种<strong>错误检测机制</strong>，当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p>\n<p>例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（add、remove、clear 等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 <strong>ConcurrentModificationException</strong> 异常，从而产生 fail-fast 事件。</p>\n<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用 hashNext()&#x2F;next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值，从而 modCount 不等于 expectedmodCount 值抛出异常，也就是产生了 fail-fast 事件。</p>\n<p>解决办法：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变 modCount 值的地方全部加上 synchronized；</li>\n<li>使用 Java.util.concurrent 下的 CopyOnWriteArrayList 来替换 ArrayList；</li>\n<li>使用 Java.util.concurrent 下的 ConcurrentHashMap 来替换 HashMap。</li>\n</ol>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list. add(<span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class=\"line\">clist.add(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// 运行时此行报错</span></span><br><span class=\"line\">System.out.println(list. size());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>Collection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h4 id=\"如何边遍历边移除-Collection-中的元素？\"><a href=\"#如何边遍历边移除-Collection-中的元素？\" class=\"headerlink\" title=\"如何边遍历边移除 Collection 中的元素？\"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">   it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一种最常见的<strong>错误</strong>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String item : list) &#123;</span><br><span class=\"line\">  System.out.println(++cnt);</span><br><span class=\"line\">  list.remove(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(Arrays.toString(list.toArray()));</span><br></pre></td></tr></table></figure>\n\n<p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。<br>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个 iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据 fail-fast 机制，会抛异常。</p>\n<h4 id=\"遍历一个-List-有哪些不同的方式？\"><a href=\"#遍历一个-List-有哪些不同的方式？\" class=\"headerlink\" title=\"遍历一个 List 有哪些不同的方式？\"></a>遍历一个 List 有哪些不同的方式？</h4><ol>\n<li>for 循环，维护一个计数器；</li>\n<li>迭代器，Iterator。Collection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作；</li>\n<li>增强 for 循环。增强 for 循环 foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。<br> 优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<h4 id=\"说一下-ArrayList-的优缺点\"><a href=\"#说一下-ArrayList-的优缺点\" class=\"headerlink\" title=\"说一下 ArrayList 的优缺点\"></a>说一下 ArrayList 的优缺点</h4><p><strong>ArrayList 比较适合顺序添加、随机访问的场景。</strong></p>\n<p>ArrayList 的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>向<strong>中间某个位置删除</strong>元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；</li>\n<li>向<strong>中间某个位置插入</strong>元素的时候，也需要做元素复制操作，缺点同上。</li>\n</ul>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// list to array</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">list.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// array to list</span></span><br><span class=\"line\">String[] array = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;456&quot;</span>&#125;;</span><br><span class=\"line\">Arrays.asList(array);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>\n<li>底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；</li>\n<li>访问和增删元素效率：ArrayList 随机访问和顺序插入&#x2F;删除元素效率更高；</li>\n<li>内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。</li>\n</ul>\n<p>综合来说，在需要<strong>频繁读取</strong>集合中的元素时，更推荐使用 ArrayList，而在<strong>插入和删除操作较多</strong>时，更推荐使用 LinkedList。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>主要区别是线程安全问题：<br>Vector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。</p>\n<h4 id=\"多线程场景下如何使用-ArrayList？\"><a href=\"#多线程场景下如何使用-ArrayList？\" class=\"headerlink\" title=\"多线程场景下如何使用 ArrayList？\"></a>多线程场景下如何使用 ArrayList？</h4><p>可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。</p>\n<h4 id=\"为什么-ArrayList-的-elementData-加上-transient-修饰？\"><a href=\"#为什么-ArrayList-的-elementData-加上-transient-修饰？\" class=\"headerlink\" title=\"为什么 ArrayList 的 elementData 加上 transient 修饰？\"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<br>对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成 1.5 倍大小，扩容之后除了新加<br>的元素以外还有多的空间没有放元素，比如现在容量是 15，而集合里面只存了 11 个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11 个元素），而不是整个数组，从而节省空间和时间。</p>\n<h3 id=\"⭐ArrayList扩容机制\"><a href=\"#⭐ArrayList扩容机制\" class=\"headerlink\" title=\"⭐ArrayList扩容机制\"></a>⭐ArrayList扩容机制</h3><blockquote>\n<p><strong>总结：</strong></p>\n<ul>\n<li><p>初始化如果使用无参构造器的话：</p>\n<p>  在第一次添加元素的时候，将数组容量设置为10，然后进行添加。</p>\n<p>  一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。</p>\n</li>\n<li><p>初始化如果使用有参构造器的话：</p>\n<p>  那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"1-先从-ArrayList-的构造函数说起\"><a href=\"#1-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"1. 先从 ArrayList 的构造函数说起\"></a>1. 先从 ArrayList 的构造函数说起</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>\n</blockquote>\n<h4 id=\"2-一步一步分析-ArrayList-扩容机制\"><a href=\"#2-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"2. 一步一步分析 ArrayList 扩容机制\"></a>2. 一步一步分析 ArrayList 扩容机制</h4><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h5 id=\"2-1-add\"><a href=\"#2-1-add\" class=\"headerlink\" title=\"2.1.  add\"></a>2.1.  <code>add</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-ensureCapacityInternal\"><a href=\"#2-2-ensureCapacityInternal\" class=\"headerlink\" title=\"2.2. ensureCapacityInternal()\"></a>2.2. <code>ensureCapacityInternal()</code></h5><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>\n<blockquote>\n<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>\n</blockquote>\n<h5 id=\"2-3-ensureExplicitCapacity\"><a href=\"#2-3-ensureExplicitCapacity\" class=\"headerlink\" title=\"2.3. ensureExplicitCapacity()\"></a>2.3. <code>ensureExplicitCapacity()</code></h5><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>\n<h5 id=\"2-4-grow\"><a href=\"#2-4-grow\" class=\"headerlink\" title=\"2.4. grow()\"></a>2.4. <code>grow()</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong> </p>\n<p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p>\n<ul>\n<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>\n<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<h5 id=\"2-5-hugeCapacity\"><a href=\"#2-5-hugeCapacity\" class=\"headerlink\" title=\"2.5. hugeCapacity()\"></a>2.5. <code>hugeCapacity()</code></h5><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"HashSet-的实现原理？\"><a href=\"#HashSet-的实现原理？\" class=\"headerlink\" title=\"HashSet 的实现原理？\"></a>HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet 的值存放于 HashMap 的 key 上，HashMap 的 value 统一为 Object 常量 PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。</p>\n<h4 id=\"HashSet是如何保证数据不可重复的？\"><a href=\"#HashSet是如何保证数据不可重复的？\" class=\"headerlink\" title=\"HashSet是如何保证数据不可重复的？\"></a>HashSet是如何保证数据不可重复的？</h4><p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dummy value to associate with an Object in the backing Map</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap线程不安全的主要体现？\"><a href=\"#HashMap线程不安全的主要体现？\" class=\"headerlink\" title=\"HashMap线程不安全的主要体现？\"></a>HashMap线程不安全的主要体现？</h3><ol>\n<li><p>在 jdk1.7 中，在多线程环境下，<strong>扩容</strong>时会造成死链。</p>\n<blockquote>\n<p>作者：磊哥<br>链接：<a href=\"https://www.zhihu.com/question/394039290/answer/2314917909\">https://www.zhihu.com/question/394039290/answer/2314917909</a><br>来源：知乎</p>\n</blockquote>\n<p> 1.1、</p>\n<p> 死循环是因为并发 HashMap 扩容导致的，并发扩容的第一步，线程 T1 和线程 T2 要对 HashMap 进行扩容操作，此时 T1 和 T2 指向的是链表的头结点元素 A，而 T1 和 T2 的下一个节点，也就是 T1.next 和 T2.next 指向的是 B 节点，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg\" alt=\"多线程扩容导致死循环问题-1\"></p>\n<p> 1.2、</p>\n<p> 死循环的第二步操作是，线程 T2 时间片用完进入休眠状态，而线程 T1 开始执行扩容操作，一直到线程 T1 扩容完成后，线程 T2 才被唤醒，扩容之后的场景如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg\" alt=\"多线程扩容导致死循环问题-2\"></p>\n<p>  从上图可知线程 T1 执行之后，<strong>因为是头插法，所以HashMap的顺序已经发生了改变</strong>，但线程 T2 对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2 指向的是 A 元素，T2.next 指向的节点是 B 元素。</p>\n<p> 1.3、</p>\n<p> 当线程 T1 执行完，而线程 T2 恢复执行时，死循环就建立了，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg\" alt=\"多线程扩容导致死循环问题-3\"></p>\n<p>  因为 T1 执行完扩容之后 B 节点的下一个节点是 A，而 T2 线程指向的首节点是 A，第二个节点是 B，这个顺序刚好和 T1 扩完容完之后的节点顺序是相反的。<strong>T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了</strong>，这就是 HashMap 死循环导致的原因。</p>\n</li>\n<li><p>在 jdk1.8 中，在多线程环境下，<strong>插入</strong>时会发生数据覆盖的情况（<strong>尾插法</strong>）。</p>\n</li>\n</ol>\n<h3 id=\"HashMap在JDK1-7和JDK1-8中有哪些不同？\"><a href=\"#HashMap在JDK1-7和JDK1-8中有哪些不同？\" class=\"headerlink\" title=\"HashMap在JDK1.7和JDK1.8中有哪些不同？\"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>存储结构</strong></td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td><strong>hash值计算方式</strong></td>\n<td>扰动处理 &#x3D; 4次位运算 + 5次异或运算</td>\n<td>扰动处理 &#x3D; 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td><strong>存放数据的规则</strong></td>\n<td>无冲突时，存放数组；<br />冲突时，存放链表</td>\n<td>无冲突时，存放数组；<br />冲突 &amp; 链表长度 &lt; 8：插入单链表；<br />链表长度&gt;8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树</td>\n</tr>\n<tr>\n<td><strong>插入数据方式</strong></td>\n<td>头插法</td>\n<td>尾插法</td>\n</tr>\n<tr>\n<td><strong>扩容后存储位置的计算方式</strong></td>\n<td>按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&amp;length-1</td>\n<td>根据元素的hash值进行判断 <br />扩容后的位置&#x3D;原位置 or 原位置 + 旧容量</td>\n</tr>\n</tbody></table>\n<h3 id=\"HashMap的hash算法\"><a href=\"#HashMap的hash算法\" class=\"headerlink\" title=\"HashMap的hash算法\"></a>HashMap的hash算法</h3><h4 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h4><p>Hash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；</p>\n<p>hash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）</p>\n<h4 id=\"什么是哈希冲突？\"><a href=\"#什么是哈希冲突？\" class=\"headerlink\" title=\"什么是哈希冲突？\"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞&#x2F;冲突。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>底层数据结构：数组+链表<br><strong>数组的特点是：方便查找；链表的特点是：方便插入删除</strong><br>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突</p>\n<blockquote>\n<p>解决哈希冲突的其他方法：<br>开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；<br>再哈希法（构造多个不同的哈希函数）。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png\" alt=\"HashMap数据结构\"></p>\n<h4 id=\"扰动处理\"><a href=\"#扰动处理\" class=\"headerlink\" title=\"扰动处理\"></a>扰动处理</h4><p>由于计算下标时，通过 h &amp; (length - 1)，由于 hash 值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有 hash 值的低位，<strong>高位是没有起到任何作用的</strong>，这将会大大增加哈希碰撞的概率。所以我们的思路就是让 hashCode 值的高位也参与运算，进一步降低 hash 碰撞的概率，使得<strong>数据分布更平均</strong>，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的 hash()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<h4 id=\"下标计算\"><a href=\"#下标计算\" class=\"headerlink\" title=\"下标计算\"></a>下标计算</h4><p>在得到 hash 值之后，我们要把这些 hash 值映射到相应的数组下标上，那么就可以考虑使用 hash % length</p>\n<p>而 hash % length&#x3D;&#x3D;hash &amp; (length-1) 并且前提是 length 是 2 的 n 次方。<br>由于采用二进制位操作 &amp;，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为 16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">indexFor</span><span class=\"params\">(<span class=\"type\">int</span> h, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么要将数组长度设置为-2-的n次幂呢？\"><a href=\"#为什么要将数组长度设置为-2-的n次幂呢？\" class=\"headerlink\" title=\"为什么要将数组长度设置为 2 的n次幂呢？\"></a>为什么要将数组长度设置为 2 的n次幂呢？</h4><p>当数组长度为 2 的 n 次幂的时候，不同的 key 与 1111（n 个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 </p>\n<h4 id=\"JDK1-8新增红黑树\"><a href=\"#JDK1-8新增红黑树\" class=\"headerlink\" title=\"JDK1.8新增红黑树\"></a>JDK1.8新增红黑树</h4><p>为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至 O(logn)；</p>\n<h4 id=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"><a href=\"#HashMap是使用了哪些方法来有效解决哈希冲突的？\" class=\"headerlink\" title=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"></a>HashMap是使用了哪些方法来有效解决哈希冲突的？</h4><ol>\n<li>使用链地址法（使用散列表）来链接拥有相同 hash 值的数据；</li>\n<li>使用 2 次扰动函数（1 次位运算和 1 次异或运算）来降低哈希冲突的概率，使得数据分布更平均；</li>\n<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。</li>\n</ol>\n<h3 id=\"HashMap的get方法的具体流程？\"><a href=\"#HashMap的get方法的具体流程？\" class=\"headerlink\" title=\"HashMap的get方法的具体流程？\"></a>HashMap的get方法的具体流程？</h3><ol>\n<li>先使用 key 的 hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；</li>\n<li>判断首结点，如果首结点和 key 的 <strong>hash值</strong> （hashCode 值经过扰动函数处理后的值）相等，并且两者的 <strong>key值地址相等、equals相等</strong>，则返回首结点；</li>\n<li>否则，则红黑树或者链表中进行查找，查找时判断两个 key 的 hash 值、key 值地址相等、equals 是否都相等。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Node数组不为空，数组长度大于0，数组对应下标的Node不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"comment\">//也是通过 hash &amp; (length - 1) 来替代 hash % length 的</span></span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等</span></span><br><span class=\"line\">        <span class=\"comment\">//则返回第一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">//是链表结构的话就一个一个遍历，直到找到key对应的结点，</span></span><br><span class=\"line\">            <span class=\"comment\">//或者e的下一个结点为null退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的put方法的具体流程？\"><a href=\"#HashMap的put方法的具体流程？\" class=\"headerlink\" title=\"HashMap的put方法的具体流程？\"></a>HashMap的put方法的具体流程？</h3><ol>\n<li>如果 table 未初始化或者长度为 0 空则执行 resize()进行扩容，转向②</li>\n<li>根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]&#x3D;&#x3D;null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果 table[i]不为空，转向③；</li>\n<li>判断 table[i]的首个元素是否和 key 一样，如果相同（hashCode 相同、key 地址相同、equals 相同）直接覆盖 value，否则转向④；</li>\n<li>判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li>\n<li>遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</li>\n<li>插入成功后，判断实际存在的键值对数量 size 是否超出当前最大容量 threshold，如果超过，进行扩容。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Map.put和相关方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤①：tab为空则创建 </span></span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤②：计算index，并对null做处理  </span></span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤④：判断该链为红黑树 </span></span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 步骤⑤：该链为链表 </span></span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//判断该链表尾部指针是不是空的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">//链表结构转树形结构</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的扩容操作是怎么实现的？\"><a href=\"#HashMap的扩容操作是怎么实现的？\" class=\"headerlink\" title=\"HashMap的扩容操作是怎么实现的？\"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在 jdk1.8 中，resize 方法是在 hashmap 中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的 2 倍，或者初始化时（扩容为 16），就调用 resize 方法进行扩容；</p>\n<p>②.在 1.7 中，扩容之后需要重新去计算其 Hash 值，根据 Hash 值对其进行分发，但在 1.8 版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为 0，重新进行 hash 分配后，该元素 hash 值与旧容量与运算为 0 则留在原始位置，hash 值与旧容量与运算为 1 则移动到 原位置 + oldCap 这个位置上</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png\" alt=\"HashMap的resize操作\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//oldTab指向hash桶数组</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCap</span> <span class=\"operator\">=</span> (oldTab == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldThr</span> <span class=\"operator\">=</span> threshold;</span><br><span class=\"line\">    <span class=\"type\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class=\"comment\">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;<span class=\"comment\">//返回</span></span><br><span class=\"line\">        &#125;<span class=\"comment\">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold 双倍扩容阀值threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将该值赋给新的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"type\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新的threshold = 新的cap * 0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> (<span class=\"type\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"type\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"type\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[newCap];<span class=\"comment\">//新建hash桶数组</span></span><br><span class=\"line\">    table = newTab;<span class=\"comment\">//将新数组的值复制给旧的hash桶数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历新数组的所有桶下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"built_in\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"comment\">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"literal\">null</span>, loTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"literal\">null</span>, hiTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;             </span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class=\"line\">                                <span class=\"comment\">// 代表下标保持不变的链表的头元素</span></span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                </span><br><span class=\"line\">                                <span class=\"comment\">// loTail.next指向当前e</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            <span class=\"comment\">// loTail指向当前的元素e</span></span><br><span class=\"line\">                            <span class=\"comment\">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class=\"line\">                            <span class=\"comment\">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class=\"line\">                            <span class=\"comment\">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class=\"line\">                            loTail = e;                           </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap负载因子为什么设置为-0-75\"><a href=\"#HashMap负载因子为什么设置为-0-75\" class=\"headerlink\" title=\"HashMap负载因子为什么设置为 0.75?\"></a>HashMap负载因子为什么设置为 0.75?</h3><p>hashmap 的源码中有一段注释解释了为什么设置为 0.75，是<strong>空间和时间效率的折中考虑</strong>。</p>\n<h3 id=\"能否使用任何类作为-Map-的-key？\"><a href=\"#能否使用任何类作为-Map-的-key？\" class=\"headerlink\" title=\"能否使用任何类作为 Map 的 key？\"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，前提是该类重写了 hashCode 和 equals 方法。重写 hashCode() 是为了计算数据的存储位置，重写 equals 方法是为了确保 key 在哈希表中的唯一性。最终目的是为了保证 Map 中键 key 的唯一性。</p>\n<h3 id=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为key？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"></a>为什么HashMap中String、Integer这样的包装类适合作为key？</h3><p>重写了 hashCode 和 equals 方法，保证了 Map 中键<strong>key的唯一性</strong>。并且他们都不可变，可以将它们的 hash 值<strong>缓存下来，提高效率</strong>。</p>\n<h3 id=\"HashMap-与-HashTable-有什么区别？\"><a href=\"#HashMap-与-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 与 HashTable 有什么区别？\"></a>HashMap 与 HashTable 有什么区别？</h3><ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 <code>synchronized</code> 修饰；</li>\n<li><strong>效率</strong>： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛 NullPointerException；</li>\n<li>**初始容量大小和每次扩充容量大小的不同 **：<br> ①创建时如果不指定容量初始值，HashTable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍；<br> ②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小；</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-和-HashTable-的区别？\"><a href=\"#ConcurrentHashMap-和-HashTable-的区别？\" class=\"headerlink\" title=\"ConcurrentHashMap 和 HashTable 的区别？\"></a>ConcurrentHashMap 和 HashTable 的区别？</h3><p>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构</strong>：<br>  JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表&#x2F;红黑二叉树。<br>  HashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）</strong>：<br>  ① <strong>在JDK1.7的时候，ConcurrentHashMap使用分段锁</strong> 对整个桶数组进行了分割分段(Segment 锁继承 ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 HashTable 效率提高 16 倍。）<br>  <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap<br>  ② <strong>HashTable(全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n<li>⭐<strong>Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。</strong></li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png\" alt=\"HashTable全表锁\"></p>\n<p>JDK1.7 的 ConcurrentHashMap：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png\" alt=\"JDK1.7的ConcurrentHashMap分段锁\"></p>\n<p>JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png\" alt=\"JDK1.8的ConcurrentHashMap分段锁\"></p>\n","site":{"data":{}},"length":21285,"excerpt":"<blockquote>\n<p>整理的Java集合相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"集合容器概述\"><a href=\"#集合容器概述\" class=\"headerlink\" title=\"集合容器概述\"></a>集合容器概述</h2><h3 id=\"什么是集合\"><a href=\"#什么是集合\" class=\"headerlink\" title=\"什么是集合\"></a>什么是集合</h3><p>用于存储数据的容器。</p>\n<h3 id=\"集合和数组的区别\"><a href=\"#集合和数组的区别\" class=\"headerlink\" title=\"集合和数组的区别\"></a>集合和数组的区别</h3><ul>\n<li>数组是固定长度的；集合可变长度的。</li>\n<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>\n</ul>\n<h3 id=\"常用的集合类有哪些？\"><a href=\"#常用的集合类有哪些？\" class=\"headerlink\" title=\"常用的集合类有哪些？\"></a>常用的集合类有哪些？</h3><p>Collection 接口和 Map 接口是所有集合框架的父接口。</p>\n<p>Collection 接口：子接口包括 Set 接口和 List 接口</p>\n<ol>\n<li>Set 接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等；</li>\n<li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等。</li>\n</ol>\n<p>Map 接口：实现类主要有 HashMap、TreeMap、HashTable、ConcurrentHashMap 以及 Properties 等。</p>\n<h3 id=\"List、Set、Map三者的区别？\"><a href=\"#List、Set、Map三者的区别？\" class=\"headerlink\" title=\"List、Set、Map三者的区别？\"></a>List、Set、Map三者的区别？</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL290aGVyLzE0MDgxODMvMjAxOTExLzE0MDgxODMtMjAxOTExMTkxODQxNDk1NTktMTU3MTU5NTY2OC5qcGc.png\" alt=\"Collection架构\"></p>\n<p>List 和 Set 两大接口是 Collection 的子接口</p>\n<ul>\n<li><p>List：有序容器，元素可以重复，可以插入多个 null 元素，元素都有索引；<br>  常用实现类：ArrayList、LinkedList 和 Vector。</p>\n</li>\n<li><p>Set：无序容器，不可以存储重复元素，只允许存入一个 null 元素，必须保证元素唯一性；</p>\n<p>  常用实现类：HashSet、LinkedHashSet 以及 TreeSet。</p>\n</li>\n</ul>\n<ul>\n<li><p>Map 是一个键值对集合，存储键、值和之间的映射。 key 无序，唯一；value 不要求有序，允许重复；</p>\n<p>  常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap。</p>\n</li>\n</ul>\n<h3 id=\"集合框架底层数据结构\"><a href=\"#集合框架底层数据结构\" class=\"headerlink\" title=\"集合框架底层数据结构\"></a>集合框架底层数据结构</h3><h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><ol>\n<li>List</li>\n</ol>\n<ul>\n<li>Arraylist： Object 数组</li>\n<li>Vector： Object 数组</li>\n<li>LinkedList： 双向链表</li>\n</ul>\n<ol start=\"2\">\n<li>Set</li>\n</ol>\n<ul>\n<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>\n<li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li>\n<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>\n</ul>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><ul>\n<li>HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8），且数组长度大于 64，将链表转化为红黑树，以减少搜索时间，否则扩容数组。</li>\n<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>\n<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>\n<li>TreeMap： 红黑树（自平衡的排序二叉树）</li>\n</ul>\n<h3 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h3><p>vector 和 hashtable，通过在方法上加 synchronized 关键字实现线程安全</p>\n<h3 id=\"Java集合的快速失败机制-“fail-fast”？\"><a href=\"#Java集合的快速失败机制-“fail-fast”？\" class=\"headerlink\" title=\"Java集合的快速失败机制 “fail-fast”？\"></a>Java集合的快速失败机制 “fail-fast”？</h3><p>fail-fast 是 Java 集合的一种<strong>错误检测机制</strong>，当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。</p>\n<p>例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（add、remove、clear 等结构上的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 <strong>ConcurrentModificationException</strong> 异常，从而产生 fail-fast 事件。</p>\n<p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。每当迭代器使用 hashNext()&#x2F;next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值，从而 modCount 不等于 expectedmodCount 值抛出异常，也就是产生了 fail-fast 事件。</p>\n<p>解决办法：</p>\n<ol>\n<li>在遍历过程中，所有涉及到改变 modCount 值的地方全部加上 synchronized；</li>\n<li>使用 Java.util.concurrent 下的 CopyOnWriteArrayList 来替换 ArrayList；</li>\n<li>使用 Java.util.concurrent 下的 ConcurrentHashMap 来替换 HashMap。</li>\n</ol>\n<h3 id=\"怎么确保一个集合不能被修改？\"><a href=\"#怎么确保一个集合不能被修改？\" class=\"headerlink\" title=\"怎么确保一个集合不能被修改？\"></a>怎么确保一个集合不能被修改？</h3><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list. add(<span class=\"string\">&quot;x&quot;</span>);</span><br><span class=\"line\">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class=\"line\">clist.add(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// 运行时此行报错</span></span><br><span class=\"line\">System.out.println(list. size());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>Collection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">Iterator&lt;String&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> it.next();</span><br><span class=\"line\">    System.out.println(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n<h4 id=\"如何边遍历边移除-Collection-中的元素？\"><a href=\"#如何边遍历边移除-Collection-中的元素？\" class=\"headerlink\" title=\"如何边遍历边移除 Collection 中的元素？\"></a>如何边遍历边移除 Collection 中的元素？</h4><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">   <span class=\"comment\">// do something</span></span><br><span class=\"line\">   it.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一种最常见的<strong>错误</strong>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String item : list) &#123;</span><br><span class=\"line\">  System.out.println(++cnt);</span><br><span class=\"line\">  list.remove(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(Arrays.toString(list.toArray()));</span><br></pre></td></tr></table></figure>\n\n<p>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。<br>这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个 iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。集合发生结构性变化，根据 fail-fast 机制，会抛异常。</p>\n<h4 id=\"遍历一个-List-有哪些不同的方式？\"><a href=\"#遍历一个-List-有哪些不同的方式？\" class=\"headerlink\" title=\"遍历一个 List 有哪些不同的方式？\"></a>遍历一个 List 有哪些不同的方式？</h4><ol>\n<li>for 循环，维护一个计数器；</li>\n<li>迭代器，Iterator。Collection 接口实现了 Iterable 接口，通过实现 Iterable 接口中的 iterator()方法返回 Iterator 接口的实例，通过 iterator 对集合的元素进行迭代操作；</li>\n<li>增强 for 循环。增强 for 循环 foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。<br> 优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>\n</ol>\n<h4 id=\"说一下-ArrayList-的优缺点\"><a href=\"#说一下-ArrayList-的优缺点\" class=\"headerlink\" title=\"说一下 ArrayList 的优缺点\"></a>说一下 ArrayList 的优缺点</h4><p><strong>ArrayList 比较适合顺序添加、随机访问的场景。</strong></p>\n<p>ArrayList 的优点如下：</p>\n<ul>\n<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，标记 List 实现是否支持 Random Access，导致它可以随机访问的根本原因是它底层是数组结构，数组可以通过下标获取相应的值，而 RandomAccess 只是一个标记。因此查找的时候非常快。可以用 for 循环通过下标获取元素。</li>\n<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>\n</ul>\n<p>ArrayList 的缺点如下：</p>\n<ul>\n<li>向<strong>中间某个位置删除</strong>元素的时候，需要做元素复制操作。如果要复制的元素很多，那么就会比较耗费性能；</li>\n<li>向<strong>中间某个位置插入</strong>元素的时候，也需要做元素复制操作，缺点同上。</li>\n</ul>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><ul>\n<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>\n<li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// list to array</span></span><br><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">list.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// array to list</span></span><br><span class=\"line\">String[] array = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;<span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;456&quot;</span>&#125;;</span><br><span class=\"line\">Arrays.asList(array);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><ul>\n<li>底层实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现；</li>\n<li>访问和增删元素效率：ArrayList 随机访问和顺序插入&#x2F;删除元素效率更高；</li>\n<li>内存占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素；</li>\n<li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。</li>\n</ul>\n<p>综合来说，在需要<strong>频繁读取</strong>集合中的元素时，更推荐使用 ArrayList，而在<strong>插入和删除操作较多</strong>时，更推荐使用 LinkedList。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>主要区别是线程安全问题：<br>Vector 使用了 synchronized 来实现线程同步（性能差），是线程安全的，而 ArrayList 是非线程安全的。</p>\n<h4 id=\"多线程场景下如何使用-ArrayList？\"><a href=\"#多线程场景下如何使用-ArrayList？\" class=\"headerlink\" title=\"多线程场景下如何使用 ArrayList？\"></a>多线程场景下如何使用 ArrayList？</h4><p>可以用 Java.util.concurrent.CopyOnWriteArrayList 替换 ArrayList。</p>\n<h4 id=\"为什么-ArrayList-的-elementData-加上-transient-修饰？\"><a href=\"#为什么-ArrayList-的-elementData-加上-transient-修饰？\" class=\"headerlink\" title=\"为什么 ArrayList 的 elementData 加上 transient 修饰？\"></a>为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><p>ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<br>对于 elementData，由于 elementData 可能有多余的容量（容量不足会扩容成 1.5 倍大小，扩容之后除了新加<br>的元素以外还有多的空间没有放元素，比如现在容量是 15，而集合里面只存了 11 个元素），不对 elementData 加上 transient 修饰，而是手动进行序列化，可以保证只序列化实际存储的那些元素（11 个元素），而不是整个数组，从而节省空间和时间。</p>\n<h3 id=\"⭐ArrayList扩容机制\"><a href=\"#⭐ArrayList扩容机制\" class=\"headerlink\" title=\"⭐ArrayList扩容机制\"></a>⭐ArrayList扩容机制</h3><blockquote>\n<p><strong>总结：</strong></p>\n<ul>\n<li><p>初始化如果使用无参构造器的话：</p>\n<p>  在第一次添加元素的时候，将数组容量设置为10，然后进行添加。</p>\n<p>  一直添加，直到要添加的元素超出当前数组容量了，进入扩容，将数组长度扩容为1.5倍长度，然后进行添加。</p>\n</li>\n<li><p>初始化如果使用有参构造器的话：</p>\n<p>  那么每次添加元素只需要判断是否需要扩容即可，不需要第一次的初始化为10的判断。</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"1-先从-ArrayList-的构造函数说起\"><a href=\"#1-先从-ArrayList-的构造函数说起\" class=\"headerlink\" title=\"1. 先从 ArrayList 的构造函数说起\"></a>1. 先从 ArrayList 的构造函数说起</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 默认初始容量大小</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量大于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建initialCapacity大小的数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[initialCapacity];</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//初始容量等于0</span></span><br><span class=\"line\">         <span class=\"comment\">//创建空数组</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//初始容量小于0，抛出异常</span></span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Illegal Capacity: &quot;</span>+</span><br><span class=\"line\">                                            initialCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class=\"line\"><span class=\"comment\"> *如果指定的集合为null，throws NullPointerException。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class=\"line\">     elementData = c.toArray();</span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)</span><br><span class=\"line\">             elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">         <span class=\"built_in\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong> </p>\n<blockquote>\n<p>补充：JDK6 new 无参构造的 <code>ArrayList</code> 对象时，直接创建了长度是 10 的 <code>Object[]</code> 数组 elementData 。</p>\n</blockquote>\n<h4 id=\"2-一步一步分析-ArrayList-扩容机制\"><a href=\"#2-一步一步分析-ArrayList-扩容机制\" class=\"headerlink\" title=\"2. 一步一步分析 ArrayList 扩容机制\"></a>2. 一步一步分析 ArrayList 扩容机制</h4><p>这里以无参构造函数创建的 ArrayList 为例分析</p>\n<h5 id=\"2-1-add\"><a href=\"#2-1-add\" class=\"headerlink\" title=\"2.1.  add\"></a>2.1.  <code>add</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 将指定的元素追加到此列表的末尾。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class=\"line\">     ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">     <span class=\"comment\">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class=\"line\">     elementData[size++] = e;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-2-ensureCapacityInternal\"><a href=\"#2-2-ensureCapacityInternal\" class=\"headerlink\" title=\"2.2. ensureCapacityInternal()\"></a>2.2. <code>ensureCapacityInternal()</code></h5><p>（JDK7）可以看到 <code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//得到最小扩容量</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 获取默认的容量和传入参数的较大值</span></span><br><span class=\"line\">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p>\n<blockquote>\n<p>此处和后续 JDK8 代码格式化略有不同，核心代码基本一样。</p>\n</blockquote>\n<h5 id=\"2-3-ensureExplicitCapacity\"><a href=\"#2-3-ensureExplicitCapacity\" class=\"headerlink\" title=\"2.3. ensureExplicitCapacity()\"></a>2.3. <code>ensureExplicitCapacity()</code></h5><p>如果调用 <code>ensureCapacityInternal()</code> 方法就一定会进入（执行）这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">      modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"comment\">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class=\"line\">          grow(minCapacity);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来仔细分析一下：</p>\n<ul>\n<li>当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li>\n<li>当 add 第 2 个元素时，minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li>\n<li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li>\n</ul>\n<p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>\n<h5 id=\"2-4-grow\"><a href=\"#2-4-grow\" class=\"headerlink\" title=\"2.4. grow()\"></a>2.4. <code>grow()</code></h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要分配的最大数组大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAX_ARRAY_SIZE</span> <span class=\"operator\">=</span> Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ArrayList扩容的核心方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class=\"line\">    <span class=\"comment\">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">   <span class=\"comment\">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class=\"line\">   <span class=\"comment\">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong> </p>\n<p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p>\n<ul>\n<li>当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity &#x3D; minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li>\n<li>当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li>\n<li>以此类推······</li>\n</ul>\n<h5 id=\"2-5-hugeCapacity\"><a href=\"#2-5-hugeCapacity\" class=\"headerlink\" title=\"2.5. hugeCapacity()\"></a>2.5. <code>hugeCapacity()</code></h5><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"comment\">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class=\"line\">    <span class=\"comment\">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class=\"line\">    <span class=\"comment\">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><h4 id=\"HashSet-的实现原理？\"><a href=\"#HashSet-的实现原理？\" class=\"headerlink\" title=\"HashSet 的实现原理？\"></a>HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet 的值存放于 HashMap 的 key 上，HashMap 的 value 统一为 Object 常量 PRESENT，由于 HashMap 的 key 不允许重复，而 HashSet 不允许重复的值，因此 HashSet 可以基于 HashMap 实现，基本上都是直接调用底层 HashMap 的相关方法来完成。</p>\n<h4 id=\"HashSet是如何保证数据不可重复的？\"><a href=\"#HashSet是如何保证数据不可重复的？\" class=\"headerlink\" title=\"HashSet是如何保证数据不可重复的？\"></a>HashSet是如何保证数据不可重复的？</h4><p>当你把对象加入 hashSet 时，hashSet 会先计算对象的 hashcode 值来判断对象加入的位置，如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，表明已经有了相同的对象了，hashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Dummy value to associate with an Object in the backing Map</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"只重写-hashCode-可以吗？\"><a href=\"#只重写-hashCode-可以吗？\" class=\"headerlink\" title=\"只重写 hashCode 可以吗？\"></a>只重写 hashCode 可以吗？</h4><p>两个对象的 hashCode 相同，但是内容可能不同，在 set 中明明应该是两个不同的对象，这时候只通过 hashCode 判断他俩相同会导致只插入一个元素。</p>\n<h4 id=\"只重写-equals可以吗？\"><a href=\"#只重写-equals可以吗？\" class=\"headerlink\" title=\"只重写 equals可以吗？\"></a>只重写 equals可以吗？</h4><p>如果在重写 equals 时，不重写 hashCode，就会引起比如说将两个相等的自定义对象存储在 Set 集合时，会将这两个对象都进行插入。（无法去重）</p>\n<h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><h3 id=\"HashMap线程不安全的主要体现？\"><a href=\"#HashMap线程不安全的主要体现？\" class=\"headerlink\" title=\"HashMap线程不安全的主要体现？\"></a>HashMap线程不安全的主要体现？</h3><ol>\n<li><p>在 jdk1.7 中，在多线程环境下，<strong>扩容</strong>时会造成死链。</p>\n<blockquote>\n<p>作者：磊哥<br>链接：<a href=\"https://www.zhihu.com/question/394039290/answer/2314917909\">https://www.zhihu.com/question/394039290/answer/2314917909</a><br>来源：知乎</p>\n</blockquote>\n<p> 1.1、</p>\n<p> 死循环是因为并发 HashMap 扩容导致的，并发扩容的第一步，线程 T1 和线程 T2 要对 HashMap 进行扩容操作，此时 T1 和 T2 指向的是链表的头结点元素 A，而 T1 和 T2 的下一个节点，也就是 T1.next 和 T2.next 指向的是 B 节点，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-e0b4f5ea00cb277bde490f315b9b387f_720w.jpg\" alt=\"多线程扩容导致死循环问题-1\"></p>\n<p> 1.2、</p>\n<p> 死循环的第二步操作是，线程 T2 时间片用完进入休眠状态，而线程 T1 开始执行扩容操作，一直到线程 T1 扩容完成后，线程 T2 才被唤醒，扩容之后的场景如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_r.jpg\" alt=\"多线程扩容导致死循环问题-2\"></p>\n<p>  从上图可知线程 T1 执行之后，<strong>因为是头插法，所以HashMap的顺序已经发生了改变</strong>，但线程 T2 对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2 指向的是 A 元素，T2.next 指向的节点是 B 元素。</p>\n<p> 1.3、</p>\n<p> 当线程 T1 执行完，而线程 T2 恢复执行时，死循环就建立了，如下图所示： </p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/v2-bd4a753db8c985119aa4dcd4356609cf_720w.jpg\" alt=\"多线程扩容导致死循环问题-3\"></p>\n<p>  因为 T1 执行完扩容之后 B 节点的下一个节点是 A，而 T2 线程指向的首节点是 A，第二个节点是 B，这个顺序刚好和 T1 扩完容完之后的节点顺序是相反的。<strong>T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了</strong>，这就是 HashMap 死循环导致的原因。</p>\n</li>\n<li><p>在 jdk1.8 中，在多线程环境下，<strong>插入</strong>时会发生数据覆盖的情况（<strong>尾插法</strong>）。</p>\n</li>\n</ol>\n<h3 id=\"HashMap在JDK1-7和JDK1-8中有哪些不同？\"><a href=\"#HashMap在JDK1-7和JDK1-8中有哪些不同？\" class=\"headerlink\" title=\"HashMap在JDK1.7和JDK1.8中有哪些不同？\"></a>HashMap在JDK1.7和JDK1.8中有哪些不同？</h3><table>\n<thead>\n<tr>\n<th>不同</th>\n<th>JDK 1.7</th>\n<th>JDK 1.8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>存储结构</strong></td>\n<td>数组 + 链表</td>\n<td>数组 + 链表 + 红黑树</td>\n</tr>\n<tr>\n<td><strong>hash值计算方式</strong></td>\n<td>扰动处理 &#x3D; 4次位运算 + 5次异或运算</td>\n<td>扰动处理 &#x3D; 1次位运算 + 1次异或运算</td>\n</tr>\n<tr>\n<td><strong>存放数据的规则</strong></td>\n<td>无冲突时，存放数组；<br />冲突时，存放链表</td>\n<td>无冲突时，存放数组；<br />冲突 &amp; 链表长度 &lt; 8：插入单链表；<br />链表长度&gt;8，先尝试扩容数组，数组长度大于64<br />链表转为红黑树，插入到红黑树</td>\n</tr>\n<tr>\n<td><strong>插入数据方式</strong></td>\n<td>头插法</td>\n<td>尾插法</td>\n</tr>\n<tr>\n<td><strong>扩容后存储位置的计算方式</strong></td>\n<td>按照原来方法重新进行计算<br />hashCode、扰动函数、与运算h&amp;length-1</td>\n<td>根据元素的hash值进行判断 <br />扩容后的位置&#x3D;原位置 or 原位置 + 旧容量</td>\n</tr>\n</tbody></table>\n<h3 id=\"HashMap的hash算法\"><a href=\"#HashMap的hash算法\" class=\"headerlink\" title=\"HashMap的hash算法\"></a>HashMap的hash算法</h3><h4 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h4><p>Hash，就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；</p>\n<p>hash 值不同，输入一定不同；输入不同，hash 值可能相同（即哈希碰撞）</p>\n<h4 id=\"什么是哈希冲突？\"><a href=\"#什么是哈希冲突？\" class=\"headerlink\" title=\"什么是哈希冲突？\"></a>什么是哈希冲突？</h4><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做哈希碰撞&#x2F;冲突。</p>\n<h4 id=\"HashMap的数据结构\"><a href=\"#HashMap的数据结构\" class=\"headerlink\" title=\"HashMap的数据结构\"></a>HashMap的数据结构</h4><p>底层数据结构：数组+链表<br><strong>数组的特点是：方便查找；链表的特点是：方便插入删除</strong><br>所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做<strong>链地址法</strong>的方式可以解决哈希冲突</p>\n<blockquote>\n<p>解决哈希冲突的其他方法：<br>开放定址法（冲突了通过某种方式散列到另一个不冲突的位置上）；<br>再哈希法（构造多个不同的哈希函数）。</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83ODk2ODkwLWM2NmE0YmQ4OTA3ZjQ5ZjYucG5n.png\" alt=\"HashMap数据结构\"></p>\n<h4 id=\"扰动处理\"><a href=\"#扰动处理\" class=\"headerlink\" title=\"扰动处理\"></a>扰动处理</h4><p>由于计算下标时，通过 h &amp; (length - 1)，由于 hash 值范围很大，而数组长度相对来说小得多，导致进行与运算时参与运算的只有 hash 值的低位，<strong>高位是没有起到任何作用的</strong>，这将会大大增加哈希碰撞的概率。所以我们的思路就是让 hashCode 值的高位也参与运算，进一步降低 hash 碰撞的概率，使得<strong>数据分布更平均</strong>，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的 hash()函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>\n<h4 id=\"下标计算\"><a href=\"#下标计算\" class=\"headerlink\" title=\"下标计算\"></a>下标计算</h4><p>在得到 hash 值之后，我们要把这些 hash 值映射到相应的数组下标上，那么就可以考虑使用 hash % length</p>\n<p>而 hash % length&#x3D;&#x3D;hash &amp; (length-1) 并且前提是 length 是 2 的 n 次方。<br>由于采用二进制位操作 &amp;，相对于%能够提高运算效率，因此可以将 HashMap 的长度设计为 2 的幂次方。（初始化为 16，如果指定初始化容量的值，会扩容至第一个大于该容量的 2 的幂次方作为数组容量）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">indexFor</span><span class=\"params\">(<span class=\"type\">int</span> h, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"为什么要将数组长度设置为-2-的n次幂呢？\"><a href=\"#为什么要将数组长度设置为-2-的n次幂呢？\" class=\"headerlink\" title=\"为什么要将数组长度设置为 2 的n次幂呢？\"></a>为什么要将数组长度设置为 2 的n次幂呢？</h4><p>当数组长度为 2 的 n 次幂的时候，不同的 key 与 1111（n 个）进行与预算得到相同下标的几率较小，发生碰撞的几率小。 </p>\n<h4 id=\"JDK1-8新增红黑树\"><a href=\"#JDK1-8新增红黑树\" class=\"headerlink\" title=\"JDK1.8新增红黑树\"></a>JDK1.8新增红黑树</h4><p>为了解决一条链上的元素过多，查找效率低的问题，将链表转化为红黑树，遍历复杂度降低至 O(logn)；</p>\n<h4 id=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"><a href=\"#HashMap是使用了哪些方法来有效解决哈希冲突的？\" class=\"headerlink\" title=\"HashMap是使用了哪些方法来有效解决哈希冲突的？\"></a>HashMap是使用了哪些方法来有效解决哈希冲突的？</h4><ol>\n<li>使用链地址法（使用散列表）来链接拥有相同 hash 值的数据；</li>\n<li>使用 2 次扰动函数（1 次位运算和 1 次异或运算）来降低哈希冲突的概率，使得数据分布更平均；</li>\n<li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快。</li>\n</ol>\n<h3 id=\"HashMap的get方法的具体流程？\"><a href=\"#HashMap的get方法的具体流程？\" class=\"headerlink\" title=\"HashMap的get方法的具体流程？\"></a>HashMap的get方法的具体流程？</h3><ol>\n<li>先使用 key 的 hashCode、扰动处理、与数组长度-1 进行与运算（对数组长度去余）得到槽位；</li>\n<li>判断首结点，如果首结点和 key 的 <strong>hash值</strong> （hashCode 值经过扰动函数处理后的值）相等，并且两者的 <strong>key值地址相等、equals相等</strong>，则返回首结点；</li>\n<li>否则，则红黑树或者链表中进行查找，查找时判断两个 key 的 hash 值、key 值地址相等、equals 是否都相等。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">get</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title function_\">getNode</span><span class=\"params\">(<span class=\"type\">int</span> hash, Object key)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"type\">int</span> n; K k;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//Node数组不为空，数组长度大于0，数组对应下标的Node不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"literal\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        <span class=\"comment\">//也是通过 hash &amp; (length - 1) 来替代 hash % length 的</span></span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//先和第一个结点比，hash值相等且key不为空，key的第一个结点的key的对象地址和值均相等</span></span><br><span class=\"line\">        <span class=\"comment\">//则返回第一个结点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"comment\">//如果key和第一个结点不匹配，则看.next是否为空，不为null则继续，为空则返回null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果此时是红黑树的结构，则进行处理getTreeNode()方法搜索key</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">//是链表结构的话就一个一个遍历，直到找到key对应的结点，</span></span><br><span class=\"line\">            <span class=\"comment\">//或者e的下一个结点为null退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的put方法的具体流程？\"><a href=\"#HashMap的put方法的具体流程？\" class=\"headerlink\" title=\"HashMap的put方法的具体流程？\"></a>HashMap的put方法的具体流程？</h3><ol>\n<li>如果 table 未初始化或者长度为 0 空则执行 resize()进行扩容，转向②</li>\n<li>根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]&#x3D;&#x3D;null，即数组该位置上没有元素，直接新建节点插入，转向⑥判断是否需要扩容，如果 table[i]不为空，转向③；</li>\n<li>判断 table[i]的首个元素是否和 key 一样，如果相同（hashCode 相同、key 地址相同、equals 相同）直接覆盖 value，否则转向④；</li>\n<li>判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li>\n<li>遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</li>\n<li>插入成功后，判断实际存在的键值对数量 size 是否超出当前最大容量 threshold，如果超过，进行扩容。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">hash</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Map.put和相关方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤①：tab为空则创建 </span></span><br><span class=\"line\">    <span class=\"comment\">// table未初始化或者长度为0，进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤②：计算index，并对null做处理  </span></span><br><span class=\"line\">    <span class=\"comment\">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 桶中已经存在元素</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤③：节点key存在，直接覆盖value </span></span><br><span class=\"line\">        <span class=\"comment\">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                <span class=\"comment\">// 将第一个元素赋值给e，用e来记录</span></span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 步骤④：判断该链为红黑树 </span></span><br><span class=\"line\">        <span class=\"comment\">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 放入树中</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"comment\">// 步骤⑤：该链为链表 </span></span><br><span class=\"line\">        <span class=\"comment\">// 为链表结点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在链表最末插入结点</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 到达链表的尾部</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//判断该链表尾部指针是不是空的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 在尾部插入新结点</span></span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">//链表结构转树形结构</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"comment\">// 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 相等，跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 记录e的value</span></span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">            <span class=\"comment\">// onlyIfAbsent为false或者旧值为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//用新值替换旧值</span></span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"comment\">// 访问后回调</span></span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 结构性修改</span></span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤⑥：超过最大容量就扩容 </span></span><br><span class=\"line\">    <span class=\"comment\">// 实际大小大于阈值则扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"comment\">// 插入后回调</span></span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap的扩容操作是怎么实现的？\"><a href=\"#HashMap的扩容操作是怎么实现的？\" class=\"headerlink\" title=\"HashMap的扩容操作是怎么实现的？\"></a>HashMap的扩容操作是怎么实现的？</h3><p>①.在 jdk1.8 中，resize 方法是在 hashmap 中的键值对（元素数量）大于阀值时（阈值为容量*负载因子）扩容为原容量的 2 倍，或者初始化时（扩容为 16），就调用 resize 方法进行扩容；</p>\n<p>②.在 1.7 中，扩容之后需要重新去计算其 Hash 值，根据 Hash 值对其进行分发，但在 1.8 版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为 0，重新进行 hash 分配后，该元素 hash 值与旧容量与运算为 0 则留在原始位置，hash 值与旧容量与运算为 1 则移动到 原位置 + oldCap 这个位置上</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20190128152700351.png\" alt=\"HashMap的resize操作\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;<span class=\"comment\">//oldTab指向hash桶数组</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCap</span> <span class=\"operator\">=</span> (oldTab == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldThr</span> <span class=\"operator\">=</span> threshold;</span><br><span class=\"line\">    <span class=\"type\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class=\"comment\">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;<span class=\"comment\">//返回</span></span><br><span class=\"line\">        &#125;<span class=\"comment\">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold 双倍扩容阀值threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class=\"line\">    <span class=\"comment\">// 直接将该值赋给新的容量</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"comment\">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"type\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 新的threshold = 新的cap * 0.75</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> (<span class=\"type\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"type\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"type\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"comment\">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[newCap];<span class=\"comment\">//新建hash桶数组</span></span><br><span class=\"line\">    table = newTab;<span class=\"comment\">//将新数组的值复制给旧的hash桶数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历新数组的所有桶下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class=\"line\">                oldTab[j] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"comment\">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"built_in\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"comment\">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    <span class=\"comment\">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"literal\">null</span>, loTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"literal\">null</span>, hiTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历链表</span></span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;             </span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class=\"line\">                                <span class=\"comment\">// 代表下标保持不变的链表的头元素</span></span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span>                                </span><br><span class=\"line\">                                <span class=\"comment\">// loTail.next指向当前e</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            <span class=\"comment\">// loTail指向当前的元素e</span></span><br><span class=\"line\">                            <span class=\"comment\">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class=\"line\">                            <span class=\"comment\">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class=\"line\">                            <span class=\"comment\">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class=\"line\">                            loTail = e;                           </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                <span class=\"comment\">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HashMap负载因子为什么设置为-0-75\"><a href=\"#HashMap负载因子为什么设置为-0-75\" class=\"headerlink\" title=\"HashMap负载因子为什么设置为 0.75?\"></a>HashMap负载因子为什么设置为 0.75?</h3><p>hashmap 的源码中有一段注释解释了为什么设置为 0.75，是<strong>空间和时间效率的折中考虑</strong>。</p>\n<h3 id=\"能否使用任何类作为-Map-的-key？\"><a href=\"#能否使用任何类作为-Map-的-key？\" class=\"headerlink\" title=\"能否使用任何类作为 Map 的 key？\"></a>能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，前提是该类重写了 hashCode 和 equals 方法。重写 hashCode() 是为了计算数据的存储位置，重写 equals 方法是为了确保 key 在哈希表中的唯一性。最终目的是为了保证 Map 中键 key 的唯一性。</p>\n<h3 id=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"><a href=\"#为什么HashMap中String、Integer这样的包装类适合作为key？\" class=\"headerlink\" title=\"为什么HashMap中String、Integer这样的包装类适合作为key？\"></a>为什么HashMap中String、Integer这样的包装类适合作为key？</h3><p>重写了 hashCode 和 equals 方法，保证了 Map 中键<strong>key的唯一性</strong>。并且他们都不可变，可以将它们的 hash 值<strong>缓存下来，提高效率</strong>。</p>\n<h3 id=\"HashMap-与-HashTable-有什么区别？\"><a href=\"#HashMap-与-HashTable-有什么区别？\" class=\"headerlink\" title=\"HashMap 与 HashTable 有什么区别？\"></a>HashMap 与 HashTable 有什么区别？</h3><ol>\n<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的，内部的方法基本都经过 <code>synchronized</code> 修饰；</li>\n<li><strong>效率</strong>： 因为线程安全的问题 synchronized，HashMap 要比 HashTable 效率高一点；</li>\n<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛 NullPointerException；</li>\n<li>**初始容量大小和每次扩充容量大小的不同 **：<br> ①创建时如果不指定容量初始值，HashTable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍；<br> ②创建时如果给定了容量初始值，那么 HashTable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小；</li>\n<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。HashTable 没有这样的机制。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-和-HashTable-的区别？\"><a href=\"#ConcurrentHashMap-和-HashTable-的区别？\" class=\"headerlink\" title=\"ConcurrentHashMap 和 HashTable 的区别？\"></a>ConcurrentHashMap 和 HashTable 的区别？</h3><p>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li><strong>底层数据结构</strong>：<br>  JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表&#x2F;红黑二叉树。<br>  HashTable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li><strong>实现线程安全的方式（重要）</strong>：<br>  ① <strong>在JDK1.7的时候，ConcurrentHashMap使用分段锁</strong> 对整个桶数组进行了分割分段(Segment 锁继承 ReentrantLock)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配 16 个 Segment，比 HashTable 效率提高 16 倍。）<br>  <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，synchronized只锁定当前链表或红黑树的首节点。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap<br>  ② <strong>HashTable(全表锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n<li>⭐<strong>Jdk1.7采用分段锁，锁粒度较大，容易发生冲突，并发量低；因此 Jdk1.8 采用只锁定桶的首结点，锁的力度较低，不容易发生冲突，并发量高。</strong></li>\n</ul>\n<p><strong>两者的对比图</strong>：</p>\n<p>HashTable:</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYyNTYxOTY.png\" alt=\"HashTable全表锁\"></p>\n<p>JDK1.7 的 ConcurrentHashMap：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYwMDhiZTQ.png\" alt=\"JDK1.7的ConcurrentHashMap分段锁\"></p>\n<p>JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC84LzIzLzE2NTY2NzdhNmYxNGUwMzk.png\" alt=\"JDK1.8的ConcurrentHashMap分段锁\"></p>"},{"title":"Java八股文 - SpringMVC","copyright":true,"mathjax":false,"date":"2023-01-23T08:14:20.000Z","toc":true,"urlname":"java-springmvc","_content":"\n> 整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n## 概述\n\n### 什么是Spring MVC？简单介绍下你对Spring MVC的理解？\n\nSpring MVC 是一个基于 Java 的实现了 MVC 设计模式的请求驱动类型的轻量级 Web 框架，通过把模型-视图-控制器分离，将 web 层进行职责解耦，简化开发。\n\n## 核心组件\n\n### Spring MVC的主要组件？\n\n（1）前端控制器 DispatcherServlet（不需要程序员开发）\n\n作用：接收请求、响应结果，相当于转发器，有了 DispatcherServlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器 HandlerMapping（不需要程序员开发）\n\n作用：根据请求的 URL 来查找 Handler\n\n（3）处理器适配器 HandlerAdapter\n\n注意：在编写 Handler 的时候要按照 HandlerAdapter 要求的规则去编写，这样适配器 HandlerAdapter 才可以正确的去执行 Handler。\n\n（4）处理器 Handler（需要程序员开发）\n\n（5）视图解析器 ViewResolver（不需要程序员开发）\n\n作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）\n\n（6）视图 View（需要程序员开发 jsp）\n\nView 是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf 等等）\n\n### 什么是DispatcherServlet\n\nSpring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。\n\n### 什么是Spring MVC框架的控制器？\n\n控制器使用@Controller 注解，并且提供了@RequestMapping 注解，通过解析 url 中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。\n\n### Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。\n\n## 工作原理\n\n### 请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\n\n1. 用户发送请求至前端控制器 DispatcherServlet；\n2. DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器，请求获取 Handler；\n3. HandlerMapping 处理器映射器根据请求 url**找到具体的处理器**，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet；\n4. DispatcherServlet 调用 HandlerAdapter 处理器适配器；\n5. HandlerAdapter 经过适配 **调用具体处理器**(Handler，也叫后端控制器)；\n6. Handler 执行完成返回 ModelAndView；\n7. HandlerAdapter 将 Handler 执行结果 ModelAndView 返回给 DispatcherServlet；\n8. DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析；\n9. ViewResolver 解析后返回具体 View；\n10. DispatcherServlet 对 View 进行渲染成为视图（即将模型数据填充至视图中）；\n11. DispatcherServlet 响应用户。\n\n![Spring MVC的工作流程](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png)\n\n## 常用注解\n\n### 注解原理是什么\n\n注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。\n\n### Spring MVC常用的注解有哪些？\n\n@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n@RequestBody：注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象。\n\n@ResponseBody：注解实现将 controller 方法返回对象转化为 json 对象响应给客户。\n\n### Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\n\n答：一般用@Controller 注解，也可以使用@RestController，@RestController 注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回 json 数据＋ @Controller 用于表明控制器\n\n### @Controller注解的作用\n\n@Controller 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。通过请求的 url 和@RequestMapping 注解对应到实际处理请求的处理器。需要开启 mvc 注解扫描找到@Controller 的控制器。\n\n### @RequestMapping注解的作用\n\nRequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。\n\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping 注解有六个属性：\n\n**path/value， method**\n\n* value： 指定请求的实际地址，指定的地址可以是 URI Template 模式（后面将会说明）；\n\n* method： 指定请求的 method 类型， GET、POST、PUT、DELETE 等；\n\n**consumes，produces**\n\n* consumes： 指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html;\n\n* produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回；\n\n**params，headers**\n\n* params： 指定 request 中必须包含某些参数值时，才让该方法处理。\n\n* headers： 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。\n\n### @PathVariable和@RequestParam的区别\n\n@PathVariable 作用： 用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。\n\n```java\n/**\n* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法\n* 然后，其中的10就是sid占位符所占的位置的数据，然后通过@PathVaribale注解将其赋值给 id\n*/\n@RequestMapping(path = \"testPathVariable/{sid}\")\npublic String testPathVariable(@PathVariable(value = \"sid\") String id) {\n    System.out.println(\"执行了testPathVariable...\");\n    System.out.println(id);\n    return \"success\";\n}\n```\n\n@RequestParam 作用： 把请求中指定名称的参数给控制器中的形参赋值。\n\n```java\n// Controller中的代码：\n@RequestMapping(path = \"/testRequestParam\")\npublic String testRequestParam(@RequestParam(value = \"name\") String username) {\n    // 把请求中指定的name赋值给控制器中的形参username\n    System.out.println(\"执行了testRequestParam...\");\n    System.out.println(username);\n    return \"success\";\n}\n```\n\n## 其他\n\n### Spring MVC怎么样设定转发和重定向的？\n\n（1）转发：使用 forward\nforward 是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。\n\n（2）重定向：使用 redirect\n重定向是指当浏览器请求一个 URL 时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的 URL 再重新发送新请求。请求两次服务器。重定向地址改变。\n\n### Spring MVC怎么和AJAX相互调用的？\n\n通过 Jackson 或者是 fastjson 就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象，来进行传输。\n\n### 如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决 post 请求乱码问题：\n\n在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n（2）get 请求中文参数出现乱码解决方法有两个：\n\n修改 tomcat 配置文件添加编码与工程编码一致，如下：\n\n```xml\n<ConnectorURIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n\n### Spring MVC的异常处理\n\n可以将异常抛给 Spring 框架，由 Spring 框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n### 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\n\n答：可以在@RequestMapping 注解里面加上 method=RequestMethod.GET。\n\n### 怎样在方法里面得到Request,或者Session？\n\n答：直接在方法的形参中声明 request,Spring MVC 就自动把 request 对象传入。\n\n### 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n或者使用 RequestParam 注解将前台的参数名 A 传给形参中的参数 B\n\n### 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,Spring MVC 就自动会把属性赋值到这个对象里面。\n\n### Spring MVC中函数的返回值是什么？\n\n返回值可以有很多类型,有 String, ModelAndView（视图和数据合并在一起）。\n\n### Spring MVC用什么对象从后台向前台传递数据的？\n\n通过 ModelMap 对象,可以在这个对象里面调用 put 方法,把对象加到里面,前台就可以通过 el 表达式拿到。\n\n### 怎么样把ModelMap里面的数据放入Session里面？\n\n可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 里面的 key。\n\n### Spring MVC里面拦截器是怎么写的\n\n有两种写法,一种是实现 HandlerInterceptor 接口，重写 prehandle 等方法，然后配置拦截器\n","source":"_posts/Java八股文 - SpringMVC.md","raw":"---\ntitle: Java八股文 - SpringMVC\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 16:14:20\ntags:\ntoc: true\nurlname: java-springmvc\n---\n\n> 整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<!--more-->\n\n## 概述\n\n### 什么是Spring MVC？简单介绍下你对Spring MVC的理解？\n\nSpring MVC 是一个基于 Java 的实现了 MVC 设计模式的请求驱动类型的轻量级 Web 框架，通过把模型-视图-控制器分离，将 web 层进行职责解耦，简化开发。\n\n## 核心组件\n\n### Spring MVC的主要组件？\n\n（1）前端控制器 DispatcherServlet（不需要程序员开发）\n\n作用：接收请求、响应结果，相当于转发器，有了 DispatcherServlet 就减少了其它组件之间的耦合度。\n\n（2）处理器映射器 HandlerMapping（不需要程序员开发）\n\n作用：根据请求的 URL 来查找 Handler\n\n（3）处理器适配器 HandlerAdapter\n\n注意：在编写 Handler 的时候要按照 HandlerAdapter 要求的规则去编写，这样适配器 HandlerAdapter 才可以正确的去执行 Handler。\n\n（4）处理器 Handler（需要程序员开发）\n\n（5）视图解析器 ViewResolver（不需要程序员开发）\n\n作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）\n\n（6）视图 View（需要程序员开发 jsp）\n\nView 是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf 等等）\n\n### 什么是DispatcherServlet\n\nSpring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。\n\n### 什么是Spring MVC框架的控制器？\n\n控制器使用@Controller 注解，并且提供了@RequestMapping 注解，通过解析 url 中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。\n\n### Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\n\n单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。\n\n## 工作原理\n\n### 请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\n\n1. 用户发送请求至前端控制器 DispatcherServlet；\n2. DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器，请求获取 Handler；\n3. HandlerMapping 处理器映射器根据请求 url**找到具体的处理器**，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet；\n4. DispatcherServlet 调用 HandlerAdapter 处理器适配器；\n5. HandlerAdapter 经过适配 **调用具体处理器**(Handler，也叫后端控制器)；\n6. Handler 执行完成返回 ModelAndView；\n7. HandlerAdapter 将 Handler 执行结果 ModelAndView 返回给 DispatcherServlet；\n8. DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析；\n9. ViewResolver 解析后返回具体 View；\n10. DispatcherServlet 对 View 进行渲染成为视图（即将模型数据填充至视图中）；\n11. DispatcherServlet 响应用户。\n\n![Spring MVC的工作流程](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png)\n\n## 常用注解\n\n### 注解原理是什么\n\n注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。\n\n### Spring MVC常用的注解有哪些？\n\n@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n@RequestBody：注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象。\n\n@ResponseBody：注解实现将 controller 方法返回对象转化为 json 对象响应给客户。\n\n### Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\n\n答：一般用@Controller 注解，也可以使用@RestController，@RestController 注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回 json 数据＋ @Controller 用于表明控制器\n\n### @Controller注解的作用\n\n@Controller 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。通过请求的 url 和@RequestMapping 注解对应到实际处理请求的处理器。需要开启 mvc 注解扫描找到@Controller 的控制器。\n\n### @RequestMapping注解的作用\n\nRequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。\n\n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping 注解有六个属性：\n\n**path/value， method**\n\n* value： 指定请求的实际地址，指定的地址可以是 URI Template 模式（后面将会说明）；\n\n* method： 指定请求的 method 类型， GET、POST、PUT、DELETE 等；\n\n**consumes，produces**\n\n* consumes： 指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html;\n\n* produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回；\n\n**params，headers**\n\n* params： 指定 request 中必须包含某些参数值时，才让该方法处理。\n\n* headers： 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。\n\n### @PathVariable和@RequestParam的区别\n\n@PathVariable 作用： 用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。\n\n```java\n/**\n* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法\n* 然后，其中的10就是sid占位符所占的位置的数据，然后通过@PathVaribale注解将其赋值给 id\n*/\n@RequestMapping(path = \"testPathVariable/{sid}\")\npublic String testPathVariable(@PathVariable(value = \"sid\") String id) {\n    System.out.println(\"执行了testPathVariable...\");\n    System.out.println(id);\n    return \"success\";\n}\n```\n\n@RequestParam 作用： 把请求中指定名称的参数给控制器中的形参赋值。\n\n```java\n// Controller中的代码：\n@RequestMapping(path = \"/testRequestParam\")\npublic String testRequestParam(@RequestParam(value = \"name\") String username) {\n    // 把请求中指定的name赋值给控制器中的形参username\n    System.out.println(\"执行了testRequestParam...\");\n    System.out.println(username);\n    return \"success\";\n}\n```\n\n## 其他\n\n### Spring MVC怎么样设定转发和重定向的？\n\n（1）转发：使用 forward\nforward 是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。\n\n（2）重定向：使用 redirect\n重定向是指当浏览器请求一个 URL 时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的 URL 再重新发送新请求。请求两次服务器。重定向地址改变。\n\n### Spring MVC怎么和AJAX相互调用的？\n\n通过 Jackson 或者是 fastjson 就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象，来进行传输。\n\n### 如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决 post 请求乱码问题：\n\n在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n（2）get 请求中文参数出现乱码解决方法有两个：\n\n修改 tomcat 配置文件添加编码与工程编码一致，如下：\n\n```xml\n<ConnectorURIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n```\n\n### Spring MVC的异常处理\n\n可以将异常抛给 Spring 框架，由 Spring 框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。\n\n### 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\n\n答：可以在@RequestMapping 注解里面加上 method=RequestMethod.GET。\n\n### 怎样在方法里面得到Request,或者Session？\n\n答：直接在方法的形参中声明 request,Spring MVC 就自动把 request 对象传入。\n\n### 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\n\n直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。\n或者使用 RequestParam 注解将前台的参数名 A 传给形参中的参数 B\n\n### 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\n\n直接在方法中声明这个对象,Spring MVC 就自动会把属性赋值到这个对象里面。\n\n### Spring MVC中函数的返回值是什么？\n\n返回值可以有很多类型,有 String, ModelAndView（视图和数据合并在一起）。\n\n### Spring MVC用什么对象从后台向前台传递数据的？\n\n通过 ModelMap 对象,可以在这个对象里面调用 put 方法,把对象加到里面,前台就可以通过 el 表达式拿到。\n\n### 怎么样把ModelMap里面的数据放入Session里面？\n\n可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 里面的 key。\n\n### Spring MVC里面拦截器是怎么写的\n\n有两种写法,一种是实现 HandlerInterceptor 接口，重写 prehandle 等方法，然后配置拦截器\n","slug":"Java八股文 - SpringMVC","published":1,"updated":"2023-01-26T12:35:58.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw321000ft9t82hv43rgr","content":"<blockquote>\n<p>整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\"><a href=\"#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\" class=\"headerlink\" title=\"什么是Spring MVC？简单介绍下你对Spring MVC的理解？\"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><p>Spring MVC 是一个基于 Java 的实现了 MVC 设计模式的请求驱动类型的轻量级 Web 框架，通过把模型-视图-控制器分离，将 web 层进行职责解耦，简化开发。</p>\n<h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><h3 id=\"Spring-MVC的主要组件？\"><a href=\"#Spring-MVC的主要组件？\" class=\"headerlink\" title=\"Spring MVC的主要组件？\"></a>Spring MVC的主要组件？</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>\n<p>作用：接收请求、响应结果，相当于转发器，有了 DispatcherServlet 就减少了其它组件之间的耦合度。</p>\n<p>（2）处理器映射器 HandlerMapping（不需要程序员开发）</p>\n<p>作用：根据请求的 URL 来查找 Handler</p>\n<p>（3）处理器适配器 HandlerAdapter</p>\n<p>注意：在编写 Handler 的时候要按照 HandlerAdapter 要求的规则去编写，这样适配器 HandlerAdapter 才可以正确的去执行 Handler。</p>\n<p>（4）处理器 Handler（需要程序员开发）</p>\n<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>\n<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>\n<p>（6）视图 View（需要程序员开发 jsp）</p>\n<p>View 是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf 等等）</p>\n<h3 id=\"什么是DispatcherServlet\"><a href=\"#什么是DispatcherServlet\" class=\"headerlink\" title=\"什么是DispatcherServlet\"></a>什么是DispatcherServlet</h3><p>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。</p>\n<h3 id=\"什么是Spring-MVC框架的控制器？\"><a href=\"#什么是Spring-MVC框架的控制器？\" class=\"headerlink\" title=\"什么是Spring MVC框架的控制器？\"></a>什么是Spring MVC框架的控制器？</h3><p>控制器使用@Controller 注解，并且提供了@RequestMapping 注解，通过解析 url 中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。</p>\n<h3 id=\"Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\"><a href=\"#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\" class=\"headerlink\" title=\"Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><p>单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h3 id=\"请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\"><a href=\"#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\" class=\"headerlink\" title=\"请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h3><ol>\n<li>用户发送请求至前端控制器 DispatcherServlet；</li>\n<li>DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器，请求获取 Handler；</li>\n<li>HandlerMapping 处理器映射器根据请求 url<strong>找到具体的处理器</strong>，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet；</li>\n<li>DispatcherServlet 调用 HandlerAdapter 处理器适配器；</li>\n<li>HandlerAdapter 经过适配 <strong>调用具体处理器</strong>(Handler，也叫后端控制器)；</li>\n<li>Handler 执行完成返回 ModelAndView；</li>\n<li>HandlerAdapter 将 Handler 执行结果 ModelAndView 返回给 DispatcherServlet；</li>\n<li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析；</li>\n<li>ViewResolver 解析后返回具体 View；</li>\n<li>DispatcherServlet 对 View 进行渲染成为视图（即将模型数据填充至视图中）；</li>\n<li>DispatcherServlet 响应用户。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png\" alt=\"Spring MVC的工作流程\"></p>\n<h2 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h2><h3 id=\"注解原理是什么\"><a href=\"#注解原理是什么\" class=\"headerlink\" title=\"注解原理是什么\"></a>注解原理是什么</h3><p>注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。</p>\n<h3 id=\"Spring-MVC常用的注解有哪些？\"><a href=\"#Spring-MVC常用的注解有哪些？\" class=\"headerlink\" title=\"Spring MVC常用的注解有哪些？\"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>@RequestBody：注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象。</p>\n<p>@ResponseBody：注解实现将 controller 方法返回对象转化为 json 对象响应给客户。</p>\n<h3 id=\"Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\"><a href=\"#Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\" class=\"headerlink\" title=\"Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\"></a>Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller 注解，也可以使用@RestController，@RestController 注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回 json 数据＋ @Controller 用于表明控制器</p>\n<h3 id=\"Controller注解的作用\"><a href=\"#Controller注解的作用\" class=\"headerlink\" title=\"@Controller注解的作用\"></a>@Controller注解的作用</h3><p>@Controller 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。通过请求的 url 和@RequestMapping 注解对应到实际处理请求的处理器。需要开启 mvc 注解扫描找到@Controller 的控制器。</p>\n<h3 id=\"RequestMapping注解的作用\"><a href=\"#RequestMapping注解的作用\" class=\"headerlink\" title=\"@RequestMapping注解的作用\"></a>@RequestMapping注解的作用</h3><p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。</p>\n<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping 注解有六个属性：</p>\n<p><strong>path&#x2F;value， method</strong></p>\n<ul>\n<li><p>value： 指定请求的实际地址，指定的地址可以是 URI Template 模式（后面将会说明）；</p>\n</li>\n<li><p>method： 指定请求的 method 类型， GET、POST、PUT、DELETE 等；</p>\n</li>\n</ul>\n<p><strong>consumes，produces</strong></p>\n<ul>\n<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如 application&#x2F;json, text&#x2F;html;</p>\n</li>\n<li><p>produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回；</p>\n</li>\n</ul>\n<p><strong>params，headers</strong></p>\n<ul>\n<li><p>params： 指定 request 中必须包含某些参数值时，才让该方法处理。</p>\n</li>\n<li><p>headers： 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。</p>\n</li>\n</ul>\n<h3 id=\"PathVariable和-RequestParam的区别\"><a href=\"#PathVariable和-RequestParam的区别\" class=\"headerlink\" title=\"@PathVariable和@RequestParam的区别\"></a>@PathVariable和@RequestParam的区别</h3><p>@PathVariable 作用： 用于绑定 url 中的占位符。例如：请求 url 中 &#x2F;delete&#x2F;{id}，这个{id}就是 url 占位符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法</span></span><br><span class=\"line\"><span class=\"comment\">* 然后，其中的10就是sid占位符所占的位置的数据，然后通过<span class=\"doctag\">@PathVaribale</span>注解将其赋值给 id</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;testPathVariable/&#123;sid&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testPathVariable</span><span class=\"params\">(<span class=\"meta\">@PathVariable(value = &quot;sid&quot;)</span> String id)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testPathVariable...&quot;</span>);</span><br><span class=\"line\">    System.out.println(id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@RequestParam 作用： 把请求中指定名称的参数给控制器中的形参赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller中的代码：</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;/testRequestParam&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testRequestParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam(value = &quot;name&quot;)</span> String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把请求中指定的name赋值给控制器中的形参username</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testRequestParam...&quot;</span>);</span><br><span class=\"line\">    System.out.println(username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Spring-MVC怎么样设定转发和重定向的？\"><a href=\"#Spring-MVC怎么样设定转发和重定向的？\" class=\"headerlink\" title=\"Spring MVC怎么样设定转发和重定向的？\"></a>Spring MVC怎么样设定转发和重定向的？</h3><p>（1）转发：使用 forward<br>forward 是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。</p>\n<p>（2）重定向：使用 redirect<br>重定向是指当浏览器请求一个 URL 时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的 URL 再重新发送新请求。请求两次服务器。重定向地址改变。</p>\n<h3 id=\"Spring-MVC怎么和AJAX相互调用的？\"><a href=\"#Spring-MVC怎么和AJAX相互调用的？\" class=\"headerlink\" title=\"Spring MVC怎么和AJAX相互调用的？\"></a>Spring MVC怎么和AJAX相互调用的？</h3><p>通过 Jackson 或者是 fastjson 就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象，来进行传输。</p>\n<h3 id=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"><a href=\"#如何解决POST请求中文乱码问题，GET的又如何处理呢？\" class=\"headerlink\" title=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><p>（1）解决 post 请求乱码问题：</p>\n<p>在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）get 请求中文参数出现乱码解决方法有两个：</p>\n<p>修改 tomcat 配置文件添加编码与工程编码一致，如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-MVC的异常处理\"><a href=\"#Spring-MVC的异常处理\" class=\"headerlink\" title=\"Spring MVC的异常处理\"></a>Spring MVC的异常处理</h3><p>可以将异常抛给 Spring 框架，由 Spring 框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>\n<h3 id=\"如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\"><a href=\"#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\" class=\"headerlink\" title=\"如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping 注解里面加上 method&#x3D;RequestMethod.GET。</p>\n<h3 id=\"怎样在方法里面得到Request-或者Session？\"><a href=\"#怎样在方法里面得到Request-或者Session？\" class=\"headerlink\" title=\"怎样在方法里面得到Request,或者Session？\"></a>怎样在方法里面得到Request,或者Session？</h3><p>答：直接在方法的形参中声明 request,Spring MVC 就自动把 request 对象传入。</p>\n<h3 id=\"如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\"><a href=\"#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\" class=\"headerlink\" title=\"如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。<br>或者使用 RequestParam 注解将前台的参数名 A 传给形参中的参数 B</p>\n<h3 id=\"如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\"><a href=\"#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\" class=\"headerlink\" title=\"如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>直接在方法中声明这个对象,Spring MVC 就自动会把属性赋值到这个对象里面。</p>\n<h3 id=\"Spring-MVC中函数的返回值是什么？\"><a href=\"#Spring-MVC中函数的返回值是什么？\" class=\"headerlink\" title=\"Spring MVC中函数的返回值是什么？\"></a>Spring MVC中函数的返回值是什么？</h3><p>返回值可以有很多类型,有 String, ModelAndView（视图和数据合并在一起）。</p>\n<h3 id=\"Spring-MVC用什么对象从后台向前台传递数据的？\"><a href=\"#Spring-MVC用什么对象从后台向前台传递数据的？\" class=\"headerlink\" title=\"Spring MVC用什么对象从后台向前台传递数据的？\"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>通过 ModelMap 对象,可以在这个对象里面调用 put 方法,把对象加到里面,前台就可以通过 el 表达式拿到。</p>\n<h3 id=\"怎么样把ModelMap里面的数据放入Session里面？\"><a href=\"#怎么样把ModelMap里面的数据放入Session里面？\" class=\"headerlink\" title=\"怎么样把ModelMap里面的数据放入Session里面？\"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 里面的 key。</p>\n<h3 id=\"Spring-MVC里面拦截器是怎么写的\"><a href=\"#Spring-MVC里面拦截器是怎么写的\" class=\"headerlink\" title=\"Spring MVC里面拦截器是怎么写的\"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现 HandlerInterceptor 接口，重写 prehandle 等方法，然后配置拦截器</p>\n","site":{"data":{}},"length":5011,"excerpt":"<blockquote>\n<p>整理的SpringMVC相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\"><a href=\"#什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？\" class=\"headerlink\" title=\"什么是Spring MVC？简单介绍下你对Spring MVC的理解？\"></a>什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><p>Spring MVC 是一个基于 Java 的实现了 MVC 设计模式的请求驱动类型的轻量级 Web 框架，通过把模型-视图-控制器分离，将 web 层进行职责解耦，简化开发。</p>\n<h2 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h2><h3 id=\"Spring-MVC的主要组件？\"><a href=\"#Spring-MVC的主要组件？\" class=\"headerlink\" title=\"Spring MVC的主要组件？\"></a>Spring MVC的主要组件？</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>\n<p>作用：接收请求、响应结果，相当于转发器，有了 DispatcherServlet 就减少了其它组件之间的耦合度。</p>\n<p>（2）处理器映射器 HandlerMapping（不需要程序员开发）</p>\n<p>作用：根据请求的 URL 来查找 Handler</p>\n<p>（3）处理器适配器 HandlerAdapter</p>\n<p>注意：在编写 Handler 的时候要按照 HandlerAdapter 要求的规则去编写，这样适配器 HandlerAdapter 才可以正确的去执行 Handler。</p>\n<p>（4）处理器 Handler（需要程序员开发）</p>\n<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>\n<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>\n<p>（6）视图 View（需要程序员开发 jsp）</p>\n<p>View 是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf 等等）</p>\n<h3 id=\"什么是DispatcherServlet\"><a href=\"#什么是DispatcherServlet\" class=\"headerlink\" title=\"什么是DispatcherServlet\"></a>什么是DispatcherServlet</h3><p>Spring 的 MVC 框架是围绕 DispatcherServlet 来设计的，它用来处理所有的 HTTP 请求和响应。</p>\n<h3 id=\"什么是Spring-MVC框架的控制器？\"><a href=\"#什么是Spring-MVC框架的控制器？\" class=\"headerlink\" title=\"什么是Spring MVC框架的控制器？\"></a>什么是Spring MVC框架的控制器？</h3><p>控制器使用@Controller 注解，并且提供了@RequestMapping 注解，通过解析 url 中的路径，可以找到相应的控制器进行逻辑处理，响应数据等。</p>\n<h3 id=\"Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\"><a href=\"#Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？\" class=\"headerlink\" title=\"Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？\"></a>Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><p>单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器保持控制器无状态（不要写字段）。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h3 id=\"请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\"><a href=\"#请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？\" class=\"headerlink\" title=\"请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？\"></a>请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h3><ol>\n<li>用户发送请求至前端控制器 DispatcherServlet；</li>\n<li>DispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器，请求获取 Handler；</li>\n<li>HandlerMapping 处理器映射器根据请求 url<strong>找到具体的处理器</strong>，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet；</li>\n<li>DispatcherServlet 调用 HandlerAdapter 处理器适配器；</li>\n<li>HandlerAdapter 经过适配 <strong>调用具体处理器</strong>(Handler，也叫后端控制器)；</li>\n<li>Handler 执行完成返回 ModelAndView；</li>\n<li>HandlerAdapter 将 Handler 执行结果 ModelAndView 返回给 DispatcherServlet；</li>\n<li>DispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析；</li>\n<li>ViewResolver 解析后返回具体 View；</li>\n<li>DispatcherServlet 对 View 进行渲染成为视图（即将模型数据填充至视图中）；</li>\n<li>DispatcherServlet 响应用户。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20200208211439106.png\" alt=\"Spring MVC的工作流程\"></p>\n<h2 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h2><h3 id=\"注解原理是什么\"><a href=\"#注解原理是什么\" class=\"headerlink\" title=\"注解原理是什么\"></a>注解原理是什么</h3><p>注解本质是一个继承了 Annotation 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象。通过代理对象调用自定义注解的方法。</p>\n<h3 id=\"Spring-MVC常用的注解有哪些？\"><a href=\"#Spring-MVC常用的注解有哪些？\" class=\"headerlink\" title=\"Spring MVC常用的注解有哪些？\"></a>Spring MVC常用的注解有哪些？</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>@RequestBody：注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象。</p>\n<p>@ResponseBody：注解实现将 controller 方法返回对象转化为 json 对象响应给客户。</p>\n<h3 id=\"Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\"><a href=\"#Sping-MVC中的控制器的注解一般用哪个-有没有别的注解可以替代？\" class=\"headerlink\" title=\"Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？\"></a>Sping MVC中的控制器的注解一般用哪个,有没有别的注解可以替代？</h3><p>答：一般用@Controller 注解，也可以使用@RestController，@RestController 注解相当于@ResponseBody ＋ @Controller，@ResponseBody 用于返回 json 数据＋ @Controller 用于表明控制器</p>\n<h3 id=\"Controller注解的作用\"><a href=\"#Controller注解的作用\" class=\"headerlink\" title=\"@Controller注解的作用\"></a>@Controller注解的作用</h3><p>@Controller 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。通过请求的 url 和@RequestMapping 注解对应到实际处理请求的处理器。需要开启 mvc 注解扫描找到@Controller 的控制器。</p>\n<h3 id=\"RequestMapping注解的作用\"><a href=\"#RequestMapping注解的作用\" class=\"headerlink\" title=\"@RequestMapping注解的作用\"></a>@RequestMapping注解的作用</h3><p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。</p>\n<p>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping 注解有六个属性：</p>\n<p><strong>path&#x2F;value， method</strong></p>\n<ul>\n<li><p>value： 指定请求的实际地址，指定的地址可以是 URI Template 模式（后面将会说明）；</p>\n</li>\n<li><p>method： 指定请求的 method 类型， GET、POST、PUT、DELETE 等；</p>\n</li>\n</ul>\n<p><strong>consumes，produces</strong></p>\n<ul>\n<li><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如 application&#x2F;json, text&#x2F;html;</p>\n</li>\n<li><p>produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回；</p>\n</li>\n</ul>\n<p><strong>params，headers</strong></p>\n<ul>\n<li><p>params： 指定 request 中必须包含某些参数值时，才让该方法处理。</p>\n</li>\n<li><p>headers： 指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求。</p>\n</li>\n</ul>\n<h3 id=\"PathVariable和-RequestParam的区别\"><a href=\"#PathVariable和-RequestParam的区别\" class=\"headerlink\" title=\"@PathVariable和@RequestParam的区别\"></a>@PathVariable和@RequestParam的区别</h3><p>@PathVariable 作用： 用于绑定 url 中的占位符。例如：请求 url 中 &#x2F;delete&#x2F;{id}，这个{id}就是 url 占位符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据path /anno/testPathVariable/10 找到 testPathVariable 方法</span></span><br><span class=\"line\"><span class=\"comment\">* 然后，其中的10就是sid占位符所占的位置的数据，然后通过<span class=\"doctag\">@PathVaribale</span>注解将其赋值给 id</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;testPathVariable/&#123;sid&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testPathVariable</span><span class=\"params\">(<span class=\"meta\">@PathVariable(value = &quot;sid&quot;)</span> String id)</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testPathVariable...&quot;</span>);</span><br><span class=\"line\">    System.out.println(id);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>@RequestParam 作用： 把请求中指定名称的参数给控制器中的形参赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller中的代码：</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(path = &quot;/testRequestParam&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">testRequestParam</span><span class=\"params\">(<span class=\"meta\">@RequestParam(value = &quot;name&quot;)</span> String username)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把请求中指定的name赋值给控制器中的形参username</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;执行了testRequestParam...&quot;</span>);</span><br><span class=\"line\">    System.out.println(username);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"Spring-MVC怎么样设定转发和重定向的？\"><a href=\"#Spring-MVC怎么样设定转发和重定向的？\" class=\"headerlink\" title=\"Spring MVC怎么样设定转发和重定向的？\"></a>Spring MVC怎么样设定转发和重定向的？</h3><p>（1）转发：使用 forward<br>forward 是指内部转发，相当于服务器内部方法跳转调用。请求一次服务器。转发地址不变。</p>\n<p>（2）重定向：使用 redirect<br>重定向是指当浏览器请求一个 URL 时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的 URL 再重新发送新请求。请求两次服务器。重定向地址改变。</p>\n<h3 id=\"Spring-MVC怎么和AJAX相互调用的？\"><a href=\"#Spring-MVC怎么和AJAX相互调用的？\" class=\"headerlink\" title=\"Spring MVC怎么和AJAX相互调用的？\"></a>Spring MVC怎么和AJAX相互调用的？</h3><p>通过 Jackson 或者是 fastjson 就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象，来进行传输。</p>\n<h3 id=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"><a href=\"#如何解决POST请求中文乱码问题，GET的又如何处理呢？\" class=\"headerlink\" title=\"如何解决POST请求中文乱码问题，GET的又如何处理呢？\"></a>如何解决POST请求中文乱码问题，GET的又如何处理呢？</h3><p>（1）解决 post 请求乱码问题：</p>\n<p>在 web.xml 中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）get 请求中文参数出现乱码解决方法有两个：</p>\n<p>修改 tomcat 配置文件添加编码与工程编码一致，如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spring-MVC的异常处理\"><a href=\"#Spring-MVC的异常处理\" class=\"headerlink\" title=\"Spring MVC的异常处理\"></a>Spring MVC的异常处理</h3><p>可以将异常抛给 Spring 框架，由 Spring 框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>\n<h3 id=\"如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\"><a href=\"#如果在拦截请求中，我想拦截get方式提交的方法-怎么配置\" class=\"headerlink\" title=\"如果在拦截请求中，我想拦截get方式提交的方法,怎么配置\"></a>如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h3><p>答：可以在@RequestMapping 注解里面加上 method&#x3D;RequestMethod.GET。</p>\n<h3 id=\"怎样在方法里面得到Request-或者Session？\"><a href=\"#怎样在方法里面得到Request-或者Session？\" class=\"headerlink\" title=\"怎样在方法里面得到Request,或者Session？\"></a>怎样在方法里面得到Request,或者Session？</h3><p>答：直接在方法的形参中声明 request,Spring MVC 就自动把 request 对象传入。</p>\n<h3 id=\"如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\"><a href=\"#如果想在拦截的方法里面得到从前台传入的参数-怎么得到？\" class=\"headerlink\" title=\"如果想在拦截的方法里面得到从前台传入的参数,怎么得到？\"></a>如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h3><p>直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。<br>或者使用 RequestParam 注解将前台的参数名 A 传给形参中的参数 B</p>\n<h3 id=\"如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\"><a href=\"#如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？\" class=\"headerlink\" title=\"如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？\"></a>如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h3><p>直接在方法中声明这个对象,Spring MVC 就自动会把属性赋值到这个对象里面。</p>\n<h3 id=\"Spring-MVC中函数的返回值是什么？\"><a href=\"#Spring-MVC中函数的返回值是什么？\" class=\"headerlink\" title=\"Spring MVC中函数的返回值是什么？\"></a>Spring MVC中函数的返回值是什么？</h3><p>返回值可以有很多类型,有 String, ModelAndView（视图和数据合并在一起）。</p>\n<h3 id=\"Spring-MVC用什么对象从后台向前台传递数据的？\"><a href=\"#Spring-MVC用什么对象从后台向前台传递数据的？\" class=\"headerlink\" title=\"Spring MVC用什么对象从后台向前台传递数据的？\"></a>Spring MVC用什么对象从后台向前台传递数据的？</h3><p>通过 ModelMap 对象,可以在这个对象里面调用 put 方法,把对象加到里面,前台就可以通过 el 表达式拿到。</p>\n<h3 id=\"怎么样把ModelMap里面的数据放入Session里面？\"><a href=\"#怎么样把ModelMap里面的数据放入Session里面？\" class=\"headerlink\" title=\"怎么样把ModelMap里面的数据放入Session里面？\"></a>怎么样把ModelMap里面的数据放入Session里面？</h3><p>可以在类上面加上@SessionAttributes 注解,里面包含的字符串就是要放入 session 里面的 key。</p>\n<h3 id=\"Spring-MVC里面拦截器是怎么写的\"><a href=\"#Spring-MVC里面拦截器是怎么写的\" class=\"headerlink\" title=\"Spring MVC里面拦截器是怎么写的\"></a>Spring MVC里面拦截器是怎么写的</h3><p>有两种写法,一种是实现 HandlerInterceptor 接口，重写 prehandle 等方法，然后配置拦截器</p>"},{"title":"Java八股文 - Spring","copyright":true,"mathjax":false,"date":"2023-01-23T08:14:06.000Z","toc":true,"urlname":"java-spring","_content":"\n> 整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Spring概述\n\n### 什么是spring?\n\nSpring 是**一个轻量级Java开发框架**，目的是为了解决开发中的**业务逻辑层和其他各层的耦合问题**，简化 Java 开发。\n\n### Spring框架的核心是什么\n\n**Spring框架的核心**：IoC 容器和 AOP 模块。\n通过 IoC 容器管理 Java Bean 对象及其生命周期以及他们之间的耦合关系；\n通过 AOP 将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度\n\n### Spring的优缺点是什么？\n\n优点\n\n- 方便解耦，简化开发（**IoC**）\n\n\tSpring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。\n\n- AOP 编程的支持（**AOP**）\n\n\tSpring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n\n- 声明式事务的支持（**事务**）\n\n\t只需要通过配置就可以完成对事务的管理，而无需手动编程。\n\n- 方便集成各种优秀框架（**集成**）\n\n\tSpring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。\n\n\n缺点\n\n- Spring**依赖反射，反射影响性能**\n\n### Spring 框架中都用到了哪些设计模式？\n\n1. 工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。\n2. 单例模式：Bean 默认为单例模式。\n3. 代理模式：Spring 的 AOP 功能用到了基于接口的 JDK 的动态代理和基于子类的 CGLIB 动态代理；\n\n### Spring框架中有哪些不同类型的事件\n\n**Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。**  \n\n如果一个 bean 实现了`ApplicationListener`接口，当一个`ApplicationEvent` 被发布以后，bean 会自动被通知。\n\n```javascript\npublic class AllApplicationEventListener implements ApplicationListener < ApplicationEvent >{\n    @Override\n    public void onApplicationEvent(ApplicationEvent applicationEvent){\n        //process event\n    }\n}\n```\n\n**Spring 提供了以下5种标准的事件：**\n\n- 上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用`ConfigurableApplicationContext` 接口中的`refresh()`方法时被触发。\n- 上下文开始事件（ContextStartedEvent）：当容器调用`ConfigurableApplicationContext`的`Start()`方法开始/重新开始容器时触发该事件。\n- 上下文停止事件（ContextStoppedEvent）：当容器调用`ConfigurableApplicationContext`的`Stop()`方法停止容器时触发该事件。\n- 上下文关闭事件（ContextClosedEvent）：当`ApplicationContext`被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。\n- 请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。\n\n### Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n- Bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n- Bean 配置文件 - 包含类的信息以及如何配置它们。\n- 接口 - 处理 Bean \n- 用户程序 - 它使用接口。\n\n## Spring控制反转(IOC)\n\n### 什么是Spring IOC 容器？\n\nSpring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC 让相互协作的组件保持松耦合。\n\n### Spring IoC 的实现机制\n\nSpring 中的 IoC 的实现原理就是**工厂模式加反射**。\n\n```java\ninterface Fruit {\n    void eat();\n}\n\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println(\"Apple\");\n    }\n}\n\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println(\"Orange\");\n    }\n}\n\nclass Factory {\n    public static Fruit getInstance(String className) {\t// 使用反射，用字符串获取到实例\n        Fruit f=null;\n        try {\n            f = (Fruit) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\n\nclass Client {\n    public static void main(String[] a) {\n        Fruit f = Factory.getInstance(\"io.github.dunwu.spring.Apple\");\n        if(f != null){\n            f.eat();\n        }\n    }\n}\n```\n\n### BeanFactory 和 ApplicationContext有什么区别？\n\nBeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。\nApplicationContext 是 BeanFactory 的子接口。\n\n1. 依赖关系\n\nBeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。\n\nApplicationContext 接口作为 BeanFactory 的子接口，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：\n\n- 支持国际化。\n- 支持访问文件资源\n- 支持事件发布通知\n- 同时加载多个配置文件。\n\n配置流程：\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。\n3. 加载方式\n\n**BeanFactroy**采用的是**延迟加载**形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入或者是属性注入错误，BeanFacotry 加载后，直至第一次使用调用 getBean 方法才会抛出异常。\n\n**ApplicationContext**，它是在容器启动时，**一次性创建**了所有的 Bean。这样，在容器启动时，我们就可以**发现Spring中存在的配置错误**，这样有利于检查所依赖属性是否注入。 ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n由于在容器启动时一次性创建所有的 Bean，因此 ApplicationContext 更加占用内存空间，当配置的 Bean 比较多时，程序启动较慢。\n\n#### ⭐BeanFactory和FactoryBean区别？\n\nBeanFactory：是 spring IoC 容器的底层接口，可以用来管理 bean 及其生命周期；\n\nFactoryBean：如果某个 bean 实现了 FactoryBean 这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值\n\n### ApplicationContext通常的实现是什么？\n\n**FileSystemXmlApplicationContext** ：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\n\n**ClassPathXmlApplicationContext**：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。\n\n**AnnotationConfigApplicationContext**：它是用于读取注解创建容器的\n\n### 什么是Spring的依赖注入？\n\n具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在 Spring 里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由 Spring 容器来完成，然后注入调用者，因此也称为依赖注入。\n\n### 依赖注入有什么优势\n\n依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露 JavaBean 的 setter 方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：\n\n- 查找定位操作与应用代码完全无关。\n- 不依赖于容器的 API，可以很容易地在任何容器以外使用应用对象。\n- 不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。\n\n### 有哪些不同类型的依赖注入实现方式？\n\n**构造器依赖注入**：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\n\n**Setter方法注入**：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。\n\n### 构造器依赖注入和 setter方法注入的区别\n\n（部分注入）在 setter 注入,可以将依赖项部分注入,构造方法注入不能部分注入。\n\n（属性覆盖）如果我们为同一属性提供 setter 和构造方法注入，setter 注入将覆盖构造方法注入。但是构造方法注入不能覆盖 setter 注入值。显然，构造方法注入被称为创建实例的第一选项。\n\n（循环依赖）在构造函数注入,如果 A 和 B 对象相互依赖：A 依赖于 B,B 也依赖于 A,此时在创建对象的 A 或者 B 时，Spring 抛出 ObjectCurrentlyInCreationException。所以 Spring 可以通过 setter 注入,从而解决循环依赖的问题。\n\n**最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖**\n\n### 讲一讲Spring中的循环依赖\n\nhttps://www.cnblogs.com/daimzh/p/13256413.html\n\nhttps://blog.csdn.net/weixin_49592546/article/details/108050566\n\n#### 什么是循环依赖？\n\n```java\n@Component\npublic class A {\n    // A中注入了B\n\t@Autowired\n\tprivate B b;\n}\n\n@Component\npublic class B {\n    // B中也注入了A\n\t@Autowired\n\tprivate A a;\n}\n```\n\n#### Spring是如何解决的循环依赖？\n\n> 以下：\n>\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n首先，Spring 解决循环依赖有两个前提条件：\n\n1. 不全是构造器方式的循环依赖\n2. 必须是单例\n\n基于上面的问题，我们知道 Bean 的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。\n\n```java\n/** Cache of singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n/** Cache of early singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n/** Cache of singleton factories: bean name to ObjectFactory. */\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n```\n\n第一级缓存：用来保存实例化、初始化都完成的对象\n\n第二级缓存：用来保存实例化完成，但是未初始化完成的对象\n\n第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象\n\n![Spring三级缓存](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg)\n\n假设一个简单的循环依赖场景，A、B 互相依赖。\n\n![简单的循环依赖场景](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg)\n\nA 对象的创建过程：\n\n1. 创建对象 A，实例化的时候把 A 对象工厂放入三级缓存；\n\n![实例化对象A](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg)\n\n\n\n2. A 注入属性时，发现依赖 B，转而去实例化 B\n\n3. 同样创建对象 B，注入属性时发现依赖 A，依次从一级到三级缓存查询 A，从三级缓存通过对象工厂拿到 A，把 A 放入二级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入一级缓存。\n\n![创建对象B](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg)\n\n4. 接着继续创建 A，顺利从一级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除二级缓存中的 A，同时把 A 放入一级缓存\n\n5. 最后，一级缓存中保存着实例化、初始化都完成的 A、B 对象\n\n![最终结果](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg)\n\n因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。\n\n### 8. 为什么要三级缓存？二级不行吗？\n\n不可以，主要是为了生成代理对象。\n\n因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。\n\n假设只有二级缓存的情况，往二级缓存中放的显示一个普通的 Bean 对象，`BeanPostProcessor`去生成代理对象之后，覆盖掉二级缓存中的普通 Bean 对象，那么多线程环境下可能取到的对象就不一致了。\n\n![A代理对象覆盖A普通Bean](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg)\n\n\n\n## Spring Beans\n\n### 如何给Spring 容器提供配置元数据？Spring有几种配置方式\n\n这里有三种重要的方法给 Spring 容器提供配置元数据。\n\n- XML 配置文件。\n- 基于注解的配置。\n- 基于 Java 的配置。\n\n### Spring配置文件包含了哪些信息\n\nSpring 配置文件是个 XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入 ioc 容器中，该对象可以通过 id 来获取\n\n### Spring基于xml注入bean的几种方式\n\n1. Set 方法注入：`<property name=\"xxx\" value=\"yyy\"/>`\n2. 构造器注入：`<construtor-arg type/index/name=\"xxx\" value=\"yyy\"/>`\n3. 静态工厂注入；factory-bean factory-method\n4. 实例工厂； class factory-method\n\n### 解释Spring支持的几种bean的作用域\n\nSpring 框架支持以下五种 bean 的作用域：\n\n- **singleton :** bean 在每个 Spring ioc 容器中只有一个实例。\n- **prototype**：一个 bean 的定义可以有多个实例。\n- **request**：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。\n- **session**：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。\n- **global-session**：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。\n\n**注意：** 缺省的 Spring bean 的作用域是 singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。\n\n### Spring框架中的单例bean是线程安全的吗？\n\n不是，Spring 框架中的单例 bean 不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n\n然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。\n\n> 有状态就是有数据存储功能\n> 无状态就是不会保存数据\n\n### Spring如何处理线程并发问题？\n\n**Spring使用ThreadLocal对一些Bean的线程安全问题进行处理**。\n\nThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时间”的方式。\n\nThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。\n\n### 解释Spring框架中bean的生命周期\n\n参考：https://www.cnblogs.com/javazhiyin/p/10905294.html\n\n![Spring中Bean的生命周期](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png)\n\n**1、实例化Bean：**\n\n对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。\n对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean。\n\n**2、依赖注入：**\n\n实例化后的对象被封装在 BeanWrapper 对象中，紧接着，Spring 根据 BeanDefinition 中的信息 以及 通过 BeanWrapper 提供的设置属性的接口完成依赖注入。\n\n**3、处理Aware接口（配置Bean对象的id值、工厂/上下文）：**\n\n接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：\n\n- 如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String beanId)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；\n- 如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory()方法，传递的是 Spring 工厂自身；\n- 如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文；\n\n**4、postProcessBeforeInitialization（初始化前置处理）：**\n\n如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在 Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；\n\n**5、自定义初始化init-method：**\n\n如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的**自定义初始化**方法。\n\n**6、postProcessAfterInitialization（初始化后置处理）**\n\n如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法，**AOP在这个时候进行代理对象的创建**。\n\n**NOW** 以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。\n\n**7、清理阶段destroy：**\n\n当 Bean 不再需要时，会进入清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy()方法；\n\n**8、自定义销毁destroy-method：**\n\n最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的**自定义销毁**方法。\n\n### 在 Spring中如何注入一个Java集合？\n\n用`<list>`注入一列值，用`<map>`注入一组映射数据。\n\n### 什么是bean装配？\n\n通过 bean 的依赖关系，使用依赖注入将 spring 中的 bean 装配在一起。\nspring 可以通过 bean 的依赖关系自动完成 bean 之间的配置。\n\n### Spring 自动装配 bean 有哪些方式？\n\n在 spring 中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。\n\n在 Spring 框架 xml 配置中共有 5 种自动装配：\n\n- no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。\n- byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 与另一 bean 的 name 相同，就进行自动装配。\n- byType：通过参数的数据类型进行自动装配。\n- constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配。\n- autodetect：自动探测，如果有构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。\n\n### 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置注解扫描 `<context:annotation-config />`。\n\n在启动 spring IoC 时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired 时，首先在容器中**查询对应类型**的 bean：\n\n- 如果对应类型查询结果刚好为一个，就将该 bean 装配给@Autowired 指定的数据；\n- 如果对应类型查询的结果不止一个，那么@Autowired 会根据名称来查找；\n- 如果上述查找的结果为空或者不止一个，那么会抛出异常。\n\n## Spring注解\n\n### 什么是基于Java的Spring注解配置? 给一些注解的例子\n\n基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。\n\n以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring IOC 容器使用。\n\n另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。\n\n```java\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n```\n\n### 怎样开启注解装配？\n\n注解装配在默认情况下是不开启的，为了使用注解装配，必须在 Spring 配置文件中配置 `<context:annotation-config/>`。\n\n### @Component, @Controller, @Repository, @Service 有何区别？\n\n@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到 IoC 容器中。\n\n@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n\n@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n\n@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n### @Required 注解有什么作用\n\n`@Required`注解作用于 Bean`setter`方法上，用于检查一个 Bean 的属性的值**在配置期间是否被赋予或设置**，如果未被设置，容器将抛出 BeanInitializationException。示例：\n\n```java\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n```\n\n### @Autowired和@Resource之间的区别\n\n@Autowired 可用于：构造函数、成员变量、Setter 方法\n\n@Autowired 和@Resource 之间的区别\n\n- @Autowired 默认是**按照类型装配注入**的，默认情况下它要求依赖对象必须存在（可以设置它 required 属性为 false）。\n- @Resource 默认是**按照名称来装配注入**的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入。\n\n### @Qualifier 注解有什么作用\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n### @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：\n\n- 类级别：映射请求的 URL\n- 方法级别：映射 URL 以及 HTTP 请求方法\n\n## Spring事务\n\n### Spring支持的事务管理类型/事务实现方式有哪些？\n\nSpring 支持两种类型的事务管理：\n\n**编程式事务管理**：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。\n\n**声明式事务管理**：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。\n\n### Spring事务的实现方式和实现原理\n\nSpring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。\n\n```xml\n<!-- 2、配置事务的通知以及事务的属性-->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n<!-- 配置事务的属性\nisolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔\n离级别。\npropagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会\n有事务。查询方法可以选择SUPPORTS。\nread-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是\nfalse，表示读写。\ntimeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，\n以秒为单位。\nrollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，\n事务不回滚。没有默认值。表示任何异常都回滚。\nno-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常\n时事务回滚。没有默认值。表示任何异常都回滚。\n-->\n<tx:attributes>\n    <!--非查询方法-->\n    <tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/>\n    <!--查询方法-->\n    <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n### 说一下Spring的事务传播行为\n\nspring 事务的传播行为说的是，当多个事务同时存在的时候，spring 如何处理这些事务的行为。\n\n> ① **PROPAGATION_REQUIRED**：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）\n> ② **PROPAGATION_SUPPORTS**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）\n> ③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n> ④ **PROPAGATION_REQUIRES_NEW**：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）\n> ⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n> ⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n> ⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### 说一下 spring 的事务隔离？\n\nspring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：\n\n1. ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\n2. ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；\n3. ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；\n4. ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\n5. ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n## Spring面向切面编程(AOP)\n\n### 什么是AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些**公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等**。\n\n### Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\n\nAOP 实现的关键在于 代理模式，AOP 代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。\n\n（1）AspectJ 采用静态代理模式，属于**编译时增强**，会在编译阶段织入切面生成相应的代理对象\n\n（2）Spring AOP 采用动态代理模式，属于**运行时增强**，每次运行时织入切面在内存中临时生成相应的代理对象\n\n### JDK动态代理和CGLIB动态代理的区别\n\nJDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。\n\n而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是**基于 asm 第三方框架**，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。\n\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 解释一下Spring AOP里面的几个名词\n\n（1）切面（Aspect）：切面是通知和切点的结合。 在 Spring AOP 中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n\n（2）连接点（Join point）：方法\n\n（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强\n\n（4）切入点（Pointcut）：哪些连接点需要增强\n\n（5）目标对象（Target Object）： 被代理（proxied） 对象。\n\n（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。\n\n（7）Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。\n\n> - 编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。\n> - 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。\n> - 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。\n\n### Spring通知有哪些类型？\n\n在 AOP 术语中，切面的工作被称为通知，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。\n\nSpring 切面可以应用 5 种类型的通知：\n\n1. 前置通知（Before）：在目标方法被调用之前调用通知功能；\n2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；\n3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；\n4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；\n5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。\n\n> 同一个aspect，不同advice的执行顺序：\n>\n> ①没有异常情况下的执行顺序：\n>\n> around before advice\t方法调用之前自定义行为\n> before advice\n> target method 执行\n> around after advice\t方法调用后自定义行为\n> after advice\n> afterReturning\n>\n> ②有异常情况下的执行顺序：\n>\n> around before advice\n> before advice\n> target method 执行\n> around after advice\n> after advice\n> afterThrowing:异常发生\n> Java.lang.RuntimeException: 异常发生\n\n### 什么是切面 Aspect？\n\naspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 \nAOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  \n\n- 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n- 如何在 advice 中编写切面代码\n\n可以简单地认为, 使用 @Aspect 注解的类就是切面\n\n![在这里插入图片描述](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png)\n","source":"_posts/Java八股文 - Spring.md","raw":"---\ntitle: Java八股文 - Spring\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-23 16:14:06\ntags:\ntoc: true\nurlname: java-spring\n---\n\n> 整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Spring概述\n\n### 什么是spring?\n\nSpring 是**一个轻量级Java开发框架**，目的是为了解决开发中的**业务逻辑层和其他各层的耦合问题**，简化 Java 开发。\n\n### Spring框架的核心是什么\n\n**Spring框架的核心**：IoC 容器和 AOP 模块。\n通过 IoC 容器管理 Java Bean 对象及其生命周期以及他们之间的耦合关系；\n通过 AOP 将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度\n\n### Spring的优缺点是什么？\n\n优点\n\n- 方便解耦，简化开发（**IoC**）\n\n\tSpring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。\n\n- AOP 编程的支持（**AOP**）\n\n\tSpring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。\n\n- 声明式事务的支持（**事务**）\n\n\t只需要通过配置就可以完成对事务的管理，而无需手动编程。\n\n- 方便集成各种优秀框架（**集成**）\n\n\tSpring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。\n\n\n缺点\n\n- Spring**依赖反射，反射影响性能**\n\n### Spring 框架中都用到了哪些设计模式？\n\n1. 工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。\n2. 单例模式：Bean 默认为单例模式。\n3. 代理模式：Spring 的 AOP 功能用到了基于接口的 JDK 的动态代理和基于子类的 CGLIB 动态代理；\n\n### Spring框架中有哪些不同类型的事件\n\n**Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。**  \n\n如果一个 bean 实现了`ApplicationListener`接口，当一个`ApplicationEvent` 被发布以后，bean 会自动被通知。\n\n```javascript\npublic class AllApplicationEventListener implements ApplicationListener < ApplicationEvent >{\n    @Override\n    public void onApplicationEvent(ApplicationEvent applicationEvent){\n        //process event\n    }\n}\n```\n\n**Spring 提供了以下5种标准的事件：**\n\n- 上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用`ConfigurableApplicationContext` 接口中的`refresh()`方法时被触发。\n- 上下文开始事件（ContextStartedEvent）：当容器调用`ConfigurableApplicationContext`的`Start()`方法开始/重新开始容器时触发该事件。\n- 上下文停止事件（ContextStoppedEvent）：当容器调用`ConfigurableApplicationContext`的`Stop()`方法停止容器时触发该事件。\n- 上下文关闭事件（ContextClosedEvent）：当`ApplicationContext`被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。\n- 请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。\n\n### Spring 应用程序有哪些不同组件？\n\nSpring 应用一般有以下组件：\n\n- Bean 类 - 它包含属性，setter 和 getter 方法，函数等。\n- Bean 配置文件 - 包含类的信息以及如何配置它们。\n- 接口 - 处理 Bean \n- 用户程序 - 它使用接口。\n\n## Spring控制反转(IOC)\n\n### 什么是Spring IOC 容器？\n\nSpring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC 让相互协作的组件保持松耦合。\n\n### Spring IoC 的实现机制\n\nSpring 中的 IoC 的实现原理就是**工厂模式加反射**。\n\n```java\ninterface Fruit {\n    void eat();\n}\n\nclass Apple implements Fruit {\n    public void eat(){\n        System.out.println(\"Apple\");\n    }\n}\n\nclass Orange implements Fruit {\n    public void eat(){\n        System.out.println(\"Orange\");\n    }\n}\n\nclass Factory {\n    public static Fruit getInstance(String className) {\t// 使用反射，用字符串获取到实例\n        Fruit f=null;\n        try {\n            f = (Fruit) Class.forName(className).newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return f;\n    }\n}\n\nclass Client {\n    public static void main(String[] a) {\n        Fruit f = Factory.getInstance(\"io.github.dunwu.spring.Apple\");\n        if(f != null){\n            f.eat();\n        }\n    }\n}\n```\n\n### BeanFactory 和 ApplicationContext有什么区别？\n\nBeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。\nApplicationContext 是 BeanFactory 的子接口。\n\n1. 依赖关系\n\nBeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。\n\nApplicationContext 接口作为 BeanFactory 的子接口，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：\n\n- 支持国际化。\n- 支持访问文件资源\n- 支持事件发布通知\n- 同时加载多个配置文件。\n\n配置流程：\n\n1. 加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放`<BeanName，Class对象>`的映射\n2. 调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。\n3. 加载方式\n\n**BeanFactroy**采用的是**延迟加载**形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入或者是属性注入错误，BeanFacotry 加载后，直至第一次使用调用 getBean 方法才会抛出异常。\n\n**ApplicationContext**，它是在容器启动时，**一次性创建**了所有的 Bean。这样，在容器启动时，我们就可以**发现Spring中存在的配置错误**，这样有利于检查所依赖属性是否注入。 ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。\n\n由于在容器启动时一次性创建所有的 Bean，因此 ApplicationContext 更加占用内存空间，当配置的 Bean 比较多时，程序启动较慢。\n\n#### ⭐BeanFactory和FactoryBean区别？\n\nBeanFactory：是 spring IoC 容器的底层接口，可以用来管理 bean 及其生命周期；\n\nFactoryBean：如果某个 bean 实现了 FactoryBean 这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值\n\n### ApplicationContext通常的实现是什么？\n\n**FileSystemXmlApplicationContext** ：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。\n\n**ClassPathXmlApplicationContext**：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。\n\n**AnnotationConfigApplicationContext**：它是用于读取注解创建容器的\n\n### 什么是Spring的依赖注入？\n\n具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在 Spring 里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由 Spring 容器来完成，然后注入调用者，因此也称为依赖注入。\n\n### 依赖注入有什么优势\n\n依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露 JavaBean 的 setter 方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：\n\n- 查找定位操作与应用代码完全无关。\n- 不依赖于容器的 API，可以很容易地在任何容器以外使用应用对象。\n- 不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。\n\n### 有哪些不同类型的依赖注入实现方式？\n\n**构造器依赖注入**：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。\n\n**Setter方法注入**：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。\n\n### 构造器依赖注入和 setter方法注入的区别\n\n（部分注入）在 setter 注入,可以将依赖项部分注入,构造方法注入不能部分注入。\n\n（属性覆盖）如果我们为同一属性提供 setter 和构造方法注入，setter 注入将覆盖构造方法注入。但是构造方法注入不能覆盖 setter 注入值。显然，构造方法注入被称为创建实例的第一选项。\n\n（循环依赖）在构造函数注入,如果 A 和 B 对象相互依赖：A 依赖于 B,B 也依赖于 A,此时在创建对象的 A 或者 B 时，Spring 抛出 ObjectCurrentlyInCreationException。所以 Spring 可以通过 setter 注入,从而解决循环依赖的问题。\n\n**最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖**\n\n### 讲一讲Spring中的循环依赖\n\nhttps://www.cnblogs.com/daimzh/p/13256413.html\n\nhttps://blog.csdn.net/weixin_49592546/article/details/108050566\n\n#### 什么是循环依赖？\n\n```java\n@Component\npublic class A {\n    // A中注入了B\n\t@Autowired\n\tprivate B b;\n}\n\n@Component\npublic class B {\n    // B中也注入了A\n\t@Autowired\n\tprivate A a;\n}\n```\n\n#### Spring是如何解决的循环依赖？\n\n> 以下：\n>\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n首先，Spring 解决循环依赖有两个前提条件：\n\n1. 不全是构造器方式的循环依赖\n2. 必须是单例\n\n基于上面的问题，我们知道 Bean 的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。\n\n```java\n/** Cache of singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\n/** Cache of early singleton objects: bean name to bean instance. */\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n/** Cache of singleton factories: bean name to ObjectFactory. */\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\n```\n\n第一级缓存：用来保存实例化、初始化都完成的对象\n\n第二级缓存：用来保存实例化完成，但是未初始化完成的对象\n\n第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象\n\n![Spring三级缓存](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg)\n\n假设一个简单的循环依赖场景，A、B 互相依赖。\n\n![简单的循环依赖场景](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg)\n\nA 对象的创建过程：\n\n1. 创建对象 A，实例化的时候把 A 对象工厂放入三级缓存；\n\n![实例化对象A](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg)\n\n\n\n2. A 注入属性时，发现依赖 B，转而去实例化 B\n\n3. 同样创建对象 B，注入属性时发现依赖 A，依次从一级到三级缓存查询 A，从三级缓存通过对象工厂拿到 A，把 A 放入二级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入一级缓存。\n\n![创建对象B](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg)\n\n4. 接着继续创建 A，顺利从一级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除二级缓存中的 A，同时把 A 放入一级缓存\n\n5. 最后，一级缓存中保存着实例化、初始化都完成的 A、B 对象\n\n![最终结果](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg)\n\n因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。\n\n### 8. 为什么要三级缓存？二级不行吗？\n\n不可以，主要是为了生成代理对象。\n\n因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。\n\n假设只有二级缓存的情况，往二级缓存中放的显示一个普通的 Bean 对象，`BeanPostProcessor`去生成代理对象之后，覆盖掉二级缓存中的普通 Bean 对象，那么多线程环境下可能取到的对象就不一致了。\n\n![A代理对象覆盖A普通Bean](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg)\n\n\n\n## Spring Beans\n\n### 如何给Spring 容器提供配置元数据？Spring有几种配置方式\n\n这里有三种重要的方法给 Spring 容器提供配置元数据。\n\n- XML 配置文件。\n- 基于注解的配置。\n- 基于 Java 的配置。\n\n### Spring配置文件包含了哪些信息\n\nSpring 配置文件是个 XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入 ioc 容器中，该对象可以通过 id 来获取\n\n### Spring基于xml注入bean的几种方式\n\n1. Set 方法注入：`<property name=\"xxx\" value=\"yyy\"/>`\n2. 构造器注入：`<construtor-arg type/index/name=\"xxx\" value=\"yyy\"/>`\n3. 静态工厂注入；factory-bean factory-method\n4. 实例工厂； class factory-method\n\n### 解释Spring支持的几种bean的作用域\n\nSpring 框架支持以下五种 bean 的作用域：\n\n- **singleton :** bean 在每个 Spring ioc 容器中只有一个实例。\n- **prototype**：一个 bean 的定义可以有多个实例。\n- **request**：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。\n- **session**：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。\n- **global-session**：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。\n\n**注意：** 缺省的 Spring bean 的作用域是 singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。\n\n### Spring框架中的单例bean是线程安全的吗？\n\n不是，Spring 框架中的单例 bean 不是线程安全的。\n\nspring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。\n\n然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。\n\n> 有状态就是有数据存储功能\n> 无状态就是不会保存数据\n\n### Spring如何处理线程并发问题？\n\n**Spring使用ThreadLocal对一些Bean的线程安全问题进行处理**。\n\nThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时间”的方式。\n\nThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。\n\n### 解释Spring框架中bean的生命周期\n\n参考：https://www.cnblogs.com/javazhiyin/p/10905294.html\n\n![Spring中Bean的生命周期](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png)\n\n**1、实例化Bean：**\n\n对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。\n对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean。\n\n**2、依赖注入：**\n\n实例化后的对象被封装在 BeanWrapper 对象中，紧接着，Spring 根据 BeanDefinition 中的信息 以及 通过 BeanWrapper 提供的设置属性的接口完成依赖注入。\n\n**3、处理Aware接口（配置Bean对象的id值、工厂/上下文）：**\n\n接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：\n\n- 如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String beanId)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；\n- 如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory()方法，传递的是 Spring 工厂自身；\n- 如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文；\n\n**4、postProcessBeforeInitialization（初始化前置处理）：**\n\n如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在 Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；\n\n**5、自定义初始化init-method：**\n\n如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的**自定义初始化**方法。\n\n**6、postProcessAfterInitialization（初始化后置处理）**\n\n如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法，**AOP在这个时候进行代理对象的创建**。\n\n**NOW** 以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。\n\n**7、清理阶段destroy：**\n\n当 Bean 不再需要时，会进入清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy()方法；\n\n**8、自定义销毁destroy-method：**\n\n最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的**自定义销毁**方法。\n\n### 在 Spring中如何注入一个Java集合？\n\n用`<list>`注入一列值，用`<map>`注入一组映射数据。\n\n### 什么是bean装配？\n\n通过 bean 的依赖关系，使用依赖注入将 spring 中的 bean 装配在一起。\nspring 可以通过 bean 的依赖关系自动完成 bean 之间的配置。\n\n### Spring 自动装配 bean 有哪些方式？\n\n在 spring 中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。\n\n在 Spring 框架 xml 配置中共有 5 种自动装配：\n\n- no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。\n- byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 与另一 bean 的 name 相同，就进行自动装配。\n- byType：通过参数的数据类型进行自动装配。\n- constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配。\n- autodetect：自动探测，如果有构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。\n\n### 使用@Autowired注解自动装配的过程是怎样的？\n\n使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置注解扫描 `<context:annotation-config />`。\n\n在启动 spring IoC 时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired 时，首先在容器中**查询对应类型**的 bean：\n\n- 如果对应类型查询结果刚好为一个，就将该 bean 装配给@Autowired 指定的数据；\n- 如果对应类型查询的结果不止一个，那么@Autowired 会根据名称来查找；\n- 如果上述查找的结果为空或者不止一个，那么会抛出异常。\n\n## Spring注解\n\n### 什么是基于Java的Spring注解配置? 给一些注解的例子\n\n基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。\n\n以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring IOC 容器使用。\n\n另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。\n\n```java\n@Configuration\npublic class StudentConfig {\n    @Bean\n    public StudentBean myStudent() {\n        return new StudentBean();\n    }\n}\n```\n\n### 怎样开启注解装配？\n\n注解装配在默认情况下是不开启的，为了使用注解装配，必须在 Spring 配置文件中配置 `<context:annotation-config/>`。\n\n### @Component, @Controller, @Repository, @Service 有何区别？\n\n@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到 IoC 容器中。\n\n@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。\n\n@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。\n\n@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。\n\n### @Required 注解有什么作用\n\n`@Required`注解作用于 Bean`setter`方法上，用于检查一个 Bean 的属性的值**在配置期间是否被赋予或设置**，如果未被设置，容器将抛出 BeanInitializationException。示例：\n\n```java\npublic class Employee {\n    private String name;\n    @Required\n    public void setName(String name){\n        this.name=name;\n    }\n    public string getName(){\n        return name;\n    }\n}\n```\n\n### @Autowired和@Resource之间的区别\n\n@Autowired 可用于：构造函数、成员变量、Setter 方法\n\n@Autowired 和@Resource 之间的区别\n\n- @Autowired 默认是**按照类型装配注入**的，默认情况下它要求依赖对象必须存在（可以设置它 required 属性为 false）。\n- @Resource 默认是**按照名称来装配注入**的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入。\n\n### @Qualifier 注解有什么作用\n\n当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。\n\n### @RequestMapping 注解有什么用？\n\n@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：\n\n- 类级别：映射请求的 URL\n- 方法级别：映射 URL 以及 HTTP 请求方法\n\n## Spring事务\n\n### Spring支持的事务管理类型/事务实现方式有哪些？\n\nSpring 支持两种类型的事务管理：\n\n**编程式事务管理**：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。\n\n**声明式事务管理**：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。\n\n### Spring事务的实现方式和实现原理\n\nSpring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。\n\n```xml\n<!-- 2、配置事务的通知以及事务的属性-->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n<!-- 配置事务的属性\nisolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔\n离级别。\npropagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会\n有事务。查询方法可以选择SUPPORTS。\nread-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是\nfalse，表示读写。\ntimeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，\n以秒为单位。\nrollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，\n事务不回滚。没有默认值。表示任何异常都回滚。\nno-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常\n时事务回滚。没有默认值。表示任何异常都回滚。\n-->\n<tx:attributes>\n    <!--非查询方法-->\n    <tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/>\n    <!--查询方法-->\n    <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n```\n\n### 说一下Spring的事务传播行为\n\nspring 事务的传播行为说的是，当多个事务同时存在的时候，spring 如何处理这些事务的行为。\n\n> ① **PROPAGATION_REQUIRED**：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）\n> ② **PROPAGATION_SUPPORTS**：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）\n> ③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。\n> ④ **PROPAGATION_REQUIRES_NEW**：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）\n> ⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n> ⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。\n> ⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。\n\n### 说一下 spring 的事务隔离？\n\nspring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：\n\n1. ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\n2. ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；\n3. ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；\n4. ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\n5. ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n## Spring面向切面编程(AOP)\n\n### 什么是AOP\n\nOOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。\n\nAOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些**公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等**。\n\n### Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\n\nAOP 实现的关键在于 代理模式，AOP 代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。\n\n（1）AspectJ 采用静态代理模式，属于**编译时增强**，会在编译阶段织入切面生成相应的代理对象\n\n（2）Spring AOP 采用动态代理模式，属于**运行时增强**，每次运行时织入切面在内存中临时生成相应的代理对象\n\n### JDK动态代理和CGLIB动态代理的区别\n\nJDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。\n\n而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是**基于 asm 第三方框架**，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。\n\n> 作者：阿里云云栖号\n>\n> 链接：https://zhuanlan.zhihu.com/p/368769721\n>\n> 来源：知乎\n>\n> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n### 解释一下Spring AOP里面的几个名词\n\n（1）切面（Aspect）：切面是通知和切点的结合。 在 Spring AOP 中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n\n（2）连接点（Join point）：方法\n\n（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强\n\n（4）切入点（Pointcut）：哪些连接点需要增强\n\n（5）目标对象（Target Object）： 被代理（proxied） 对象。\n\n（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。\n\n（7）Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。\n\n> - 编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。\n> - 类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。\n> - 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。\n\n### Spring通知有哪些类型？\n\n在 AOP 术语中，切面的工作被称为通知，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。\n\nSpring 切面可以应用 5 种类型的通知：\n\n1. 前置通知（Before）：在目标方法被调用之前调用通知功能；\n2. 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；\n3. 返回通知（After-returning ）：在目标方法成功执行之后调用通知；\n4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知；\n5. 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。\n\n> 同一个aspect，不同advice的执行顺序：\n>\n> ①没有异常情况下的执行顺序：\n>\n> around before advice\t方法调用之前自定义行为\n> before advice\n> target method 执行\n> around after advice\t方法调用后自定义行为\n> after advice\n> afterReturning\n>\n> ②有异常情况下的执行顺序：\n>\n> around before advice\n> before advice\n> target method 执行\n> around after advice\n> after advice\n> afterThrowing:异常发生\n> Java.lang.RuntimeException: 异常发生\n\n### 什么是切面 Aspect？\n\naspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 \nAOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  \n\n- 如何通过 pointcut 和 advice 定位到特定的 joinpoint 上\n- 如何在 advice 中编写切面代码\n\n可以简单地认为, 使用 @Aspect 注解的类就是切面\n\n![在这里插入图片描述](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png)\n","slug":"Java八股文 - Spring","published":1,"updated":"2023-01-26T12:35:58.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw322000ht9t8001aa5cu","content":"<blockquote>\n<p>整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Spring概述\"><a href=\"#Spring概述\" class=\"headerlink\" title=\"Spring概述\"></a>Spring概述</h2><h3 id=\"什么是spring\"><a href=\"#什么是spring\" class=\"headerlink\" title=\"什么是spring?\"></a>什么是spring?</h3><p>Spring 是<strong>一个轻量级Java开发框架</strong>，目的是为了解决开发中的<strong>业务逻辑层和其他各层的耦合问题</strong>，简化 Java 开发。</p>\n<h3 id=\"Spring框架的核心是什么\"><a href=\"#Spring框架的核心是什么\" class=\"headerlink\" title=\"Spring框架的核心是什么\"></a>Spring框架的核心是什么</h3><p><strong>Spring框架的核心</strong>：IoC 容器和 AOP 模块。<br>通过 IoC 容器管理 Java Bean 对象及其生命周期以及他们之间的耦合关系；<br>通过 AOP 将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度</p>\n<h3 id=\"Spring的优缺点是什么？\"><a href=\"#Spring的优缺点是什么？\" class=\"headerlink\" title=\"Spring的优缺点是什么？\"></a>Spring的优缺点是什么？</h3><p>优点</p>\n<ul>\n<li><p>方便解耦，简化开发（<strong>IoC</strong>）</p>\n<p>  Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</p>\n</li>\n<li><p>AOP 编程的支持（<strong>AOP</strong>）</p>\n<p>  Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n</li>\n<li><p>声明式事务的支持（<strong>事务</strong>）</p>\n<p>  只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n</li>\n<li><p>方便集成各种优秀框架（<strong>集成</strong>）</p>\n<p>  Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。</p>\n</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>Spring<strong>依赖反射，反射影响性能</strong></li>\n</ul>\n<h3 id=\"Spring-框架中都用到了哪些设计模式？\"><a href=\"#Spring-框架中都用到了哪些设计模式？\" class=\"headerlink\" title=\"Spring 框架中都用到了哪些设计模式？\"></a>Spring 框架中都用到了哪些设计模式？</h3><ol>\n<li>工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。</li>\n<li>单例模式：Bean 默认为单例模式。</li>\n<li>代理模式：Spring 的 AOP 功能用到了基于接口的 JDK 的动态代理和基于子类的 CGLIB 动态代理；</li>\n</ol>\n<h3 id=\"Spring框架中有哪些不同类型的事件\"><a href=\"#Spring框架中有哪些不同类型的事件\" class=\"headerlink\" title=\"Spring框架中有哪些不同类型的事件\"></a>Spring框架中有哪些不同类型的事件</h3><p><strong>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</strong>  </p>\n<p>如果一个 bean 实现了<code>ApplicationListener</code>接口，当一个<code>ApplicationEvent</code> 被发布以后，bean 会自动被通知。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> <span class=\"title class_\">AllApplicationEventListener</span> implements <span class=\"title class_\">ApplicationListener</span> &lt; <span class=\"title class_\">ApplicationEvent</span> &gt;&#123;</span><br><span class=\"line\">    @<span class=\"title class_\">Override</span></span><br><span class=\"line\">    public <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span>(<span class=\"params\">ApplicationEvent applicationEvent</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//process event</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Spring 提供了以下5种标准的事件：</strong></p>\n<ul>\n<li>上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用<code>ConfigurableApplicationContext</code> 接口中的<code>refresh()</code>方法时被触发。</li>\n<li>上下文开始事件（ContextStartedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Start()</code>方法开始&#x2F;重新开始容器时触发该事件。</li>\n<li>上下文停止事件（ContextStoppedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Stop()</code>方法停止容器时触发该事件。</li>\n<li>上下文关闭事件（ContextClosedEvent）：当<code>ApplicationContext</code>被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>\n<li>请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。</li>\n</ul>\n<h3 id=\"Spring-应用程序有哪些不同组件？\"><a href=\"#Spring-应用程序有哪些不同组件？\" class=\"headerlink\" title=\"Spring 应用程序有哪些不同组件？\"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>\n<ul>\n<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>\n<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>\n<li>接口 - 处理 Bean </li>\n<li>用户程序 - 它使用接口。</li>\n</ul>\n<h2 id=\"Spring控制反转-IOC\"><a href=\"#Spring控制反转-IOC\" class=\"headerlink\" title=\"Spring控制反转(IOC)\"></a>Spring控制反转(IOC)</h2><h3 id=\"什么是Spring-IOC-容器？\"><a href=\"#什么是Spring-IOC-容器？\" class=\"headerlink\" title=\"什么是Spring IOC 容器？\"></a>什么是Spring IOC 容器？</h3><p>Spring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC 让相互协作的组件保持松耦合。</p>\n<h3 id=\"Spring-IoC-的实现机制\"><a href=\"#Spring-IoC-的实现机制\" class=\"headerlink\" title=\"Spring IoC 的实现机制\"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Orange</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Fruit <span class=\"title function_\">getInstance</span><span class=\"params\">(String className)</span> &#123;\t<span class=\"comment\">// 使用反射，用字符串获取到实例</span></span><br><span class=\"line\">        Fruit f=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            f = (Fruit) Class.forName(className).newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] a)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Fruit</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Factory.getInstance(<span class=\"string\">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            f.eat();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BeanFactory-和-ApplicationContext有什么区别？\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别？\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别？\"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。<br>ApplicationContext 是 BeanFactory 的子接口。</p>\n<ol>\n<li>依赖关系</li>\n</ol>\n<p>BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。</p>\n<p>ApplicationContext 接口作为 BeanFactory 的子接口，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>支持国际化。</li>\n<li>支持访问文件资源</li>\n<li>支持事件发布通知</li>\n<li>同时加载多个配置文件。</li>\n</ul>\n<p>配置流程：</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>\n<li>加载方式</li>\n</ol>\n<p><strong>BeanFactroy</strong>采用的是<strong>延迟加载</strong>形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入或者是属性注入错误，BeanFacotry 加载后，直至第一次使用调用 getBean 方法才会抛出异常。</p>\n<p><strong>ApplicationContext</strong>，它是在容器启动时，<strong>一次性创建</strong>了所有的 Bean。这样，在容器启动时，我们就可以<strong>发现Spring中存在的配置错误</strong>，这样有利于检查所依赖属性是否注入。 ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>由于在容器启动时一次性创建所有的 Bean，因此 ApplicationContext 更加占用内存空间，当配置的 Bean 比较多时，程序启动较慢。</p>\n<h4 id=\"⭐BeanFactory和FactoryBean区别？\"><a href=\"#⭐BeanFactory和FactoryBean区别？\" class=\"headerlink\" title=\"⭐BeanFactory和FactoryBean区别？\"></a>⭐BeanFactory和FactoryBean区别？</h4><p>BeanFactory：是 spring IoC 容器的底层接口，可以用来管理 bean 及其生命周期；</p>\n<p>FactoryBean：如果某个 bean 实现了 FactoryBean 这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值</p>\n<h3 id=\"ApplicationContext通常的实现是什么？\"><a href=\"#ApplicationContext通常的实现是什么？\" class=\"headerlink\" title=\"ApplicationContext通常的实现是什么？\"></a>ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>\n<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</p>\n<p><strong>AnnotationConfigApplicationContext</strong>：它是用于读取注解创建容器的</p>\n<h3 id=\"什么是Spring的依赖注入？\"><a href=\"#什么是Spring的依赖注入？\" class=\"headerlink\" title=\"什么是Spring的依赖注入？\"></a>什么是Spring的依赖注入？</h3><p>具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在 Spring 里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由 Spring 容器来完成，然后注入调用者，因此也称为依赖注入。</p>\n<h3 id=\"依赖注入有什么优势\"><a href=\"#依赖注入有什么优势\" class=\"headerlink\" title=\"依赖注入有什么优势\"></a>依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露 JavaBean 的 setter 方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>\n<ul>\n<li>查找定位操作与应用代码完全无关。</li>\n<li>不依赖于容器的 API，可以很容易地在任何容器以外使用应用对象。</li>\n<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>\n</ul>\n<h3 id=\"有哪些不同类型的依赖注入实现方式？\"><a href=\"#有哪些不同类型的依赖注入实现方式？\" class=\"headerlink\" title=\"有哪些不同类型的依赖注入实现方式？\"></a>有哪些不同类型的依赖注入实现方式？</h3><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>\n<p><strong>Setter方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。</p>\n<h3 id=\"构造器依赖注入和-setter方法注入的区别\"><a href=\"#构造器依赖注入和-setter方法注入的区别\" class=\"headerlink\" title=\"构造器依赖注入和 setter方法注入的区别\"></a>构造器依赖注入和 setter方法注入的区别</h3><p>（部分注入）在 setter 注入,可以将依赖项部分注入,构造方法注入不能部分注入。</p>\n<p>（属性覆盖）如果我们为同一属性提供 setter 和构造方法注入，setter 注入将覆盖构造方法注入。但是构造方法注入不能覆盖 setter 注入值。显然，构造方法注入被称为创建实例的第一选项。</p>\n<p>（循环依赖）在构造函数注入,如果 A 和 B 对象相互依赖：A 依赖于 B,B 也依赖于 A,此时在创建对象的 A 或者 B 时，Spring 抛出 ObjectCurrentlyInCreationException。所以 Spring 可以通过 setter 注入,从而解决循环依赖的问题。</p>\n<p><strong>最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖</strong></p>\n<h3 id=\"讲一讲Spring中的循环依赖\"><a href=\"#讲一讲Spring中的循环依赖\" class=\"headerlink\" title=\"讲一讲Spring中的循环依赖\"></a>讲一讲Spring中的循环依赖</h3><p><a href=\"https://www.cnblogs.com/daimzh/p/13256413.html\">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_49592546/article/details/108050566\">https://blog.csdn.net/weixin_49592546/article/details/108050566</a></p>\n<h4 id=\"什么是循环依赖？\"><a href=\"#什么是循环依赖？\" class=\"headerlink\" title=\"什么是循环依赖？\"></a>什么是循环依赖？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A中注入了B</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// B中也注入了A</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Spring是如何解决的循环依赖？\"><a href=\"#Spring是如何解决的循环依赖？\" class=\"headerlink\" title=\"Spring是如何解决的循环依赖？\"></a>Spring是如何解决的循环依赖？</h4><blockquote>\n<p>以下：</p>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<p>首先，Spring 解决循环依赖有两个前提条件：</p>\n<ol>\n<li>不全是构造器方式的循环依赖</li>\n<li>必须是单例</li>\n</ol>\n<p>基于上面的问题，我们知道 Bean 的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>第一级缓存：用来保存实例化、初始化都完成的对象</p>\n<p>第二级缓存：用来保存实例化完成，但是未初始化完成的对象</p>\n<p>第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg\" alt=\"Spring三级缓存\"></p>\n<p>假设一个简单的循环依赖场景，A、B 互相依赖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg\" alt=\"简单的循环依赖场景\"></p>\n<p>A 对象的创建过程：</p>\n<ol>\n<li>创建对象 A，实例化的时候把 A 对象工厂放入三级缓存；</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg\" alt=\"实例化对象A\"></p>\n<ol start=\"2\">\n<li><p>A 注入属性时，发现依赖 B，转而去实例化 B</p>\n</li>\n<li><p>同样创建对象 B，注入属性时发现依赖 A，依次从一级到三级缓存查询 A，从三级缓存通过对象工厂拿到 A，把 A 放入二级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入一级缓存。</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg\" alt=\"创建对象B\"></p>\n<ol start=\"4\">\n<li><p>接着继续创建 A，顺利从一级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除二级缓存中的 A，同时把 A 放入一级缓存</p>\n</li>\n<li><p>最后，一级缓存中保存着实例化、初始化都完成的 A、B 对象</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg\" alt=\"最终结果\"></p>\n<p>因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。</p>\n<h3 id=\"8-为什么要三级缓存？二级不行吗？\"><a href=\"#8-为什么要三级缓存？二级不行吗？\" class=\"headerlink\" title=\"8. 为什么要三级缓存？二级不行吗？\"></a>8. 为什么要三级缓存？二级不行吗？</h3><p>不可以，主要是为了生成代理对象。</p>\n<p>因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。</p>\n<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的 Bean 对象，<code>BeanPostProcessor</code>去生成代理对象之后，覆盖掉二级缓存中的普通 Bean 对象，那么多线程环境下可能取到的对象就不一致了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg\" alt=\"A代理对象覆盖A普通Bean\"></p>\n<h2 id=\"Spring-Beans\"><a href=\"#Spring-Beans\" class=\"headerlink\" title=\"Spring Beans\"></a>Spring Beans</h2><h3 id=\"如何给Spring-容器提供配置元数据？Spring有几种配置方式\"><a href=\"#如何给Spring-容器提供配置元数据？Spring有几种配置方式\" class=\"headerlink\" title=\"如何给Spring 容器提供配置元数据？Spring有几种配置方式\"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给 Spring 容器提供配置元数据。</p>\n<ul>\n<li>XML 配置文件。</li>\n<li>基于注解的配置。</li>\n<li>基于 Java 的配置。</li>\n</ul>\n<h3 id=\"Spring配置文件包含了哪些信息\"><a href=\"#Spring配置文件包含了哪些信息\" class=\"headerlink\" title=\"Spring配置文件包含了哪些信息\"></a>Spring配置文件包含了哪些信息</h3><p>Spring 配置文件是个 XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入 ioc 容器中，该对象可以通过 id 来获取</p>\n<h3 id=\"Spring基于xml注入bean的几种方式\"><a href=\"#Spring基于xml注入bean的几种方式\" class=\"headerlink\" title=\"Spring基于xml注入bean的几种方式\"></a>Spring基于xml注入bean的几种方式</h3><ol>\n<li>Set 方法注入：<code>&lt;property name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>构造器注入：<code>&lt;construtor-arg type/index/name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>静态工厂注入；factory-bean factory-method</li>\n<li>实例工厂； class factory-method</li>\n</ol>\n<h3 id=\"解释Spring支持的几种bean的作用域\"><a href=\"#解释Spring支持的几种bean的作用域\" class=\"headerlink\" title=\"解释Spring支持的几种bean的作用域\"></a>解释Spring支持的几种bean的作用域</h3><p>Spring 框架支持以下五种 bean 的作用域：</p>\n<ul>\n<li><strong>singleton :</strong> bean 在每个 Spring ioc 容器中只有一个实例。</li>\n<li><strong>prototype</strong>：一个 bean 的定义可以有多个实例。</li>\n<li><strong>request</strong>：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>\n<li><strong>session</strong>：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>\n<li><strong>global-session</strong>：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>\n</ul>\n<p><strong>注意：</strong> 缺省的 Spring bean 的作用域是 singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>\n<h3 id=\"Spring框架中的单例bean是线程安全的吗？\"><a href=\"#Spring框架中的单例bean是线程安全的吗？\" class=\"headerlink\" title=\"Spring框架中的单例bean是线程安全的吗？\"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring 框架中的单例 bean 不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n<p>然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n<blockquote>\n<p>有状态就是有数据存储功能<br>无状态就是不会保存数据</p>\n</blockquote>\n<h3 id=\"Spring如何处理线程并发问题？\"><a href=\"#Spring如何处理线程并发问题？\" class=\"headerlink\" title=\"Spring如何处理线程并发问题？\"></a>Spring如何处理线程并发问题？</h3><p><strong>Spring使用ThreadLocal对一些Bean的线程安全问题进行处理</strong>。</p>\n<p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时间”的方式。</p>\n<p>ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。</p>\n<h3 id=\"解释Spring框架中bean的生命周期\"><a href=\"#解释Spring框架中bean的生命周期\" class=\"headerlink\" title=\"解释Spring框架中bean的生命周期\"></a>解释Spring框架中bean的生命周期</h3><p>参考：<a href=\"https://www.cnblogs.com/javazhiyin/p/10905294.html\">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png\" alt=\"Spring中Bean的生命周期\"></p>\n<p><strong>1、实例化Bean：</strong></p>\n<p>对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。<br>对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean。</p>\n<p><strong>2、依赖注入：</strong></p>\n<p>实例化后的对象被封装在 BeanWrapper 对象中，紧接着，Spring 根据 BeanDefinition 中的信息 以及 通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p>\n<p><strong>3、处理Aware接口（配置Bean对象的id值、工厂&#x2F;上下文）：</strong></p>\n<p>接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p>\n<ul>\n<li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String beanId)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；</li>\n<li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory()方法，传递的是 Spring 工厂自身；</li>\n<li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文；</li>\n</ul>\n<p><strong>4、postProcessBeforeInitialization（初始化前置处理）：</strong></p>\n<p>如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在 Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>\n<p><strong>5、自定义初始化init-method：</strong></p>\n<p>如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的<strong>自定义初始化</strong>方法。</p>\n<p><strong>6、postProcessAfterInitialization（初始化后置处理）</strong></p>\n<p>如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法，<strong>AOP在这个时候进行代理对象的创建</strong>。</p>\n<p><strong>NOW</strong> 以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p>\n<p><strong>7、清理阶段destroy：</strong></p>\n<p>当 Bean 不再需要时，会进入清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy()方法；</p>\n<p><strong>8、自定义销毁destroy-method：</strong></p>\n<p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的<strong>自定义销毁</strong>方法。</p>\n<h3 id=\"在-Spring中如何注入一个Java集合？\"><a href=\"#在-Spring中如何注入一个Java集合？\" class=\"headerlink\" title=\"在 Spring中如何注入一个Java集合？\"></a>在 Spring中如何注入一个Java集合？</h3><p>用<code>&lt;list&gt;</code>注入一列值，用<code>&lt;map&gt;</code>注入一组映射数据。</p>\n<h3 id=\"什么是bean装配？\"><a href=\"#什么是bean装配？\" class=\"headerlink\" title=\"什么是bean装配？\"></a>什么是bean装配？</h3><p>通过 bean 的依赖关系，使用依赖注入将 spring 中的 bean 装配在一起。<br>spring 可以通过 bean 的依赖关系自动完成 bean 之间的配置。</p>\n<h3 id=\"Spring-自动装配-bean-有哪些方式？\"><a href=\"#Spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"Spring 自动装配 bean 有哪些方式？\"></a>Spring 自动装配 bean 有哪些方式？</h3><p>在 spring 中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p>\n<p>在 Spring 框架 xml 配置中共有 5 种自动装配：</p>\n<ul>\n<li>no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。</li>\n<li>byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 与另一 bean 的 name 相同，就进行自动装配。</li>\n<li>byType：通过参数的数据类型进行自动装配。</li>\n<li>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配。</li>\n<li>autodetect：自动探测，如果有构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。</li>\n</ul>\n<h3 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置注解扫描 <code>&lt;context:annotation-config /&gt;</code>。</p>\n<p>在启动 spring IoC 时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired 时，首先在容器中<strong>查询对应类型</strong>的 bean：</p>\n<ul>\n<li>如果对应类型查询结果刚好为一个，就将该 bean 装配给@Autowired 指定的数据；</li>\n<li>如果对应类型查询的结果不止一个，那么@Autowired 会根据名称来查找；</li>\n<li>如果上述查找的结果为空或者不止一个，那么会抛出异常。</li>\n</ul>\n<h2 id=\"Spring注解\"><a href=\"#Spring注解\" class=\"headerlink\" title=\"Spring注解\"></a>Spring注解</h2><h3 id=\"什么是基于Java的Spring注解配置-给一些注解的例子\"><a href=\"#什么是基于Java的Spring注解配置-给一些注解的例子\" class=\"headerlink\" title=\"什么是基于Java的Spring注解配置? 给一些注解的例子\"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。</p>\n<p>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring IOC 容器使用。</p>\n<p>另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StudentConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StudentBean <span class=\"title function_\">myStudent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StudentBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"怎样开启注解装配？\"><a href=\"#怎样开启注解装配？\" class=\"headerlink\" title=\"怎样开启注解装配？\"></a>怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，必须在 Spring 配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>。</p>\n<h3 id=\"Component-Controller-Repository-Service-有何区别？\"><a href=\"#Component-Controller-Repository-Service-有何区别？\" class=\"headerlink\" title=\"@Component, @Controller, @Repository, @Service 有何区别？\"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到 IoC 容器中。</p>\n<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>\n<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>\n<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>\n<h3 id=\"Required-注解有什么作用\"><a href=\"#Required-注解有什么作用\" class=\"headerlink\" title=\"@Required 注解有什么作用\"></a>@Required 注解有什么作用</h3><p><code>@Required</code>注解作用于 Bean<code>setter</code>方法上，用于检查一个 Bean 的属性的值<strong>在配置期间是否被赋予或设置</strong>，如果未被设置，容器将抛出 BeanInitializationException。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Required</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> string <span class=\"title function_\">getName</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired 可用于：构造函数、成员变量、Setter 方法</p>\n<p>@Autowired 和@Resource 之间的区别</p>\n<ul>\n<li>@Autowired 默认是<strong>按照类型装配注入</strong>的，默认情况下它要求依赖对象必须存在（可以设置它 required 属性为 false）。</li>\n<li>@Resource 默认是<strong>按照名称来装配注入</strong>的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入。</li>\n</ul>\n<h3 id=\"Qualifier-注解有什么作用\"><a href=\"#Qualifier-注解有什么作用\" class=\"headerlink\" title=\"@Qualifier 注解有什么作用\"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<h3 id=\"RequestMapping-注解有什么用？\"><a href=\"#RequestMapping-注解有什么用？\" class=\"headerlink\" title=\"@RequestMapping 注解有什么用？\"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p>\n<ul>\n<li>类级别：映射请求的 URL</li>\n<li>方法级别：映射 URL 以及 HTTP 请求方法</li>\n</ul>\n<h2 id=\"Spring事务\"><a href=\"#Spring事务\" class=\"headerlink\" title=\"Spring事务\"></a>Spring事务</h2><h3 id=\"Spring支持的事务管理类型-x2F-事务实现方式有哪些？\"><a href=\"#Spring支持的事务管理类型-x2F-事务实现方式有哪些？\" class=\"headerlink\" title=\"Spring支持的事务管理类型&#x2F;事务实现方式有哪些？\"></a>Spring支持的事务管理类型&#x2F;事务实现方式有哪些？</h3><p>Spring 支持两种类型的事务管理：</p>\n<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>\n<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。</p>\n<h3 id=\"Spring事务的实现方式和实现原理\"><a href=\"#Spring事务的实现方式和实现原理\" class=\"headerlink\" title=\"Spring事务的实现方式和实现原理\"></a>Spring事务的实现方式和实现原理</h3><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 2、配置事务的通知以及事务的属性--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务的属性</span></span><br><span class=\"line\"><span class=\"comment\">isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔</span></span><br><span class=\"line\"><span class=\"comment\">离级别。</span></span><br><span class=\"line\"><span class=\"comment\">propagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会</span></span><br><span class=\"line\"><span class=\"comment\">有事务。查询方法可以选择SUPPORTS。</span></span><br><span class=\"line\"><span class=\"comment\">read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是</span></span><br><span class=\"line\"><span class=\"comment\">false，表示读写。</span></span><br><span class=\"line\"><span class=\"comment\">timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，</span></span><br><span class=\"line\"><span class=\"comment\">以秒为单位。</span></span><br><span class=\"line\"><span class=\"comment\">rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，</span></span><br><span class=\"line\"><span class=\"comment\">事务不回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常</span></span><br><span class=\"line\"><span class=\"comment\">时事务回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--非查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;find*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;SUPPORTS&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说一下Spring的事务传播行为\"><a href=\"#说一下Spring的事务传播行为\" class=\"headerlink\" title=\"说一下Spring的事务传播行为\"></a>说一下Spring的事务传播行为</h3><p>spring 事务的传播行为说的是，当多个事务同时存在的时候，spring 如何处理这些事务的行为。</p>\n<blockquote>\n<p>① <strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）<br>② <strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ <strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n</blockquote>\n<h3 id=\"说一下-spring-的事务隔离？\"><a href=\"#说一下-spring-的事务隔离？\" class=\"headerlink\" title=\"说一下 spring 的事务隔离？\"></a>说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>\n<ol>\n<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>\n<li>ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；</li>\n<li>ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；</li>\n<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>\n<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ol>\n<h2 id=\"Spring面向切面编程-AOP\"><a href=\"#Spring面向切面编程-AOP\" class=\"headerlink\" title=\"Spring面向切面编程(AOP)\"></a>Spring面向切面编程(AOP)</h2><h3 id=\"什么是AOP\"><a href=\"#什么是AOP\" class=\"headerlink\" title=\"什么是AOP\"></a>什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些<strong>公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等</strong>。</p>\n<h3 id=\"Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\"><a href=\"#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\" class=\"headerlink\" title=\"Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP 实现的关键在于 代理模式，AOP 代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。</p>\n<p>（1）AspectJ 采用静态代理模式，属于<strong>编译时增强</strong>，会在编译阶段织入切面生成相应的代理对象</p>\n<p>（2）Spring AOP 采用动态代理模式，属于<strong>运行时增强</strong>，每次运行时织入切面在内存中临时生成相应的代理对象</p>\n<h3 id=\"JDK动态代理和CGLIB动态代理的区别\"><a href=\"#JDK动态代理和CGLIB动态代理的区别\" class=\"headerlink\" title=\"JDK动态代理和CGLIB动态代理的区别\"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。</p>\n<p>而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是<strong>基于 asm 第三方框架</strong>，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。</p>\n<blockquote>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h3 id=\"解释一下Spring-AOP里面的几个名词\"><a href=\"#解释一下Spring-AOP里面的几个名词\" class=\"headerlink\" title=\"解释一下Spring AOP里面的几个名词\"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。 在 Spring AOP 中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>\n<p>（2）连接点（Join point）：方法</p>\n<p>（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强</p>\n<p>（4）切入点（Pointcut）：哪些连接点需要增强</p>\n<p>（5）目标对象（Target Object）： 被代理（proxied） 对象。</p>\n<p>（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。</p>\n<p>（7）Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。</p>\n<blockquote>\n<ul>\n<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>\n</ul>\n</blockquote>\n<h3 id=\"Spring通知有哪些类型？\"><a href=\"#Spring通知有哪些类型？\" class=\"headerlink\" title=\"Spring通知有哪些类型？\"></a>Spring通知有哪些类型？</h3><p>在 AOP 术语中，切面的工作被称为通知，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。</p>\n<p>Spring 切面可以应用 5 种类型的通知：</p>\n<ol>\n<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>\n<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>\n<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>\n<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>\n<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>\n</ol>\n<blockquote>\n<p>同一个aspect，不同advice的执行顺序：</p>\n<p>①没有异常情况下的执行顺序：</p>\n<p>around before advice\t方法调用之前自定义行为<br>before advice<br>target method 执行<br>around after advice\t方法调用后自定义行为<br>after advice<br>afterReturning</p>\n<p>②有异常情况下的执行顺序：</p>\n<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>Java.lang.RuntimeException: 异常发生</p>\n</blockquote>\n<h3 id=\"什么是切面-Aspect？\"><a href=\"#什么是切面-Aspect？\" class=\"headerlink\" title=\"什么是切面 Aspect？\"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  </p>\n<ul>\n<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>\n<li>如何在 advice 中编写切面代码</li>\n</ul>\n<p>可以简单地认为, 使用 @Aspect 注解的类就是切面</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"length":15032,"excerpt":"<blockquote>\n<p>整理的Spring框架相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Spring概述\"><a href=\"#Spring概述\" class=\"headerlink\" title=\"Spring概述\"></a>Spring概述</h2><h3 id=\"什么是spring\"><a href=\"#什么是spring\" class=\"headerlink\" title=\"什么是spring?\"></a>什么是spring?</h3><p>Spring 是<strong>一个轻量级Java开发框架</strong>，目的是为了解决开发中的<strong>业务逻辑层和其他各层的耦合问题</strong>，简化 Java 开发。</p>\n<h3 id=\"Spring框架的核心是什么\"><a href=\"#Spring框架的核心是什么\" class=\"headerlink\" title=\"Spring框架的核心是什么\"></a>Spring框架的核心是什么</h3><p><strong>Spring框架的核心</strong>：IoC 容器和 AOP 模块。<br>通过 IoC 容器管理 Java Bean 对象及其生命周期以及他们之间的耦合关系；<br>通过 AOP 将一些公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低模块间的耦合度</p>\n<h3 id=\"Spring的优缺点是什么？\"><a href=\"#Spring的优缺点是什么？\" class=\"headerlink\" title=\"Spring的优缺点是什么？\"></a>Spring的优缺点是什么？</h3><p>优点</p>\n<ul>\n<li><p>方便解耦，简化开发（<strong>IoC</strong>）</p>\n<p>  Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</p>\n</li>\n<li><p>AOP 编程的支持（<strong>AOP</strong>）</p>\n<p>  Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n</li>\n<li><p>声明式事务的支持（<strong>事务</strong>）</p>\n<p>  只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n</li>\n<li><p>方便集成各种优秀框架（<strong>集成</strong>）</p>\n<p>  Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。</p>\n</li>\n</ul>\n<p>缺点</p>\n<ul>\n<li>Spring<strong>依赖反射，反射影响性能</strong></li>\n</ul>\n<h3 id=\"Spring-框架中都用到了哪些设计模式？\"><a href=\"#Spring-框架中都用到了哪些设计模式？\" class=\"headerlink\" title=\"Spring 框架中都用到了哪些设计模式？\"></a>Spring 框架中都用到了哪些设计模式？</h3><ol>\n<li>工厂模式：通过 BeanFactory 和 ApplicationContext 来管理 Bean 对象。</li>\n<li>单例模式：Bean 默认为单例模式。</li>\n<li>代理模式：Spring 的 AOP 功能用到了基于接口的 JDK 的动态代理和基于子类的 CGLIB 动态代理；</li>\n</ol>\n<h3 id=\"Spring框架中有哪些不同类型的事件\"><a href=\"#Spring框架中有哪些不同类型的事件\" class=\"headerlink\" title=\"Spring框架中有哪些不同类型的事件\"></a>Spring框架中有哪些不同类型的事件</h3><p><strong>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。</strong>  </p>\n<p>如果一个 bean 实现了<code>ApplicationListener</code>接口，当一个<code>ApplicationEvent</code> 被发布以后，bean 会自动被通知。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> <span class=\"title class_\">AllApplicationEventListener</span> implements <span class=\"title class_\">ApplicationListener</span> &lt; <span class=\"title class_\">ApplicationEvent</span> &gt;&#123;</span><br><span class=\"line\">    @<span class=\"title class_\">Override</span></span><br><span class=\"line\">    public <span class=\"keyword\">void</span> <span class=\"title function_\">onApplicationEvent</span>(<span class=\"params\">ApplicationEvent applicationEvent</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//process event</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Spring 提供了以下5种标准的事件：</strong></p>\n<ul>\n<li>上下文更新事件（ContextRefreshedEvent）：该事件会在 ApplicationContext 被初始化或者更新时发布。也可以在调用<code>ConfigurableApplicationContext</code> 接口中的<code>refresh()</code>方法时被触发。</li>\n<li>上下文开始事件（ContextStartedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Start()</code>方法开始&#x2F;重新开始容器时触发该事件。</li>\n<li>上下文停止事件（ContextStoppedEvent）：当容器调用<code>ConfigurableApplicationContext</code>的<code>Stop()</code>方法停止容器时触发该事件。</li>\n<li>上下文关闭事件（ContextClosedEvent）：当<code>ApplicationContext</code>被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>\n<li>请求处理事件（RequestHandledEvent）：在 Web 应用中，当一个 http 请求（request）结束触发该事件。</li>\n</ul>\n<h3 id=\"Spring-应用程序有哪些不同组件？\"><a href=\"#Spring-应用程序有哪些不同组件？\" class=\"headerlink\" title=\"Spring 应用程序有哪些不同组件？\"></a>Spring 应用程序有哪些不同组件？</h3><p>Spring 应用一般有以下组件：</p>\n<ul>\n<li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li>\n<li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li>\n<li>接口 - 处理 Bean </li>\n<li>用户程序 - 它使用接口。</li>\n</ul>\n<h2 id=\"Spring控制反转-IOC\"><a href=\"#Spring控制反转-IOC\" class=\"headerlink\" title=\"Spring控制反转(IOC)\"></a>Spring控制反转(IOC)</h2><h3 id=\"什么是Spring-IOC-容器？\"><a href=\"#什么是Spring-IOC-容器？\" class=\"headerlink\" title=\"什么是Spring IOC 容器？\"></a>什么是Spring IOC 容器？</h3><p>Spring IOC（控制反转） 把组件对象控制权交给容器，容器负责创建对象，配置对象（通过依赖注入（DI），并且管理这些对象的整个生命周期。IoC 让相互协作的组件保持松耦合。</p>\n<h3 id=\"Spring-IoC-的实现机制\"><a href=\"#Spring-IoC-的实现机制\" class=\"headerlink\" title=\"Spring IoC 的实现机制\"></a>Spring IoC 的实现机制</h3><p>Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Orange</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Fruit</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Factory</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Fruit <span class=\"title function_\">getInstance</span><span class=\"params\">(String className)</span> &#123;\t<span class=\"comment\">// 使用反射，用字符串获取到实例</span></span><br><span class=\"line\">        Fruit f=<span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            f = (Fruit) Class.forName(className).newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] a)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Fruit</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Factory.getInstance(<span class=\"string\">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            f.eat();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BeanFactory-和-ApplicationContext有什么区别？\"><a href=\"#BeanFactory-和-ApplicationContext有什么区别？\" class=\"headerlink\" title=\"BeanFactory 和 ApplicationContext有什么区别？\"></a>BeanFactory 和 ApplicationContext有什么区别？</h3><p>BeanFactory 和 ApplicationContext 是 Spring 的两大核心接口，都可以当做 Spring 的容器。<br>ApplicationContext 是 BeanFactory 的子接口。</p>\n<ol>\n<li>依赖关系</li>\n</ol>\n<p>BeanFactory：是 Spring 里面最底层的接口，包含了各种 Bean 的定义，读取 bean 配置文档，管理 bean 的加载、实例化，控制 bean 的生命周期，维护 bean 之间的依赖关系。</p>\n<p>ApplicationContext 接口作为 BeanFactory 的子接口，除了提供 BeanFactory 所具有的功能外，还提供了更完整的框架功能：</p>\n<ul>\n<li>支持国际化。</li>\n<li>支持访问文件资源</li>\n<li>支持事件发布通知</li>\n<li>同时加载多个配置文件。</li>\n</ul>\n<p>配置流程：</p>\n<ol>\n<li>加载配置文件，解析成 BeanDefinition 放在 Map 里，map 中存放<code>&lt;BeanName，Class对象&gt;</code>的映射</li>\n<li>调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象使用反射进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</li>\n<li>加载方式</li>\n</ol>\n<p><strong>BeanFactroy</strong>采用的是<strong>延迟加载</strong>形式来注入 Bean 的，即只有在使用到某个 Bean 时(调用 getBean())，才对该 Bean 进行加载实例化。这样，我们就不能发现一些存在的 Spring 的配置问题。如果 Bean 的某一个属性没有注入或者是属性注入错误，BeanFacotry 加载后，直至第一次使用调用 getBean 方法才会抛出异常。</p>\n<p><strong>ApplicationContext</strong>，它是在容器启动时，<strong>一次性创建</strong>了所有的 Bean。这样，在容器启动时，我们就可以<strong>发现Spring中存在的配置错误</strong>，这样有利于检查所依赖属性是否注入。 ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p>\n<p>由于在容器启动时一次性创建所有的 Bean，因此 ApplicationContext 更加占用内存空间，当配置的 Bean 比较多时，程序启动较慢。</p>\n<h4 id=\"⭐BeanFactory和FactoryBean区别？\"><a href=\"#⭐BeanFactory和FactoryBean区别？\" class=\"headerlink\" title=\"⭐BeanFactory和FactoryBean区别？\"></a>⭐BeanFactory和FactoryBean区别？</h4><p>BeanFactory：是 spring IoC 容器的底层接口，可以用来管理 bean 及其生命周期；</p>\n<p>FactoryBean：如果某个 bean 实现了 FactoryBean 这个接口，通过 getBean 方法来获取 bean 的时候，并不是返回自己的实例，而是返回其 getObject() 方法的返回值</p>\n<h3 id=\"ApplicationContext通常的实现是什么？\"><a href=\"#ApplicationContext通常的实现是什么？\" class=\"headerlink\" title=\"ApplicationContext通常的实现是什么？\"></a>ApplicationContext通常的实现是什么？</h3><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个 XML 文件中加载 beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p>\n<p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个 XML 文件中加载 beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。</p>\n<p><strong>AnnotationConfigApplicationContext</strong>：它是用于读取注解创建容器的</p>\n<h3 id=\"什么是Spring的依赖注入？\"><a href=\"#什么是Spring的依赖注入？\" class=\"headerlink\" title=\"什么是Spring的依赖注入？\"></a>什么是Spring的依赖注入？</h3><p>具体含义是:当某个调用者需要另一个被调用者的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在 Spring 里，创建被调用者的工作不再由调用者来完成，因此称为控制反转；创建被调用者 实例的工作通常由 Spring 容器来完成，然后注入调用者，因此也称为依赖注入。</p>\n<h3 id=\"依赖注入有什么优势\"><a href=\"#依赖注入有什么优势\" class=\"headerlink\" title=\"依赖注入有什么优势\"></a>依赖注入有什么优势</h3><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露 JavaBean 的 setter 方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p>\n<ul>\n<li>查找定位操作与应用代码完全无关。</li>\n<li>不依赖于容器的 API，可以很容易地在任何容器以外使用应用对象。</li>\n<li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li>\n</ul>\n<h3 id=\"有哪些不同类型的依赖注入实现方式？\"><a href=\"#有哪些不同类型的依赖注入实现方式？\" class=\"headerlink\" title=\"有哪些不同类型的依赖注入实现方式？\"></a>有哪些不同类型的依赖注入实现方式？</h3><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</p>\n<p><strong>Setter方法注入</strong>：Setter 方法注入是容器通过调用无参构造器或无参 static 工厂 方法实例化 bean 之后，调用该 bean 的 setter 方法，即实现了基于 setter 的依赖注入。</p>\n<h3 id=\"构造器依赖注入和-setter方法注入的区别\"><a href=\"#构造器依赖注入和-setter方法注入的区别\" class=\"headerlink\" title=\"构造器依赖注入和 setter方法注入的区别\"></a>构造器依赖注入和 setter方法注入的区别</h3><p>（部分注入）在 setter 注入,可以将依赖项部分注入,构造方法注入不能部分注入。</p>\n<p>（属性覆盖）如果我们为同一属性提供 setter 和构造方法注入，setter 注入将覆盖构造方法注入。但是构造方法注入不能覆盖 setter 注入值。显然，构造方法注入被称为创建实例的第一选项。</p>\n<p>（循环依赖）在构造函数注入,如果 A 和 B 对象相互依赖：A 依赖于 B,B 也依赖于 A,此时在创建对象的 A 或者 B 时，Spring 抛出 ObjectCurrentlyInCreationException。所以 Spring 可以通过 setter 注入,从而解决循环依赖的问题。</p>\n<p><strong>最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖</strong></p>\n<h3 id=\"讲一讲Spring中的循环依赖\"><a href=\"#讲一讲Spring中的循环依赖\" class=\"headerlink\" title=\"讲一讲Spring中的循环依赖\"></a>讲一讲Spring中的循环依赖</h3><p><a href=\"https://www.cnblogs.com/daimzh/p/13256413.html\">https://www.cnblogs.com/daimzh/p/13256413.html</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_49592546/article/details/108050566\">https://blog.csdn.net/weixin_49592546/article/details/108050566</a></p>\n<h4 id=\"什么是循环依赖？\"><a href=\"#什么是循环依赖？\" class=\"headerlink\" title=\"什么是循环依赖？\"></a>什么是循环依赖？</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// A中注入了B</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> B b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// B中也注入了A</span></span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Spring是如何解决的循环依赖？\"><a href=\"#Spring是如何解决的循环依赖？\" class=\"headerlink\" title=\"Spring是如何解决的循环依赖？\"></a>Spring是如何解决的循环依赖？</h4><blockquote>\n<p>以下：</p>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<p>首先，Spring 解决循环依赖有两个前提条件：</p>\n<ol>\n<li>不全是构造器方式的循环依赖</li>\n<li>必须是单例</li>\n</ol>\n<p>基于上面的问题，我们知道 Bean 的生命周期，本质上解决循环依赖的问题就是三级缓存，通过三级缓存提前拿到未初始化完全的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;(<span class=\"number\">256</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n<p>第一级缓存：用来保存实例化、初始化都完成的对象</p>\n<p>第二级缓存：用来保存实例化完成，但是未初始化完成的对象</p>\n<p>第三级缓存：用来保存一个对象工厂，提供一个匿名内部类，用于创建二级缓存中的对象</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-dbda6a103e41cde4a54548386d6c1cc2_720w.jpg\" alt=\"Spring三级缓存\"></p>\n<p>假设一个简单的循环依赖场景，A、B 互相依赖。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-f20f1e81c8011fd99f723127cacf7430_720w.jpg\" alt=\"简单的循环依赖场景\"></p>\n<p>A 对象的创建过程：</p>\n<ol>\n<li>创建对象 A，实例化的时候把 A 对象工厂放入三级缓存；</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-b295374aff4235ee9c0538bf03856217_720w.jpg\" alt=\"实例化对象A\"></p>\n<ol start=\"2\">\n<li><p>A 注入属性时，发现依赖 B，转而去实例化 B</p>\n</li>\n<li><p>同样创建对象 B，注入属性时发现依赖 A，依次从一级到三级缓存查询 A，从三级缓存通过对象工厂拿到 A，把 A 放入二级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入一级缓存。</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-51cb735fc6c02c2225d2f38b9b5b6da9_720w.jpg\" alt=\"创建对象B\"></p>\n<ol start=\"4\">\n<li><p>接着继续创建 A，顺利从一级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除二级缓存中的 A，同时把 A 放入一级缓存</p>\n</li>\n<li><p>最后，一级缓存中保存着实例化、初始化都完成的 A、B 对象</p>\n</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-a1eaa5d9f8bec23e373dc1b9f86ddb25_720w.jpg\" alt=\"最终结果\"></p>\n<p>因此，由于把实例化和初始化的流程分开了，所以如果都是用构造器的话，就没法分离这个操作，所以都是构造器的话就无法解决循环依赖的问题了。</p>\n<h3 id=\"8-为什么要三级缓存？二级不行吗？\"><a href=\"#8-为什么要三级缓存？二级不行吗？\" class=\"headerlink\" title=\"8. 为什么要三级缓存？二级不行吗？\"></a>8. 为什么要三级缓存？二级不行吗？</h3><p>不可以，主要是为了生成代理对象。</p>\n<p>因为三级缓存中放的是生成具体对象的对象工厂，他可以生成代理对象，也可以是普通的实例对象。</p>\n<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的 Bean 对象，<code>BeanPostProcessor</code>去生成代理对象之后，覆盖掉二级缓存中的普通 Bean 对象，那么多线程环境下可能取到的对象就不一致了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesv2-e4e9050787017c7272dc313f88af9382_720w.jpg\" alt=\"A代理对象覆盖A普通Bean\"></p>\n<h2 id=\"Spring-Beans\"><a href=\"#Spring-Beans\" class=\"headerlink\" title=\"Spring Beans\"></a>Spring Beans</h2><h3 id=\"如何给Spring-容器提供配置元数据？Spring有几种配置方式\"><a href=\"#如何给Spring-容器提供配置元数据？Spring有几种配置方式\" class=\"headerlink\" title=\"如何给Spring 容器提供配置元数据？Spring有几种配置方式\"></a>如何给Spring 容器提供配置元数据？Spring有几种配置方式</h3><p>这里有三种重要的方法给 Spring 容器提供配置元数据。</p>\n<ul>\n<li>XML 配置文件。</li>\n<li>基于注解的配置。</li>\n<li>基于 Java 的配置。</li>\n</ul>\n<h3 id=\"Spring配置文件包含了哪些信息\"><a href=\"#Spring配置文件包含了哪些信息\" class=\"headerlink\" title=\"Spring配置文件包含了哪些信息\"></a>Spring配置文件包含了哪些信息</h3><p>Spring 配置文件是个 XML 文件，通过读取指定类的全限定类名。反射创建对象，丢入 ioc 容器中，该对象可以通过 id 来获取</p>\n<h3 id=\"Spring基于xml注入bean的几种方式\"><a href=\"#Spring基于xml注入bean的几种方式\" class=\"headerlink\" title=\"Spring基于xml注入bean的几种方式\"></a>Spring基于xml注入bean的几种方式</h3><ol>\n<li>Set 方法注入：<code>&lt;property name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>构造器注入：<code>&lt;construtor-arg type/index/name=&quot;xxx&quot; value=&quot;yyy&quot;/&gt;</code></li>\n<li>静态工厂注入；factory-bean factory-method</li>\n<li>实例工厂； class factory-method</li>\n</ol>\n<h3 id=\"解释Spring支持的几种bean的作用域\"><a href=\"#解释Spring支持的几种bean的作用域\" class=\"headerlink\" title=\"解释Spring支持的几种bean的作用域\"></a>解释Spring支持的几种bean的作用域</h3><p>Spring 框架支持以下五种 bean 的作用域：</p>\n<ul>\n<li><strong>singleton :</strong> bean 在每个 Spring ioc 容器中只有一个实例。</li>\n<li><strong>prototype</strong>：一个 bean 的定义可以有多个实例。</li>\n<li><strong>request</strong>：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>\n<li><strong>session</strong>：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>\n<li><strong>global-session</strong>：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>\n</ul>\n<p><strong>注意：</strong> 缺省的 Spring bean 的作用域是 singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>\n<h3 id=\"Spring框架中的单例bean是线程安全的吗？\"><a href=\"#Spring框架中的单例bean是线程安全的吗？\" class=\"headerlink\" title=\"Spring框架中的单例bean是线程安全的吗？\"></a>Spring框架中的单例bean是线程安全的吗？</h3><p>不是，Spring 框架中的单例 bean 不是线程安全的。</p>\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n<p>然而，实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n<blockquote>\n<p>有状态就是有数据存储功能<br>无状态就是不会保存数据</p>\n</blockquote>\n<h3 id=\"Spring如何处理线程并发问题？\"><a href=\"#Spring如何处理线程并发问题？\" class=\"headerlink\" title=\"Spring如何处理线程并发问题？\"></a>Spring如何处理线程并发问题？</h3><p><strong>Spring使用ThreadLocal对一些Bean的线程安全问题进行处理</strong>。</p>\n<p>ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而 ThreadLocal 采用了“空间换时间”的方式。</p>\n<p>ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。</p>\n<h3 id=\"解释Spring框架中bean的生命周期\"><a href=\"#解释Spring框架中bean的生命周期\" class=\"headerlink\" title=\"解释Spring框架中bean的生命周期\"></a>解释Spring框架中bean的生命周期</h3><p>参考：<a href=\"https://www.cnblogs.com/javazhiyin/p/10905294.html\">https://www.cnblogs.com/javazhiyin/p/10905294.html</a></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes201911012343410.png\" alt=\"Spring中Bean的生命周期\"></p>\n<p><strong>1、实例化Bean：</strong></p>\n<p>对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 bean 时，或初始化 bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。<br>对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 bean。</p>\n<p><strong>2、依赖注入：</strong></p>\n<p>实例化后的对象被封装在 BeanWrapper 对象中，紧接着，Spring 根据 BeanDefinition 中的信息 以及 通过 BeanWrapper 提供的设置属性的接口完成依赖注入。</p>\n<p><strong>3、处理Aware接口（配置Bean对象的id值、工厂&#x2F;上下文）：</strong></p>\n<p>接着，Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p>\n<ul>\n<li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String beanId)方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；</li>\n<li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory()方法，传递的是 Spring 工厂自身；</li>\n<li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文；</li>\n</ul>\n<p><strong>4、postProcessBeforeInitialization（初始化前置处理）：</strong></p>\n<p>如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s)方法。由于这个方法是在 Bean 初始化结束时调用的，所以可以被应用于内存或缓存技术；</p>\n<p><strong>5、自定义初始化init-method：</strong></p>\n<p>如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的<strong>自定义初始化</strong>方法。</p>\n<p><strong>6、postProcessAfterInitialization（初始化后置处理）</strong></p>\n<p>如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s)方法，<strong>AOP在这个时候进行代理对象的创建</strong>。</p>\n<p><strong>NOW</strong> 以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p>\n<p><strong>7、清理阶段destroy：</strong></p>\n<p>当 Bean 不再需要时，会进入清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy()方法；</p>\n<p><strong>8、自定义销毁destroy-method：</strong></p>\n<p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的<strong>自定义销毁</strong>方法。</p>\n<h3 id=\"在-Spring中如何注入一个Java集合？\"><a href=\"#在-Spring中如何注入一个Java集合？\" class=\"headerlink\" title=\"在 Spring中如何注入一个Java集合？\"></a>在 Spring中如何注入一个Java集合？</h3><p>用<code>&lt;list&gt;</code>注入一列值，用<code>&lt;map&gt;</code>注入一组映射数据。</p>\n<h3 id=\"什么是bean装配？\"><a href=\"#什么是bean装配？\" class=\"headerlink\" title=\"什么是bean装配？\"></a>什么是bean装配？</h3><p>通过 bean 的依赖关系，使用依赖注入将 spring 中的 bean 装配在一起。<br>spring 可以通过 bean 的依赖关系自动完成 bean 之间的配置。</p>\n<h3 id=\"Spring-自动装配-bean-有哪些方式？\"><a href=\"#Spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"Spring 自动装配 bean 有哪些方式？\"></a>Spring 自动装配 bean 有哪些方式？</h3><p>在 spring 中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象。</p>\n<p>在 Spring 框架 xml 配置中共有 5 种自动装配：</p>\n<ul>\n<li>no：默认的方式是不进行自动装配的，通过手工设置 ref 属性来进行装配 bean。</li>\n<li>byName：通过 bean 的名称进行自动装配，如果一个 bean 的 property 与另一 bean 的 name 相同，就进行自动装配。</li>\n<li>byType：通过参数的数据类型进行自动装配。</li>\n<li>constructor：利用构造函数进行装配，并且构造函数的参数通过 byType 进行装配。</li>\n<li>autodetect：自动探测，如果有构造方法，通过 construct 的方式自动装配，否则使用 byType 的方式自动装配。</li>\n</ul>\n<h3 id=\"使用-Autowired注解自动装配的过程是怎样的？\"><a href=\"#使用-Autowired注解自动装配的过程是怎样的？\" class=\"headerlink\" title=\"使用@Autowired注解自动装配的过程是怎样的？\"></a>使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置注解扫描 <code>&lt;context:annotation-config /&gt;</code>。</p>\n<p>在启动 spring IoC 时，容器自动装载了一个后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired 时，首先在容器中<strong>查询对应类型</strong>的 bean：</p>\n<ul>\n<li>如果对应类型查询结果刚好为一个，就将该 bean 装配给@Autowired 指定的数据；</li>\n<li>如果对应类型查询的结果不止一个，那么@Autowired 会根据名称来查找；</li>\n<li>如果上述查找的结果为空或者不止一个，那么会抛出异常。</li>\n</ul>\n<h2 id=\"Spring注解\"><a href=\"#Spring注解\" class=\"headerlink\" title=\"Spring注解\"></a>Spring注解</h2><h3 id=\"什么是基于Java的Spring注解配置-给一些注解的例子\"><a href=\"#什么是基于Java的Spring注解配置-给一些注解的例子\" class=\"headerlink\" title=\"什么是基于Java的Spring注解配置? 给一些注解的例子\"></a>什么是基于Java的Spring注解配置? 给一些注解的例子</h3><p>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。</p>\n<p>以@Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring IOC 容器使用。</p>\n<p>另一个例子是@Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StudentConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StudentBean <span class=\"title function_\">myStudent</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StudentBean</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"怎样开启注解装配？\"><a href=\"#怎样开启注解装配？\" class=\"headerlink\" title=\"怎样开启注解装配？\"></a>怎样开启注解装配？</h3><p>注解装配在默认情况下是不开启的，为了使用注解装配，必须在 Spring 配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>。</p>\n<h3 id=\"Component-Controller-Repository-Service-有何区别？\"><a href=\"#Component-Controller-Repository-Service-有何区别？\" class=\"headerlink\" title=\"@Component, @Controller, @Repository, @Service 有何区别？\"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><p>@Component：这将 Java 类标记为 bean。spring 的组件扫描机制可以将其扫描并将其注册到 IoC 容器中。</p>\n<p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p>\n<p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p>\n<p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p>\n<h3 id=\"Required-注解有什么作用\"><a href=\"#Required-注解有什么作用\" class=\"headerlink\" title=\"@Required 注解有什么作用\"></a>@Required 注解有什么作用</h3><p><code>@Required</code>注解作用于 Bean<code>setter</code>方法上，用于检查一个 Bean 的属性的值<strong>在配置期间是否被赋予或设置</strong>，如果未被设置，容器将抛出 BeanInitializationException。示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Employee</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Required</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> string <span class=\"title function_\">getName</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Autowired和-Resource之间的区别\"><a href=\"#Autowired和-Resource之间的区别\" class=\"headerlink\" title=\"@Autowired和@Resource之间的区别\"></a>@Autowired和@Resource之间的区别</h3><p>@Autowired 可用于：构造函数、成员变量、Setter 方法</p>\n<p>@Autowired 和@Resource 之间的区别</p>\n<ul>\n<li>@Autowired 默认是<strong>按照类型装配注入</strong>的，默认情况下它要求依赖对象必须存在（可以设置它 required 属性为 false）。</li>\n<li>@Resource 默认是<strong>按照名称来装配注入</strong>的，只有当找不到与名称匹配的 bean 才会按照类型来装配注入。</li>\n</ul>\n<h3 id=\"Qualifier-注解有什么作用\"><a href=\"#Qualifier-注解有什么作用\" class=\"headerlink\" title=\"@Qualifier 注解有什么作用\"></a>@Qualifier 注解有什么作用</h3><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>\n<h3 id=\"RequestMapping-注解有什么用？\"><a href=\"#RequestMapping-注解有什么用？\" class=\"headerlink\" title=\"@RequestMapping 注解有什么用？\"></a>@RequestMapping 注解有什么用？</h3><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p>\n<ul>\n<li>类级别：映射请求的 URL</li>\n<li>方法级别：映射 URL 以及 HTTP 请求方法</li>\n</ul>\n<h2 id=\"Spring事务\"><a href=\"#Spring事务\" class=\"headerlink\" title=\"Spring事务\"></a>Spring事务</h2><h3 id=\"Spring支持的事务管理类型-x2F-事务实现方式有哪些？\"><a href=\"#Spring支持的事务管理类型-x2F-事务实现方式有哪些？\" class=\"headerlink\" title=\"Spring支持的事务管理类型&#x2F;事务实现方式有哪些？\"></a>Spring支持的事务管理类型&#x2F;事务实现方式有哪些？</h3><p>Spring 支持两种类型的事务管理：</p>\n<p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p>\n<p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和 XML 配置来管理事务。</p>\n<h3 id=\"Spring事务的实现方式和实现原理\"><a href=\"#Spring事务的实现方式和实现原理\" class=\"headerlink\" title=\"Spring事务的实现方式和实现原理\"></a>Spring事务的实现方式和实现原理</h3><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 2、配置事务的通知以及事务的属性--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;txAdvice&quot;</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务的属性</span></span><br><span class=\"line\"><span class=\"comment\">isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔</span></span><br><span class=\"line\"><span class=\"comment\">离级别。</span></span><br><span class=\"line\"><span class=\"comment\">propagation：用于指定事务的传播行为。默认值是REQUIRED(增删改)，表示一定会</span></span><br><span class=\"line\"><span class=\"comment\">有事务。查询方法可以选择SUPPORTS。</span></span><br><span class=\"line\"><span class=\"comment\">read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是</span></span><br><span class=\"line\"><span class=\"comment\">false，表示读写。</span></span><br><span class=\"line\"><span class=\"comment\">timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，</span></span><br><span class=\"line\"><span class=\"comment\">以秒为单位。</span></span><br><span class=\"line\"><span class=\"comment\">rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，</span></span><br><span class=\"line\"><span class=\"comment\">事务不回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常</span></span><br><span class=\"line\"><span class=\"comment\">时事务回滚。没有默认值。表示任何异常都回滚。</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--非查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;REQUIRED&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--查询方法--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;find*&quot;</span> <span class=\"attr\">propagation</span>=<span class=\"string\">&quot;SUPPORTS&quot;</span> <span class=\"attr\">read-only</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"说一下Spring的事务传播行为\"><a href=\"#说一下Spring的事务传播行为\" class=\"headerlink\" title=\"说一下Spring的事务传播行为\"></a>说一下Spring的事务传播行为</h3><p>spring 事务的传播行为说的是，当多个事务同时存在的时候，spring 如何处理这些事务的行为。</p>\n<blockquote>\n<p>① <strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。（默认值，适用于非查询方法，增删改）（事务存在就用不存在要创建）<br>② <strong>PROPAGATION_SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。（适用于查询方法）（事务存在就用不存在就不用）<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ <strong>PROPAGATION_REQUIRES_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。（永远都要新事务）<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p>\n</blockquote>\n<h3 id=\"说一下-spring-的事务隔离？\"><a href=\"#说一下-spring-的事务隔离？\" class=\"headerlink\" title=\"说一下 spring 的事务隔离？\"></a>说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>\n<ol>\n<li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li>\n<li>ISOLATION_READ_UNCOMMITTED：读未提交，最低隔离级别、事务未提交前，就可被其他事务读取（会出现脏读、不可重复读、幻读）；</li>\n<li>ISOLATION_READ_COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（会造成不可重复读、幻读），SQL server 的默认级别；</li>\n<li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li>\n<li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>\n</ol>\n<h2 id=\"Spring面向切面编程-AOP\"><a href=\"#Spring面向切面编程-AOP\" class=\"headerlink\" title=\"Spring面向切面编程(AOP)\"></a>Spring面向切面编程(AOP)</h2><h3 id=\"什么是AOP\"><a href=\"#什么是AOP\" class=\"headerlink\" title=\"什么是AOP\"></a>什么是AOP</h3><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，将一些<strong>公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等</strong>。</p>\n<h3 id=\"Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\"><a href=\"#Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？\" class=\"headerlink\" title=\"Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？\"></a>Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h3><p>AOP 实现的关键在于 代理模式，AOP 代理主要分为静态代理（AspectJ）和动态代理（Spring AOP）。</p>\n<p>（1）AspectJ 采用静态代理模式，属于<strong>编译时增强</strong>，会在编译阶段织入切面生成相应的代理对象</p>\n<p>（2）Spring AOP 采用动态代理模式，属于<strong>运行时增强</strong>，每次运行时织入切面在内存中临时生成相应的代理对象</p>\n<h3 id=\"JDK动态代理和CGLIB动态代理的区别\"><a href=\"#JDK动态代理和CGLIB动态代理的区别\" class=\"headerlink\" title=\"JDK动态代理和CGLIB动态代理的区别\"></a>JDK动态代理和CGLIB动态代理的区别</h3><p>JDK 动态代理主要是针对类实现了某个接口，AOP 则会使用 JDK 动态代理。基于反射的机制实现，生成一个实现该接口的一个代理类，然后通过重写方法的方式，实现对代码的增强。</p>\n<p>而如果某个类没有实现接口，AOP 则会使用 CGLIB 代理。底层原理是<strong>基于 asm 第三方框架</strong>，通过修改字节码生成一个子类，然后重写父类的方法，实现对代码的增强。</p>\n<blockquote>\n<p>作者：阿里云云栖号</p>\n<p>链接：<a href=\"https://zhuanlan.zhihu.com/p/368769721\">https://zhuanlan.zhihu.com/p/368769721</a></p>\n<p>来源：知乎</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h3 id=\"解释一下Spring-AOP里面的几个名词\"><a href=\"#解释一下Spring-AOP里面的几个名词\" class=\"headerlink\" title=\"解释一下Spring AOP里面的几个名词\"></a>解释一下Spring AOP里面的几个名词</h3><p>（1）切面（Aspect）：切面是通知和切点的结合。 在 Spring AOP 中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>\n<p>（2）连接点（Join point）：方法</p>\n<p>（3）通知（Advice）：在要增强上的连接点上要进行怎样的增强</p>\n<p>（4）切入点（Pointcut）：哪些连接点需要增强</p>\n<p>（5）目标对象（Target Object）： 被代理（proxied） 对象。</p>\n<p>（6）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。</p>\n<p>（7）Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类。</p>\n<blockquote>\n<ul>\n<li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li>\n</ul>\n</blockquote>\n<h3 id=\"Spring通知有哪些类型？\"><a href=\"#Spring通知有哪些类型？\" class=\"headerlink\" title=\"Spring通知有哪些类型？\"></a>Spring通知有哪些类型？</h3><p>在 AOP 术语中，切面的工作被称为通知，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。</p>\n<p>Spring 切面可以应用 5 种类型的通知：</p>\n<ol>\n<li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li>\n<li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li>\n<li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li>\n<li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li>\n<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>\n</ol>\n<blockquote>\n<p>同一个aspect，不同advice的执行顺序：</p>\n<p>①没有异常情况下的执行顺序：</p>\n<p>around before advice\t方法调用之前自定义行为<br>before advice<br>target method 执行<br>around after advice\t方法调用后自定义行为<br>after advice<br>afterReturning</p>\n<p>②有异常情况下的执行顺序：</p>\n<p>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>Java.lang.RuntimeException: 异常发生</p>\n</blockquote>\n<h3 id=\"什么是切面-Aspect？\"><a href=\"#什么是切面-Aspect？\" class=\"headerlink\" title=\"什么是切面 Aspect？\"></a>什么是切面 Aspect？</h3><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:  </p>\n<ul>\n<li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li>\n<li>如何在 advice 中编写切面代码</li>\n</ul>\n<p>可以简单地认为, 使用 @Aspect 注解的类就是切面</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2020021212264438.png\" alt=\"在这里插入图片描述\"></p>"},{"title":"Java八股文 - MySQL","copyright":true,"mathjax":false,"date":"2023-01-25T05:43:41.000Z","toc":true,"urlname":"mysql","_content":"\n> 整理的 MySQL 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## MySQL基础篇\n\n### 说一说三个范式\n\n**第一范式(确保每列保持原子性)**\n\n第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。\n\n**第二范式(确保表中的每列都和主键相关)**（前提是第一范式）\n\n在一个数据库表中，一个表中只能保存**一种**数据，不可以把多种数据保存在同一张数据库表中。\n\n**第三范式(确保表中每列都和主键直接相关,而不是间接相关)**（前提是第一第二范式）\n\n已经分好了多张表的话，一张表中只能有另一张表的 ID，而不能有其他任何信息（其他任何信息，一律用主键在另一张表中查询）。\n\n### 说一下 MySQL 执行一条查询语句的内部执行过程？\n\n> 连接器 → 查询缓存 → 分析器 → 优化器 → 执行器\n\n*   客户端先通过**连接器**连接到 MySQL 服务器。\n\n*   连接器权限验证通过之后，先查询是否有**查询缓存**，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。\n\n*   **分析器**会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。\n\n*   **优化器**对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。\n\n*   优化器执行完就进入**执行器**，开始执行查询语句直到查询出满足条件的所有数据，然后进行返回。\n\n### MySQL 查询缓存的功能有何优缺点？\n\n优点是效率高，如果已经有缓存则会直接返回结果。 \n\n但是，如果数据库表中数据和结构发生变化时（增删改、表结构调整），查询缓存将会失效并被清除，导致缓存命中率比较低。\n\n### MySQL 的常用引擎都有哪些？\n\nMySQL 的常用引擎有 InnoDB、MyISAM、Memory（所有数据放在内存中） 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。\n\n### MySQL 可以针对表级别设置数据库引擎吗？怎么设置？\n\n可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如 Memory）来设置此表的存储引擎。\n\n###  InnoDB v.s. MyISAM\n\n* 最大的区别是 InnoDB 支持**事务**，而 MyISAM 不支持事务；\n\n* InnoDB 支持**崩溃后安全恢复**，MyISAM 不支持崩溃后安全恢复；\n* InnoDB 支持**行锁**，MyISAM 不支持行锁，只支持表锁；\n* InnoDB 支持**外键**，MyISAM 不支持外键；\n\n### InnoDB 有哪些特性？\n\n**1）插入缓冲(insert buffer)**：插入缓冲带来的是**性能**。对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引叶子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。（**对于非聚集索引页，不是直接放到索引页中，而是先放到缓冲池中，这时候缓冲池中可能存放了多个非聚集索引页，然后将这多个非聚集索引页的插入合并到一个操作中，取代了之前的一个一个插入**）\n\n**2）两次写(double write)**：两次写带来的是**可靠性**，主要用来解决部分写失败。doublewrite 由两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。**（要进行写操作时，不是直接写硬盘，而是写拷贝到内存中的两次写缓冲区大小2M，然后把两次写缓冲区的内容分两次写（每次写1M）到共享表空间的磁盘上，然后再将共享表空间的内容同步到数据文件上）**\n\n![两次写](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-ad3fb88b0ef6d41d.png) \n\n**3）自适应哈希索引(adaptive hash index)**：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。**（为了提高性能会自动建立一些 hash 索引，查找效率很高，直接通过 hash 值定位到数据）**\n\n### 一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？\n\n> 等价于：自增主键能不能被持久化的问题？\n>\n> MyISAM：自增主键会持久化到数据文件中\n>\n> InnoDB：\n> \t5.7 以及之前：不会持久化\n> \t从 8 开始：自增主键会持久化到 redo log\n\n1. 如果表的引擎类型是 **MyISAM**，那么这条记录的 ID 就是 4。因为 **MyISAM表会把自增主键的最大ID记录到数据文件里面**，重启 MySQL 后，自增主键的最大 ID 也不会丢失。\n\n2. 如果表的引擎类型是 **InnoDB**，那么这条记录的 ID 就是 2。因为 **InnoDB表把自增主键的最大ID记录到内存中**，所以重启数据库后会使最大 ID（其实是 AUTO_INCREMENT 计数器的值）丢失；一旦数据库重新运行，数据库会自动计算自增主键的最大 ID（**其实就是把最后一条记录 ID 加 1 并赋值给 AUTO_INCREMENT**）再次放入到内存中。\n\n\t【注】**这仅仅是 MySQL 8 以前的版本，也就是 MySQL 5.7 以及之前的版本**。因为在 MySQL 8.0 中，**InnoDB 的行为已更改**。每次更改时，当前最大自动增量计数器值（AUTO_INCREMENT）都会写入重做日志 redo log，并保存到每个检查点的引擎专用系统表中。这些更改使当前的最大自动增量计数器值在服务器重新启动后保持不变，与 **MyISAM** 一样了。详见官方文档：[InnoDB AUTO_INCREMENT 计数器初始化](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-initialization)\n\n\t【注】如果删除的不是最后的记录，那么自增的最大 ID 全部都一样，因为自动增量计数器值（AUTO_INCREMENT）不会改变。\n\n### MySQL 中什么情况会导致自增主键不能连续？\n\n> 1. 唯一键冲突\n> 2. 事务回滚\n\n*   执行器执行插入，自增键+1，但是 innoDB 发现插入时**唯一键冲突**，无法插入，导致的不连续。\n\n*   事务添加自增键+1，但是由于**事务回滚**，数据被清除，导致的不连续。\n\n### 什么是覆盖索引？\n\n覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据即回表。\n\n### 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\n\n如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。\n\n### 内存表和临时表有什么区别？\n\n内存表，指的是使用 Memory 引擎的表，数据放在内存中，重启会被清空；\n\n临时表，指的是使用 InnoDB 引擎或者 MyISAM 引擎的表，数据放在磁盘上，重启不会清空。\n\n### MySQL 中的字符串类型都有哪些？\n\n| **类型**     | **取值范围**              |\n| ------------ | ------------------------- |\n| CHAR(N)      | 0~255                     |\n| VARCHAR(N)   | 0~65536                   |\n| TINYBLOB     | 0~255                     |\n| BLOB         | 0~65535                   |\n| MEDUIMBLOB   | 0~167772150               |\n| LONGBLOB     | 0~4294967295              |\n| TINYTEXT     | 0~255                     |\n| TEXT         | 0~65535                   |\n| MEDIUMTEXT   | 0~167772150               |\n| LONGTEXT     | 0~4294967295              |\n| VARBINARY(N) | 0~N个字节的变长字节字符集 |\n| BINARY(N)    | 0~N个字节的定长字节字符集 |\n\n### VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？\n\nVARCHAR 的长度是可变的，而 CHAR 是固定长度。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。\n\n### MySQL 存储金额应该使用哪种数据类型？为什么？\n\nMySQL 存储金额应该使用 `decimal` ，因为如果存储其他数据类型，比如 `float` 有导致小数点后数据丢失的风险。\n\n### limit 3,2 的含义是什么？\n\n去除前三条数据之后查询两条信息。\n\n### *lastinsertid()* 函数功能是什么？有什么特点？\n\n*lastinsertid()* 用于查询最后一次自增表的编号（全局的），它的特点是查询时不需要指定表名，使用 `select last_insert_id()` 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10， *lastinsertid()* 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 *lastinsertid()* 查询的值就是 3。\n\n### 删除表的数据有几种方式？它们有什么区别？\n\n删除数据有两种方式：delete 和 truncate，它们的区别如下：\n\n*   delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；\n\n*   delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，\n\t因此 detele 的信息可以被找回而 truncate 的信息无法被找回；\n\n*   truncate 因为不记录日志所以执行效率比 delete 快。\n\n### MySQL 中支持几种模糊查询？它们有什么区别？\n\nMySQL 中支持两种模糊查询：regexp 和 like\nlike 是对任意多字符匹配或任意单字符进行模糊匹配，\n而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。 \nregexp 和 like 的使用示例如下： \n\n> select * from person where uname like '%SQL%';\n> select * from person where uname regexp '.SQL*.'; \n\n### *count(column)* 和 *count(\\*)* 有什么区别？\n\n*count(column)* 统计不会统计列值为 null 的数据，\n而 *count(\\*)* 则会统计所有信息，所以最终的统计结果可能会不同。\n\n### 为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？\n\n因为 **InnoDB 支持事务**，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。\n\n### InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？\n\nMyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。\n\n### 在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？\n\ncount(字段)<count(主键 id)<count(1)≈count(*) 题目解析：\n\n*   对于 count(字段) 来说，遍历整张表，取这个字段，然后判断是否为 null，不为 null 则加 1\n*   对于 count(主键 id) 来说，遍历整张表，取主键 id，不可能为空，每次加 1。但是可能使用最小的索引树。\n*   对于 count(1) 来说，遍历整张表，不取值。1 是不可能为空的，每次加 1。\n*   对于 count(\\*) 来说，遍历整张表，不取值，直接按行累加。实际上，当使用 count(\\*) 时，MySQL 会将 * 参数转化为参数 0 来处理。\n\n所以最后得出的结果是：count(字段)<count(主键 id)<count(1)≈count(*)。\n\n### MySQL 中内连接、左连接、右连接有什么区别？\n\n*   内连（inner join）— 把匹配的关联数据显示出来；\n\n*   左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；\n\n*   右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；\n\n## MySQL索引篇\n\n### 什么是索引？  \n\n索引是一种能帮助 MySQL 提高查询效率的数据结构。\n\n### 索引分别有哪些优点和缺点？  \n\n**索引的优点：**\n\n*   提高查询效率\n\n\n**索引的缺点：**\n\n*   虽然提高了查询速度，但却降低了更新表的速度，比如 update、insert；\n\t因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；\n\n*   建立索引的索引文件会占用磁盘。\n\n### MySQL索引的注意事项\n\n**1、联合索引遵循前缀原则**\n\n**2、like模糊查询，%不能在前**\n\n**3、**列值为空（NULL）时是可以使用索引的，但 MySQL 难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在 MySQL 内部进行特殊处理。\n\n**4、** 如果 MySQL 估计使用索引比全表扫描更慢，会放弃使用索引，例如：\n表中只有 100 条数据左右。对于 SQL 语句 WHERE id > 1 AND id < 100，MySQL 会优先考虑全表扫描。\n\n**5、** **如果关键词or前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。**\n\n**6、** 列类型是字符串，查询时一定要给值加引号，否则索引失效，例如：\n列 name varchar(16)，存储了字符串\"100\"\nWHERE name = 100;  （做了自动类型转换）\n以上 SQL 语句能搜到，但无法用到索引。\n\n**7、不在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描** \n\n### 为什么 MySQL 官方建议使用自增主键作为表的主键？ \n\n优点：\n\n1. 页分裂问题。如果使用非自增主键作为表的主键的话，当新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上，以确保索引有序。也就是说造成了页分裂，大量移动数据的过程严重影响插入效率。\n\n2. 存储空间问题。自增主键存储空间小，同一个结点内能存放更多的主键，树的高度可能降低，减少 io 次数。\n\n缺点：\n\n1. 数据量过大，可能会超出自增长取值范围；\n2. 无法满足分布式存储，分库分表的情况下无法合并表；\n3. 主键有自增规律，容易被破解；\n\n**综上所述：**是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。\n\n### 索引有几种类型？分别如何创建？  \n\n**MySQL 的索引有两种分类方式：逻辑分类和物理分类。 **\n\n**按照逻辑分类，索引可分为：**\n\n*   主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；\n*   唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；\n*   普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；\n\n**按照物理分类，索引可分为：**\n\n*   聚簇索引：InnoDB 的主键索引存储采用聚簇索引，主键值和数据存放在一起\n*   非聚簇索引：MyISAM 的主键索引存储采用非聚簇索引，主键值和指向数据的指针存放在一起，数据另开空间存储\n\n**各种索引的创建脚本如下：**\n\n```sql\n-- 创建主键索引\nALTER TABLE user ADD PRIMARY KEY (column_list);\n-- 创建唯一索引\nALTER TABLE user ADD UNIQUE index_name (column_list);\n-- 创建普通索引\nALTER TABLE user ADD INDEX index_name (column_list);\n-- 创建全文索引\nALTER TABLE user ADD FULLTEXT index_name (column_list);\n```\n\n### 什么叫回表查询？  \n\n普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。\n\n也就是说，基于非主键索引的查询需要多扫描一次主键索引树。因此，我们在应用中应该尽量使用主键查询。\n\n例外就是使用非主键索引时，如果当前索引满足查询需求，则不用回表。\n\n### 在 InnDB 中主键索引为什么比普通索引的查询性能高？  \n\n回表。因为普通索引的查询会多执行一次检索操作。比如主键查询 select * from t where id=10 只需要搜索 id 的这棵 B+ 树，而普通索引查询 select * from t where f=3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。\n\n### MySQL 复合索引应该注意什么？  \n\nMySQL 中的复合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。\n\n### 复合索引的作用是什么？  \n\n*   用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了`key(a)、key(a,b)、key(a,b,c)`等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；\n*   覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：`select a,b,c from table where a=1 and b = 1` ，就可以直接通过遍历索引取得数据，而**无需回表查询**，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；\n*   索引列越多，通过索引筛选出的数据越少。  \n\n### 什么是最左匹配原则？它的生效原则有哪些？  \n\n最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（>、<、between、like）就会停止匹配。\n\n### 以下语句会走索引么？\n\n```\nselect * from t where year(date)>2018;\n```\n\n不会，因为在索引列上涉及到了运算。\n\n### 能否给手机号的前 6 位创建索引？如何创建？  \n\n可以，创建方式有两种：\n\n```\nalter table t add index index_phone(phone(6));\ncreate index index_phone on t(phone(6));\n```\n\n### 什么是前缀索引？  \n\n前缀索引也叫局部索引，比如给身份证的前 10 位添加索引。\n类似这种给某列部分信息添加索引的方式叫做前缀索引。\n\n### 为什么要用前缀索引？  \n\n前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。\n\n### 什么情况下适合使用前缀索引？  \n\n当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性（不重复的索引值和表记录数的比值，越大说明索引价值越大）为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。\n\n### InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？  \n\n因为 B 树、Hash、红黑树或二叉树存在以下问题：\n\n*   B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低；\n*   Hash：虽然可以快速定位，但是没有顺序，无法进行范围查找，IO 复杂度高；\n*   二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；\n*   红黑树：树的高度随着数据量增加而增加，IO 代价高。  \n\n### MySQL 如何指定查询的索引？  \n\n在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：\n\n```sql\nselect * from t force index(index_t);\n```\n\n### 在 MySQL 中指定了查询索引，为什么没有生效？  \n\n我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。\n\n### 如何优化身份证的索引？ \n\n在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：\n\n*   **使用身份证倒序存储**，这样设置前六位的意义就很大了；\n*   **使用 hash 值**，新创建一个字段用于存储身份证的 hash 值。\n\n### 索引的使用场景\n\n- 对于非常小的表，大部分情况下全表扫描效率更高。\n- 中到大型表，索引非常有效。\n- 特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。\n\n\n\n### 聚簇索引和非聚簇索引\n\nInnobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。\n\nInnodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引\n\n#### 聚簇索引(聚集索引)\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145143172-1760681728.png)\n\n\n\n　　Innodb 聚簇索引和 MyIsam 非聚簇索引的比较说明\n　　参考博客：https://www.cnblogs.com/zlcxbb/p/5757245.html\n\n#### InnoDB索引实现\n\n　　InnoDB**使用B+Tree作为索引结构**，但具体实现方式却与 MyISAM 截然不同.\n\n1）主键索引：\n\n**MyISAM索引文件和数据文件是分离的**，**索引文件仅保存数据记录的地址**。而在**InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构**，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。\n\n ![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1464190-20191106145200302-932404581.png)\n\n(图 inndb 主键索引）是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则**MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形**。\n\n2）InnoDB 的辅助索引\n\n   InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引：\n\n ![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145241480-1330791289.png)\n\nInnoDB 使用的是聚簇索引，将主键组织到一棵 B+树中，而行数据就储存在叶子节点上，若使用\"where id = 14\"这样的条件查找主键，则按照 B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B+树中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B+树中再执行一次 B+树检索操作，最终到达叶子节点即可获取整行数据。\n\n#### MyISAM索引实现\n\nMyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址\n\n1）主键索引：\n\nMyISAM 引擎使用 B+Tree 作为索引结构，叶节点的**data域存放的是数据记录的地址**。下图是 MyISAM 主键索引的原理图：\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151308457-531875534.png)\n\n \n\n这里设表一共有三列，假设我们以 Col1 为主键，图 myisam1 是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。\n\n2）辅助索引（Secondary key）\n\n在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，**只是主索引要求key是唯一的，而辅助索引的key可以重复**。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示。\n\n同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。\n\n ![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151427711-625351515.png)\n\n　　**MyISM使用的是非聚簇索引**，非聚簇索引的两棵 B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引 B+树的节点存储了主键，辅助键索引 B+树存储了辅助键。表数据存储在独立的地方，这两颗 B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。\n\n为了更形象说明这两种索引的区别，我们假想一个表如下图存储了 4 行数据。其中 Id 作为主索引，Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151527647-152458631.png)\n\n \n\n🌟**InnoDB聚簇索引：**\n\n主键索引树，根结点存的是主键 id 和对应的数据；\n\n辅助索引树，根结点存的是辅助索引和对应的主键索引，因此需要根据主键到主键索引树上在遍历一次得到对应的数据。\n\n🌟**MyISAM非聚簇索引：**\n\n主键索引树，根结点存的是主键到数据地址的映射；\n\n辅助索引树，根结点存的是辅助索引到数据地址的映射，也可以直接得到数据，不需要回表。\n\n#### 问题：主键索引是聚集索引还是非聚集索引？\n\n在 InnoDB 下主键索引是聚集索引，在 MyISAM 下主键索引是非聚集索引\n\n#### MyISAM索引实现？\n\nMyISAM 存储引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。MyISAM 的索引方式也叫做非聚簇索引的，之所以这么称呼是为了与 InnoDB 的聚簇索引区分。\n\n#### MyISAM索引与InnoDB索引的区别？\n\n- InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。\n- InnoDB 的主键索引的叶子节点存储着索引和行数据，因此主键索引非常高效。\n- MyISAM 索引的叶子节点存储的是行数据地址，需要根据数据地址访问对应的地址才能得到数据。\n- **InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。**\n\n### 简单说一说drop、delete与truncate的区别\n\nSQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别\n\n> 1、delete和truncate只删除表的数据不删除表的结构\n> 2、速度,一般来说: drop> truncate >delete\n> 3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;\n> 4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.\n\n### delete、truncate和drop分别在什么场景之下使用？\n\n1. 想删除部分数据行时候，用 delete，并且带上 where 子句\n2. 保留表而删除所有数据的时候用 truncate\n3. 不再需要一张表的时候，用 drop\n\n### ⭐为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？\n\n1. B+Tree 的磁盘读写代价更低\n\n> B+Tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B-Tree 更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。\n\n2. B+Tree 的查询效率更加稳定\n\n> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n\n### ⭐Hash索引和B+树所有有什么区别或者说优劣呢?\n\n首先要知道 Hash 索引和 B+树索引的底层实现原理：\n\n**hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.**\nB+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.\n\n那么可以看出他们有以下的不同：\n\n- hash 索引进行等值查询更快(一般情况下),但是却无法进行范围查询.\n\n- hash 索引不支持使用索引进行排序,原理同上.\n- hash 索引不支持模糊查询.\n- hash 索引任何时候都避免不了回表查询数据,而 B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.\n- hash 索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生 hash 碰撞,此时效率可能极差.而 B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.\n\n因此,在大多数情况下,直接选择 B+树索引可以获得稳定且较好的查询速度.而不需要使用 hash 索引.\n\n### 非聚簇索引一定会回表查询吗?\n\n有如下一张 InnoDB 表：\n\n```sql\nCREATE TABLE `user` (\n`id` INT NOT NULL ,\n`name` VARCHAR NOT NULL ,\n`age` INT NOT NULL);\n```\n\n其中 id 为自增主键，name 是一个普通索引。在执行 select * from user where id = 1 时，会在主键索引对应的 B+树的叶子结点上搜索到关键字 id=1 的节点，并读取位于该节点上的整行数据。但是在执行 select * from user where name = 'tom'时，会分为两个步骤：\n\n先到 name 索引对应的 B+树的叶子结点上搜索到关键字 name='tom’的节点，并从该节点上获取对应的主键 id 值。\n\n然后再根据 id 值使用主键索引读取到整行数据。\n\n其中第二个步骤叫作回表查询。需要扫描辅助索引和主键索引两棵 B+树才能拿到整行数据，效率较低。\n\n如果执行 select id, name from user where name = 'tom',则只需要扫描 name 索引树就可以获取到所有的字段，因为 id 和 name 都保存在 name 索引 B+树的叶子节点上，所以不需要再去主键索引上查找。这就是所谓的索引覆盖。只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。\n\n而 select id, name, age from user where name = 'tom'，因为 age 字段没有存储到 name 索引的叶子节点上，所以需要根据主键索引回表查询到 age 列值。如果把 name 索引改成(name，age)的联合索引就可以实现索引覆盖，无需回表了。（覆盖索引，sql 语句中用到的字段都有索引）\n————————————————\n版权声明：本文为 CSDN 博主「lmyno」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_33603681/article/details/113387941\n\n### 联合索引是什么?为什么需要注意联合索引中的顺序?\n\n因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.\n\n### 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?\n\nMySQL 提供了 explain 命令来查看语句的执行计划\n\n\n\n## MySQL事务篇（重点）\n\n### 可见性判断\n\n> 总结：\n>\n> 大于等于下一个分配的事务ID不可见\n>\n> 包含在未提交事务集合中但是和创建read view的事务ID不相等则也不可见。\n\n事务版本号小于当前最小的事务 ID，那么说明它已经提交了，可见。\n\n事务版本号**大于等于下一个分配的事务ID**，说明这个事务在当前 read view 生成后在生成，**不可见**。\n\n事务版本号在 [最小事务 ID，下一个分配的事务 ID) 区间内：\n\n​\t如果未提交事务集合包含该事务版本号，那么判断是否该事务版本号是否等于创建该 read view 的事务 ID，\n\n​\t\t等于则说明这个版本的数据是当前事务生成的，可见。**不等于则不可见**。\n\n​\t如果不包含，说明这个事务版本号已经提交，可见。\n\n### 查询一条记录，基于MVCC，是怎样的流程\n\n1. 获取数据版本号即**数据行中的事务id隐藏字段**\n2. **执行sql，得到Read View**\n3. 根据数据版本号和 read view 进行**可见性判断**，判断当前版本数据是否可见\n4. 如果不符合 Read View 的可见性规则， 即就需要**Undo log**中历史快照重新和 read view 可见性判断\n5. 最后返回符合规则的数据\n\nInnoDB 实现 MVCC，是通过` Read View+ Undo Log` 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。\n\n### RC下可以读到已提交数据，但不能读到未提交数据\n\n![1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1.png)\n\n### RR下已提交和未提交数据都不能读到\n\n![2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes2.png)\n\n### 为什么RR下解决了不可重复读问题？\n\n实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟**Read view工作方式有关**。\n\n- 在读已提交（RC）隔离级别下，同一个事务里面，**每一次查询都会产生一个新的Read View**，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。\n\n| begin                               |                   |\n| ----------------------------------- | ----------------- |\n| select * from core_user where id =1 | 生成一个Read View |\n| /                                   | /                 |\n| /                                   | /                 |\n| select * from core_user where id =1 | 生成一个Read View |\n\n- 在可重复读（RR）隔离级别下，**一个事务里只会获取一次read view**，都是副本共用的，从而保证每次查询的数据都是一样的。\n\n| begin                               |                       |\n| ----------------------------------- | --------------------- |\n| select * from core_user where id =1 | 生成一个Read View     |\n| /                                   |                       |\n| /                                   |                       |\n| select * from core_user where id =1 | 共用一个Read View副本 |\n\n### MVCC是否解决了幻读问题呢？\n\n对于幻读来说，存在快照读（可以读到多个版本，普通的 select）和当前读（读的是最新的 for update）的情况：\n\n1. RR 隔离级别下为了解决幻读问题：**快照读依靠MVCC控制，当前读通过间隙锁解决**；\n2. 间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；\n3. **间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度**。\n\n\n\n### 并发事务有什么什么问题？应该如何解决？\n\n并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：\n\n*   加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。\n\n*   提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。\n\n### MySQL 事务实现原理是什么？\n\n以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。\n事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。\n\n\n\n## MVCC详细版\n\n### 1. 相关数据库知识点回顾\n\n#### 1.1 什么是数据库事务，为什么要有事务\n\n事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。\n\n**为什么要有事务呢？** 就是为了保证数据的最终一致性。\n\n#### 1.2 事务包括哪几个特性？\n\n事务四个典型特性，即 ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。\n\n- 原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作**要么全部都执行，要么都不执行**。\n- 一致性： 指在**事务开始之前和事务结束以后**，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。\n- 隔离性： 多个事务并发访问时，**事务之间是相互隔离**的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。\n- 持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将**持久地保存在数据库**之中。\n\n#### 1.3 事务并发存在的问题\n\n事务并发会引起**脏读、不可重复读、幻读**问题。\n\n##### 1.3.1 脏读\n\n> 如果一个事务读取到了另一个未提交事务修改过的数据，我们就称发生了脏读现象。\n\n##### 1.3.2 不可重复读\n\n> 同一个事务内，前后多次读取，读取到的数据内容不一致\n\n##### 1.3.3 幻读\n\n> 如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如insert、delete、update），两次读取到的结果集却不一样了，就意味着发生了**幻读**。\n\n#### 1.4 四大隔离级别\n\n为了解决并发事务存在的**脏读、不可重复读、幻读**等问题，数据库大叔设计了四种隔离级别。分别是**读未提交，读已提交，可重复读，串行化（Serializable）**。\n\n##### 1.4.1 读未提交\n\n读未提交隔离级别，只限制了两个数据**不能同时修改**，但是修改数据的时候，即使事务**未提交**，都是可以被别的事务读取到的，这级别的事务隔离有**脏读、重复读、幻读**的问题；\n\n##### 1.4.2 读已提交\n\n读已提交隔离级别，当前事务只能读取到其他事务**提交**的数据，所以这种事务的隔离级别**解决了脏读**问题，但还是会存在**重复读、幻读**问题；\n\n##### 1.4 3 可重复读\n\n可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以**解决了重复读**的问题，但是读取范围数据的时候，是可以插入数据，所以还会存在**幻读**问题；\n\n##### 1.4.4 串行化\n\n事务最高的隔离级别，在该级别下，所有事务都是进行**串行化顺序**执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。\n\n##### 1.4.5 四大隔离级别，都会存在哪些并发问题呢\n\n| 隔离级别 | 脏读 | 不可重复读 | 幻读 |\n| -------- | ---- | ---------- | ---- |\n| 读未提交 | √    | √          | √    |\n| 读已提交 | ×    | √          | √    |\n| 可重复读 | ×    | ×          | √    |\n| 串行化   | ×    | ×          | ×    |\n\n#### 1.5 数据库是如何保证事务的隔离性的呢？\n\n数据库是通过**加锁**，来实现事务的隔离性的。这就好像，如果你想一个人静静，不被别人打扰，你就可以在房门上加上一把锁。\n\n加锁确实好使，可以保证隔离性。比如**串行化隔离级别就是加锁实现的**。但是频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大**降低了数据库性能**。\n\n**那么，如何解决加锁后的性能问题的？**\n\n答案就是,**MVCC多版本并发控制**！它实现读取数据不用加锁，可以让读取数据同时修改。修改数据时同时可读取。\n\n### 2. 什么是 MVCC？\n\nMVCC，即**Multi-Version  Concurrency Control （多版本并发控制）**。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。\n\n> 通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。\n\n数据库隔离级别**读已提交、可重复读** 都是基于 MVCC 实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。\n\n### 3. MVCC实现的关键知识点\n\n#### 3.1 事务版本号\n\n> 事务每次开启前，都会从数据库获得一个**自增长**的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。\n\n#### 3.2 隐式字段\n\n对于 InnoDB 存储引擎，每一行记录都有两个隐藏列**trx_id**、**roll_pointer**，如果表中没有主键和非 NULL 唯一键时，则还会有第三个隐藏的主键列**row_id**。\n\n| 列名         | 是否必须 | 描述                                                     |\n| ------------ | -------- | -------------------------------------------------------- |\n| row_id       | 否       | 单调递增的行ID，不是必需的，占用6个字节。                |\n| trx_id       | 是       | 记录操作该数据事务的**事务ID**                           |\n| roll_pointer | 是       | 这个隐藏列就相当于一个**回滚指针**，指向回滚段的undo日志 |\n\n#### 3.3 undo log\n\nundo log，**回滚日志**，用于**记录数据被修改前**的信息。在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。\n\n可以这样认为，当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，当 update 一条记录时，它记录一条对应相反的 update 记录。\n\nundo log 有什么**用途**呢？\n\n1. 事务回滚时，保证原子性和一致性。\n2. 用于 MVCC**快照读**。\n\n#### 3.4 版本链\n\n多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为**版本链**。如下：\n\n![image-20220422131424393](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131424393.png)\n\n其实，通过版本链，我们就可以看出**事务版本号、表格隐藏的列和undo log**它们之间的关系。我们再来小分析一下。\n\n1. 假设现在有一张 core_user 表，表里面有一条数据,id 为 1，名字为孙权：\n\n\t<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131445316.png\" alt=\"image-20220422131445316\" style=\"zoom: 50%;\" />\n\n2. 现在开启一个事务 A： 对 core_user 表执行`update core_user set name =\"曹操\" where id=1`,会进行如下流程操作\n\n- 首先获得一个事务 ID=100\n- 把 core_user 表修改前的数据,拷贝到 undo log\n- 修改 core_user 表中，id=1 的数据，名字改为曹操\n- 把修改后的数据事务 Id=101 改成当前事务版本号，并把**roll_pointer**指向 undo log 数据地址。\n\n\t<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131527508.png\" alt=\"image-20220422131527508\" style=\"zoom: 50%;\" />\n\n#### 3.5 快照读和当前读\n\n**快照读：** 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的 select 语句都是快照读,如：\n\n```\nselect * from core_user where id > 2;\n```\n\n**当前读**：读取的是记录数据的最新版本，显式加锁的都是当前读\n\n```\nselect * from core_user where id > 2 for update;\n```\n\n#### 3.6 Read View\n\n- **Read View是什么呢？** 它就是事务执行 SQL 语句时，产生的读视图。实际上在 innodb 中，每个 SQL 语句执行前都会得到一个 Read View。\n- **Read View有什么用呢？** 它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据\n\nRead View 是如何保证可见性判断的呢？我们先看看 Read view 的几个重要属性\n\n- m_ids:当前系统中那些活跃(**未提交**)的读写事务 ID, 它数据结构为一个 List，[min_limit_id, max_limit_id)\n- min_limit_id:表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，即 m_ids 中的最小值。\n- max_limit_id:表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值，即即 m_ids 中的最大值+1\n- creator_trx_id: 创建当前 read view 的事务 ID\n\n**Read view 匹配条件规则**如下：\n\n1. 如果新的数据事务 ID `trx_id < min_limit_id`，表明生成该版本的事务在生成 Read View 前，已经提交(因为事务 ID 是递增的)，所以该版本可以被当前事务访问。\n2. 如果`trx_id>= max_limit_id`，表明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。\n3. 如果 `min_limit_id =<trx_id< max_limit_id`,需要分 3 种情况讨论\n\n> （1）如果`m_ids`包含`trx_id`,则代表Read View生成时刻，这个事务还未提交，但是如果数据的`trx_id`等于`creator_trx_id`的话，表明数据是自己生成的，因此是**可见**的。\n>\n> （2）如果`m_ids`包含`trx_id`，并且`trx_id`不等于`creator_trx_id`，则Read  View生成时，事务未提交，并且不是自己生产的，所以当前事务也是**看不见**的；\n>\n> （3）如果`m_ids`不包含`trx_id`，则说明你这个事务在Read View生成之前就**已经提交**了，修改的结果，当前事务是能看见的。\n\n### 4. MVCC实现原理分析\n\n<img src=\"/Users/yaxing/blog/source/_posts/E:/Markdown%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/8%20MySQL.assets/v2-a086ef515e7d0a023ca3cfcc5759c7f6_720w.jpg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n#### 4.1 查询一条记录，基于MVCC，是怎样的流程\n\n1. 获取事务 ID\n2. 执行 sql，得到 Read View\n3. 查询得到的数据，然后与 Read View 中的事务 ID 进行比较，帮助判断当前版本的数据是否可见。\n4. 如果不符合 Read View 的可见性规则， 即就需要 Undo log 中历史快照;\n5. 最后返回符合规则的数据\n\nInnoDB 实现 MVCC，是通过` Read View+ Undo Log` 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。\n\n#### 4.2 读已提交（RC）隔离级别，存在不可重复读问题的分析历程\n\n1. 创建 core_user 表，插入一条初始化数据,如下：\n\n\t<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131554547.png\" alt=\"image-20220422131554547\" style=\"zoom: 33%;\" />\n\n2. 隔离级别设置为读已提交（RC），事务 A 和事务 B 同时对 core_user 表进行查询和修改操作。\n\n```\n事务A: select * fom core_user where id=1\n事务B: update core_user set name =”曹操”\n// 事务A两次读到的数据不一样，事务A会读到其他事务提交的数据，不能读到其他事务未提交的数据。\n```\n\n执行流程如下：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131620047.png\" alt=\"image-20220422131620047\" style=\"zoom: 33%;\" />\n\n最后事务 A 查询到的结果是，**name=曹操**的记录，我们**基于MVCC**，来分析一下执行流程：\n\n(1) A 开启事务，首先得到一个事务 ID 为 100\n\n(2) B 开启事务，得到事务 ID 为 101\n\n(3) 事务 A 生成一个 Read View，read view 对应的值如下\n\n| 变量                                                    | 值       |\n| ------------------------------------------------------- | -------- |\n| m_ids（未提交的事务ID）                                 | 100，101 |\n| max_limit_id（下一个应该分配的事务ID）                  | 102      |\n| min_limit_id（当前read view中活跃的未提交事务的最小值） | 100      |\n| creator_trx_id（创建该read view的事务ID）               | 100      |\n\n然后回到版本链：开始从版本链中挑选可见的记录：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131642264.png\" alt=\"image-20220422131642264\" style=\"zoom: 33%;\" />\n\n由图可以看出，最新版本的列 name 的内容是`孙权`，该版本的`trx_id`值为 100。开始执行 read view 可见性规则校验：\n\n```\nmin_limit_id(100)=<trx_id（100）<102;\ncreator_trx_id = trx_id =100;\n```\n\n由此可得，trx_id=100 的这个记录，当前事务是可见的。所以查到是 name 为`孙权`的记录。\n\n(4) 事务 B 进行修改操作，把名字改为曹操。把原数据拷贝到 undo log,然后对数据进行修改，标记事务 ID 和上一个数据版本在 undo log 的地址。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131733370.png\" alt=\"image-20220422131733370\" style=\"zoom:33%;\" />\n\n(5) 提交事务\n\n(6) 事务 A 再次执行查询操作，**新生成一个Read View**，Read View 对应的值如下\n\n| 变量                                    | 值   |\n| --------------------------------------- | ---- |\n| m_ids（未提交的事务ID）                 | 100  |\n| max_limit_id（下一个应当分配的事务ID）  | 102  |\n| min_limit_id（最小的事务ID）            | 100  |\n| creator_trx_id（创建read view的事务ID） | 100  |\n\n然后再次回到版本链：从版本链中挑选可见的记录：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131753554.png\" alt=\"image-20220422131753554\" style=\"zoom:33%;\" />\n\n从图可得，最新版本的列 name 的内容是`曹操`，该版本的`trx_id`值为 101。开始执行 Read View 可见性规则校验：\n\n```\nmin_limit_id(100)=<trx_id（101）<max_limit_id（102);\n但是,trx_id=101，不属于m_ids集合，说明101这个事务已经提交了，当前事务可见\n```\n\n因此，`trx_id=101`这个记录，对于当前事务是可见的。所以 SQL 查询到的是 name 为`曹操`的记录。\n\n综上所述，在**读已提交（RC）隔离级别**下，同一个事务里，两个相同的查询，读取同一条记录（id=1），却返回了不同的数据（**第一次查出来是孙权，第二次查出来是曹操那条记录**），因此 RC 隔离级别，存在**不可重复读**并发问题。\n\n#### 4.3 可重复读（RR）隔离级别，解决不可重复读问题的分析\n\n在 RR 隔离级别下，是如何解决不可重复读问题的呢？我们一起再来看下，\n\n还是 4.2 小节那个流程，还是这个事务 A 和事务 B，如下：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131811671.png\" alt=\"image-20220422131811671\" style=\"zoom:33%;\" />\n\n##### 4.3.1 不同隔离级别下，Read view的工作方式不同\n\n实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟**Read view工作方式有关**。\n\n- 在读已提交（RC）隔离级别下，同一个事务里面，**每一次查询都会产生一个新的Read View副本**，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。\n\n| begin                               |                   |\n| ----------------------------------- | ----------------- |\n| select * from core_user where id =1 | 生成一个Read View |\n| /                                   | /                 |\n| /                                   | /                 |\n| select * from core_user where id =1 | 生成一个Read View |\n\n- 在可重复读（RR）隔离级别下，**一个事务里只会获取一次read view**，都是副本共用的，从而保证每次查询的数据都是一样的。\n\n| begin                               |                       |\n| ----------------------------------- | --------------------- |\n| select * from core_user where id =1 | 生成一个Read View     |\n| /                                   |                       |\n| /                                   |                       |\n| select * from core_user where id =1 | 共用一个Read View副本 |\n\n##### 4.3.2 实例分析\n\n我们穿越下，回到**刚4.2的例子**，然后执行第 2 个查询的时候：\n\n事务 A 再次执行查询操作，复用老的 Read View 副本，Read View 对应的值如下\n\n| 变量           | 值       |\n| -------------- | -------- |\n| m_ids          | 100，101 |\n| max_limit_id   | 102      |\n| min_limit_id   | 100      |\n| creator_trx_id | 100      |\n\n然后再次回到版本链：从版本链中挑选可见的记录：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131828812.png\" alt=\"image-20220422131828812\" style=\"zoom:33%;\" />\n\n从图可得，最新版本的列 name 的内容是`曹操`，该版本的`trx_id`值为 101。开始执行 read view 可见性规则校验：\n\n```\nmin_limit_id(100)=<trx_id（101）<max_limit_id（102);\n因为m_ids{100,101}包含trx_id（101），\n并且creator_trx_id (100) 不等于trx_id（101）\n```\n\n所以，`trx_id=101`这个记录，对于当前事务是**不可见**的。这时候呢，版本链`roll_pointer`跳到下一个版本，`trx_id=100`这个记录，再次校验是否可见：\n\n```\nmin_limit_id(100)=<trx_id（100）< max_limit_id（102);\n因为m_ids{100,101}包含trx_id（100），\n并且creator_trx_id (100) 等于trx_id（100）\n```\n\n所以，`trx_id=100`这个记录，对于当前事务是**可见**的。即在可重复读（RR）隔离级别下，复用老的 Read View 副本，解决了**不可重复读**的问题。\n\n#### 4.4 MVCC是否解决了幻读问题呢？\n\n对于幻读来说，存在当前读和快照读的情况：\n\n1. RR 隔离级别下为了解决幻读问题：**快照读依靠MVCC控制，当前读通过间隙锁解决**；\n2. 间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；\n3. 间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度。\n\n作者：捡田螺的小男孩\n\n链接：https://juejin.cn/post/7016165148020703246\n\n来源：稀土掘金\n\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n## MySQL锁篇\n\n### 什么是锁？MySQL 中提供了几类锁？\n\n锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。\n\n排他锁（写锁），共享锁（读锁）\n乐观锁，悲观锁\n全局锁，表锁，行锁，页锁\n\n### 什么是死锁？\n\n死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。\n\n### 如何处理死锁？\n\n对待死锁常见的两种策略：\n\n*   设置超时时间\n\n*   发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。\n\n### 如何避免死锁？\n\n使用 SELECT … FOR UPDATE 语句来获取必要的锁。\n\n### 什么是全局锁？它的应用场景有哪些？\n\n全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。\n\n### 什么是共享锁？\n\n共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。\n\n### 什么是排它锁？\n\n排他锁 exclusive lock（也叫 writer lock）又称写锁。\n\n若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。\n\n排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。\n\n### 使用全局锁会导致什么问题？\n\n如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。\n\n如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。\n\n如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQL dump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。\n\n### 悲观锁和乐观锁有什么区别？\n\n顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。\n\n说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。\n\n**乐观锁是用数据版本（Version）记录机制实现**，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。\n\n### 乐观锁有什么优点和缺点？\n\n因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。\n\n### ⭐InnoDB 存储引擎有几种锁算法？\n\n*   Record Lock — 单个行记录上的锁；\n\n*   Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；\n\n*   Next-Key Lock（包含行锁和间隙锁） — 锁定一个范围，包括记录本身。\n\n### InnoDB 如何实现行锁？\n\n共享锁：**in share mode**\n\n排他锁：**for update**\n\n### 优化锁方面你有什么建议？\n\n*   尽量使用较低的隔离级别。\n*   精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。\n*   选择合理的事务大小，小事务发生锁冲突的几率也更小。\n*   给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。\n*   不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。\n*   尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。\n*   不要申请超过实际需要的锁级别。\n*   除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。\n*   对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。\n\n### MySQL 中有哪几种锁？\n\n**1、表级锁：** 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。\n\n**2、行级锁：**  开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。\n\n**3、页锁：**  开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。\n\n\n\n### 锁机制与InnoDB锁算法\n\n**MyISAM和InnoDB存储引擎使用的锁：**\n\n- MyISAM 采用表级锁(table-level locking)。\n- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁\n\n**表级锁和行级锁对比：**\n\n- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。\n\n- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。\n\n### 锁的优化策略\n\n**1、** 读写分离\n\n**2、** 分段加锁\n\n**3、** 减少锁持有的时间\n\n多个线程尽量以相同的顺序去获取资源\n\n不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大锁。\n\n## MySQL日志篇\n\n### MySQL 有哪些重要的日志文件？  \n\nMySQL 中的重要日志分为以下几个：\n\n**① 错误日志：**用来记录 MySQL 服务器运行过程中的错误信息\n\n**② 查询日志**：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:\n\n*   insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；\n\n*   update 时也会查询因为更新的时候很可能会更新某一块数据；\n\n*   delete 查询，只删除符合条件的数据；\n\n因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。\n\n查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。\n\n**③ 慢日志**：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：\n\n```\nset global slowquerylog='ON';\n```\n\n使用 set global slow*query*log='ON' 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf，设置 slow*query*log=1 并重启 MySQL 服务器。\n\n**④ redo log（重做日志）**：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。\n\n**⑤ undo log（回滚日志）**：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。\n\n**⑥ bin log（二进制日志）**：是一个二进制文件，主要**记录了对 MySQL 数据库执行更改的所有操作**，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，不记录 SELECT、SHOW 等那些不修改数据或数据库结构的 SQL 语句。\n\nbinlog 的作用如下：\n\n*   恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；\n\n*   复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；\n\n*   审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。\n\n除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。\n\nbinlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。\n\n通过以下命令来查询 binlog 是否开启：\n\n```\nshow variables like 'log_%'; \n```\n\nbinlog 格式分为: STATEMENT、ROW 和 MIXED 三种：\n\n*   STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；\n\n*   ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；\n\n*   MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT*USER()、ROW*COUNT() 等无法确定的函数。\n\n### redo log 和 binlog 有什么区别？\n\nredo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：\n\n*   redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。\n\n*   binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\n\n*   redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\n\n*   redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。\n\n### 什么是 crash-safe？\n\ncrash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。\n\n### 什么是脏页和干净页？\n\nMySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。\n\n### 什么情况下会引发 MySQL 刷脏页（flush）的操作？\n\n*   内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；\n\n*   系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；\n\n*   系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；\n\n*   MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。\n\n### MySQL 刷脏页的速度很慢可能是什么原因？\n\n在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。\n\n### 如何控制 MySQL 只刷新当前脏页？\n\n在 InnoDB 中设置 innodb*flush*neighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。\n\n### MySQL 的 WAL 技术是解决什么问题的？\n\nA.防止误删除，找回数据用的 B.容灾恢复，为了还原异常数据用的 C.事务处理，为了数据库的稳定性 D.为了降低 IO 成本 答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。\n\n### 为什么有时候会感觉 MySQL 偶尔卡一下？\n\n如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。\n\n### redo log 和 binlog 是怎么关联的?\n\n它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：\n\n*   如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；\n\n*   如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。\n\n### MySQL 怎么知道 binlog 是完整的?\n\n*   statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。\n\n*   row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。\n\n### MySQL 中可不可以只要 binlog，不要 redo log？\n\n不可以，binlog 没有崩溃恢复的能力。\n\n### MySQL 中可不可以只要 redo log，不要 binlog？\n\n不可以，原因有以下两个：\n\n*   redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；\n\n*   binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。\n\n### 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？\n\n因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。\n\n### 事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？\n\n不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。\n\n### 在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？\n\nredo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。\n\n### 以下说法错误的是？\n\nA.redo log 是 InnoDB 引擎特有的，它的固定大小的 B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关 C.redo log 可以保证数据库异常重启之后，数据不丢失 D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。\n\n### 以下说法正确的是？\n\nA.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志 B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志 C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 D.以上说法都正确 答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。\n\n### 有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？\n\n可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。\n\n\n\n## MySQL性能优化\n\n### MySQL 性能指标都有哪些？如何得到这些指标？\n\nMySQL 的性能指标如下：\n\n**① TPS（Transaction Per Second）** 每秒事务数，即数据库每秒执行的事务数。\n\nMySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。\n\n需要使用的参数：\n\n*   Com_commit ：表示提交次数，通过命令 `show global status like 'Com_commit';` 获取；\n\n*   Com_rollback：表示回滚次数，通过命令 `show global status like 'Com_rollback';` 获取。\n\n我们定义第一次获取的 Com*commit 的值与 Com*rollback 值的和为 c_r1，时间为 t1；\n\n第二次获取的 Com*commit 的值与 Com*rollback 值的和为 c*r2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS = ( c*r2 - c_r1 ) / ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。\n\n**② QPS（Query Per Second）** 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS = Queries / Seconds Queries 是系统状态值—总查询次数，可以通过 `show status like 'queries';` 查询得出 \n\nSeconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：\n\n> QPS = (Q2 - Q1) / 10\n\n**③ IOPS（Input/Output Operations per Second）** 每秒处理的 I/O 请求次数。\n\nIOPS 是判断磁盘 I/O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I/O 就不会是瓶颈了。\n\n注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。\n\n可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：\n\n> yum install sysstat iostat -dx 1 10\n\n执行效果如下图所示： \n\nIOPS = r/s + w/s 其中：\n\n*   r/s：代表每秒读了多少次；\n\n*   w/s：代表每秒写了多少次。\n\n### 什么是慢查询？\n\n慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 *longquerytime* 值的 SQL，则会被记录到慢查询日志中。 *longquerytime* 的默认值为 10，意思是运行 10s 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。\n\n使用 `mysql> show variables like '%slow_query_log%';` 来查询慢查询日志是否开启\n\n### 如何开启慢查询日志？\n\n开启慢查询日志，可以使用如下 MySQL 命令：\n\n> mysql> set global slow*query*log=1\n\n不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：\n\n> slow*query*log =1 slow*query*log*file=/tmp/mysql*slow.log\n\n### 如何定位慢查询？\n\n使用 MySQL 中的 explain 分析执行语句，比如：\n\n> explain select * from t where id=5;\n\n如下图所示：\n\n![avatar](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-2ff861def7876a91.png) \n\n其中：\n\n*   id — 选择标识符。id 越大优先级越高，越先被执行。\n\n*   select_type — 表示查询的类型。\n\n*   table — 输出结果集的表\n\n*   partitions — 匹配的分区\n\n*   type — 表示表的连接类型\n\n*   possible_keys — 表示查询时，可能使用的索引\n\n*   key — 表示实际使用的索引\n\n*   key_len — 索引字段的长度\n\n*   ref— 列与索引的比较\n\n*   rows — 大概估算的行数\n\n*   filtered — 按表条件过滤的行百分比\n\n*   Extra — 执行情况的描述和说明\n\n其中最重要的就是 type 字段，type 值类型如下：\n\n*   all — 扫描全表数据\n\n*   index — 遍历索引\n\n*   range — 索引范围查找\n\n*   index_subquery — 在子查询中使用 ref\n\n*   uniquesubquery — 在子查询中使用 eq*ref\n\n*   ref*or*null — 对 null 进行索引的优化的 ref\n\n*   fulltext — 使用全文索引\n\n*   ref — 使用非唯一索引查找数据\n\n*   eq_ref — 在 join 查询中使用主键或唯一索引关联\n\n*   const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点\n\n### ⭐MySQL 的优化手段都有哪些？\n\nMySQL 的常见的优化手段有以下五种：\n\n#### ① 查询优化\n\n*   避免 SELECT *，只查询需要的字段。\n\n*   小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。\n\n*   一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。\n\n#### ② 优化索引的使用\n\n*   尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。\n\n*   不做列运算，把计算都放入各个业务系统实现\n\n*   查询语句尽可能简单，大语句拆小语句，减少锁时间\n\n*   不使用 select * 查询\n\n*   or 查询改写成 in 查询\n\n*   不用函数和触发器\n\n*   避免 %xx 查询\n\n*   少用 join 查询\n\n*   使用同类型比较，比如 '123' 和 '123'、123 和 123\n\n*   尽量避免在 where 子句中使用 != 或者 <> 操作符，查询引用会放弃索引而进行全表扫描\n\n*   避免在索引列上使用 is null 和 is not null\n\n*   尽量使用主键查询\n\n*   避免在 where 子句中对字段进行表达式操作\n\n*   尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型\n\n#### ③ 表结构设计优化\n\n*   使用可以存下数据最小的数据类型。\n\n*   使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。\n\n*   尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。\n\n*   尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。\n\n*   尽量少用 text 类型，非用不可时最好考虑分表。\n\n*   尽量使用 timestamp，而非 datetime。\n\n*   单表不要有太多字段，建议在 20 个字段以内。\n\n#### ④ 表拆分\n\n当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 \n\n**a）垂直拆分**：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：\n\n*   把不常用的字段单独放在一张表；\n\n*   把 text，blob 等大字段拆分出来放在附表中；\n\n*   经常组合查询的列放在一张表中。\n\n**b）水平拆分**：指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。\n\n通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。\n\n#### ⑤ 读写分离\n\n一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。\n\n### MySQL 常见读写分离方案有哪些？\n\nMySQL 常见的读写分离方案，如下列表：\n\n**1）应用层解决方案** 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。\n\n**2）中间件解决方案** 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。\n\n### 怎样保证确保备库无延迟？\n\n通常保证主备无延迟有以下三种方法：\n\n*   每次从库执行查询请求前，先判断 seconds*behind*master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds*behind*master 参数是用来衡量主备延迟时间的长短；\n\n*   对比位点确保主备无延迟。Master*Log*File 和 Read*Master*Log*Pos，表示的是读到的主库的最新位点，Relay*Master*Log*File 和 Exec*Master*Log_Pos，表示的是备库执行的最新位点；\n\n*   对比 GTID 集合确保主备无延迟。Auto*Position=1 ，表示这对主备关系使用了 GTID 协议；Retrieved*Gtid*Set，是备库收到的所有日志的 GTID 集合；Executed*Gtid_Set，是备库所有已经执行完成的 GTID 集合。\n\n## MySQL开放问题\n\n### 有一个超级大表，如何优化分页查询？\n\n超级大表的分页优化分有以下两种方式：\n\n*   数据库层面优化：利用子查询优化超多分页场景，比如：`SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id` ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，\n\t**利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现**；\n\n*   程序层面优化：可以利用**缓存**把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。\n\n### ⭐查询长时间不返回可能是什么原因？应该如何处理？\n\n查询速度慢的原因很多，常见如下几种：\n\n 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： \n\n*   以 % 开头的 like 查询\n\n*   数据类型出现隐式转换时不会使用索引\n\n*   不符合最左前缀原则；\n\n*   如果查询条件有 or 分割，如果有 or 的字段没有索引，会引起全表查询；\n\n*   如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。\n\n2）I/O 压力大，读取磁盘速度变慢，df 看硬盘\n\n3）内存不足，free 看内存（top 看 cpu）\n\n4）网络速度慢 \n\n5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 \n\n6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 `show processlist;` 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。\n\n![avatar](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-1a918d44eacc26e6.png) \n\n其中，当 State 列值为 Locked 时，表示被锁定。\n\n以上问题的解决方案如下：\n\n1）正确创建和使用索引。 \n\n2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 \n\n3）升级内存，更换更大的内存。 \n\n4）提升网速，升级带宽。 \n\n5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 \n\n6）查询时值返回需要的字段。 \n\n7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。\n\n### MySQL 主从延迟的原因有哪些？\n\n主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： `show slave status;`，其中 Seconds*Behind*Master 如果为 0 表示主从复制状态正常。 导致主从延迟的原因有以下几个：\n\n*   主库有大事务处理；\n\n*   主库做大量的增、删、改操作；\n\n*   主库对大表进行字段新增、修改或添加索引等操作；\n\n*   主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；\n\n*   从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；\n\n*   主库读写压力大，导致复制延迟；\n\n*   从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。\n\n### 如何保证数据不被误删？\n\n保证数据不被误删的方法如下列表：\n\n*   权限控制与分配（数据库和服务器权限）\n\n*   避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；\n\n*   重要的数据库操作，通过平台型工具自动实施，减少人工操作；\n\n*   部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；\n\n*   确认备份制度及时有效；\n\n*   启用 SQL 审计功能，养成良好 SQL 习惯；\n\n*   启用 sql*safe*updates 选项，不允许没 where 条件的更新/删除；\n\n*   将系统层的 rm 改为 mv；\n\n*   线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；\n\n*   启用堡垒机，屏蔽高危 SQL；\n\n*   降低数据库中普通账号的权限级别；\n\n*   开启 binlog，方便追溯数据。\n\n### ⭐MySQL 服务器 CPU 飙升应该如何处理？\n\n使用 `show full processlist;` 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，然后再去项目中找到执行慢的 SQL 语句进行修改和优化。\n\n### MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？\n\n可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：\n\n*   定期断开空闲的长连接；\n\n*   如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql*reset*connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。\n\n### 如何实现一个高并发的系统？\n\n这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。\n\n#### 1）前端优化\n\n① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。 \n② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。 \n③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。\n\n#### 2）中间层负载分发\n\n可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：\n\n① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 ② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：\n\n```\nupstream backend { \n    server 192.168.0.14 weight=10; \n    server 192.168.0.15 weight=10; \n}\n```\n\n③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：\n\n```\nupstream backend { \n    ip_hash; \n    server 192.168.0.14:88; \n    server 192.168.0.15:80; \n}\n```\n\n④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：\n\n```\nupstream backend { \n    fair; \n    server server1.com; \n    server server2.com; \n}\n```\n\n⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。\n\n```\nupstream backend {\n    hash $request_uri;\n    server server1.com; \n    server server2.com;   \n}\n```\n\n#### 3）控制层（网关层）\n\n限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。\n\n#### 4）服务层\n\n① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。 \n② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。 \n③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。\n\n#### 5）数据库层\n\n① 合理使用数据库引擎 ② 合理设置事务隔离级别，合理使用事务 ③ 正确使用 SQL 语句和查询索引 ④ 合理分库分表 ⑤ 使用数据库中间件实现数据库读写分离 ⑥ 设置数据库主从读写分离\n\n\n\n## 补充\n\n### 查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？\n\n查询中用到的关键词主要包含六个，并且他们的顺序依次为 `select--from--where--group by--having--order by`\n\n其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序 与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行\n\n- from:需要从哪个数据表检索数据\n- where:过滤表中数据的条件\n- group by:如何将上面过滤出的数据分组\n- having:对上面已经分组的数据进行过滤的条件\n- select:查看结果集中的哪个列，或列的计算结果\n- order by :按照什么样的顺序来查看返回的数据\n\nfrom 后面的表关联，是自右向左解析 而 where 条件的解析顺序是自下而上的。\n\n也就是说，在写 SQL 文的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在 where 语句的最左边 （用小表去匹配大表）\n\n### 非关系型数据库和关系型数据库区别，优势比较？\n\n#### 非关系型数据库的优势\n\n**1. 性能**\n\nNOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。\n\n**2. 可扩展性**\n\n同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。\n\n#### 关系型数据库的优势\n\n**1. 复杂查询**\n\n可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n\n**2. 事务支持**\n\n使得对于安全性能很高的数据访问要求得以实现。\n\n#### 总结\n\n**对于这两类数据库，对方的优势就是自己的弱势，反之亦然**。\n\nNOSQL 数据库慢慢开始具备 SQL 数据库的一些复杂查询功能，比如 MongoDB。\n\n对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如 Redis set nx。\n\n### 数据库三范式，根据某个场景设计数据表？\n\n- 所有字段值都是不可分解的原子值。\n- 在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。\n- 数据表中的每一列数据都和主键直接相关，而不能间接相关。\n\n#### 第一范式(确保每列保持原子性)\n\n**第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式**。\n\n第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。\n\n上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。\n\n#### 第二范式(确保表中的每列都和主键相关)\n\n第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中**。\n\n**比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键**。\n\n#### 第三范式(确保每列都和主键列直接相关,而不是间接相关)\n\n第三范式需要确保数据表中的**每一列数据都和主键直接相关，而不能间接相关**。\n\n比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。\n\n### MySQL 高并发环境解决方案？\n\nMySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。\n\n**需求分析**：互联网单位 每天大量数据读取，写入，并发性高。\n\n- **现有解决方式**：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。\n- **集群方案**：解决 DB 宕机带来的单点 DB 不能访问问题。\n- **读写分离策略**：极大限度提高了应用中 Read 数据的速度和并发量。无法解决高写入压力。\n\n\n\n### 数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）？\n\n#### Undo Log\n\n**Undo Log 是为了实现事务的原子性**，在 MySQL 数据库 InnoDB 存储引擎中，还用了 Undo Log 来实现多版本并发控制(简称：MVCC)。\n\n- **事务的原子性**(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。\n- **原理**Undo Log 的原理很简单，**为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 UndoLog）**。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，**系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态**。\n\n**之所以能同时保证原子性和持久化，是因为以下特点**：\n\n- 更新数据前记录 Undo log。\n- 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。\n- **Undo log 必须先于数据持久化到磁盘**。如果在 G,H 之间系统崩溃，**undo log 是完整的， 可以用来回滚事务**。\n- 如果在 A-F 之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。\n\n**缺陷**：**每个事务提交前将数据和 Undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低**。\n\n如果能够将数据缓存一段时间，就能减少 IO 提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。\n\n#### Redo Log\n\n- **原理和 Undo Log 相反**，**Redo Log 记录的是新数据的备份**。**在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态**。\n\n### Explain 性能分析\n\n**是什么**\n\n查看执行计划：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。分析查询语句或是表结构的性能瓶颈。\n\n**能干嘛**\n\n- 表的读取顺序\n- 数据读取操作的操作类型\n- 哪些索引可以使用\n- 哪些索引被实际使用\n- 表之间的引用\n- 每张表有多少行被优化器查询\n\n**怎么玩**\n\nExplain + SQL 语句。\nExplain 执行后返回的信息：\n <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131912576.png\" alt=\"image-20220422131912576\" style=\"zoom:50%;\" />\n\n**各字段解释**\n\n1. id：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。\n\n\t- id 相同，执行顺序由上至下\n\t- id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\n\t- id 有相同也有不同：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行\n\n\t> id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。\n\n2. select_type：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询，取值范围如下：\n\n\t- simple：简单的 select 查询，查询中不包含子查询或者 UNION\n\t- primary：查询中若包含任何复杂的子部分，最外层查询则被标记为 primary\n\t- derived：在 FROM 列表中包含的子查询被标记为 DERIVED (衍生)，MySQL 会递归执行这些子查询, 把结果放在临时表里。\n\t- subquery：在 SELECT 或 WHERE 列表中包含了子查询\n\t- depedent subquery：在 SELECT 或 WHERE 列表中包含了子查询，子查询基于外层\n\t- uncacheable subquery：无法使用缓存的子查询\n\t- union：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED\n\t- union result：从 UNION 表获取结果的 SELECT\n\n3. table：这个数据是基于哪张表的。\n\n4. type：是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n\t> 只需要记住：system > const > eq_ref > ref > range > index > ALL 就行了，其他的不常见。\n\n\t- system：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计。\n\t- const：表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。\n\t- eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。\n\t- ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。\n\t- range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在 where 语句中出现了 between、<、>、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。\n\t- index：出现 index 是 sql 使用了索引但是没用索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。\n\t- all：将遍历全表以找到匹配的行。\n\n\t> 其他 type 如下：\n\n\t- index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 关键字的 sql 中。\n\t- ref_or_null：对于某个字段既需要过滤条件，也需要 null 值的情况下。查询优化器会选择用 ref_or_null 连接查询。\n\t- index_subquery：利用索引来关联子查询，不再全表扫描。\n\t- unique_subquery：该联接类型类似于 index_subquery。子查询中的唯一索引。\n\n5. possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。\n\n6. key：实际使用的索引。如果为 NULL，则没有使用索引。\n\n7. key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度。如何计算 key_len？\n\n\t- 先看索引上字段的类型 + 长度，比如：int=4; varchar(20)=20; char(20)=20\n\t- 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3，GBK 要乘 2\n\t- varchar 这种动态字符串要加 2 个字节\n\t- 允许为空的字段要加 1 个字节\n\n8. ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。\n\n9. rows：显示 MySQL 认为它执行查询时必须检查的行数。越少越好！\n\n10. Extra：其他的额外重要的信息。\n\n\t- Using filesort：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。**排序字段若通过索引去访问将大大提高排序速度**。\n\t- Using temporary：使用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。\n\t- Using index：表示相应的 select 操作中使用了覆盖索引 (Covering Index)，避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。\n\t- Using where：表明使用了 where 过滤。\n\t- Using join buffer：使用了连接缓存。\n\t- impossible where：where 子句的值总是 false，不能用来获取任何数据。\n\t- select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。\n\t- distinct：优化 distinct 操作，在找到第一匹配的元祖后即停止找同样值的动作。\n","source":"_posts/Java八股文-MySQL.md","raw":"---\ntitle: Java八股文 - MySQL\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-25 13:43:41\ntags:\ntoc: true\nurlname: mysql\n---\n\n> 整理的 MySQL 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## MySQL基础篇\n\n### 说一说三个范式\n\n**第一范式(确保每列保持原子性)**\n\n第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。\n\n**第二范式(确保表中的每列都和主键相关)**（前提是第一范式）\n\n在一个数据库表中，一个表中只能保存**一种**数据，不可以把多种数据保存在同一张数据库表中。\n\n**第三范式(确保表中每列都和主键直接相关,而不是间接相关)**（前提是第一第二范式）\n\n已经分好了多张表的话，一张表中只能有另一张表的 ID，而不能有其他任何信息（其他任何信息，一律用主键在另一张表中查询）。\n\n### 说一下 MySQL 执行一条查询语句的内部执行过程？\n\n> 连接器 → 查询缓存 → 分析器 → 优化器 → 执行器\n\n*   客户端先通过**连接器**连接到 MySQL 服务器。\n\n*   连接器权限验证通过之后，先查询是否有**查询缓存**，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。\n\n*   **分析器**会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。\n\n*   **优化器**对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。\n\n*   优化器执行完就进入**执行器**，开始执行查询语句直到查询出满足条件的所有数据，然后进行返回。\n\n### MySQL 查询缓存的功能有何优缺点？\n\n优点是效率高，如果已经有缓存则会直接返回结果。 \n\n但是，如果数据库表中数据和结构发生变化时（增删改、表结构调整），查询缓存将会失效并被清除，导致缓存命中率比较低。\n\n### MySQL 的常用引擎都有哪些？\n\nMySQL 的常用引擎有 InnoDB、MyISAM、Memory（所有数据放在内存中） 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。\n\n### MySQL 可以针对表级别设置数据库引擎吗？怎么设置？\n\n可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine=引擎名（比如 Memory）来设置此表的存储引擎。\n\n###  InnoDB v.s. MyISAM\n\n* 最大的区别是 InnoDB 支持**事务**，而 MyISAM 不支持事务；\n\n* InnoDB 支持**崩溃后安全恢复**，MyISAM 不支持崩溃后安全恢复；\n* InnoDB 支持**行锁**，MyISAM 不支持行锁，只支持表锁；\n* InnoDB 支持**外键**，MyISAM 不支持外键；\n\n### InnoDB 有哪些特性？\n\n**1）插入缓冲(insert buffer)**：插入缓冲带来的是**性能**。对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引叶子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。（**对于非聚集索引页，不是直接放到索引页中，而是先放到缓冲池中，这时候缓冲池中可能存放了多个非聚集索引页，然后将这多个非聚集索引页的插入合并到一个操作中，取代了之前的一个一个插入**）\n\n**2）两次写(double write)**：两次写带来的是**可靠性**，主要用来解决部分写失败。doublewrite 由两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。**（要进行写操作时，不是直接写硬盘，而是写拷贝到内存中的两次写缓冲区大小2M，然后把两次写缓冲区的内容分两次写（每次写1M）到共享表空间的磁盘上，然后再将共享表空间的内容同步到数据文件上）**\n\n![两次写](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-ad3fb88b0ef6d41d.png) \n\n**3）自适应哈希索引(adaptive hash index)**：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。**（为了提高性能会自动建立一些 hash 索引，查找效率很高，直接通过 hash 值定位到数据）**\n\n### 一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？\n\n> 等价于：自增主键能不能被持久化的问题？\n>\n> MyISAM：自增主键会持久化到数据文件中\n>\n> InnoDB：\n> \t5.7 以及之前：不会持久化\n> \t从 8 开始：自增主键会持久化到 redo log\n\n1. 如果表的引擎类型是 **MyISAM**，那么这条记录的 ID 就是 4。因为 **MyISAM表会把自增主键的最大ID记录到数据文件里面**，重启 MySQL 后，自增主键的最大 ID 也不会丢失。\n\n2. 如果表的引擎类型是 **InnoDB**，那么这条记录的 ID 就是 2。因为 **InnoDB表把自增主键的最大ID记录到内存中**，所以重启数据库后会使最大 ID（其实是 AUTO_INCREMENT 计数器的值）丢失；一旦数据库重新运行，数据库会自动计算自增主键的最大 ID（**其实就是把最后一条记录 ID 加 1 并赋值给 AUTO_INCREMENT**）再次放入到内存中。\n\n\t【注】**这仅仅是 MySQL 8 以前的版本，也就是 MySQL 5.7 以及之前的版本**。因为在 MySQL 8.0 中，**InnoDB 的行为已更改**。每次更改时，当前最大自动增量计数器值（AUTO_INCREMENT）都会写入重做日志 redo log，并保存到每个检查点的引擎专用系统表中。这些更改使当前的最大自动增量计数器值在服务器重新启动后保持不变，与 **MyISAM** 一样了。详见官方文档：[InnoDB AUTO_INCREMENT 计数器初始化](https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-initialization)\n\n\t【注】如果删除的不是最后的记录，那么自增的最大 ID 全部都一样，因为自动增量计数器值（AUTO_INCREMENT）不会改变。\n\n### MySQL 中什么情况会导致自增主键不能连续？\n\n> 1. 唯一键冲突\n> 2. 事务回滚\n\n*   执行器执行插入，自增键+1，但是 innoDB 发现插入时**唯一键冲突**，无法插入，导致的不连续。\n\n*   事务添加自增键+1，但是由于**事务回滚**，数据被清除，导致的不连续。\n\n### 什么是覆盖索引？\n\n覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据即回表。\n\n### 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\n\n如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。\n\n### 内存表和临时表有什么区别？\n\n内存表，指的是使用 Memory 引擎的表，数据放在内存中，重启会被清空；\n\n临时表，指的是使用 InnoDB 引擎或者 MyISAM 引擎的表，数据放在磁盘上，重启不会清空。\n\n### MySQL 中的字符串类型都有哪些？\n\n| **类型**     | **取值范围**              |\n| ------------ | ------------------------- |\n| CHAR(N)      | 0~255                     |\n| VARCHAR(N)   | 0~65536                   |\n| TINYBLOB     | 0~255                     |\n| BLOB         | 0~65535                   |\n| MEDUIMBLOB   | 0~167772150               |\n| LONGBLOB     | 0~4294967295              |\n| TINYTEXT     | 0~255                     |\n| TEXT         | 0~65535                   |\n| MEDIUMTEXT   | 0~167772150               |\n| LONGTEXT     | 0~4294967295              |\n| VARBINARY(N) | 0~N个字节的变长字节字符集 |\n| BINARY(N)    | 0~N个字节的定长字节字符集 |\n\n### VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？\n\nVARCHAR 的长度是可变的，而 CHAR 是固定长度。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。\n\n### MySQL 存储金额应该使用哪种数据类型？为什么？\n\nMySQL 存储金额应该使用 `decimal` ，因为如果存储其他数据类型，比如 `float` 有导致小数点后数据丢失的风险。\n\n### limit 3,2 的含义是什么？\n\n去除前三条数据之后查询两条信息。\n\n### *lastinsertid()* 函数功能是什么？有什么特点？\n\n*lastinsertid()* 用于查询最后一次自增表的编号（全局的），它的特点是查询时不需要指定表名，使用 `select last_insert_id()` 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10， *lastinsertid()* 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 *lastinsertid()* 查询的值就是 3。\n\n### 删除表的数据有几种方式？它们有什么区别？\n\n删除数据有两种方式：delete 和 truncate，它们的区别如下：\n\n*   delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；\n\n*   delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，\n\t因此 detele 的信息可以被找回而 truncate 的信息无法被找回；\n\n*   truncate 因为不记录日志所以执行效率比 delete 快。\n\n### MySQL 中支持几种模糊查询？它们有什么区别？\n\nMySQL 中支持两种模糊查询：regexp 和 like\nlike 是对任意多字符匹配或任意单字符进行模糊匹配，\n而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。 \nregexp 和 like 的使用示例如下： \n\n> select * from person where uname like '%SQL%';\n> select * from person where uname regexp '.SQL*.'; \n\n### *count(column)* 和 *count(\\*)* 有什么区别？\n\n*count(column)* 统计不会统计列值为 null 的数据，\n而 *count(\\*)* 则会统计所有信息，所以最终的统计结果可能会不同。\n\n### 为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？\n\n因为 **InnoDB 支持事务**，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。\n\n### InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？\n\nMyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。\n\n### 在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？\n\ncount(字段)<count(主键 id)<count(1)≈count(*) 题目解析：\n\n*   对于 count(字段) 来说，遍历整张表，取这个字段，然后判断是否为 null，不为 null 则加 1\n*   对于 count(主键 id) 来说，遍历整张表，取主键 id，不可能为空，每次加 1。但是可能使用最小的索引树。\n*   对于 count(1) 来说，遍历整张表，不取值。1 是不可能为空的，每次加 1。\n*   对于 count(\\*) 来说，遍历整张表，不取值，直接按行累加。实际上，当使用 count(\\*) 时，MySQL 会将 * 参数转化为参数 0 来处理。\n\n所以最后得出的结果是：count(字段)<count(主键 id)<count(1)≈count(*)。\n\n### MySQL 中内连接、左连接、右连接有什么区别？\n\n*   内连（inner join）— 把匹配的关联数据显示出来；\n\n*   左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；\n\n*   右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；\n\n## MySQL索引篇\n\n### 什么是索引？  \n\n索引是一种能帮助 MySQL 提高查询效率的数据结构。\n\n### 索引分别有哪些优点和缺点？  \n\n**索引的优点：**\n\n*   提高查询效率\n\n\n**索引的缺点：**\n\n*   虽然提高了查询速度，但却降低了更新表的速度，比如 update、insert；\n\t因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；\n\n*   建立索引的索引文件会占用磁盘。\n\n### MySQL索引的注意事项\n\n**1、联合索引遵循前缀原则**\n\n**2、like模糊查询，%不能在前**\n\n**3、**列值为空（NULL）时是可以使用索引的，但 MySQL 难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在 MySQL 内部进行特殊处理。\n\n**4、** 如果 MySQL 估计使用索引比全表扫描更慢，会放弃使用索引，例如：\n表中只有 100 条数据左右。对于 SQL 语句 WHERE id > 1 AND id < 100，MySQL 会优先考虑全表扫描。\n\n**5、** **如果关键词or前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。**\n\n**6、** 列类型是字符串，查询时一定要给值加引号，否则索引失效，例如：\n列 name varchar(16)，存储了字符串\"100\"\nWHERE name = 100;  （做了自动类型转换）\n以上 SQL 语句能搜到，但无法用到索引。\n\n**7、不在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描** \n\n### 为什么 MySQL 官方建议使用自增主键作为表的主键？ \n\n优点：\n\n1. 页分裂问题。如果使用非自增主键作为表的主键的话，当新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上，以确保索引有序。也就是说造成了页分裂，大量移动数据的过程严重影响插入效率。\n\n2. 存储空间问题。自增主键存储空间小，同一个结点内能存放更多的主键，树的高度可能降低，减少 io 次数。\n\n缺点：\n\n1. 数据量过大，可能会超出自增长取值范围；\n2. 无法满足分布式存储，分库分表的情况下无法合并表；\n3. 主键有自增规律，容易被破解；\n\n**综上所述：**是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。\n\n### 索引有几种类型？分别如何创建？  \n\n**MySQL 的索引有两种分类方式：逻辑分类和物理分类。 **\n\n**按照逻辑分类，索引可分为：**\n\n*   主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；\n*   唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；\n*   普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；\n\n**按照物理分类，索引可分为：**\n\n*   聚簇索引：InnoDB 的主键索引存储采用聚簇索引，主键值和数据存放在一起\n*   非聚簇索引：MyISAM 的主键索引存储采用非聚簇索引，主键值和指向数据的指针存放在一起，数据另开空间存储\n\n**各种索引的创建脚本如下：**\n\n```sql\n-- 创建主键索引\nALTER TABLE user ADD PRIMARY KEY (column_list);\n-- 创建唯一索引\nALTER TABLE user ADD UNIQUE index_name (column_list);\n-- 创建普通索引\nALTER TABLE user ADD INDEX index_name (column_list);\n-- 创建全文索引\nALTER TABLE user ADD FULLTEXT index_name (column_list);\n```\n\n### 什么叫回表查询？  \n\n普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。\n\n也就是说，基于非主键索引的查询需要多扫描一次主键索引树。因此，我们在应用中应该尽量使用主键查询。\n\n例外就是使用非主键索引时，如果当前索引满足查询需求，则不用回表。\n\n### 在 InnDB 中主键索引为什么比普通索引的查询性能高？  \n\n回表。因为普通索引的查询会多执行一次检索操作。比如主键查询 select * from t where id=10 只需要搜索 id 的这棵 B+ 树，而普通索引查询 select * from t where f=3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。\n\n### MySQL 复合索引应该注意什么？  \n\nMySQL 中的复合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。\n\n### 复合索引的作用是什么？  \n\n*   用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了`key(a)、key(a,b)、key(a,b,c)`等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；\n*   覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：`select a,b,c from table where a=1 and b = 1` ，就可以直接通过遍历索引取得数据，而**无需回表查询**，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；\n*   索引列越多，通过索引筛选出的数据越少。  \n\n### 什么是最左匹配原则？它的生效原则有哪些？  \n\n最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（>、<、between、like）就会停止匹配。\n\n### 以下语句会走索引么？\n\n```\nselect * from t where year(date)>2018;\n```\n\n不会，因为在索引列上涉及到了运算。\n\n### 能否给手机号的前 6 位创建索引？如何创建？  \n\n可以，创建方式有两种：\n\n```\nalter table t add index index_phone(phone(6));\ncreate index index_phone on t(phone(6));\n```\n\n### 什么是前缀索引？  \n\n前缀索引也叫局部索引，比如给身份证的前 10 位添加索引。\n类似这种给某列部分信息添加索引的方式叫做前缀索引。\n\n### 为什么要用前缀索引？  \n\n前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。\n\n### 什么情况下适合使用前缀索引？  \n\n当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性（不重复的索引值和表记录数的比值，越大说明索引价值越大）为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。\n\n### InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？  \n\n因为 B 树、Hash、红黑树或二叉树存在以下问题：\n\n*   B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低；\n*   Hash：虽然可以快速定位，但是没有顺序，无法进行范围查找，IO 复杂度高；\n*   二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；\n*   红黑树：树的高度随着数据量增加而增加，IO 代价高。  \n\n### MySQL 如何指定查询的索引？  \n\n在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：\n\n```sql\nselect * from t force index(index_t);\n```\n\n### 在 MySQL 中指定了查询索引，为什么没有生效？  \n\n我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。\n\n### 如何优化身份证的索引？ \n\n在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：\n\n*   **使用身份证倒序存储**，这样设置前六位的意义就很大了；\n*   **使用 hash 值**，新创建一个字段用于存储身份证的 hash 值。\n\n### 索引的使用场景\n\n- 对于非常小的表，大部分情况下全表扫描效率更高。\n- 中到大型表，索引非常有效。\n- 特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。\n\n\n\n### 聚簇索引和非聚簇索引\n\nInnobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。\n\nInnodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引\n\n#### 聚簇索引(聚集索引)\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145143172-1760681728.png)\n\n\n\n　　Innodb 聚簇索引和 MyIsam 非聚簇索引的比较说明\n　　参考博客：https://www.cnblogs.com/zlcxbb/p/5757245.html\n\n#### InnoDB索引实现\n\n　　InnoDB**使用B+Tree作为索引结构**，但具体实现方式却与 MyISAM 截然不同.\n\n1）主键索引：\n\n**MyISAM索引文件和数据文件是分离的**，**索引文件仅保存数据记录的地址**。而在**InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构**，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。\n\n ![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1464190-20191106145200302-932404581.png)\n\n(图 inndb 主键索引）是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则**MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形**。\n\n2）InnoDB 的辅助索引\n\n   InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引：\n\n ![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145241480-1330791289.png)\n\nInnoDB 使用的是聚簇索引，将主键组织到一棵 B+树中，而行数据就储存在叶子节点上，若使用\"where id = 14\"这样的条件查找主键，则按照 B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B+树中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B+树中再执行一次 B+树检索操作，最终到达叶子节点即可获取整行数据。\n\n#### MyISAM索引实现\n\nMyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址\n\n1）主键索引：\n\nMyISAM 引擎使用 B+Tree 作为索引结构，叶节点的**data域存放的是数据记录的地址**。下图是 MyISAM 主键索引的原理图：\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151308457-531875534.png)\n\n \n\n这里设表一共有三列，假设我们以 Col1 为主键，图 myisam1 是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。\n\n2）辅助索引（Secondary key）\n\n在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，**只是主索引要求key是唯一的，而辅助索引的key可以重复**。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示。\n\n同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。\n\n ![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151427711-625351515.png)\n\n　　**MyISM使用的是非聚簇索引**，非聚簇索引的两棵 B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引 B+树的节点存储了主键，辅助键索引 B+树存储了辅助键。表数据存储在独立的地方，这两颗 B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。\n\n为了更形象说明这两种索引的区别，我们假想一个表如下图存储了 4 行数据。其中 Id 作为主索引，Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151527647-152458631.png)\n\n \n\n🌟**InnoDB聚簇索引：**\n\n主键索引树，根结点存的是主键 id 和对应的数据；\n\n辅助索引树，根结点存的是辅助索引和对应的主键索引，因此需要根据主键到主键索引树上在遍历一次得到对应的数据。\n\n🌟**MyISAM非聚簇索引：**\n\n主键索引树，根结点存的是主键到数据地址的映射；\n\n辅助索引树，根结点存的是辅助索引到数据地址的映射，也可以直接得到数据，不需要回表。\n\n#### 问题：主键索引是聚集索引还是非聚集索引？\n\n在 InnoDB 下主键索引是聚集索引，在 MyISAM 下主键索引是非聚集索引\n\n#### MyISAM索引实现？\n\nMyISAM 存储引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。MyISAM 的索引方式也叫做非聚簇索引的，之所以这么称呼是为了与 InnoDB 的聚簇索引区分。\n\n#### MyISAM索引与InnoDB索引的区别？\n\n- InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。\n- InnoDB 的主键索引的叶子节点存储着索引和行数据，因此主键索引非常高效。\n- MyISAM 索引的叶子节点存储的是行数据地址，需要根据数据地址访问对应的地址才能得到数据。\n- **InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。**\n\n### 简单说一说drop、delete与truncate的区别\n\nSQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别\n\n> 1、delete和truncate只删除表的数据不删除表的结构\n> 2、速度,一般来说: drop> truncate >delete\n> 3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;\n> 4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.\n\n### delete、truncate和drop分别在什么场景之下使用？\n\n1. 想删除部分数据行时候，用 delete，并且带上 where 子句\n2. 保留表而删除所有数据的时候用 truncate\n3. 不再需要一张表的时候，用 drop\n\n### ⭐为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？\n\n1. B+Tree 的磁盘读写代价更低\n\n> B+Tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B-Tree 更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。\n\n2. B+Tree 的查询效率更加稳定\n\n> 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n\n### ⭐Hash索引和B+树所有有什么区别或者说优劣呢?\n\n首先要知道 Hash 索引和 B+树索引的底层实现原理：\n\n**hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.**\nB+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.\n\n那么可以看出他们有以下的不同：\n\n- hash 索引进行等值查询更快(一般情况下),但是却无法进行范围查询.\n\n- hash 索引不支持使用索引进行排序,原理同上.\n- hash 索引不支持模糊查询.\n- hash 索引任何时候都避免不了回表查询数据,而 B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.\n- hash 索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生 hash 碰撞,此时效率可能极差.而 B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.\n\n因此,在大多数情况下,直接选择 B+树索引可以获得稳定且较好的查询速度.而不需要使用 hash 索引.\n\n### 非聚簇索引一定会回表查询吗?\n\n有如下一张 InnoDB 表：\n\n```sql\nCREATE TABLE `user` (\n`id` INT NOT NULL ,\n`name` VARCHAR NOT NULL ,\n`age` INT NOT NULL);\n```\n\n其中 id 为自增主键，name 是一个普通索引。在执行 select * from user where id = 1 时，会在主键索引对应的 B+树的叶子结点上搜索到关键字 id=1 的节点，并读取位于该节点上的整行数据。但是在执行 select * from user where name = 'tom'时，会分为两个步骤：\n\n先到 name 索引对应的 B+树的叶子结点上搜索到关键字 name='tom’的节点，并从该节点上获取对应的主键 id 值。\n\n然后再根据 id 值使用主键索引读取到整行数据。\n\n其中第二个步骤叫作回表查询。需要扫描辅助索引和主键索引两棵 B+树才能拿到整行数据，效率较低。\n\n如果执行 select id, name from user where name = 'tom',则只需要扫描 name 索引树就可以获取到所有的字段，因为 id 和 name 都保存在 name 索引 B+树的叶子节点上，所以不需要再去主键索引上查找。这就是所谓的索引覆盖。只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。\n\n而 select id, name, age from user where name = 'tom'，因为 age 字段没有存储到 name 索引的叶子节点上，所以需要根据主键索引回表查询到 age 列值。如果把 name 索引改成(name，age)的联合索引就可以实现索引覆盖，无需回表了。（覆盖索引，sql 语句中用到的字段都有索引）\n————————————————\n版权声明：本文为 CSDN 博主「lmyno」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_33603681/article/details/113387941\n\n### 联合索引是什么?为什么需要注意联合索引中的顺序?\n\n因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.\n\n### 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?\n\nMySQL 提供了 explain 命令来查看语句的执行计划\n\n\n\n## MySQL事务篇（重点）\n\n### 可见性判断\n\n> 总结：\n>\n> 大于等于下一个分配的事务ID不可见\n>\n> 包含在未提交事务集合中但是和创建read view的事务ID不相等则也不可见。\n\n事务版本号小于当前最小的事务 ID，那么说明它已经提交了，可见。\n\n事务版本号**大于等于下一个分配的事务ID**，说明这个事务在当前 read view 生成后在生成，**不可见**。\n\n事务版本号在 [最小事务 ID，下一个分配的事务 ID) 区间内：\n\n​\t如果未提交事务集合包含该事务版本号，那么判断是否该事务版本号是否等于创建该 read view 的事务 ID，\n\n​\t\t等于则说明这个版本的数据是当前事务生成的，可见。**不等于则不可见**。\n\n​\t如果不包含，说明这个事务版本号已经提交，可见。\n\n### 查询一条记录，基于MVCC，是怎样的流程\n\n1. 获取数据版本号即**数据行中的事务id隐藏字段**\n2. **执行sql，得到Read View**\n3. 根据数据版本号和 read view 进行**可见性判断**，判断当前版本数据是否可见\n4. 如果不符合 Read View 的可见性规则， 即就需要**Undo log**中历史快照重新和 read view 可见性判断\n5. 最后返回符合规则的数据\n\nInnoDB 实现 MVCC，是通过` Read View+ Undo Log` 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。\n\n### RC下可以读到已提交数据，但不能读到未提交数据\n\n![1](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1.png)\n\n### RR下已提交和未提交数据都不能读到\n\n![2](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes2.png)\n\n### 为什么RR下解决了不可重复读问题？\n\n实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟**Read view工作方式有关**。\n\n- 在读已提交（RC）隔离级别下，同一个事务里面，**每一次查询都会产生一个新的Read View**，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。\n\n| begin                               |                   |\n| ----------------------------------- | ----------------- |\n| select * from core_user where id =1 | 生成一个Read View |\n| /                                   | /                 |\n| /                                   | /                 |\n| select * from core_user where id =1 | 生成一个Read View |\n\n- 在可重复读（RR）隔离级别下，**一个事务里只会获取一次read view**，都是副本共用的，从而保证每次查询的数据都是一样的。\n\n| begin                               |                       |\n| ----------------------------------- | --------------------- |\n| select * from core_user where id =1 | 生成一个Read View     |\n| /                                   |                       |\n| /                                   |                       |\n| select * from core_user where id =1 | 共用一个Read View副本 |\n\n### MVCC是否解决了幻读问题呢？\n\n对于幻读来说，存在快照读（可以读到多个版本，普通的 select）和当前读（读的是最新的 for update）的情况：\n\n1. RR 隔离级别下为了解决幻读问题：**快照读依靠MVCC控制，当前读通过间隙锁解决**；\n2. 间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；\n3. **间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度**。\n\n\n\n### 并发事务有什么什么问题？应该如何解决？\n\n并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：\n\n*   加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。\n\n*   提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。\n\n### MySQL 事务实现原理是什么？\n\n以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。\n事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。\n\n\n\n## MVCC详细版\n\n### 1. 相关数据库知识点回顾\n\n#### 1.1 什么是数据库事务，为什么要有事务\n\n事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。\n\n**为什么要有事务呢？** 就是为了保证数据的最终一致性。\n\n#### 1.2 事务包括哪几个特性？\n\n事务四个典型特性，即 ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。\n\n- 原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作**要么全部都执行，要么都不执行**。\n- 一致性： 指在**事务开始之前和事务结束以后**，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。\n- 隔离性： 多个事务并发访问时，**事务之间是相互隔离**的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。\n- 持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将**持久地保存在数据库**之中。\n\n#### 1.3 事务并发存在的问题\n\n事务并发会引起**脏读、不可重复读、幻读**问题。\n\n##### 1.3.1 脏读\n\n> 如果一个事务读取到了另一个未提交事务修改过的数据，我们就称发生了脏读现象。\n\n##### 1.3.2 不可重复读\n\n> 同一个事务内，前后多次读取，读取到的数据内容不一致\n\n##### 1.3.3 幻读\n\n> 如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如insert、delete、update），两次读取到的结果集却不一样了，就意味着发生了**幻读**。\n\n#### 1.4 四大隔离级别\n\n为了解决并发事务存在的**脏读、不可重复读、幻读**等问题，数据库大叔设计了四种隔离级别。分别是**读未提交，读已提交，可重复读，串行化（Serializable）**。\n\n##### 1.4.1 读未提交\n\n读未提交隔离级别，只限制了两个数据**不能同时修改**，但是修改数据的时候，即使事务**未提交**，都是可以被别的事务读取到的，这级别的事务隔离有**脏读、重复读、幻读**的问题；\n\n##### 1.4.2 读已提交\n\n读已提交隔离级别，当前事务只能读取到其他事务**提交**的数据，所以这种事务的隔离级别**解决了脏读**问题，但还是会存在**重复读、幻读**问题；\n\n##### 1.4 3 可重复读\n\n可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以**解决了重复读**的问题，但是读取范围数据的时候，是可以插入数据，所以还会存在**幻读**问题；\n\n##### 1.4.4 串行化\n\n事务最高的隔离级别，在该级别下，所有事务都是进行**串行化顺序**执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。\n\n##### 1.4.5 四大隔离级别，都会存在哪些并发问题呢\n\n| 隔离级别 | 脏读 | 不可重复读 | 幻读 |\n| -------- | ---- | ---------- | ---- |\n| 读未提交 | √    | √          | √    |\n| 读已提交 | ×    | √          | √    |\n| 可重复读 | ×    | ×          | √    |\n| 串行化   | ×    | ×          | ×    |\n\n#### 1.5 数据库是如何保证事务的隔离性的呢？\n\n数据库是通过**加锁**，来实现事务的隔离性的。这就好像，如果你想一个人静静，不被别人打扰，你就可以在房门上加上一把锁。\n\n加锁确实好使，可以保证隔离性。比如**串行化隔离级别就是加锁实现的**。但是频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大**降低了数据库性能**。\n\n**那么，如何解决加锁后的性能问题的？**\n\n答案就是,**MVCC多版本并发控制**！它实现读取数据不用加锁，可以让读取数据同时修改。修改数据时同时可读取。\n\n### 2. 什么是 MVCC？\n\nMVCC，即**Multi-Version  Concurrency Control （多版本并发控制）**。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。\n\n> 通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。\n\n数据库隔离级别**读已提交、可重复读** 都是基于 MVCC 实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。\n\n### 3. MVCC实现的关键知识点\n\n#### 3.1 事务版本号\n\n> 事务每次开启前，都会从数据库获得一个**自增长**的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。\n\n#### 3.2 隐式字段\n\n对于 InnoDB 存储引擎，每一行记录都有两个隐藏列**trx_id**、**roll_pointer**，如果表中没有主键和非 NULL 唯一键时，则还会有第三个隐藏的主键列**row_id**。\n\n| 列名         | 是否必须 | 描述                                                     |\n| ------------ | -------- | -------------------------------------------------------- |\n| row_id       | 否       | 单调递增的行ID，不是必需的，占用6个字节。                |\n| trx_id       | 是       | 记录操作该数据事务的**事务ID**                           |\n| roll_pointer | 是       | 这个隐藏列就相当于一个**回滚指针**，指向回滚段的undo日志 |\n\n#### 3.3 undo log\n\nundo log，**回滚日志**，用于**记录数据被修改前**的信息。在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。\n\n可以这样认为，当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，当 update 一条记录时，它记录一条对应相反的 update 记录。\n\nundo log 有什么**用途**呢？\n\n1. 事务回滚时，保证原子性和一致性。\n2. 用于 MVCC**快照读**。\n\n#### 3.4 版本链\n\n多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为**版本链**。如下：\n\n![image-20220422131424393](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131424393.png)\n\n其实，通过版本链，我们就可以看出**事务版本号、表格隐藏的列和undo log**它们之间的关系。我们再来小分析一下。\n\n1. 假设现在有一张 core_user 表，表里面有一条数据,id 为 1，名字为孙权：\n\n\t<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131445316.png\" alt=\"image-20220422131445316\" style=\"zoom: 50%;\" />\n\n2. 现在开启一个事务 A： 对 core_user 表执行`update core_user set name =\"曹操\" where id=1`,会进行如下流程操作\n\n- 首先获得一个事务 ID=100\n- 把 core_user 表修改前的数据,拷贝到 undo log\n- 修改 core_user 表中，id=1 的数据，名字改为曹操\n- 把修改后的数据事务 Id=101 改成当前事务版本号，并把**roll_pointer**指向 undo log 数据地址。\n\n\t<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131527508.png\" alt=\"image-20220422131527508\" style=\"zoom: 50%;\" />\n\n#### 3.5 快照读和当前读\n\n**快照读：** 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的 select 语句都是快照读,如：\n\n```\nselect * from core_user where id > 2;\n```\n\n**当前读**：读取的是记录数据的最新版本，显式加锁的都是当前读\n\n```\nselect * from core_user where id > 2 for update;\n```\n\n#### 3.6 Read View\n\n- **Read View是什么呢？** 它就是事务执行 SQL 语句时，产生的读视图。实际上在 innodb 中，每个 SQL 语句执行前都会得到一个 Read View。\n- **Read View有什么用呢？** 它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据\n\nRead View 是如何保证可见性判断的呢？我们先看看 Read view 的几个重要属性\n\n- m_ids:当前系统中那些活跃(**未提交**)的读写事务 ID, 它数据结构为一个 List，[min_limit_id, max_limit_id)\n- min_limit_id:表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，即 m_ids 中的最小值。\n- max_limit_id:表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值，即即 m_ids 中的最大值+1\n- creator_trx_id: 创建当前 read view 的事务 ID\n\n**Read view 匹配条件规则**如下：\n\n1. 如果新的数据事务 ID `trx_id < min_limit_id`，表明生成该版本的事务在生成 Read View 前，已经提交(因为事务 ID 是递增的)，所以该版本可以被当前事务访问。\n2. 如果`trx_id>= max_limit_id`，表明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。\n3. 如果 `min_limit_id =<trx_id< max_limit_id`,需要分 3 种情况讨论\n\n> （1）如果`m_ids`包含`trx_id`,则代表Read View生成时刻，这个事务还未提交，但是如果数据的`trx_id`等于`creator_trx_id`的话，表明数据是自己生成的，因此是**可见**的。\n>\n> （2）如果`m_ids`包含`trx_id`，并且`trx_id`不等于`creator_trx_id`，则Read  View生成时，事务未提交，并且不是自己生产的，所以当前事务也是**看不见**的；\n>\n> （3）如果`m_ids`不包含`trx_id`，则说明你这个事务在Read View生成之前就**已经提交**了，修改的结果，当前事务是能看见的。\n\n### 4. MVCC实现原理分析\n\n<img src=\"/Users/yaxing/blog/source/_posts/E:/Markdown%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/8%20MySQL.assets/v2-a086ef515e7d0a023ca3cfcc5759c7f6_720w.jpg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n#### 4.1 查询一条记录，基于MVCC，是怎样的流程\n\n1. 获取事务 ID\n2. 执行 sql，得到 Read View\n3. 查询得到的数据，然后与 Read View 中的事务 ID 进行比较，帮助判断当前版本的数据是否可见。\n4. 如果不符合 Read View 的可见性规则， 即就需要 Undo log 中历史快照;\n5. 最后返回符合规则的数据\n\nInnoDB 实现 MVCC，是通过` Read View+ Undo Log` 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。\n\n#### 4.2 读已提交（RC）隔离级别，存在不可重复读问题的分析历程\n\n1. 创建 core_user 表，插入一条初始化数据,如下：\n\n\t<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131554547.png\" alt=\"image-20220422131554547\" style=\"zoom: 33%;\" />\n\n2. 隔离级别设置为读已提交（RC），事务 A 和事务 B 同时对 core_user 表进行查询和修改操作。\n\n```\n事务A: select * fom core_user where id=1\n事务B: update core_user set name =”曹操”\n// 事务A两次读到的数据不一样，事务A会读到其他事务提交的数据，不能读到其他事务未提交的数据。\n```\n\n执行流程如下：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131620047.png\" alt=\"image-20220422131620047\" style=\"zoom: 33%;\" />\n\n最后事务 A 查询到的结果是，**name=曹操**的记录，我们**基于MVCC**，来分析一下执行流程：\n\n(1) A 开启事务，首先得到一个事务 ID 为 100\n\n(2) B 开启事务，得到事务 ID 为 101\n\n(3) 事务 A 生成一个 Read View，read view 对应的值如下\n\n| 变量                                                    | 值       |\n| ------------------------------------------------------- | -------- |\n| m_ids（未提交的事务ID）                                 | 100，101 |\n| max_limit_id（下一个应该分配的事务ID）                  | 102      |\n| min_limit_id（当前read view中活跃的未提交事务的最小值） | 100      |\n| creator_trx_id（创建该read view的事务ID）               | 100      |\n\n然后回到版本链：开始从版本链中挑选可见的记录：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131642264.png\" alt=\"image-20220422131642264\" style=\"zoom: 33%;\" />\n\n由图可以看出，最新版本的列 name 的内容是`孙权`，该版本的`trx_id`值为 100。开始执行 read view 可见性规则校验：\n\n```\nmin_limit_id(100)=<trx_id（100）<102;\ncreator_trx_id = trx_id =100;\n```\n\n由此可得，trx_id=100 的这个记录，当前事务是可见的。所以查到是 name 为`孙权`的记录。\n\n(4) 事务 B 进行修改操作，把名字改为曹操。把原数据拷贝到 undo log,然后对数据进行修改，标记事务 ID 和上一个数据版本在 undo log 的地址。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131733370.png\" alt=\"image-20220422131733370\" style=\"zoom:33%;\" />\n\n(5) 提交事务\n\n(6) 事务 A 再次执行查询操作，**新生成一个Read View**，Read View 对应的值如下\n\n| 变量                                    | 值   |\n| --------------------------------------- | ---- |\n| m_ids（未提交的事务ID）                 | 100  |\n| max_limit_id（下一个应当分配的事务ID）  | 102  |\n| min_limit_id（最小的事务ID）            | 100  |\n| creator_trx_id（创建read view的事务ID） | 100  |\n\n然后再次回到版本链：从版本链中挑选可见的记录：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131753554.png\" alt=\"image-20220422131753554\" style=\"zoom:33%;\" />\n\n从图可得，最新版本的列 name 的内容是`曹操`，该版本的`trx_id`值为 101。开始执行 Read View 可见性规则校验：\n\n```\nmin_limit_id(100)=<trx_id（101）<max_limit_id（102);\n但是,trx_id=101，不属于m_ids集合，说明101这个事务已经提交了，当前事务可见\n```\n\n因此，`trx_id=101`这个记录，对于当前事务是可见的。所以 SQL 查询到的是 name 为`曹操`的记录。\n\n综上所述，在**读已提交（RC）隔离级别**下，同一个事务里，两个相同的查询，读取同一条记录（id=1），却返回了不同的数据（**第一次查出来是孙权，第二次查出来是曹操那条记录**），因此 RC 隔离级别，存在**不可重复读**并发问题。\n\n#### 4.3 可重复读（RR）隔离级别，解决不可重复读问题的分析\n\n在 RR 隔离级别下，是如何解决不可重复读问题的呢？我们一起再来看下，\n\n还是 4.2 小节那个流程，还是这个事务 A 和事务 B，如下：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131811671.png\" alt=\"image-20220422131811671\" style=\"zoom:33%;\" />\n\n##### 4.3.1 不同隔离级别下，Read view的工作方式不同\n\n实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟**Read view工作方式有关**。\n\n- 在读已提交（RC）隔离级别下，同一个事务里面，**每一次查询都会产生一个新的Read View副本**，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。\n\n| begin                               |                   |\n| ----------------------------------- | ----------------- |\n| select * from core_user where id =1 | 生成一个Read View |\n| /                                   | /                 |\n| /                                   | /                 |\n| select * from core_user where id =1 | 生成一个Read View |\n\n- 在可重复读（RR）隔离级别下，**一个事务里只会获取一次read view**，都是副本共用的，从而保证每次查询的数据都是一样的。\n\n| begin                               |                       |\n| ----------------------------------- | --------------------- |\n| select * from core_user where id =1 | 生成一个Read View     |\n| /                                   |                       |\n| /                                   |                       |\n| select * from core_user where id =1 | 共用一个Read View副本 |\n\n##### 4.3.2 实例分析\n\n我们穿越下，回到**刚4.2的例子**，然后执行第 2 个查询的时候：\n\n事务 A 再次执行查询操作，复用老的 Read View 副本，Read View 对应的值如下\n\n| 变量           | 值       |\n| -------------- | -------- |\n| m_ids          | 100，101 |\n| max_limit_id   | 102      |\n| min_limit_id   | 100      |\n| creator_trx_id | 100      |\n\n然后再次回到版本链：从版本链中挑选可见的记录：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131828812.png\" alt=\"image-20220422131828812\" style=\"zoom:33%;\" />\n\n从图可得，最新版本的列 name 的内容是`曹操`，该版本的`trx_id`值为 101。开始执行 read view 可见性规则校验：\n\n```\nmin_limit_id(100)=<trx_id（101）<max_limit_id（102);\n因为m_ids{100,101}包含trx_id（101），\n并且creator_trx_id (100) 不等于trx_id（101）\n```\n\n所以，`trx_id=101`这个记录，对于当前事务是**不可见**的。这时候呢，版本链`roll_pointer`跳到下一个版本，`trx_id=100`这个记录，再次校验是否可见：\n\n```\nmin_limit_id(100)=<trx_id（100）< max_limit_id（102);\n因为m_ids{100,101}包含trx_id（100），\n并且creator_trx_id (100) 等于trx_id（100）\n```\n\n所以，`trx_id=100`这个记录，对于当前事务是**可见**的。即在可重复读（RR）隔离级别下，复用老的 Read View 副本，解决了**不可重复读**的问题。\n\n#### 4.4 MVCC是否解决了幻读问题呢？\n\n对于幻读来说，存在当前读和快照读的情况：\n\n1. RR 隔离级别下为了解决幻读问题：**快照读依靠MVCC控制，当前读通过间隙锁解决**；\n2. 间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；\n3. 间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度。\n\n作者：捡田螺的小男孩\n\n链接：https://juejin.cn/post/7016165148020703246\n\n来源：稀土掘金\n\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n## MySQL锁篇\n\n### 什么是锁？MySQL 中提供了几类锁？\n\n锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。\n\n排他锁（写锁），共享锁（读锁）\n乐观锁，悲观锁\n全局锁，表锁，行锁，页锁\n\n### 什么是死锁？\n\n死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。\n\n### 如何处理死锁？\n\n对待死锁常见的两种策略：\n\n*   设置超时时间\n\n*   发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。\n\n### 如何避免死锁？\n\n使用 SELECT … FOR UPDATE 语句来获取必要的锁。\n\n### 什么是全局锁？它的应用场景有哪些？\n\n全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。\n\n### 什么是共享锁？\n\n共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。\n\n### 什么是排它锁？\n\n排他锁 exclusive lock（也叫 writer lock）又称写锁。\n\n若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。\n\n排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。\n\n### 使用全局锁会导致什么问题？\n\n如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。\n\n如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。\n\n如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQL dump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。\n\n### 悲观锁和乐观锁有什么区别？\n\n顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。\n\n说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。\n\n**乐观锁是用数据版本（Version）记录机制实现**，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。\n\n### 乐观锁有什么优点和缺点？\n\n因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。\n\n### ⭐InnoDB 存储引擎有几种锁算法？\n\n*   Record Lock — 单个行记录上的锁；\n\n*   Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；\n\n*   Next-Key Lock（包含行锁和间隙锁） — 锁定一个范围，包括记录本身。\n\n### InnoDB 如何实现行锁？\n\n共享锁：**in share mode**\n\n排他锁：**for update**\n\n### 优化锁方面你有什么建议？\n\n*   尽量使用较低的隔离级别。\n*   精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。\n*   选择合理的事务大小，小事务发生锁冲突的几率也更小。\n*   给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。\n*   不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。\n*   尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。\n*   不要申请超过实际需要的锁级别。\n*   除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。\n*   对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。\n\n### MySQL 中有哪几种锁？\n\n**1、表级锁：** 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。\n\n**2、行级锁：**  开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。\n\n**3、页锁：**  开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。\n\n\n\n### 锁机制与InnoDB锁算法\n\n**MyISAM和InnoDB存储引擎使用的锁：**\n\n- MyISAM 采用表级锁(table-level locking)。\n- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁\n\n**表级锁和行级锁对比：**\n\n- **表级锁：** MySQL 中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。\n\n- **行级锁：** MySQL 中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。\n\n### 锁的优化策略\n\n**1、** 读写分离\n\n**2、** 分段加锁\n\n**3、** 减少锁持有的时间\n\n多个线程尽量以相同的顺序去获取资源\n\n不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大锁。\n\n## MySQL日志篇\n\n### MySQL 有哪些重要的日志文件？  \n\nMySQL 中的重要日志分为以下几个：\n\n**① 错误日志：**用来记录 MySQL 服务器运行过程中的错误信息\n\n**② 查询日志**：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:\n\n*   insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；\n\n*   update 时也会查询因为更新的时候很可能会更新某一块数据；\n\n*   delete 查询，只删除符合条件的数据；\n\n因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。\n\n查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。\n\n**③ 慢日志**：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：\n\n```\nset global slowquerylog='ON';\n```\n\n使用 set global slow*query*log='ON' 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf，设置 slow*query*log=1 并重启 MySQL 服务器。\n\n**④ redo log（重做日志）**：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。\n\n**⑤ undo log（回滚日志）**：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。\n\n**⑥ bin log（二进制日志）**：是一个二进制文件，主要**记录了对 MySQL 数据库执行更改的所有操作**，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，不记录 SELECT、SHOW 等那些不修改数据或数据库结构的 SQL 语句。\n\nbinlog 的作用如下：\n\n*   恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；\n\n*   复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；\n\n*   审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。\n\n除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。\n\nbinlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。\n\n通过以下命令来查询 binlog 是否开启：\n\n```\nshow variables like 'log_%'; \n```\n\nbinlog 格式分为: STATEMENT、ROW 和 MIXED 三种：\n\n*   STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；\n\n*   ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；\n\n*   MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT*USER()、ROW*COUNT() 等无法确定的函数。\n\n### redo log 和 binlog 有什么区别？\n\nredo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：\n\n*   redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。\n\n*   binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\n\n*   redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\n\n*   redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。\n\n### 什么是 crash-safe？\n\ncrash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。\n\n### 什么是脏页和干净页？\n\nMySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。\n\n### 什么情况下会引发 MySQL 刷脏页（flush）的操作？\n\n*   内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；\n\n*   系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；\n\n*   系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；\n\n*   MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。\n\n### MySQL 刷脏页的速度很慢可能是什么原因？\n\n在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。\n\n### 如何控制 MySQL 只刷新当前脏页？\n\n在 InnoDB 中设置 innodb*flush*neighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。\n\n### MySQL 的 WAL 技术是解决什么问题的？\n\nA.防止误删除，找回数据用的 B.容灾恢复，为了还原异常数据用的 C.事务处理，为了数据库的稳定性 D.为了降低 IO 成本 答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。\n\n### 为什么有时候会感觉 MySQL 偶尔卡一下？\n\n如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。\n\n### redo log 和 binlog 是怎么关联的?\n\n它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：\n\n*   如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；\n\n*   如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。\n\n### MySQL 怎么知道 binlog 是完整的?\n\n*   statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。\n\n*   row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。\n\n### MySQL 中可不可以只要 binlog，不要 redo log？\n\n不可以，binlog 没有崩溃恢复的能力。\n\n### MySQL 中可不可以只要 redo log，不要 binlog？\n\n不可以，原因有以下两个：\n\n*   redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；\n\n*   binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。\n\n### 为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？\n\n因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。\n\n### 事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？\n\n不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。\n\n### 在 MySQL 中用什么机制来优化随机读/写磁盘对 IO 的消耗？\n\nredo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。\n\n### 以下说法错误的是？\n\nA.redo log 是 InnoDB 引擎特有的，它的固定大小的 B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关 C.redo log 可以保证数据库异常重启之后，数据不丢失 D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。\n\n### 以下说法正确的是？\n\nA.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志 B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志 C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 D.以上说法都正确 答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。\n\n### 有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？\n\n可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。\n\n\n\n## MySQL性能优化\n\n### MySQL 性能指标都有哪些？如何得到这些指标？\n\nMySQL 的性能指标如下：\n\n**① TPS（Transaction Per Second）** 每秒事务数，即数据库每秒执行的事务数。\n\nMySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。\n\n需要使用的参数：\n\n*   Com_commit ：表示提交次数，通过命令 `show global status like 'Com_commit';` 获取；\n\n*   Com_rollback：表示回滚次数，通过命令 `show global status like 'Com_rollback';` 获取。\n\n我们定义第一次获取的 Com*commit 的值与 Com*rollback 值的和为 c_r1，时间为 t1；\n\n第二次获取的 Com*commit 的值与 Com*rollback 值的和为 c*r2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS = ( c*r2 - c_r1 ) / ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。\n\n**② QPS（Query Per Second）** 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS = Queries / Seconds Queries 是系统状态值—总查询次数，可以通过 `show status like 'queries';` 查询得出 \n\nSeconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：\n\n> QPS = (Q2 - Q1) / 10\n\n**③ IOPS（Input/Output Operations per Second）** 每秒处理的 I/O 请求次数。\n\nIOPS 是判断磁盘 I/O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I/O 就不会是瓶颈了。\n\n注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。\n\n可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：\n\n> yum install sysstat iostat -dx 1 10\n\n执行效果如下图所示： \n\nIOPS = r/s + w/s 其中：\n\n*   r/s：代表每秒读了多少次；\n\n*   w/s：代表每秒写了多少次。\n\n### 什么是慢查询？\n\n慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 *longquerytime* 值的 SQL，则会被记录到慢查询日志中。 *longquerytime* 的默认值为 10，意思是运行 10s 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。\n\n使用 `mysql> show variables like '%slow_query_log%';` 来查询慢查询日志是否开启\n\n### 如何开启慢查询日志？\n\n开启慢查询日志，可以使用如下 MySQL 命令：\n\n> mysql> set global slow*query*log=1\n\n不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：\n\n> slow*query*log =1 slow*query*log*file=/tmp/mysql*slow.log\n\n### 如何定位慢查询？\n\n使用 MySQL 中的 explain 分析执行语句，比如：\n\n> explain select * from t where id=5;\n\n如下图所示：\n\n![avatar](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-2ff861def7876a91.png) \n\n其中：\n\n*   id — 选择标识符。id 越大优先级越高，越先被执行。\n\n*   select_type — 表示查询的类型。\n\n*   table — 输出结果集的表\n\n*   partitions — 匹配的分区\n\n*   type — 表示表的连接类型\n\n*   possible_keys — 表示查询时，可能使用的索引\n\n*   key — 表示实际使用的索引\n\n*   key_len — 索引字段的长度\n\n*   ref— 列与索引的比较\n\n*   rows — 大概估算的行数\n\n*   filtered — 按表条件过滤的行百分比\n\n*   Extra — 执行情况的描述和说明\n\n其中最重要的就是 type 字段，type 值类型如下：\n\n*   all — 扫描全表数据\n\n*   index — 遍历索引\n\n*   range — 索引范围查找\n\n*   index_subquery — 在子查询中使用 ref\n\n*   uniquesubquery — 在子查询中使用 eq*ref\n\n*   ref*or*null — 对 null 进行索引的优化的 ref\n\n*   fulltext — 使用全文索引\n\n*   ref — 使用非唯一索引查找数据\n\n*   eq_ref — 在 join 查询中使用主键或唯一索引关联\n\n*   const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点\n\n### ⭐MySQL 的优化手段都有哪些？\n\nMySQL 的常见的优化手段有以下五种：\n\n#### ① 查询优化\n\n*   避免 SELECT *，只查询需要的字段。\n\n*   小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。\n\n*   一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。\n\n#### ② 优化索引的使用\n\n*   尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。\n\n*   不做列运算，把计算都放入各个业务系统实现\n\n*   查询语句尽可能简单，大语句拆小语句，减少锁时间\n\n*   不使用 select * 查询\n\n*   or 查询改写成 in 查询\n\n*   不用函数和触发器\n\n*   避免 %xx 查询\n\n*   少用 join 查询\n\n*   使用同类型比较，比如 '123' 和 '123'、123 和 123\n\n*   尽量避免在 where 子句中使用 != 或者 <> 操作符，查询引用会放弃索引而进行全表扫描\n\n*   避免在索引列上使用 is null 和 is not null\n\n*   尽量使用主键查询\n\n*   避免在 where 子句中对字段进行表达式操作\n\n*   尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型\n\n#### ③ 表结构设计优化\n\n*   使用可以存下数据最小的数据类型。\n\n*   使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。\n\n*   尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。\n\n*   尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。\n\n*   尽量少用 text 类型，非用不可时最好考虑分表。\n\n*   尽量使用 timestamp，而非 datetime。\n\n*   单表不要有太多字段，建议在 20 个字段以内。\n\n#### ④ 表拆分\n\n当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 \n\n**a）垂直拆分**：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：\n\n*   把不常用的字段单独放在一张表；\n\n*   把 text，blob 等大字段拆分出来放在附表中；\n\n*   经常组合查询的列放在一张表中。\n\n**b）水平拆分**：指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。\n\n通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。\n\n#### ⑤ 读写分离\n\n一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。\n\n### MySQL 常见读写分离方案有哪些？\n\nMySQL 常见的读写分离方案，如下列表：\n\n**1）应用层解决方案** 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。\n\n**2）中间件解决方案** 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。\n\n### 怎样保证确保备库无延迟？\n\n通常保证主备无延迟有以下三种方法：\n\n*   每次从库执行查询请求前，先判断 seconds*behind*master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds*behind*master 参数是用来衡量主备延迟时间的长短；\n\n*   对比位点确保主备无延迟。Master*Log*File 和 Read*Master*Log*Pos，表示的是读到的主库的最新位点，Relay*Master*Log*File 和 Exec*Master*Log_Pos，表示的是备库执行的最新位点；\n\n*   对比 GTID 集合确保主备无延迟。Auto*Position=1 ，表示这对主备关系使用了 GTID 协议；Retrieved*Gtid*Set，是备库收到的所有日志的 GTID 集合；Executed*Gtid_Set，是备库所有已经执行完成的 GTID 集合。\n\n## MySQL开放问题\n\n### 有一个超级大表，如何优化分页查询？\n\n超级大表的分页优化分有以下两种方式：\n\n*   数据库层面优化：利用子查询优化超多分页场景，比如：`SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id` ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，\n\t**利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现**；\n\n*   程序层面优化：可以利用**缓存**把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。\n\n### ⭐查询长时间不返回可能是什么原因？应该如何处理？\n\n查询速度慢的原因很多，常见如下几种：\n\n 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： \n\n*   以 % 开头的 like 查询\n\n*   数据类型出现隐式转换时不会使用索引\n\n*   不符合最左前缀原则；\n\n*   如果查询条件有 or 分割，如果有 or 的字段没有索引，会引起全表查询；\n\n*   如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。\n\n2）I/O 压力大，读取磁盘速度变慢，df 看硬盘\n\n3）内存不足，free 看内存（top 看 cpu）\n\n4）网络速度慢 \n\n5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 \n\n6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 `show processlist;` 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。\n\n![avatar](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-1a918d44eacc26e6.png) \n\n其中，当 State 列值为 Locked 时，表示被锁定。\n\n以上问题的解决方案如下：\n\n1）正确创建和使用索引。 \n\n2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 \n\n3）升级内存，更换更大的内存。 \n\n4）提升网速，升级带宽。 \n\n5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 \n\n6）查询时值返回需要的字段。 \n\n7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。\n\n### MySQL 主从延迟的原因有哪些？\n\n主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： `show slave status;`，其中 Seconds*Behind*Master 如果为 0 表示主从复制状态正常。 导致主从延迟的原因有以下几个：\n\n*   主库有大事务处理；\n\n*   主库做大量的增、删、改操作；\n\n*   主库对大表进行字段新增、修改或添加索引等操作；\n\n*   主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；\n\n*   从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；\n\n*   主库读写压力大，导致复制延迟；\n\n*   从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。\n\n### 如何保证数据不被误删？\n\n保证数据不被误删的方法如下列表：\n\n*   权限控制与分配（数据库和服务器权限）\n\n*   避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；\n\n*   重要的数据库操作，通过平台型工具自动实施，减少人工操作；\n\n*   部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；\n\n*   确认备份制度及时有效；\n\n*   启用 SQL 审计功能，养成良好 SQL 习惯；\n\n*   启用 sql*safe*updates 选项，不允许没 where 条件的更新/删除；\n\n*   将系统层的 rm 改为 mv；\n\n*   线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；\n\n*   启用堡垒机，屏蔽高危 SQL；\n\n*   降低数据库中普通账号的权限级别；\n\n*   开启 binlog，方便追溯数据。\n\n### ⭐MySQL 服务器 CPU 飙升应该如何处理？\n\n使用 `show full processlist;` 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，然后再去项目中找到执行慢的 SQL 语句进行修改和优化。\n\n### MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？\n\n可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：\n\n*   定期断开空闲的长连接；\n\n*   如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql*reset*connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。\n\n### 如何实现一个高并发的系统？\n\n这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。\n\n#### 1）前端优化\n\n① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。 \n② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。 \n③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。\n\n#### 2）中间层负载分发\n\n可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：\n\n① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 ② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：\n\n```\nupstream backend { \n    server 192.168.0.14 weight=10; \n    server 192.168.0.15 weight=10; \n}\n```\n\n③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：\n\n```\nupstream backend { \n    ip_hash; \n    server 192.168.0.14:88; \n    server 192.168.0.15:80; \n}\n```\n\n④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：\n\n```\nupstream backend { \n    fair; \n    server server1.com; \n    server server2.com; \n}\n```\n\n⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。\n\n```\nupstream backend {\n    hash $request_uri;\n    server server1.com; \n    server server2.com;   \n}\n```\n\n#### 3）控制层（网关层）\n\n限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。\n\n#### 4）服务层\n\n① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。 \n② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。 \n③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。\n\n#### 5）数据库层\n\n① 合理使用数据库引擎 ② 合理设置事务隔离级别，合理使用事务 ③ 正确使用 SQL 语句和查询索引 ④ 合理分库分表 ⑤ 使用数据库中间件实现数据库读写分离 ⑥ 设置数据库主从读写分离\n\n\n\n## 补充\n\n### 查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？\n\n查询中用到的关键词主要包含六个，并且他们的顺序依次为 `select--from--where--group by--having--order by`\n\n其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序 与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行\n\n- from:需要从哪个数据表检索数据\n- where:过滤表中数据的条件\n- group by:如何将上面过滤出的数据分组\n- having:对上面已经分组的数据进行过滤的条件\n- select:查看结果集中的哪个列，或列的计算结果\n- order by :按照什么样的顺序来查看返回的数据\n\nfrom 后面的表关联，是自右向左解析 而 where 条件的解析顺序是自下而上的。\n\n也就是说，在写 SQL 文的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在 where 语句的最左边 （用小表去匹配大表）\n\n### 非关系型数据库和关系型数据库区别，优势比较？\n\n#### 非关系型数据库的优势\n\n**1. 性能**\n\nNOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。\n\n**2. 可扩展性**\n\n同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。\n\n#### 关系型数据库的优势\n\n**1. 复杂查询**\n\n可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n\n**2. 事务支持**\n\n使得对于安全性能很高的数据访问要求得以实现。\n\n#### 总结\n\n**对于这两类数据库，对方的优势就是自己的弱势，反之亦然**。\n\nNOSQL 数据库慢慢开始具备 SQL 数据库的一些复杂查询功能，比如 MongoDB。\n\n对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如 Redis set nx。\n\n### 数据库三范式，根据某个场景设计数据表？\n\n- 所有字段值都是不可分解的原子值。\n- 在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。\n- 数据表中的每一列数据都和主键直接相关，而不能间接相关。\n\n#### 第一范式(确保每列保持原子性)\n\n**第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式**。\n\n第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。\n\n上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。\n\n#### 第二范式(确保表中的每列都和主键相关)\n\n第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中**。\n\n**比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键**。\n\n#### 第三范式(确保每列都和主键列直接相关,而不是间接相关)\n\n第三范式需要确保数据表中的**每一列数据都和主键直接相关，而不能间接相关**。\n\n比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。\n\n### MySQL 高并发环境解决方案？\n\nMySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。\n\n**需求分析**：互联网单位 每天大量数据读取，写入，并发性高。\n\n- **现有解决方式**：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。\n- **集群方案**：解决 DB 宕机带来的单点 DB 不能访问问题。\n- **读写分离策略**：极大限度提高了应用中 Read 数据的速度和并发量。无法解决高写入压力。\n\n\n\n### 数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）？\n\n#### Undo Log\n\n**Undo Log 是为了实现事务的原子性**，在 MySQL 数据库 InnoDB 存储引擎中，还用了 Undo Log 来实现多版本并发控制(简称：MVCC)。\n\n- **事务的原子性**(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。\n- **原理**Undo Log 的原理很简单，**为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 UndoLog）**。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，**系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态**。\n\n**之所以能同时保证原子性和持久化，是因为以下特点**：\n\n- 更新数据前记录 Undo log。\n- 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。\n- **Undo log 必须先于数据持久化到磁盘**。如果在 G,H 之间系统崩溃，**undo log 是完整的， 可以用来回滚事务**。\n- 如果在 A-F 之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。\n\n**缺陷**：**每个事务提交前将数据和 Undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低**。\n\n如果能够将数据缓存一段时间，就能减少 IO 提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。\n\n#### Redo Log\n\n- **原理和 Undo Log 相反**，**Redo Log 记录的是新数据的备份**。**在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态**。\n\n### Explain 性能分析\n\n**是什么**\n\n查看执行计划：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。分析查询语句或是表结构的性能瓶颈。\n\n**能干嘛**\n\n- 表的读取顺序\n- 数据读取操作的操作类型\n- 哪些索引可以使用\n- 哪些索引被实际使用\n- 表之间的引用\n- 每张表有多少行被优化器查询\n\n**怎么玩**\n\nExplain + SQL 语句。\nExplain 执行后返回的信息：\n <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131912576.png\" alt=\"image-20220422131912576\" style=\"zoom:50%;\" />\n\n**各字段解释**\n\n1. id：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。\n\n\t- id 相同，执行顺序由上至下\n\t- id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行\n\t- id 有相同也有不同：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行\n\n\t> id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。\n\n2. select_type：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询，取值范围如下：\n\n\t- simple：简单的 select 查询，查询中不包含子查询或者 UNION\n\t- primary：查询中若包含任何复杂的子部分，最外层查询则被标记为 primary\n\t- derived：在 FROM 列表中包含的子查询被标记为 DERIVED (衍生)，MySQL 会递归执行这些子查询, 把结果放在临时表里。\n\t- subquery：在 SELECT 或 WHERE 列表中包含了子查询\n\t- depedent subquery：在 SELECT 或 WHERE 列表中包含了子查询，子查询基于外层\n\t- uncacheable subquery：无法使用缓存的子查询\n\t- union：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED\n\t- union result：从 UNION 表获取结果的 SELECT\n\n3. table：这个数据是基于哪张表的。\n\n4. type：是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。\n\n\t> 只需要记住：system > const > eq_ref > ref > range > index > ALL 就行了，其他的不常见。\n\n\t- system：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计。\n\t- const：表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。\n\t- eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。\n\t- ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。\n\t- range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在 where 语句中出现了 between、<、>、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。\n\t- index：出现 index 是 sql 使用了索引但是没用索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。\n\t- all：将遍历全表以找到匹配的行。\n\n\t> 其他 type 如下：\n\n\t- index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 关键字的 sql 中。\n\t- ref_or_null：对于某个字段既需要过滤条件，也需要 null 值的情况下。查询优化器会选择用 ref_or_null 连接查询。\n\t- index_subquery：利用索引来关联子查询，不再全表扫描。\n\t- unique_subquery：该联接类型类似于 index_subquery。子查询中的唯一索引。\n\n5. possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。\n\n6. key：实际使用的索引。如果为 NULL，则没有使用索引。\n\n7. key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度。如何计算 key_len？\n\n\t- 先看索引上字段的类型 + 长度，比如：int=4; varchar(20)=20; char(20)=20\n\t- 如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3，GBK 要乘 2\n\t- varchar 这种动态字符串要加 2 个字节\n\t- 允许为空的字段要加 1 个字节\n\n8. ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。\n\n9. rows：显示 MySQL 认为它执行查询时必须检查的行数。越少越好！\n\n10. Extra：其他的额外重要的信息。\n\n\t- Using filesort：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。**排序字段若通过索引去访问将大大提高排序速度**。\n\t- Using temporary：使用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。\n\t- Using index：表示相应的 select 操作中使用了覆盖索引 (Covering Index)，避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。\n\t- Using where：表明使用了 where 过滤。\n\t- Using join buffer：使用了连接缓存。\n\t- impossible where：where 子句的值总是 false，不能用来获取任何数据。\n\t- select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN/MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。\n\t- distinct：优化 distinct 操作，在找到第一匹配的元祖后即停止找同样值的动作。\n","slug":"Java八股文-MySQL","published":1,"updated":"2023-01-26T12:35:58.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw322000it9t83h3z0w23","content":"<blockquote>\n<p>整理的 MySQL 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"MySQL基础篇\"><a href=\"#MySQL基础篇\" class=\"headerlink\" title=\"MySQL基础篇\"></a>MySQL基础篇</h2><h3 id=\"说一说三个范式\"><a href=\"#说一说三个范式\" class=\"headerlink\" title=\"说一说三个范式\"></a>说一说三个范式</h3><p><strong>第一范式(确保每列保持原子性)</strong></p>\n<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>\n<p>**第二范式(确保表中的每列都和主键相关)**（前提是第一范式）</p>\n<p>在一个数据库表中，一个表中只能保存<strong>一种</strong>数据，不可以把多种数据保存在同一张数据库表中。</p>\n<p>**第三范式(确保表中每列都和主键直接相关,而不是间接相关)**（前提是第一第二范式）</p>\n<p>已经分好了多张表的话，一张表中只能有另一张表的 ID，而不能有其他任何信息（其他任何信息，一律用主键在另一张表中查询）。</p>\n<h3 id=\"说一下-MySQL-执行一条查询语句的内部执行过程？\"><a href=\"#说一下-MySQL-执行一条查询语句的内部执行过程？\" class=\"headerlink\" title=\"说一下 MySQL 执行一条查询语句的内部执行过程？\"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h3><blockquote>\n<p>连接器 → 查询缓存 → 分析器 → 优化器 → 执行器</p>\n</blockquote>\n<ul>\n<li><p>客户端先通过<strong>连接器</strong>连接到 MySQL 服务器。</p>\n</li>\n<li><p>连接器权限验证通过之后，先查询是否有<strong>查询缓存</strong>，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</p>\n</li>\n<li><p><strong>分析器</strong>会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</p>\n</li>\n<li><p><strong>优化器</strong>对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</p>\n</li>\n<li><p>优化器执行完就进入<strong>执行器</strong>，开始执行查询语句直到查询出满足条件的所有数据，然后进行返回。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-查询缓存的功能有何优缺点？\"><a href=\"#MySQL-查询缓存的功能有何优缺点？\" class=\"headerlink\" title=\"MySQL 查询缓存的功能有何优缺点？\"></a>MySQL 查询缓存的功能有何优缺点？</h3><p>优点是效率高，如果已经有缓存则会直接返回结果。 </p>\n<p>但是，如果数据库表中数据和结构发生变化时（增删改、表结构调整），查询缓存将会失效并被清除，导致缓存命中率比较低。</p>\n<h3 id=\"MySQL-的常用引擎都有哪些？\"><a href=\"#MySQL-的常用引擎都有哪些？\" class=\"headerlink\" title=\"MySQL 的常用引擎都有哪些？\"></a>MySQL 的常用引擎都有哪些？</h3><p>MySQL 的常用引擎有 InnoDB、MyISAM、Memory（所有数据放在内存中） 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p>\n<h3 id=\"MySQL-可以针对表级别设置数据库引擎吗？怎么设置？\"><a href=\"#MySQL-可以针对表级别设置数据库引擎吗？怎么设置？\" class=\"headerlink\" title=\"MySQL 可以针对表级别设置数据库引擎吗？怎么设置？\"></a>MySQL 可以针对表级别设置数据库引擎吗？怎么设置？</h3><p>可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine&#x3D;引擎名（比如 Memory）来设置此表的存储引擎。</p>\n<h3 id=\"InnoDB-v-s-MyISAM\"><a href=\"#InnoDB-v-s-MyISAM\" class=\"headerlink\" title=\"InnoDB v.s. MyISAM\"></a>InnoDB v.s. MyISAM</h3><ul>\n<li><p>最大的区别是 InnoDB 支持<strong>事务</strong>，而 MyISAM 不支持事务；</p>\n</li>\n<li><p>InnoDB 支持<strong>崩溃后安全恢复</strong>，MyISAM 不支持崩溃后安全恢复；</p>\n</li>\n<li><p>InnoDB 支持<strong>行锁</strong>，MyISAM 不支持行锁，只支持表锁；</p>\n</li>\n<li><p>InnoDB 支持<strong>外键</strong>，MyISAM 不支持外键；</p>\n</li>\n</ul>\n<h3 id=\"InnoDB-有哪些特性？\"><a href=\"#InnoDB-有哪些特性？\" class=\"headerlink\" title=\"InnoDB 有哪些特性？\"></a>InnoDB 有哪些特性？</h3><p><strong>1）插入缓冲(insert buffer)<strong>：插入缓冲带来的是</strong>性能</strong>。对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引叶子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。（<strong>对于非聚集索引页，不是直接放到索引页中，而是先放到缓冲池中，这时候缓冲池中可能存放了多个非聚集索引页，然后将这多个非聚集索引页的插入合并到一个操作中，取代了之前的一个一个插入</strong>）</p>\n<p><strong>2）两次写(double write)<strong>：两次写带来的是</strong>可靠性</strong>，主要用来解决部分写失败。doublewrite 由两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。<strong>（要进行写操作时，不是直接写硬盘，而是写拷贝到内存中的两次写缓冲区大小2M，然后把两次写缓冲区的内容分两次写（每次写1M）到共享表空间的磁盘上，然后再将共享表空间的内容同步到数据文件上）</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-ad3fb88b0ef6d41d.png\" alt=\"两次写\"> </p>\n<p><strong>3）自适应哈希索引(adaptive hash index)<strong>：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。</strong>（为了提高性能会自动建立一些 hash 索引，查找效率很高，直接通过 hash 值定位到数据）</strong></p>\n<h3 id=\"一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？\"><a href=\"#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？\" class=\"headerlink\" title=\"一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？\"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h3><blockquote>\n<p>等价于：自增主键能不能被持久化的问题？</p>\n<p>MyISAM：自增主键会持久化到数据文件中</p>\n<p>InnoDB：<br>    5.7 以及之前：不会持久化<br>    从 8 开始：自增主键会持久化到 redo log</p>\n</blockquote>\n<ol>\n<li><p>如果表的引擎类型是 <strong>MyISAM</strong>，那么这条记录的 ID 就是 4。因为 <strong>MyISAM表会把自增主键的最大ID记录到数据文件里面</strong>，重启 MySQL 后，自增主键的最大 ID 也不会丢失。</p>\n</li>\n<li><p>如果表的引擎类型是 <strong>InnoDB</strong>，那么这条记录的 ID 就是 2。因为 <strong>InnoDB表把自增主键的最大ID记录到内存中</strong>，所以重启数据库后会使最大 ID（其实是 AUTO_INCREMENT 计数器的值）丢失；一旦数据库重新运行，数据库会自动计算自增主键的最大 ID（<strong>其实就是把最后一条记录 ID 加 1 并赋值给 AUTO_INCREMENT</strong>）再次放入到内存中。</p>\n<p> 【注】<strong>这仅仅是 MySQL 8 以前的版本，也就是 MySQL 5.7 以及之前的版本</strong>。因为在 MySQL 8.0 中，<strong>InnoDB 的行为已更改</strong>。每次更改时，当前最大自动增量计数器值（AUTO_INCREMENT）都会写入重做日志 redo log，并保存到每个检查点的引擎专用系统表中。这些更改使当前的最大自动增量计数器值在服务器重新启动后保持不变，与 <strong>MyISAM</strong> 一样了。详见官方文档：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-initialization\">InnoDB AUTO_INCREMENT 计数器初始化</a></p>\n<p> 【注】如果删除的不是最后的记录，那么自增的最大 ID 全部都一样，因为自动增量计数器值（AUTO_INCREMENT）不会改变。</p>\n</li>\n</ol>\n<h3 id=\"MySQL-中什么情况会导致自增主键不能连续？\"><a href=\"#MySQL-中什么情况会导致自增主键不能连续？\" class=\"headerlink\" title=\"MySQL 中什么情况会导致自增主键不能连续？\"></a>MySQL 中什么情况会导致自增主键不能连续？</h3><blockquote>\n<ol>\n<li>唯一键冲突</li>\n<li>事务回滚</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>执行器执行插入，自增键+1，但是 innoDB 发现插入时<strong>唯一键冲突</strong>，无法插入，导致的不连续。</p>\n</li>\n<li><p>事务添加自增键+1，但是由于<strong>事务回滚</strong>，数据被清除，导致的不连续。</p>\n</li>\n</ul>\n<h3 id=\"什么是覆盖索引？\"><a href=\"#什么是覆盖索引？\" class=\"headerlink\" title=\"什么是覆盖索引？\"></a>什么是覆盖索引？</h3><p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据即回表。</p>\n<h3 id=\"如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\"><a href=\"#如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\" class=\"headerlink\" title=\"如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\"></a>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h3><p>如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p>\n<h3 id=\"内存表和临时表有什么区别？\"><a href=\"#内存表和临时表有什么区别？\" class=\"headerlink\" title=\"内存表和临时表有什么区别？\"></a>内存表和临时表有什么区别？</h3><p>内存表，指的是使用 Memory 引擎的表，数据放在内存中，重启会被清空；</p>\n<p>临时表，指的是使用 InnoDB 引擎或者 MyISAM 引擎的表，数据放在磁盘上，重启不会清空。</p>\n<h3 id=\"MySQL-中的字符串类型都有哪些？\"><a href=\"#MySQL-中的字符串类型都有哪些？\" class=\"headerlink\" title=\"MySQL 中的字符串类型都有哪些？\"></a>MySQL 中的字符串类型都有哪些？</h3><table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>取值范围</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CHAR(N)</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td>VARCHAR(N)</td>\n<td>0~65536</td>\n</tr>\n<tr>\n<td>TINYBLOB</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>0~65535</td>\n</tr>\n<tr>\n<td>MEDUIMBLOB</td>\n<td>0~167772150</td>\n</tr>\n<tr>\n<td>LONGBLOB</td>\n<td>0~4294967295</td>\n</tr>\n<tr>\n<td>TINYTEXT</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>0~65535</td>\n</tr>\n<tr>\n<td>MEDIUMTEXT</td>\n<td>0~167772150</td>\n</tr>\n<tr>\n<td>LONGTEXT</td>\n<td>0~4294967295</td>\n</tr>\n<tr>\n<td>VARBINARY(N)</td>\n<td>0~N个字节的变长字节字符集</td>\n</tr>\n<tr>\n<td>BINARY(N)</td>\n<td>0~N个字节的定长字节字符集</td>\n</tr>\n</tbody></table>\n<h3 id=\"VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？\"><a href=\"#VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？\" class=\"headerlink\" title=\"VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？\"></a>VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？</h3><p>VARCHAR 的长度是可变的，而 CHAR 是固定长度。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。</p>\n<h3 id=\"MySQL-存储金额应该使用哪种数据类型？为什么？\"><a href=\"#MySQL-存储金额应该使用哪种数据类型？为什么？\" class=\"headerlink\" title=\"MySQL 存储金额应该使用哪种数据类型？为什么？\"></a>MySQL 存储金额应该使用哪种数据类型？为什么？</h3><p>MySQL 存储金额应该使用 <code>decimal</code> ，因为如果存储其他数据类型，比如 <code>float</code> 有导致小数点后数据丢失的风险。</p>\n<h3 id=\"limit-3-2-的含义是什么？\"><a href=\"#limit-3-2-的含义是什么？\" class=\"headerlink\" title=\"limit 3,2 的含义是什么？\"></a>limit 3,2 的含义是什么？</h3><p>去除前三条数据之后查询两条信息。</p>\n<h3 id=\"lastinsertid-函数功能是什么？有什么特点？\"><a href=\"#lastinsertid-函数功能是什么？有什么特点？\" class=\"headerlink\" title=\"lastinsertid() 函数功能是什么？有什么特点？\"></a><em>lastinsertid()</em> 函数功能是什么？有什么特点？</h3><p><em>lastinsertid()</em> 用于查询最后一次自增表的编号（全局的），它的特点是查询时不需要指定表名，使用 <code>select last_insert_id()</code> 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10， <em>lastinsertid()</em> 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 <em>lastinsertid()</em> 查询的值就是 3。</p>\n<h3 id=\"删除表的数据有几种方式？它们有什么区别？\"><a href=\"#删除表的数据有几种方式？它们有什么区别？\" class=\"headerlink\" title=\"删除表的数据有几种方式？它们有什么区别？\"></a>删除表的数据有几种方式？它们有什么区别？</h3><p>删除数据有两种方式：delete 和 truncate，它们的区别如下：</p>\n<ul>\n<li><p>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；</p>\n</li>\n<li><p>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，<br>因此 detele 的信息可以被找回而 truncate 的信息无法被找回；</p>\n</li>\n<li><p>truncate 因为不记录日志所以执行效率比 delete 快。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-中支持几种模糊查询？它们有什么区别？\"><a href=\"#MySQL-中支持几种模糊查询？它们有什么区别？\" class=\"headerlink\" title=\"MySQL 中支持几种模糊查询？它们有什么区别？\"></a>MySQL 中支持几种模糊查询？它们有什么区别？</h3><p>MySQL 中支持两种模糊查询：regexp 和 like<br>like 是对任意多字符匹配或任意单字符进行模糊匹配，<br>而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。<br>regexp 和 like 的使用示例如下： </p>\n<blockquote>\n<p>select * from person where uname like ‘%SQL%’;<br>select * from person where uname regexp ‘.SQL*.’; </p>\n</blockquote>\n<h3 id=\"count-column-和-count-有什么区别？\"><a href=\"#count-column-和-count-有什么区别？\" class=\"headerlink\" title=\"count(column) 和 count(*) 有什么区别？\"></a><em>count(column)</em> 和 <em>count(*)</em> 有什么区别？</h3><p><em>count(column)</em> 统计不会统计列值为 null 的数据，<br>而 <em>count(*)</em> 则会统计所有信息，所以最终的统计结果可能会不同。</p>\n<h3 id=\"为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？\"><a href=\"#为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？\" class=\"headerlink\" title=\"为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？\"></a>为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？</h3><p>因为 <strong>InnoDB 支持事务</strong>，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。</p>\n<h3 id=\"InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？\"><a href=\"#InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？\" class=\"headerlink\" title=\"InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？\"></a>InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？</h3><p>MyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。</p>\n<h3 id=\"在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？\"><a href=\"#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？\" class=\"headerlink\" title=\"在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？\"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h3><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p>\n<ul>\n<li>对于 count(字段) 来说，遍历整张表，取这个字段，然后判断是否为 null，不为 null 则加 1</li>\n<li>对于 count(主键 id) 来说，遍历整张表，取主键 id，不可能为空，每次加 1。但是可能使用最小的索引树。</li>\n<li>对于 count(1) 来说，遍历整张表，不取值。1 是不可能为空的，每次加 1。</li>\n<li>对于 count(*) 来说，遍历整张表，不取值，直接按行累加。实际上，当使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。</li>\n</ul>\n<p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p>\n<h3 id=\"MySQL-中内连接、左连接、右连接有什么区别？\"><a href=\"#MySQL-中内连接、左连接、右连接有什么区别？\" class=\"headerlink\" title=\"MySQL 中内连接、左连接、右连接有什么区别？\"></a>MySQL 中内连接、左连接、右连接有什么区别？</h3><ul>\n<li><p>内连（inner join）— 把匹配的关联数据显示出来；</p>\n</li>\n<li><p>左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；</p>\n</li>\n<li><p>右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；</p>\n</li>\n</ul>\n<h2 id=\"MySQL索引篇\"><a href=\"#MySQL索引篇\" class=\"headerlink\" title=\"MySQL索引篇\"></a>MySQL索引篇</h2><h3 id=\"什么是索引？\"><a href=\"#什么是索引？\" class=\"headerlink\" title=\"什么是索引？\"></a>什么是索引？</h3><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p>\n<h3 id=\"索引分别有哪些优点和缺点？\"><a href=\"#索引分别有哪些优点和缺点？\" class=\"headerlink\" title=\"索引分别有哪些优点和缺点？\"></a>索引分别有哪些优点和缺点？</h3><p><strong>索引的优点：</strong></p>\n<ul>\n<li>提高查询效率</li>\n</ul>\n<p><strong>索引的缺点：</strong></p>\n<ul>\n<li><p>虽然提高了查询速度，但却降低了更新表的速度，比如 update、insert；<br>因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</p>\n</li>\n<li><p>建立索引的索引文件会占用磁盘。</p>\n</li>\n</ul>\n<h3 id=\"MySQL索引的注意事项\"><a href=\"#MySQL索引的注意事项\" class=\"headerlink\" title=\"MySQL索引的注意事项\"></a>MySQL索引的注意事项</h3><p><strong>1、联合索引遵循前缀原则</strong></p>\n<p><strong>2、like模糊查询，%不能在前</strong></p>\n<p><strong>3、</strong>列值为空（NULL）时是可以使用索引的，但 MySQL 难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在 MySQL 内部进行特殊处理。</p>\n<p><strong>4、</strong> 如果 MySQL 估计使用索引比全表扫描更慢，会放弃使用索引，例如：<br>表中只有 100 条数据左右。对于 SQL 语句 WHERE id &gt; 1 AND id &lt; 100，MySQL 会优先考虑全表扫描。</p>\n<p><strong>5、</strong> <strong>如果关键词or前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。</strong></p>\n<p><strong>6、</strong> 列类型是字符串，查询时一定要给值加引号，否则索引失效，例如：<br>列 name varchar(16)，存储了字符串”100”<br>WHERE name &#x3D; 100;  （做了自动类型转换）<br>以上 SQL 语句能搜到，但无法用到索引。</p>\n<p><strong>7、不在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描</strong> </p>\n<h3 id=\"为什么-MySQL-官方建议使用自增主键作为表的主键？\"><a href=\"#为什么-MySQL-官方建议使用自增主键作为表的主键？\" class=\"headerlink\" title=\"为什么 MySQL 官方建议使用自增主键作为表的主键？\"></a>为什么 MySQL 官方建议使用自增主键作为表的主键？</h3><p>优点：</p>\n<ol>\n<li><p>页分裂问题。如果使用非自增主键作为表的主键的话，当新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上，以确保索引有序。也就是说造成了页分裂，大量移动数据的过程严重影响插入效率。</p>\n</li>\n<li><p>存储空间问题。自增主键存储空间小，同一个结点内能存放更多的主键，树的高度可能降低，减少 io 次数。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>数据量过大，可能会超出自增长取值范围；</li>\n<li>无法满足分布式存储，分库分表的情况下无法合并表；</li>\n<li>主键有自增规律，容易被破解；</li>\n</ol>\n<p><strong>综上所述：</strong>是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。</p>\n<h3 id=\"索引有几种类型？分别如何创建？\"><a href=\"#索引有几种类型？分别如何创建？\" class=\"headerlink\" title=\"索引有几种类型？分别如何创建？\"></a>索引有几种类型？分别如何创建？</h3><p>**MySQL 的索引有两种分类方式：逻辑分类和物理分类。 **</p>\n<p><strong>按照逻辑分类，索引可分为：</strong></p>\n<ul>\n<li>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</li>\n<li>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</li>\n<li>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</li>\n</ul>\n<p><strong>按照物理分类，索引可分为：</strong></p>\n<ul>\n<li>聚簇索引：InnoDB 的主键索引存储采用聚簇索引，主键值和数据存放在一起</li>\n<li>非聚簇索引：MyISAM 的主键索引存储采用非聚簇索引，主键值和指向数据的指针存放在一起，数据另开空间存储</li>\n</ul>\n<p><strong>各种索引的创建脚本如下：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建主键索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (column_list);</span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> index_name (column_list);</span><br><span class=\"line\"><span class=\"comment\">-- 创建普通索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> INDEX index_name (column_list);</span><br><span class=\"line\"><span class=\"comment\">-- 创建全文索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> FULLTEXT index_name (column_list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么叫回表查询？\"><a href=\"#什么叫回表查询？\" class=\"headerlink\" title=\"什么叫回表查询？\"></a>什么叫回表查询？</h3><p>普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p>\n<p>也就是说，基于非主键索引的查询需要多扫描一次主键索引树。因此，我们在应用中应该尽量使用主键查询。</p>\n<p>例外就是使用非主键索引时，如果当前索引满足查询需求，则不用回表。</p>\n<h3 id=\"在-InnDB-中主键索引为什么比普通索引的查询性能高？\"><a href=\"#在-InnDB-中主键索引为什么比普通索引的查询性能高？\" class=\"headerlink\" title=\"在 InnDB 中主键索引为什么比普通索引的查询性能高？\"></a>在 InnDB 中主键索引为什么比普通索引的查询性能高？</h3><p>回表。因为普通索引的查询会多执行一次检索操作。比如主键查询 select * from t where id&#x3D;10 只需要搜索 id 的这棵 B+ 树，而普通索引查询 select * from t where f&#x3D;3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。</p>\n<h3 id=\"MySQL-复合索引应该注意什么？\"><a href=\"#MySQL-复合索引应该注意什么？\" class=\"headerlink\" title=\"MySQL 复合索引应该注意什么？\"></a>MySQL 复合索引应该注意什么？</h3><p>MySQL 中的复合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。</p>\n<h3 id=\"复合索引的作用是什么？\"><a href=\"#复合索引的作用是什么？\" class=\"headerlink\" title=\"复合索引的作用是什么？\"></a>复合索引的作用是什么？</h3><ul>\n<li>用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了<code>key(a)、key(a,b)、key(a,b,c)</code>等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；</li>\n<li>覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：<code>select a,b,c from table where a=1 and b = 1</code> ，就可以直接通过遍历索引取得数据，而<strong>无需回表查询</strong>，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；</li>\n<li>索引列越多，通过索引筛选出的数据越少。</li>\n</ul>\n<h3 id=\"什么是最左匹配原则？它的生效原则有哪些？\"><a href=\"#什么是最左匹配原则？它的生效原则有哪些？\" class=\"headerlink\" title=\"什么是最左匹配原则？它的生效原则有哪些？\"></a>什么是最左匹配原则？它的生效原则有哪些？</h3><p>最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。</p>\n<h3 id=\"以下语句会走索引么？\"><a href=\"#以下语句会走索引么？\" class=\"headerlink\" title=\"以下语句会走索引么？\"></a>以下语句会走索引么？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from t where year(date)&gt;2018;</span><br></pre></td></tr></table></figure>\n\n<p>不会，因为在索引列上涉及到了运算。</p>\n<h3 id=\"能否给手机号的前-6-位创建索引？如何创建？\"><a href=\"#能否给手机号的前-6-位创建索引？如何创建？\" class=\"headerlink\" title=\"能否给手机号的前 6 位创建索引？如何创建？\"></a>能否给手机号的前 6 位创建索引？如何创建？</h3><p>可以，创建方式有两种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table t add index index_phone(phone(6));</span><br><span class=\"line\">create index index_phone on t(phone(6));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么是前缀索引？\"><a href=\"#什么是前缀索引？\" class=\"headerlink\" title=\"什么是前缀索引？\"></a>什么是前缀索引？</h3><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引。<br>类似这种给某列部分信息添加索引的方式叫做前缀索引。</p>\n<h3 id=\"为什么要用前缀索引？\"><a href=\"#为什么要用前缀索引？\" class=\"headerlink\" title=\"为什么要用前缀索引？\"></a>为什么要用前缀索引？</h3><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p>\n<h3 id=\"什么情况下适合使用前缀索引？\"><a href=\"#什么情况下适合使用前缀索引？\" class=\"headerlink\" title=\"什么情况下适合使用前缀索引？\"></a>什么情况下适合使用前缀索引？</h3><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性（不重复的索引值和表记录数的比值，越大说明索引价值越大）为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p>\n<h3 id=\"InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？\"><a href=\"#InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？\" class=\"headerlink\" title=\"InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？\"></a>InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h3><p>因为 B 树、Hash、红黑树或二叉树存在以下问题：</p>\n<ul>\n<li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低；</li>\n<li>Hash：虽然可以快速定位，但是没有顺序，无法进行范围查找，IO 复杂度高；</li>\n<li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；</li>\n<li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li>\n</ul>\n<h3 id=\"MySQL-如何指定查询的索引？\"><a href=\"#MySQL-如何指定查询的索引？\" class=\"headerlink\" title=\"MySQL 如何指定查询的索引？\"></a>MySQL 如何指定查询的索引？</h3><p>在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t force index(index_t);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在-MySQL-中指定了查询索引，为什么没有生效？\"><a href=\"#在-MySQL-中指定了查询索引，为什么没有生效？\" class=\"headerlink\" title=\"在 MySQL 中指定了查询索引，为什么没有生效？\"></a>在 MySQL 中指定了查询索引，为什么没有生效？</h3><p>我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。</p>\n<h3 id=\"如何优化身份证的索引？\"><a href=\"#如何优化身份证的索引？\" class=\"headerlink\" title=\"如何优化身份证的索引？\"></a>如何优化身份证的索引？</h3><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：</p>\n<ul>\n<li><strong>使用身份证倒序存储</strong>，这样设置前六位的意义就很大了；</li>\n<li><strong>使用 hash 值</strong>，新创建一个字段用于存储身份证的 hash 值。</li>\n</ul>\n<h3 id=\"索引的使用场景\"><a href=\"#索引的使用场景\" class=\"headerlink\" title=\"索引的使用场景\"></a>索引的使用场景</h3><ul>\n<li>对于非常小的表，大部分情况下全表扫描效率更高。</li>\n<li>中到大型表，索引非常有效。</li>\n<li>特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。</li>\n</ul>\n<h3 id=\"聚簇索引和非聚簇索引\"><a href=\"#聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引\"></a>聚簇索引和非聚簇索引</h3><p>Innobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p>\n<p>Innodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引</p>\n<h4 id=\"聚簇索引-聚集索引\"><a href=\"#聚簇索引-聚集索引\" class=\"headerlink\" title=\"聚簇索引(聚集索引)\"></a>聚簇索引(聚集索引)</h4><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145143172-1760681728.png\" alt=\"img\"></p>\n<p>　　Innodb 聚簇索引和 MyIsam 非聚簇索引的比较说明<br>　　参考博客：<a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\">https://www.cnblogs.com/zlcxbb/p/5757245.html</a></p>\n<h4 id=\"InnoDB索引实现\"><a href=\"#InnoDB索引实现\" class=\"headerlink\" title=\"InnoDB索引实现\"></a>InnoDB索引实现</h4><p>　　InnoDB<strong>使用B+Tree作为索引结构</strong>，但具体实现方式却与 MyISAM 截然不同.</p>\n<p>1）主键索引：</p>\n<p><strong>MyISAM索引文件和数据文件是分离的</strong>，<strong>索引文件仅保存数据记录的地址</strong>。而在<strong>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1464190-20191106145200302-932404581.png\"></p>\n<p>(图 inndb 主键索引）是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则<strong>MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</strong>。</p>\n<p>2）InnoDB 的辅助索引</p>\n<p>   InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引：</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145241480-1330791289.png\" alt=\"img\"></p>\n<p>InnoDB 使用的是聚簇索引，将主键组织到一棵 B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14”这样的条件查找主键，则按照 B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B+树中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B+树中再执行一次 B+树检索操作，最终到达叶子节点即可获取整行数据。</p>\n<h4 id=\"MyISAM索引实现\"><a href=\"#MyISAM索引实现\" class=\"headerlink\" title=\"MyISAM索引实现\"></a>MyISAM索引实现</h4><p>MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</p>\n<p>1）主键索引：</p>\n<p>MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的<strong>data域存放的是数据记录的地址</strong>。下图是 MyISAM 主键索引的原理图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151308457-531875534.png\" alt=\"img\"></p>\n<p>这里设表一共有三列，假设我们以 Col1 为主键，图 myisam1 是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。</p>\n<p>2）辅助索引（Secondary key）</p>\n<p>在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示。</p>\n<p>同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151427711-625351515.png\" alt=\"img\"></p>\n<p>　　<strong>MyISM使用的是非聚簇索引</strong>，非聚簇索引的两棵 B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引 B+树的节点存储了主键，辅助键索引 B+树存储了辅助键。表数据存储在独立的地方，这两颗 B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>\n<p>为了更形象说明这两种索引的区别，我们假想一个表如下图存储了 4 行数据。其中 Id 作为主索引，Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151527647-152458631.png\" alt=\"img\"></p>\n<p>🌟<strong>InnoDB聚簇索引：</strong></p>\n<p>主键索引树，根结点存的是主键 id 和对应的数据；</p>\n<p>辅助索引树，根结点存的是辅助索引和对应的主键索引，因此需要根据主键到主键索引树上在遍历一次得到对应的数据。</p>\n<p>🌟<strong>MyISAM非聚簇索引：</strong></p>\n<p>主键索引树，根结点存的是主键到数据地址的映射；</p>\n<p>辅助索引树，根结点存的是辅助索引到数据地址的映射，也可以直接得到数据，不需要回表。</p>\n<h4 id=\"问题：主键索引是聚集索引还是非聚集索引？\"><a href=\"#问题：主键索引是聚集索引还是非聚集索引？\" class=\"headerlink\" title=\"问题：主键索引是聚集索引还是非聚集索引？\"></a>问题：主键索引是聚集索引还是非聚集索引？</h4><p>在 InnoDB 下主键索引是聚集索引，在 MyISAM 下主键索引是非聚集索引</p>\n<h4 id=\"MyISAM索引实现？\"><a href=\"#MyISAM索引实现？\" class=\"headerlink\" title=\"MyISAM索引实现？\"></a>MyISAM索引实现？</h4><p>MyISAM 存储引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。MyISAM 的索引方式也叫做非聚簇索引的，之所以这么称呼是为了与 InnoDB 的聚簇索引区分。</p>\n<h4 id=\"MyISAM索引与InnoDB索引的区别？\"><a href=\"#MyISAM索引与InnoDB索引的区别？\" class=\"headerlink\" title=\"MyISAM索引与InnoDB索引的区别？\"></a>MyISAM索引与InnoDB索引的区别？</h4><ul>\n<li>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。</li>\n<li>InnoDB 的主键索引的叶子节点存储着索引和行数据，因此主键索引非常高效。</li>\n<li>MyISAM 索引的叶子节点存储的是行数据地址，需要根据数据地址访问对应的地址才能得到数据。</li>\n<li><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</strong></li>\n</ul>\n<h3 id=\"简单说一说drop、delete与truncate的区别\"><a href=\"#简单说一说drop、delete与truncate的区别\" class=\"headerlink\" title=\"简单说一说drop、delete与truncate的区别\"></a>简单说一说drop、delete与truncate的区别</h3><p>SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别</p>\n<blockquote>\n<p>1、delete和truncate只删除表的数据不删除表的结构<br>2、速度,一般来说: drop&gt; truncate &gt;delete<br>3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p>\n</blockquote>\n<h3 id=\"delete、truncate和drop分别在什么场景之下使用？\"><a href=\"#delete、truncate和drop分别在什么场景之下使用？\" class=\"headerlink\" title=\"delete、truncate和drop分别在什么场景之下使用？\"></a>delete、truncate和drop分别在什么场景之下使用？</h3><ol>\n<li>想删除部分数据行时候，用 delete，并且带上 where 子句</li>\n<li>保留表而删除所有数据的时候用 truncate</li>\n<li>不再需要一张表的时候，用 drop</li>\n</ol>\n<h3 id=\"⭐为什么-B-Tree-比-B-Tree-更适合实际应用中操作系统的文件索引和数据库索引？\"><a href=\"#⭐为什么-B-Tree-比-B-Tree-更适合实际应用中操作系统的文件索引和数据库索引？\" class=\"headerlink\" title=\"⭐为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？\"></a>⭐为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？</h3><ol>\n<li>B+Tree 的磁盘读写代价更低</li>\n</ol>\n<blockquote>\n<p>B+Tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B-Tree 更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</p>\n</blockquote>\n<ol start=\"2\">\n<li>B+Tree 的查询效率更加稳定</li>\n</ol>\n<blockquote>\n<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n</blockquote>\n<h3 id=\"⭐Hash索引和B-树所有有什么区别或者说优劣呢\"><a href=\"#⭐Hash索引和B-树所有有什么区别或者说优劣呢\" class=\"headerlink\" title=\"⭐Hash索引和B+树所有有什么区别或者说优劣呢?\"></a>⭐Hash索引和B+树所有有什么区别或者说优劣呢?</h3><p>首先要知道 Hash 索引和 B+树索引的底层实现原理：</p>\n<p><strong>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.</strong><br>B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p>\n<p>那么可以看出他们有以下的不同：</p>\n<ul>\n<li><p>hash 索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>\n</li>\n<li><p>hash 索引不支持使用索引进行排序,原理同上.</p>\n</li>\n<li><p>hash 索引不支持模糊查询.</p>\n</li>\n<li><p>hash 索引任何时候都避免不了回表查询数据,而 B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</p>\n</li>\n<li><p>hash 索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生 hash 碰撞,此时效率可能极差.而 B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</p>\n</li>\n</ul>\n<p>因此,在大多数情况下,直接选择 B+树索引可以获得稳定且较好的查询速度.而不需要使用 hash 索引.</p>\n<h3 id=\"非聚簇索引一定会回表查询吗\"><a href=\"#非聚簇索引一定会回表查询吗\" class=\"headerlink\" title=\"非聚簇索引一定会回表查询吗?\"></a>非聚簇索引一定会回表查询吗?</h3><p>有如下一张 InnoDB 表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>` (</span><br><span class=\"line\">`id` <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> ,</span><br><span class=\"line\">`name` <span class=\"type\">VARCHAR</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> ,</span><br><span class=\"line\">`age` <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>其中 id 为自增主键，name 是一个普通索引。在执行 select * from user where id &#x3D; 1 时，会在主键索引对应的 B+树的叶子结点上搜索到关键字 id&#x3D;1 的节点，并读取位于该节点上的整行数据。但是在执行 select * from user where name &#x3D; ‘tom’时，会分为两个步骤：</p>\n<p>先到 name 索引对应的 B+树的叶子结点上搜索到关键字 name&#x3D;’tom’的节点，并从该节点上获取对应的主键 id 值。</p>\n<p>然后再根据 id 值使用主键索引读取到整行数据。</p>\n<p>其中第二个步骤叫作回表查询。需要扫描辅助索引和主键索引两棵 B+树才能拿到整行数据，效率较低。</p>\n<p>如果执行 select id, name from user where name &#x3D; ‘tom’,则只需要扫描 name 索引树就可以获取到所有的字段，因为 id 和 name 都保存在 name 索引 B+树的叶子节点上，所以不需要再去主键索引上查找。这就是所谓的索引覆盖。只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。</p>\n<p>而 select id, name, age from user where name &#x3D; ‘tom’，因为 age 字段没有存储到 name 索引的叶子节点上，所以需要根据主键索引回表查询到 age 列值。如果把 name 索引改成(name，age)的联合索引就可以实现索引覆盖，无需回表了。（覆盖索引，sql 语句中用到的字段都有索引）<br>————————————————<br>版权声明：本文为 CSDN 博主「lmyno」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_33603681/article/details/113387941\">https://blog.csdn.net/weixin_33603681/article/details/113387941</a></p>\n<h3 id=\"联合索引是什么-为什么需要注意联合索引中的顺序\"><a href=\"#联合索引是什么-为什么需要注意联合索引中的顺序\" class=\"headerlink\" title=\"联合索引是什么?为什么需要注意联合索引中的顺序?\"></a>联合索引是什么?为什么需要注意联合索引中的顺序?</h3><p>因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p>\n<h3 id=\"创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因\"><a href=\"#创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因\" class=\"headerlink\" title=\"创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?\"></a>创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</h3><p>MySQL 提供了 explain 命令来查看语句的执行计划</p>\n<h2 id=\"MySQL事务篇（重点）\"><a href=\"#MySQL事务篇（重点）\" class=\"headerlink\" title=\"MySQL事务篇（重点）\"></a>MySQL事务篇（重点）</h2><h3 id=\"可见性判断\"><a href=\"#可见性判断\" class=\"headerlink\" title=\"可见性判断\"></a>可见性判断</h3><blockquote>\n<p>总结：</p>\n<p>大于等于下一个分配的事务ID不可见</p>\n<p>包含在未提交事务集合中但是和创建read view的事务ID不相等则也不可见。</p>\n</blockquote>\n<p>事务版本号小于当前最小的事务 ID，那么说明它已经提交了，可见。</p>\n<p>事务版本号<strong>大于等于下一个分配的事务ID</strong>，说明这个事务在当前 read view 生成后在生成，<strong>不可见</strong>。</p>\n<p>事务版本号在 [最小事务 ID，下一个分配的事务 ID) 区间内：</p>\n<p>​\t如果未提交事务集合包含该事务版本号，那么判断是否该事务版本号是否等于创建该 read view 的事务 ID，</p>\n<p>​\t\t等于则说明这个版本的数据是当前事务生成的，可见。<strong>不等于则不可见</strong>。</p>\n<p>​\t如果不包含，说明这个事务版本号已经提交，可见。</p>\n<h3 id=\"查询一条记录，基于MVCC，是怎样的流程\"><a href=\"#查询一条记录，基于MVCC，是怎样的流程\" class=\"headerlink\" title=\"查询一条记录，基于MVCC，是怎样的流程\"></a>查询一条记录，基于MVCC，是怎样的流程</h3><ol>\n<li>获取数据版本号即<strong>数据行中的事务id隐藏字段</strong></li>\n<li><strong>执行sql，得到Read View</strong></li>\n<li>根据数据版本号和 read view 进行<strong>可见性判断</strong>，判断当前版本数据是否可见</li>\n<li>如果不符合 Read View 的可见性规则， 即就需要<strong>Undo log</strong>中历史快照重新和 read view 可见性判断</li>\n<li>最后返回符合规则的数据</li>\n</ol>\n<p>InnoDB 实现 MVCC，是通过<code> Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。</p>\n<h3 id=\"RC下可以读到已提交数据，但不能读到未提交数据\"><a href=\"#RC下可以读到已提交数据，但不能读到未提交数据\" class=\"headerlink\" title=\"RC下可以读到已提交数据，但不能读到未提交数据\"></a>RC下可以读到已提交数据，但不能读到未提交数据</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1.png\" alt=\"1\"></p>\n<h3 id=\"RR下已提交和未提交数据都不能读到\"><a href=\"#RR下已提交和未提交数据都不能读到\" class=\"headerlink\" title=\"RR下已提交和未提交数据都不能读到\"></a>RR下已提交和未提交数据都不能读到</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes2.png\" alt=\"2\"></p>\n<h3 id=\"为什么RR下解决了不可重复读问题？\"><a href=\"#为什么RR下解决了不可重复读问题？\" class=\"headerlink\" title=\"为什么RR下解决了不可重复读问题？\"></a>为什么RR下解决了不可重复读问题？</h3><p>实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟<strong>Read view工作方式有关</strong>。</p>\n<ul>\n<li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n</tbody></table>\n<ul>\n<li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>共用一个Read View副本</td>\n</tr>\n</tbody></table>\n<h3 id=\"MVCC是否解决了幻读问题呢？\"><a href=\"#MVCC是否解决了幻读问题呢？\" class=\"headerlink\" title=\"MVCC是否解决了幻读问题呢？\"></a>MVCC是否解决了幻读问题呢？</h3><p>对于幻读来说，存在快照读（可以读到多个版本，普通的 select）和当前读（读的是最新的 for update）的情况：</p>\n<ol>\n<li>RR 隔离级别下为了解决幻读问题：<strong>快照读依靠MVCC控制，当前读通过间隙锁解决</strong>；</li>\n<li>间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；</li>\n<li><strong>间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度</strong>。</li>\n</ol>\n<h3 id=\"并发事务有什么什么问题？应该如何解决？\"><a href=\"#并发事务有什么什么问题？应该如何解决？\" class=\"headerlink\" title=\"并发事务有什么什么问题？应该如何解决？\"></a>并发事务有什么什么问题？应该如何解决？</h3><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：</p>\n<ul>\n<li><p>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</p>\n</li>\n<li><p>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-事务实现原理是什么？\"><a href=\"#MySQL-事务实现原理是什么？\" class=\"headerlink\" title=\"MySQL 事务实现原理是什么？\"></a>MySQL 事务实现原理是什么？</h3><p>以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。<br>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。</p>\n<h2 id=\"MVCC详细版\"><a href=\"#MVCC详细版\" class=\"headerlink\" title=\"MVCC详细版\"></a>MVCC详细版</h2><h3 id=\"1-相关数据库知识点回顾\"><a href=\"#1-相关数据库知识点回顾\" class=\"headerlink\" title=\"1. 相关数据库知识点回顾\"></a>1. 相关数据库知识点回顾</h3><h4 id=\"1-1-什么是数据库事务，为什么要有事务\"><a href=\"#1-1-什么是数据库事务，为什么要有事务\" class=\"headerlink\" title=\"1.1 什么是数据库事务，为什么要有事务\"></a>1.1 什么是数据库事务，为什么要有事务</h4><p>事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p>\n<p><strong>为什么要有事务呢？</strong> 就是为了保证数据的最终一致性。</p>\n<h4 id=\"1-2-事务包括哪几个特性？\"><a href=\"#1-2-事务包括哪几个特性？\" class=\"headerlink\" title=\"1.2 事务包括哪几个特性？\"></a>1.2 事务包括哪几个特性？</h4><p>事务四个典型特性，即 ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>\n<ul>\n<li>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作<strong>要么全部都执行，要么都不执行</strong>。</li>\n<li>一致性： 指在<strong>事务开始之前和事务结束以后</strong>，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。</li>\n<li>隔离性： 多个事务并发访问时，<strong>事务之间是相互隔离</strong>的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。</li>\n<li>持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将<strong>持久地保存在数据库</strong>之中。</li>\n</ul>\n<h4 id=\"1-3-事务并发存在的问题\"><a href=\"#1-3-事务并发存在的问题\" class=\"headerlink\" title=\"1.3 事务并发存在的问题\"></a>1.3 事务并发存在的问题</h4><p>事务并发会引起<strong>脏读、不可重复读、幻读</strong>问题。</p>\n<h5 id=\"1-3-1-脏读\"><a href=\"#1-3-1-脏读\" class=\"headerlink\" title=\"1.3.1 脏读\"></a>1.3.1 脏读</h5><blockquote>\n<p>如果一个事务读取到了另一个未提交事务修改过的数据，我们就称发生了脏读现象。</p>\n</blockquote>\n<h5 id=\"1-3-2-不可重复读\"><a href=\"#1-3-2-不可重复读\" class=\"headerlink\" title=\"1.3.2 不可重复读\"></a>1.3.2 不可重复读</h5><blockquote>\n<p>同一个事务内，前后多次读取，读取到的数据内容不一致</p>\n</blockquote>\n<h5 id=\"1-3-3-幻读\"><a href=\"#1-3-3-幻读\" class=\"headerlink\" title=\"1.3.3 幻读\"></a>1.3.3 幻读</h5><blockquote>\n<p>如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如insert、delete、update），两次读取到的结果集却不一样了，就意味着发生了<strong>幻读</strong>。</p>\n</blockquote>\n<h4 id=\"1-4-四大隔离级别\"><a href=\"#1-4-四大隔离级别\" class=\"headerlink\" title=\"1.4 四大隔离级别\"></a>1.4 四大隔离级别</h4><p>为了解决并发事务存在的<strong>脏读、不可重复读、幻读</strong>等问题，数据库大叔设计了四种隔离级别。分别是<strong>读未提交，读已提交，可重复读，串行化（Serializable）</strong>。</p>\n<h5 id=\"1-4-1-读未提交\"><a href=\"#1-4-1-读未提交\" class=\"headerlink\" title=\"1.4.1 读未提交\"></a>1.4.1 读未提交</h5><p>读未提交隔离级别，只限制了两个数据<strong>不能同时修改</strong>，但是修改数据的时候，即使事务<strong>未提交</strong>，都是可以被别的事务读取到的，这级别的事务隔离有<strong>脏读、重复读、幻读</strong>的问题；</p>\n<h5 id=\"1-4-2-读已提交\"><a href=\"#1-4-2-读已提交\" class=\"headerlink\" title=\"1.4.2 读已提交\"></a>1.4.2 读已提交</h5><p>读已提交隔离级别，当前事务只能读取到其他事务<strong>提交</strong>的数据，所以这种事务的隔离级别<strong>解决了脏读</strong>问题，但还是会存在<strong>重复读、幻读</strong>问题；</p>\n<h5 id=\"1-4-3-可重复读\"><a href=\"#1-4-3-可重复读\" class=\"headerlink\" title=\"1.4 3 可重复读\"></a>1.4 3 可重复读</h5><p>可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以<strong>解决了重复读</strong>的问题，但是读取范围数据的时候，是可以插入数据，所以还会存在<strong>幻读</strong>问题；</p>\n<h5 id=\"1-4-4-串行化\"><a href=\"#1-4-4-串行化\" class=\"headerlink\" title=\"1.4.4 串行化\"></a>1.4.4 串行化</h5><p>事务最高的隔离级别，在该级别下，所有事务都是进行<strong>串行化顺序</strong>执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。</p>\n<h5 id=\"1-4-5-四大隔离级别，都会存在哪些并发问题呢\"><a href=\"#1-4-5-四大隔离级别，都会存在哪些并发问题呢\" class=\"headerlink\" title=\"1.4.5 四大隔离级别，都会存在哪些并发问题呢\"></a>1.4.5 四大隔离级别，都会存在哪些并发问题呢</h5><table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读未提交</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>读已提交</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>可重复读</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>串行化</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-5-数据库是如何保证事务的隔离性的呢？\"><a href=\"#1-5-数据库是如何保证事务的隔离性的呢？\" class=\"headerlink\" title=\"1.5 数据库是如何保证事务的隔离性的呢？\"></a>1.5 数据库是如何保证事务的隔离性的呢？</h4><p>数据库是通过<strong>加锁</strong>，来实现事务的隔离性的。这就好像，如果你想一个人静静，不被别人打扰，你就可以在房门上加上一把锁。</p>\n<p>加锁确实好使，可以保证隔离性。比如<strong>串行化隔离级别就是加锁实现的</strong>。但是频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大<strong>降低了数据库性能</strong>。</p>\n<p><strong>那么，如何解决加锁后的性能问题的？</strong></p>\n<p>答案就是,<strong>MVCC多版本并发控制</strong>！它实现读取数据不用加锁，可以让读取数据同时修改。修改数据时同时可读取。</p>\n<h3 id=\"2-什么是-MVCC？\"><a href=\"#2-什么是-MVCC？\" class=\"headerlink\" title=\"2. 什么是 MVCC？\"></a>2. 什么是 MVCC？</h3><p>MVCC，即<strong>Multi-Version  Concurrency Control （多版本并发控制）</strong>。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>\n<blockquote>\n<p>通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。</p>\n</blockquote>\n<p>数据库隔离级别<strong>读已提交、可重复读</strong> 都是基于 MVCC 实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。</p>\n<h3 id=\"3-MVCC实现的关键知识点\"><a href=\"#3-MVCC实现的关键知识点\" class=\"headerlink\" title=\"3. MVCC实现的关键知识点\"></a>3. MVCC实现的关键知识点</h3><h4 id=\"3-1-事务版本号\"><a href=\"#3-1-事务版本号\" class=\"headerlink\" title=\"3.1 事务版本号\"></a>3.1 事务版本号</h4><blockquote>\n<p>事务每次开启前，都会从数据库获得一个<strong>自增长</strong>的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p>\n</blockquote>\n<h4 id=\"3-2-隐式字段\"><a href=\"#3-2-隐式字段\" class=\"headerlink\" title=\"3.2 隐式字段\"></a>3.2 隐式字段</h4><p>对于 InnoDB 存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非 NULL 唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>是否必须</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>row_id</td>\n<td>否</td>\n<td>单调递增的行ID，不是必需的，占用6个字节。</td>\n</tr>\n<tr>\n<td>trx_id</td>\n<td>是</td>\n<td>记录操作该数据事务的<strong>事务ID</strong></td>\n</tr>\n<tr>\n<td>roll_pointer</td>\n<td>是</td>\n<td>这个隐藏列就相当于一个<strong>回滚指针</strong>，指向回滚段的undo日志</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-3-undo-log\"><a href=\"#3-3-undo-log\" class=\"headerlink\" title=\"3.3 undo log\"></a>3.3 undo log</h4><p>undo log，<strong>回滚日志</strong>，用于<strong>记录数据被修改前</strong>的信息。在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。</p>\n<p>可以这样认为，当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，当 update 一条记录时，它记录一条对应相反的 update 记录。</p>\n<p>undo log 有什么<strong>用途</strong>呢？</p>\n<ol>\n<li>事务回滚时，保证原子性和一致性。</li>\n<li>用于 MVCC<strong>快照读</strong>。</li>\n</ol>\n<h4 id=\"3-4-版本链\"><a href=\"#3-4-版本链\" class=\"headerlink\" title=\"3.4 版本链\"></a>3.4 版本链</h4><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131424393.png\" alt=\"image-20220422131424393\"></p>\n<p>其实，通过版本链，我们就可以看出<strong>事务版本号、表格隐藏的列和undo log</strong>它们之间的关系。我们再来小分析一下。</p>\n<ol>\n<li><p>假设现在有一张 core_user 表，表里面有一条数据,id 为 1，名字为孙权：</p>\n <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131445316.png\" alt=\"image-20220422131445316\" style=\"zoom: 50%;\" />\n</li>\n<li><p>现在开启一个事务 A： 对 core_user 表执行<code>update core_user set name =&quot;曹操&quot; where id=1</code>,会进行如下流程操作</p>\n</li>\n</ol>\n<ul>\n<li><p>首先获得一个事务 ID&#x3D;100</p>\n</li>\n<li><p>把 core_user 表修改前的数据,拷贝到 undo log</p>\n</li>\n<li><p>修改 core_user 表中，id&#x3D;1 的数据，名字改为曹操</p>\n</li>\n<li><p>把修改后的数据事务 Id&#x3D;101 改成当前事务版本号，并把<strong>roll_pointer</strong>指向 undo log 数据地址。</p>\n  <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131527508.png\" alt=\"image-20220422131527508\" style=\"zoom: 50%;\" /></li>\n</ul>\n<h4 id=\"3-5-快照读和当前读\"><a href=\"#3-5-快照读和当前读\" class=\"headerlink\" title=\"3.5 快照读和当前读\"></a>3.5 快照读和当前读</h4><p><strong>快照读：</strong> 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的 select 语句都是快照读,如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from core_user where id &gt; 2;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from core_user where id &gt; 2 for update;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-6-Read-View\"><a href=\"#3-6-Read-View\" class=\"headerlink\" title=\"3.6 Read View\"></a>3.6 Read View</h4><ul>\n<li><strong>Read View是什么呢？</strong> 它就是事务执行 SQL 语句时，产生的读视图。实际上在 innodb 中，每个 SQL 语句执行前都会得到一个 Read View。</li>\n<li><strong>Read View有什么用呢？</strong> 它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据</li>\n</ul>\n<p>Read View 是如何保证可见性判断的呢？我们先看看 Read view 的几个重要属性</p>\n<ul>\n<li>m_ids:当前系统中那些活跃(<strong>未提交</strong>)的读写事务 ID, 它数据结构为一个 List，[min_limit_id, max_limit_id)</li>\n<li>min_limit_id:表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，即 m_ids 中的最小值。</li>\n<li>max_limit_id:表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值，即即 m_ids 中的最大值+1</li>\n<li>creator_trx_id: 创建当前 read view 的事务 ID</li>\n</ul>\n<p><strong>Read view 匹配条件规则</strong>如下：</p>\n<ol>\n<li>如果新的数据事务 ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成 Read View 前，已经提交(因为事务 ID 是递增的)，所以该版本可以被当前事务访问。</li>\n<li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。</li>\n<li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>,需要分 3 种情况讨论</li>\n</ol>\n<blockquote>\n<p>（1）如果<code>m_ids</code>包含<code>trx_id</code>,则代表Read View生成时刻，这个事务还未提交，但是如果数据的<code>trx_id</code>等于<code>creator_trx_id</code>的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</p>\n<p>（2）如果<code>m_ids</code>包含<code>trx_id</code>，并且<code>trx_id</code>不等于<code>creator_trx_id</code>，则Read  View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</p>\n<p>（3）如果<code>m_ids</code>不包含<code>trx_id</code>，则说明你这个事务在Read View生成之前就<strong>已经提交</strong>了，修改的结果，当前事务是能看见的。</p>\n</blockquote>\n<h3 id=\"4-MVCC实现原理分析\"><a href=\"#4-MVCC实现原理分析\" class=\"headerlink\" title=\"4. MVCC实现原理分析\"></a>4. MVCC实现原理分析</h3><img src=\"/Users/yaxing/blog/source/_posts/E:/Markdown%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/8%20MySQL.assets/v2-a086ef515e7d0a023ca3cfcc5759c7f6_720w.jpg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n<h4 id=\"4-1-查询一条记录，基于MVCC，是怎样的流程\"><a href=\"#4-1-查询一条记录，基于MVCC，是怎样的流程\" class=\"headerlink\" title=\"4.1 查询一条记录，基于MVCC，是怎样的流程\"></a>4.1 查询一条记录，基于MVCC，是怎样的流程</h4><ol>\n<li>获取事务 ID</li>\n<li>执行 sql，得到 Read View</li>\n<li>查询得到的数据，然后与 Read View 中的事务 ID 进行比较，帮助判断当前版本的数据是否可见。</li>\n<li>如果不符合 Read View 的可见性规则， 即就需要 Undo log 中历史快照;</li>\n<li>最后返回符合规则的数据</li>\n</ol>\n<p>InnoDB 实现 MVCC，是通过<code> Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。</p>\n<h4 id=\"4-2-读已提交（RC）隔离级别，存在不可重复读问题的分析历程\"><a href=\"#4-2-读已提交（RC）隔离级别，存在不可重复读问题的分析历程\" class=\"headerlink\" title=\"4.2 读已提交（RC）隔离级别，存在不可重复读问题的分析历程\"></a>4.2 读已提交（RC）隔离级别，存在不可重复读问题的分析历程</h4><ol>\n<li><p>创建 core_user 表，插入一条初始化数据,如下：</p>\n <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131554547.png\" alt=\"image-20220422131554547\" style=\"zoom: 33%;\" />\n</li>\n<li><p>隔离级别设置为读已提交（RC），事务 A 和事务 B 同时对 core_user 表进行查询和修改操作。</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A: select * fom core_user where id=1</span><br><span class=\"line\">事务B: update core_user set name =”曹操”</span><br><span class=\"line\">// 事务A两次读到的数据不一样，事务A会读到其他事务提交的数据，不能读到其他事务未提交的数据。</span><br></pre></td></tr></table></figure>\n\n<p>执行流程如下：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131620047.png\" alt=\"image-20220422131620047\" style=\"zoom: 33%;\" />\n\n<p>最后事务 A 查询到的结果是，<strong>name&#x3D;曹操</strong>的记录，我们<strong>基于MVCC</strong>，来分析一下执行流程：</p>\n<p>(1) A 开启事务，首先得到一个事务 ID 为 100</p>\n<p>(2) B 开启事务，得到事务 ID 为 101</p>\n<p>(3) 事务 A 生成一个 Read View，read view 对应的值如下</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids（未提交的事务ID）</td>\n<td>100，101</td>\n</tr>\n<tr>\n<td>max_limit_id（下一个应该分配的事务ID）</td>\n<td>102</td>\n</tr>\n<tr>\n<td>min_limit_id（当前read view中活跃的未提交事务的最小值）</td>\n<td>100</td>\n</tr>\n<tr>\n<td>creator_trx_id（创建该read view的事务ID）</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>然后回到版本链：开始从版本链中挑选可见的记录：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131642264.png\" alt=\"image-20220422131642264\" style=\"zoom: 33%;\" />\n\n<p>由图可以看出，最新版本的列 name 的内容是<code>孙权</code>，该版本的<code>trx_id</code>值为 100。开始执行 read view 可见性规则校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（100）&lt;102;</span><br><span class=\"line\">creator_trx_id = trx_id =100;</span><br></pre></td></tr></table></figure>\n\n<p>由此可得，trx_id&#x3D;100 的这个记录，当前事务是可见的。所以查到是 name 为<code>孙权</code>的记录。</p>\n<p>(4) 事务 B 进行修改操作，把名字改为曹操。把原数据拷贝到 undo log,然后对数据进行修改，标记事务 ID 和上一个数据版本在 undo log 的地址。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131733370.png\" alt=\"image-20220422131733370\" style=\"zoom:33%;\" />\n\n<p>(5) 提交事务</p>\n<p>(6) 事务 A 再次执行查询操作，<strong>新生成一个Read View</strong>，Read View 对应的值如下</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids（未提交的事务ID）</td>\n<td>100</td>\n</tr>\n<tr>\n<td>max_limit_id（下一个应当分配的事务ID）</td>\n<td>102</td>\n</tr>\n<tr>\n<td>min_limit_id（最小的事务ID）</td>\n<td>100</td>\n</tr>\n<tr>\n<td>creator_trx_id（创建read view的事务ID）</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>然后再次回到版本链：从版本链中挑选可见的记录：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131753554.png\" alt=\"image-20220422131753554\" style=\"zoom:33%;\" />\n\n<p>从图可得，最新版本的列 name 的内容是<code>曹操</code>，该版本的<code>trx_id</code>值为 101。开始执行 Read View 可见性规则校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（101）&lt;max_limit_id（102);</span><br><span class=\"line\">但是,trx_id=101，不属于m_ids集合，说明101这个事务已经提交了，当前事务可见</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>trx_id=101</code>这个记录，对于当前事务是可见的。所以 SQL 查询到的是 name 为<code>曹操</code>的记录。</p>\n<p>综上所述，在<strong>读已提交（RC）隔离级别</strong>下，同一个事务里，两个相同的查询，读取同一条记录（id&#x3D;1），却返回了不同的数据（<strong>第一次查出来是孙权，第二次查出来是曹操那条记录</strong>），因此 RC 隔离级别，存在<strong>不可重复读</strong>并发问题。</p>\n<h4 id=\"4-3-可重复读（RR）隔离级别，解决不可重复读问题的分析\"><a href=\"#4-3-可重复读（RR）隔离级别，解决不可重复读问题的分析\" class=\"headerlink\" title=\"4.3 可重复读（RR）隔离级别，解决不可重复读问题的分析\"></a>4.3 可重复读（RR）隔离级别，解决不可重复读问题的分析</h4><p>在 RR 隔离级别下，是如何解决不可重复读问题的呢？我们一起再来看下，</p>\n<p>还是 4.2 小节那个流程，还是这个事务 A 和事务 B，如下：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131811671.png\" alt=\"image-20220422131811671\" style=\"zoom:33%;\" />\n\n<h5 id=\"4-3-1-不同隔离级别下，Read-view的工作方式不同\"><a href=\"#4-3-1-不同隔离级别下，Read-view的工作方式不同\" class=\"headerlink\" title=\"4.3.1 不同隔离级别下，Read view的工作方式不同\"></a>4.3.1 不同隔离级别下，Read view的工作方式不同</h5><p>实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟<strong>Read view工作方式有关</strong>。</p>\n<ul>\n<li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n</tbody></table>\n<ul>\n<li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>共用一个Read View副本</td>\n</tr>\n</tbody></table>\n<h5 id=\"4-3-2-实例分析\"><a href=\"#4-3-2-实例分析\" class=\"headerlink\" title=\"4.3.2 实例分析\"></a>4.3.2 实例分析</h5><p>我们穿越下，回到<strong>刚4.2的例子</strong>，然后执行第 2 个查询的时候：</p>\n<p>事务 A 再次执行查询操作，复用老的 Read View 副本，Read View 对应的值如下</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids</td>\n<td>100，101</td>\n</tr>\n<tr>\n<td>max_limit_id</td>\n<td>102</td>\n</tr>\n<tr>\n<td>min_limit_id</td>\n<td>100</td>\n</tr>\n<tr>\n<td>creator_trx_id</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>然后再次回到版本链：从版本链中挑选可见的记录：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131828812.png\" alt=\"image-20220422131828812\" style=\"zoom:33%;\" />\n\n<p>从图可得，最新版本的列 name 的内容是<code>曹操</code>，该版本的<code>trx_id</code>值为 101。开始执行 read view 可见性规则校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（101）&lt;max_limit_id（102);</span><br><span class=\"line\">因为m_ids&#123;100,101&#125;包含trx_id（101），</span><br><span class=\"line\">并且creator_trx_id (100) 不等于trx_id（101）</span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>trx_id=101</code>这个记录，对于当前事务是<strong>不可见</strong>的。这时候呢，版本链<code>roll_pointer</code>跳到下一个版本，<code>trx_id=100</code>这个记录，再次校验是否可见：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（100）&lt; max_limit_id（102);</span><br><span class=\"line\">因为m_ids&#123;100,101&#125;包含trx_id（100），</span><br><span class=\"line\">并且creator_trx_id (100) 等于trx_id（100）</span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>trx_id=100</code>这个记录，对于当前事务是<strong>可见</strong>的。即在可重复读（RR）隔离级别下，复用老的 Read View 副本，解决了<strong>不可重复读</strong>的问题。</p>\n<h4 id=\"4-4-MVCC是否解决了幻读问题呢？\"><a href=\"#4-4-MVCC是否解决了幻读问题呢？\" class=\"headerlink\" title=\"4.4 MVCC是否解决了幻读问题呢？\"></a>4.4 MVCC是否解决了幻读问题呢？</h4><p>对于幻读来说，存在当前读和快照读的情况：</p>\n<ol>\n<li>RR 隔离级别下为了解决幻读问题：<strong>快照读依靠MVCC控制，当前读通过间隙锁解决</strong>；</li>\n<li>间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；</li>\n<li>间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度。</li>\n</ol>\n<p>作者：捡田螺的小男孩</p>\n<p>链接：<a href=\"https://juejin.cn/post/7016165148020703246\">https://juejin.cn/post/7016165148020703246</a></p>\n<p>来源：稀土掘金</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"MySQL锁篇\"><a href=\"#MySQL锁篇\" class=\"headerlink\" title=\"MySQL锁篇\"></a>MySQL锁篇</h2><h3 id=\"什么是锁？MySQL-中提供了几类锁？\"><a href=\"#什么是锁？MySQL-中提供了几类锁？\" class=\"headerlink\" title=\"什么是锁？MySQL 中提供了几类锁？\"></a>什么是锁？MySQL 中提供了几类锁？</h3><p>锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。</p>\n<p>排他锁（写锁），共享锁（读锁）<br>乐观锁，悲观锁<br>全局锁，表锁，行锁，页锁</p>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>\n<h3 id=\"如何处理死锁？\"><a href=\"#如何处理死锁？\" class=\"headerlink\" title=\"如何处理死锁？\"></a>如何处理死锁？</h3><p>对待死锁常见的两种策略：</p>\n<ul>\n<li><p>设置超时时间</p>\n</li>\n<li><p>发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</p>\n</li>\n</ul>\n<h3 id=\"如何避免死锁？\"><a href=\"#如何避免死锁？\" class=\"headerlink\" title=\"如何避免死锁？\"></a>如何避免死锁？</h3><p>使用 SELECT … FOR UPDATE 语句来获取必要的锁。</p>\n<h3 id=\"什么是全局锁？它的应用场景有哪些？\"><a href=\"#什么是全局锁？它的应用场景有哪些？\" class=\"headerlink\" title=\"什么是全局锁？它的应用场景有哪些？\"></a>什么是全局锁？它的应用场景有哪些？</h3><p>全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。</p>\n<h3 id=\"什么是共享锁？\"><a href=\"#什么是共享锁？\" class=\"headerlink\" title=\"什么是共享锁？\"></a>什么是共享锁？</h3><p>共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p>\n<h3 id=\"什么是排它锁？\"><a href=\"#什么是排它锁？\" class=\"headerlink\" title=\"什么是排它锁？\"></a>什么是排它锁？</h3><p>排他锁 exclusive lock（也叫 writer lock）又称写锁。</p>\n<p>若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。</p>\n<p>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。</p>\n<h3 id=\"使用全局锁会导致什么问题？\"><a href=\"#使用全局锁会导致什么问题？\" class=\"headerlink\" title=\"使用全局锁会导致什么问题？\"></a>使用全局锁会导致什么问题？</h3><p>如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。</p>\n<p>如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。</p>\n<p>如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQL dump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。</p>\n<h3 id=\"悲观锁和乐观锁有什么区别？\"><a href=\"#悲观锁和乐观锁有什么区别？\" class=\"headerlink\" title=\"悲观锁和乐观锁有什么区别？\"></a>悲观锁和乐观锁有什么区别？</h3><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p>\n<p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p>\n<p><strong>乐观锁是用数据版本（Version）记录机制实现</strong>，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</p>\n<h3 id=\"乐观锁有什么优点和缺点？\"><a href=\"#乐观锁有什么优点和缺点？\" class=\"headerlink\" title=\"乐观锁有什么优点和缺点？\"></a>乐观锁有什么优点和缺点？</h3><p>因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。</p>\n<h3 id=\"⭐InnoDB-存储引擎有几种锁算法？\"><a href=\"#⭐InnoDB-存储引擎有几种锁算法？\" class=\"headerlink\" title=\"⭐InnoDB 存储引擎有几种锁算法？\"></a>⭐InnoDB 存储引擎有几种锁算法？</h3><ul>\n<li><p>Record Lock — 单个行记录上的锁；</p>\n</li>\n<li><p>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</p>\n</li>\n<li><p>Next-Key Lock（包含行锁和间隙锁） — 锁定一个范围，包括记录本身。</p>\n</li>\n</ul>\n<h3 id=\"InnoDB-如何实现行锁？\"><a href=\"#InnoDB-如何实现行锁？\" class=\"headerlink\" title=\"InnoDB 如何实现行锁？\"></a>InnoDB 如何实现行锁？</h3><p>共享锁：<strong>in share mode</strong></p>\n<p>排他锁：<strong>for update</strong></p>\n<h3 id=\"优化锁方面你有什么建议？\"><a href=\"#优化锁方面你有什么建议？\" class=\"headerlink\" title=\"优化锁方面你有什么建议？\"></a>优化锁方面你有什么建议？</h3><ul>\n<li>尽量使用较低的隔离级别。</li>\n<li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</li>\n<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>\n<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>\n<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</li>\n<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>\n<li>不要申请超过实际需要的锁级别。</li>\n<li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</li>\n<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>\n</ul>\n<h3 id=\"MySQL-中有哪几种锁？\"><a href=\"#MySQL-中有哪几种锁？\" class=\"headerlink\" title=\"MySQL 中有哪几种锁？\"></a>MySQL 中有哪几种锁？</h3><p><strong>1、表级锁：</strong> 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。</p>\n<p><strong>2、行级锁：</strong>  开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。</p>\n<p><strong>3、页锁：</strong>  开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。</p>\n<h3 id=\"锁机制与InnoDB锁算法\"><a href=\"#锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"锁机制与InnoDB锁算法\"></a>锁机制与InnoDB锁算法</h3><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM 采用表级锁(table-level locking)。</li>\n<li>InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li>\n</ul>\n<p><strong>表级锁和行级锁对比：</strong></p>\n<ul>\n<li><p><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</p>\n</li>\n<li><p><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>\n</li>\n</ul>\n<h3 id=\"锁的优化策略\"><a href=\"#锁的优化策略\" class=\"headerlink\" title=\"锁的优化策略\"></a>锁的优化策略</h3><p><strong>1、</strong> 读写分离</p>\n<p><strong>2、</strong> 分段加锁</p>\n<p><strong>3、</strong> 减少锁持有的时间</p>\n<p>多个线程尽量以相同的顺序去获取资源</p>\n<p>不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大锁。</p>\n<h2 id=\"MySQL日志篇\"><a href=\"#MySQL日志篇\" class=\"headerlink\" title=\"MySQL日志篇\"></a>MySQL日志篇</h2><h3 id=\"MySQL-有哪些重要的日志文件？\"><a href=\"#MySQL-有哪些重要的日志文件？\" class=\"headerlink\" title=\"MySQL 有哪些重要的日志文件？\"></a>MySQL 有哪些重要的日志文件？</h3><p>MySQL 中的重要日志分为以下几个：</p>\n<p><strong>① 错误日志：</strong>用来记录 MySQL 服务器运行过程中的错误信息</p>\n<p><strong>② 查询日志</strong>：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p>\n<ul>\n<li><p>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</p>\n</li>\n<li><p>update 时也会查询因为更新的时候很可能会更新某一块数据；</p>\n</li>\n<li><p>delete 查询，只删除符合条件的数据；</p>\n</li>\n</ul>\n<p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p>\n<p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。</p>\n<p><strong>③ 慢日志</strong>：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global slowquerylog=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>使用 set global slow<em>query</em>log&#x3D;’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf，设置 slow<em>query</em>log&#x3D;1 并重启 MySQL 服务器。</p>\n<p><strong>④ redo log（重做日志）</strong>：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。</p>\n<p><strong>⑤ undo log（回滚日志）</strong>：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>\n<p><strong>⑥ bin log（二进制日志）</strong>：是一个二进制文件，主要<strong>记录了对 MySQL 数据库执行更改的所有操作</strong>，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，不记录 SELECT、SHOW 等那些不修改数据或数据库结构的 SQL 语句。</p>\n<p>binlog 的作用如下：</p>\n<ul>\n<li><p>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</p>\n</li>\n<li><p>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</p>\n</li>\n<li><p>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p>\n</li>\n</ul>\n<p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p>\n<p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin &#x3D; [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p>\n<p>通过以下命令来查询 binlog 是否开启：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#x27;log_%&#x27;; </span><br></pre></td></tr></table></figure>\n\n<p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p>\n<ul>\n<li><p>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</p>\n</li>\n<li><p>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</p>\n</li>\n<li><p>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT<em>USER()、ROW</em>COUNT() 等无法确定的函数。</p>\n</li>\n</ul>\n<h3 id=\"redo-log-和-binlog-有什么区别？\"><a href=\"#redo-log-和-binlog-有什么区别？\" class=\"headerlink\" title=\"redo log 和 binlog 有什么区别？\"></a>redo log 和 binlog 有什么区别？</h3><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p>\n<ul>\n<li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p>\n</li>\n<li><p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</p>\n</li>\n<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>\n</li>\n<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>\n</li>\n</ul>\n<p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p>\n<h3 id=\"什么是-crash-safe？\"><a href=\"#什么是-crash-safe？\" class=\"headerlink\" title=\"什么是 crash-safe？\"></a>什么是 crash-safe？</h3><p>crash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。</p>\n<h3 id=\"什么是脏页和干净页？\"><a href=\"#什么是脏页和干净页？\" class=\"headerlink\" title=\"什么是脏页和干净页？\"></a>什么是脏页和干净页？</h3><p>MySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。</p>\n<h3 id=\"什么情况下会引发-MySQL-刷脏页（flush）的操作？\"><a href=\"#什么情况下会引发-MySQL-刷脏页（flush）的操作？\" class=\"headerlink\" title=\"什么情况下会引发 MySQL 刷脏页（flush）的操作？\"></a>什么情况下会引发 MySQL 刷脏页（flush）的操作？</h3><ul>\n<li><p>内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；</p>\n</li>\n<li><p>系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；</p>\n</li>\n<li><p>系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；</p>\n</li>\n<li><p>MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-刷脏页的速度很慢可能是什么原因？\"><a href=\"#MySQL-刷脏页的速度很慢可能是什么原因？\" class=\"headerlink\" title=\"MySQL 刷脏页的速度很慢可能是什么原因？\"></a>MySQL 刷脏页的速度很慢可能是什么原因？</h3><p>在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。</p>\n<h3 id=\"如何控制-MySQL-只刷新当前脏页？\"><a href=\"#如何控制-MySQL-只刷新当前脏页？\" class=\"headerlink\" title=\"如何控制 MySQL 只刷新当前脏页？\"></a>如何控制 MySQL 只刷新当前脏页？</h3><p>在 InnoDB 中设置 innodb<em>flush</em>neighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。</p>\n<h3 id=\"MySQL-的-WAL-技术是解决什么问题的？\"><a href=\"#MySQL-的-WAL-技术是解决什么问题的？\" class=\"headerlink\" title=\"MySQL 的 WAL 技术是解决什么问题的？\"></a>MySQL 的 WAL 技术是解决什么问题的？</h3><p>A.防止误删除，找回数据用的 B.容灾恢复，为了还原异常数据用的 C.事务处理，为了数据库的稳定性 D.为了降低 IO 成本 答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。</p>\n<h3 id=\"为什么有时候会感觉-MySQL-偶尔卡一下？\"><a href=\"#为什么有时候会感觉-MySQL-偶尔卡一下？\" class=\"headerlink\" title=\"为什么有时候会感觉 MySQL 偶尔卡一下？\"></a>为什么有时候会感觉 MySQL 偶尔卡一下？</h3><p>如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。</p>\n<h3 id=\"redo-log-和-binlog-是怎么关联的\"><a href=\"#redo-log-和-binlog-是怎么关联的\" class=\"headerlink\" title=\"redo log 和 binlog 是怎么关联的?\"></a>redo log 和 binlog 是怎么关联的?</h3><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p>\n<ul>\n<li><p>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</p>\n</li>\n<li><p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-怎么知道-binlog-是完整的\"><a href=\"#MySQL-怎么知道-binlog-是完整的\" class=\"headerlink\" title=\"MySQL 怎么知道 binlog 是完整的?\"></a>MySQL 怎么知道 binlog 是完整的?</h3><ul>\n<li><p>statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。</p>\n</li>\n<li><p>row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-中可不可以只要-binlog，不要-redo-log？\"><a href=\"#MySQL-中可不可以只要-binlog，不要-redo-log？\" class=\"headerlink\" title=\"MySQL 中可不可以只要 binlog，不要 redo log？\"></a>MySQL 中可不可以只要 binlog，不要 redo log？</h3><p>不可以，binlog 没有崩溃恢复的能力。</p>\n<h3 id=\"MySQL-中可不可以只要-redo-log，不要-binlog？\"><a href=\"#MySQL-中可不可以只要-redo-log，不要-binlog？\" class=\"headerlink\" title=\"MySQL 中可不可以只要 redo log，不要 binlog？\"></a>MySQL 中可不可以只要 redo log，不要 binlog？</h3><p>不可以，原因有以下两个：</p>\n<ul>\n<li><p>redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；</p>\n</li>\n<li><p>binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。</p>\n</li>\n</ul>\n<h3 id=\"为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？\"><a href=\"#为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？\" class=\"headerlink\" title=\"为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？\"></a>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</h3><p>因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>\n<h3 id=\"事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？\"><a href=\"#事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？\" class=\"headerlink\" title=\"事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？\"></a>事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？</h3><p>不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p>\n<h3 id=\"在-MySQL-中用什么机制来优化随机读-x2F-写磁盘对-IO-的消耗？\"><a href=\"#在-MySQL-中用什么机制来优化随机读-x2F-写磁盘对-IO-的消耗？\" class=\"headerlink\" title=\"在 MySQL 中用什么机制来优化随机读&#x2F;写磁盘对 IO 的消耗？\"></a>在 MySQL 中用什么机制来优化随机读&#x2F;写磁盘对 IO 的消耗？</h3><p>redo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。</p>\n<h3 id=\"以下说法错误的是？\"><a href=\"#以下说法错误的是？\" class=\"headerlink\" title=\"以下说法错误的是？\"></a>以下说法错误的是？</h3><p>A.redo log 是 InnoDB 引擎特有的，它的固定大小的 B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关 C.redo log 可以保证数据库异常重启之后，数据不丢失 D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。</p>\n<h3 id=\"以下说法正确的是？\"><a href=\"#以下说法正确的是？\" class=\"headerlink\" title=\"以下说法正确的是？\"></a>以下说法正确的是？</h3><p>A.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志 B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志 C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 D.以上说法都正确 答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。</p>\n<h3 id=\"有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？\"><a href=\"#有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？\" class=\"headerlink\" title=\"有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？\"></a>有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？</h3><p>可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。</p>\n<h2 id=\"MySQL性能优化\"><a href=\"#MySQL性能优化\" class=\"headerlink\" title=\"MySQL性能优化\"></a>MySQL性能优化</h2><h3 id=\"MySQL-性能指标都有哪些？如何得到这些指标？\"><a href=\"#MySQL-性能指标都有哪些？如何得到这些指标？\" class=\"headerlink\" title=\"MySQL 性能指标都有哪些？如何得到这些指标？\"></a>MySQL 性能指标都有哪些？如何得到这些指标？</h3><p>MySQL 的性能指标如下：</p>\n<p><strong>① TPS（Transaction Per Second）</strong> 每秒事务数，即数据库每秒执行的事务数。</p>\n<p>MySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。</p>\n<p>需要使用的参数：</p>\n<ul>\n<li><p>Com_commit ：表示提交次数，通过命令 <code>show global status like &#39;Com_commit&#39;;</code> 获取；</p>\n</li>\n<li><p>Com_rollback：表示回滚次数，通过命令 <code>show global status like &#39;Com_rollback&#39;;</code> 获取。</p>\n</li>\n</ul>\n<p>我们定义第一次获取的 Com<em>commit 的值与 Com</em>rollback 值的和为 c_r1，时间为 t1；</p>\n<p>第二次获取的 Com<em>commit 的值与 Com</em>rollback 值的和为 c<em>r2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS &#x3D; ( c</em>r2 - c_r1 ) &#x2F; ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。</p>\n<p><strong>② QPS（Query Per Second）</strong> 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS &#x3D; Queries &#x2F; Seconds Queries 是系统状态值—总查询次数，可以通过 <code>show status like &#39;queries&#39;;</code> 查询得出 </p>\n<p>Seconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：</p>\n<blockquote>\n<p>QPS &#x3D; (Q2 - Q1) &#x2F; 10</p>\n</blockquote>\n<p><strong>③ IOPS（Input&#x2F;Output Operations per Second）</strong> 每秒处理的 I&#x2F;O 请求次数。</p>\n<p>IOPS 是判断磁盘 I&#x2F;O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I&#x2F;O 就不会是瓶颈了。</p>\n<p>注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。</p>\n<p>可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：</p>\n<blockquote>\n<p>yum install sysstat iostat -dx 1 10</p>\n</blockquote>\n<p>执行效果如下图所示： </p>\n<p>IOPS &#x3D; r&#x2F;s + w&#x2F;s 其中：</p>\n<ul>\n<li><p>r&#x2F;s：代表每秒读了多少次；</p>\n</li>\n<li><p>w&#x2F;s：代表每秒写了多少次。</p>\n</li>\n</ul>\n<h3 id=\"什么是慢查询？\"><a href=\"#什么是慢查询？\" class=\"headerlink\" title=\"什么是慢查询？\"></a>什么是慢查询？</h3><p>慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 <em>longquerytime</em> 值的 SQL，则会被记录到慢查询日志中。 <em>longquerytime</em> 的默认值为 10，意思是运行 10s 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>\n<p>使用 <code>mysql&gt; show variables like &#39;%slow_query_log%&#39;;</code> 来查询慢查询日志是否开启</p>\n<h3 id=\"如何开启慢查询日志？\"><a href=\"#如何开启慢查询日志？\" class=\"headerlink\" title=\"如何开启慢查询日志？\"></a>如何开启慢查询日志？</h3><p>开启慢查询日志，可以使用如下 MySQL 命令：</p>\n<blockquote>\n<p>mysql&gt; set global slow<em>query</em>log&#x3D;1</p>\n</blockquote>\n<p>不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：</p>\n<blockquote>\n<p>slow<em>query</em>log &#x3D;1 slow<em>query</em>log<em>file&#x3D;&#x2F;tmp&#x2F;mysql</em>slow.log</p>\n</blockquote>\n<h3 id=\"如何定位慢查询？\"><a href=\"#如何定位慢查询？\" class=\"headerlink\" title=\"如何定位慢查询？\"></a>如何定位慢查询？</h3><p>使用 MySQL 中的 explain 分析执行语句，比如：</p>\n<blockquote>\n<p>explain select * from t where id&#x3D;5;</p>\n</blockquote>\n<p>如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-2ff861def7876a91.png\" alt=\"avatar\"> </p>\n<p>其中：</p>\n<ul>\n<li><p>id — 选择标识符。id 越大优先级越高，越先被执行。</p>\n</li>\n<li><p>select_type — 表示查询的类型。</p>\n</li>\n<li><p>table — 输出结果集的表</p>\n</li>\n<li><p>partitions — 匹配的分区</p>\n</li>\n<li><p>type — 表示表的连接类型</p>\n</li>\n<li><p>possible_keys — 表示查询时，可能使用的索引</p>\n</li>\n<li><p>key — 表示实际使用的索引</p>\n</li>\n<li><p>key_len — 索引字段的长度</p>\n</li>\n<li><p>ref— 列与索引的比较</p>\n</li>\n<li><p>rows — 大概估算的行数</p>\n</li>\n<li><p>filtered — 按表条件过滤的行百分比</p>\n</li>\n<li><p>Extra — 执行情况的描述和说明</p>\n</li>\n</ul>\n<p>其中最重要的就是 type 字段，type 值类型如下：</p>\n<ul>\n<li><p>all — 扫描全表数据</p>\n</li>\n<li><p>index — 遍历索引</p>\n</li>\n<li><p>range — 索引范围查找</p>\n</li>\n<li><p>index_subquery — 在子查询中使用 ref</p>\n</li>\n<li><p>uniquesubquery — 在子查询中使用 eq*ref</p>\n</li>\n<li><p>ref<em>or</em>null — 对 null 进行索引的优化的 ref</p>\n</li>\n<li><p>fulltext — 使用全文索引</p>\n</li>\n<li><p>ref — 使用非唯一索引查找数据</p>\n</li>\n<li><p>eq_ref — 在 join 查询中使用主键或唯一索引关联</p>\n</li>\n<li><p>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</p>\n</li>\n</ul>\n<h3 id=\"⭐MySQL-的优化手段都有哪些？\"><a href=\"#⭐MySQL-的优化手段都有哪些？\" class=\"headerlink\" title=\"⭐MySQL 的优化手段都有哪些？\"></a>⭐MySQL 的优化手段都有哪些？</h3><p>MySQL 的常见的优化手段有以下五种：</p>\n<h4 id=\"①-查询优化\"><a href=\"#①-查询优化\" class=\"headerlink\" title=\"① 查询优化\"></a>① 查询优化</h4><ul>\n<li><p>避免 SELECT *，只查询需要的字段。</p>\n</li>\n<li><p>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p>\n</li>\n<li><p>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p>\n</li>\n</ul>\n<h4 id=\"②-优化索引的使用\"><a href=\"#②-优化索引的使用\" class=\"headerlink\" title=\"② 优化索引的使用\"></a>② 优化索引的使用</h4><ul>\n<li><p>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p>\n</li>\n<li><p>不做列运算，把计算都放入各个业务系统实现</p>\n</li>\n<li><p>查询语句尽可能简单，大语句拆小语句，减少锁时间</p>\n</li>\n<li><p>不使用 select * 查询</p>\n</li>\n<li><p>or 查询改写成 in 查询</p>\n</li>\n<li><p>不用函数和触发器</p>\n</li>\n<li><p>避免 %xx 查询</p>\n</li>\n<li><p>少用 join 查询</p>\n</li>\n<li><p>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</p>\n</li>\n<li><p>尽量避免在 where 子句中使用 !&#x3D; 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</p>\n</li>\n<li><p>避免在索引列上使用 is null 和 is not null</p>\n</li>\n<li><p>尽量使用主键查询</p>\n</li>\n<li><p>避免在 where 子句中对字段进行表达式操作</p>\n</li>\n<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p>\n</li>\n</ul>\n<h4 id=\"③-表结构设计优化\"><a href=\"#③-表结构设计优化\" class=\"headerlink\" title=\"③ 表结构设计优化\"></a>③ 表结构设计优化</h4><ul>\n<li><p>使用可以存下数据最小的数据类型。</p>\n</li>\n<li><p>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p>\n</li>\n<li><p>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p>\n</li>\n<li><p>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p>\n</li>\n<li><p>尽量少用 text 类型，非用不可时最好考虑分表。</p>\n</li>\n<li><p>尽量使用 timestamp，而非 datetime。</p>\n</li>\n<li><p>单表不要有太多字段，建议在 20 个字段以内。</p>\n</li>\n</ul>\n<h4 id=\"④-表拆分\"><a href=\"#④-表拆分\" class=\"headerlink\" title=\"④ 表拆分\"></a>④ 表拆分</h4><p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 </p>\n<p><strong>a）垂直拆分</strong>：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p>\n<ul>\n<li><p>把不常用的字段单独放在一张表；</p>\n</li>\n<li><p>把 text，blob 等大字段拆分出来放在附表中；</p>\n</li>\n<li><p>经常组合查询的列放在一张表中。</p>\n</li>\n</ul>\n<p><strong>b）水平拆分</strong>：指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p>\n<p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p>\n<h4 id=\"⑤-读写分离\"><a href=\"#⑤-读写分离\" class=\"headerlink\" title=\"⑤ 读写分离\"></a>⑤ 读写分离</h4><p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p>\n<h3 id=\"MySQL-常见读写分离方案有哪些？\"><a href=\"#MySQL-常见读写分离方案有哪些？\" class=\"headerlink\" title=\"MySQL 常见读写分离方案有哪些？\"></a>MySQL 常见读写分离方案有哪些？</h3><p>MySQL 常见的读写分离方案，如下列表：</p>\n<p><strong>1）应用层解决方案</strong> 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。</p>\n<p><strong>2）中间件解决方案</strong> 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。</p>\n<h3 id=\"怎样保证确保备库无延迟？\"><a href=\"#怎样保证确保备库无延迟？\" class=\"headerlink\" title=\"怎样保证确保备库无延迟？\"></a>怎样保证确保备库无延迟？</h3><p>通常保证主备无延迟有以下三种方法：</p>\n<ul>\n<li><p>每次从库执行查询请求前，先判断 seconds<em>behind</em>master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds<em>behind</em>master 参数是用来衡量主备延迟时间的长短；</p>\n</li>\n<li><p>对比位点确保主备无延迟。Master<em>Log</em>File 和 Read<em>Master</em>Log<em>Pos，表示的是读到的主库的最新位点，Relay</em>Master<em>Log</em>File 和 Exec<em>Master</em>Log_Pos，表示的是备库执行的最新位点；</p>\n</li>\n<li><p>对比 GTID 集合确保主备无延迟。Auto<em>Position&#x3D;1 ，表示这对主备关系使用了 GTID 协议；Retrieved</em>Gtid<em>Set，是备库收到的所有日志的 GTID 集合；Executed</em>Gtid_Set，是备库所有已经执行完成的 GTID 集合。</p>\n</li>\n</ul>\n<h2 id=\"MySQL开放问题\"><a href=\"#MySQL开放问题\" class=\"headerlink\" title=\"MySQL开放问题\"></a>MySQL开放问题</h2><h3 id=\"有一个超级大表，如何优化分页查询？\"><a href=\"#有一个超级大表，如何优化分页查询？\" class=\"headerlink\" title=\"有一个超级大表，如何优化分页查询？\"></a>有一个超级大表，如何优化分页查询？</h3><p>超级大表的分页优化分有以下两种方式：</p>\n<ul>\n<li><p>数据库层面优化：利用子查询优化超多分页场景，比如：<code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code> ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，<br><strong>利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现</strong>；</p>\n</li>\n<li><p>程序层面优化：可以利用<strong>缓存</strong>把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。</p>\n</li>\n</ul>\n<h3 id=\"⭐查询长时间不返回可能是什么原因？应该如何处理？\"><a href=\"#⭐查询长时间不返回可能是什么原因？应该如何处理？\" class=\"headerlink\" title=\"⭐查询长时间不返回可能是什么原因？应该如何处理？\"></a>⭐查询长时间不返回可能是什么原因？应该如何处理？</h3><p>查询速度慢的原因很多，常见如下几种：</p>\n<p> 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： </p>\n<ul>\n<li><p>以 % 开头的 like 查询</p>\n</li>\n<li><p>数据类型出现隐式转换时不会使用索引</p>\n</li>\n<li><p>不符合最左前缀原则；</p>\n</li>\n<li><p>如果查询条件有 or 分割，如果有 or 的字段没有索引，会引起全表查询；</p>\n</li>\n<li><p>如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。</p>\n</li>\n</ul>\n<p>2）I&#x2F;O 压力大，读取磁盘速度变慢，df 看硬盘</p>\n<p>3）内存不足，free 看内存（top 看 cpu）</p>\n<p>4）网络速度慢 </p>\n<p>5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 </p>\n<p>6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 <code>show processlist;</code> 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-1a918d44eacc26e6.png\" alt=\"avatar\"> </p>\n<p>其中，当 State 列值为 Locked 时，表示被锁定。</p>\n<p>以上问题的解决方案如下：</p>\n<p>1）正确创建和使用索引。 </p>\n<p>2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 </p>\n<p>3）升级内存，更换更大的内存。 </p>\n<p>4）提升网速，升级带宽。 </p>\n<p>5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 </p>\n<p>6）查询时值返回需要的字段。 </p>\n<p>7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。</p>\n<h3 id=\"MySQL-主从延迟的原因有哪些？\"><a href=\"#MySQL-主从延迟的原因有哪些？\" class=\"headerlink\" title=\"MySQL 主从延迟的原因有哪些？\"></a>MySQL 主从延迟的原因有哪些？</h3><p>主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： <code>show slave status;</code>，其中 Seconds<em>Behind</em>Master 如果为 0 表示主从复制状态正常。 导致主从延迟的原因有以下几个：</p>\n<ul>\n<li><p>主库有大事务处理；</p>\n</li>\n<li><p>主库做大量的增、删、改操作；</p>\n</li>\n<li><p>主库对大表进行字段新增、修改或添加索引等操作；</p>\n</li>\n<li><p>主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；</p>\n</li>\n<li><p>从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；</p>\n</li>\n<li><p>主库读写压力大，导致复制延迟；</p>\n</li>\n<li><p>从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。</p>\n</li>\n</ul>\n<h3 id=\"如何保证数据不被误删？\"><a href=\"#如何保证数据不被误删？\" class=\"headerlink\" title=\"如何保证数据不被误删？\"></a>如何保证数据不被误删？</h3><p>保证数据不被误删的方法如下列表：</p>\n<ul>\n<li><p>权限控制与分配（数据库和服务器权限）</p>\n</li>\n<li><p>避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；</p>\n</li>\n<li><p>重要的数据库操作，通过平台型工具自动实施，减少人工操作；</p>\n</li>\n<li><p>部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；</p>\n</li>\n<li><p>确认备份制度及时有效；</p>\n</li>\n<li><p>启用 SQL 审计功能，养成良好 SQL 习惯；</p>\n</li>\n<li><p>启用 sql<em>safe</em>updates 选项，不允许没 where 条件的更新&#x2F;删除；</p>\n</li>\n<li><p>将系统层的 rm 改为 mv；</p>\n</li>\n<li><p>线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；</p>\n</li>\n<li><p>启用堡垒机，屏蔽高危 SQL；</p>\n</li>\n<li><p>降低数据库中普通账号的权限级别；</p>\n</li>\n<li><p>开启 binlog，方便追溯数据。</p>\n</li>\n</ul>\n<h3 id=\"⭐MySQL-服务器-CPU-飙升应该如何处理？\"><a href=\"#⭐MySQL-服务器-CPU-飙升应该如何处理？\" class=\"headerlink\" title=\"⭐MySQL 服务器 CPU 飙升应该如何处理？\"></a>⭐MySQL 服务器 CPU 飙升应该如何处理？</h3><p>使用 <code>show full processlist;</code> 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，然后再去项目中找到执行慢的 SQL 语句进行修改和优化。</p>\n<h3 id=\"MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？\"><a href=\"#MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？\" class=\"headerlink\" title=\"MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？\"></a>MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h3><p>可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p>\n<ul>\n<li><p>定期断开空闲的长连接；</p>\n</li>\n<li><p>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql<em>reset</em>connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</p>\n</li>\n</ul>\n<h3 id=\"如何实现一个高并发的系统？\"><a href=\"#如何实现一个高并发的系统？\" class=\"headerlink\" title=\"如何实现一个高并发的系统？\"></a>如何实现一个高并发的系统？</h3><p>这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。</p>\n<h4 id=\"1）前端优化\"><a href=\"#1）前端优化\" class=\"headerlink\" title=\"1）前端优化\"></a>1）前端优化</h4><p>① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。<br>② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。<br>③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。</p>\n<h4 id=\"2）中间层负载分发\"><a href=\"#2）中间层负载分发\" class=\"headerlink\" title=\"2）中间层负载分发\"></a>2）中间层负载分发</h4><p>可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：</p>\n<p>① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 ② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    server 192.168.0.14 weight=10; </span><br><span class=\"line\">    server 192.168.0.15 weight=10; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    ip_hash; </span><br><span class=\"line\">    server 192.168.0.14:88; </span><br><span class=\"line\">    server 192.168.0.15:80; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    fair; </span><br><span class=\"line\">    server server1.com; </span><br><span class=\"line\">    server server2.com; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123;</span><br><span class=\"line\">    hash $request_uri;</span><br><span class=\"line\">    server server1.com; </span><br><span class=\"line\">    server server2.com;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）控制层（网关层）\"><a href=\"#3）控制层（网关层）\" class=\"headerlink\" title=\"3）控制层（网关层）\"></a>3）控制层（网关层）</h4><p>限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。</p>\n<h4 id=\"4）服务层\"><a href=\"#4）服务层\" class=\"headerlink\" title=\"4）服务层\"></a>4）服务层</h4><p>① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。<br>② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。<br>③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。</p>\n<h4 id=\"5）数据库层\"><a href=\"#5）数据库层\" class=\"headerlink\" title=\"5）数据库层\"></a>5）数据库层</h4><p>① 合理使用数据库引擎 ② 合理设置事务隔离级别，合理使用事务 ③ 正确使用 SQL 语句和查询索引 ④ 合理分库分表 ⑤ 使用数据库中间件实现数据库读写分离 ⑥ 设置数据库主从读写分离</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"查询语句不同元素（where、jion、limit、group-by、having-等等）执行先后顺序？\"><a href=\"#查询语句不同元素（where、jion、limit、group-by、having-等等）执行先后顺序？\" class=\"headerlink\" title=\"查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？\"></a>查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？</h3><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为 <code>select--from--where--group by--having--order by</code></p>\n<p>其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序 与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行</p>\n<ul>\n<li>from:需要从哪个数据表检索数据</li>\n<li>where:过滤表中数据的条件</li>\n<li>group by:如何将上面过滤出的数据分组</li>\n<li>having:对上面已经分组的数据进行过滤的条件</li>\n<li>select:查看结果集中的哪个列，或列的计算结果</li>\n<li>order by :按照什么样的顺序来查看返回的数据</li>\n</ul>\n<p>from 后面的表关联，是自右向左解析 而 where 条件的解析顺序是自下而上的。</p>\n<p>也就是说，在写 SQL 文的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在 where 语句的最左边 （用小表去匹配大表）</p>\n<h3 id=\"非关系型数据库和关系型数据库区别，优势比较？\"><a href=\"#非关系型数据库和关系型数据库区别，优势比较？\" class=\"headerlink\" title=\"非关系型数据库和关系型数据库区别，优势比较？\"></a>非关系型数据库和关系型数据库区别，优势比较？</h3><h4 id=\"非关系型数据库的优势\"><a href=\"#非关系型数据库的优势\" class=\"headerlink\" title=\"非关系型数据库的优势\"></a>非关系型数据库的优势</h4><p><strong>1. 性能</strong></p>\n<p>NOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。</p>\n<p><strong>2. 可扩展性</strong></p>\n<p>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>\n<h4 id=\"关系型数据库的优势\"><a href=\"#关系型数据库的优势\" class=\"headerlink\" title=\"关系型数据库的优势\"></a>关系型数据库的优势</h4><p><strong>1. 复杂查询</strong></p>\n<p>可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>\n<p><strong>2. 事务支持</strong></p>\n<p>使得对于安全性能很高的数据访问要求得以实现。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><strong>对于这两类数据库，对方的优势就是自己的弱势，反之亦然</strong>。</p>\n<p>NOSQL 数据库慢慢开始具备 SQL 数据库的一些复杂查询功能，比如 MongoDB。</p>\n<p>对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如 Redis set nx。</p>\n<h3 id=\"数据库三范式，根据某个场景设计数据表？\"><a href=\"#数据库三范式，根据某个场景设计数据表？\" class=\"headerlink\" title=\"数据库三范式，根据某个场景设计数据表？\"></a>数据库三范式，根据某个场景设计数据表？</h3><ul>\n<li>所有字段值都是不可分解的原子值。</li>\n<li>在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>\n<li>数据表中的每一列数据都和主键直接相关，而不能间接相关。</li>\n</ul>\n<h4 id=\"第一范式-确保每列保持原子性\"><a href=\"#第一范式-确保每列保持原子性\" class=\"headerlink\" title=\"第一范式(确保每列保持原子性)\"></a>第一范式(确保每列保持原子性)</h4><p><strong>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式</strong>。</p>\n<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>\n<p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>\n<h4 id=\"第二范式-确保表中的每列都和主键相关\"><a href=\"#第二范式-确保表中的每列都和主键相关\" class=\"headerlink\" title=\"第二范式(确保表中的每列都和主键相关)\"></a>第二范式(确保表中的每列都和主键相关)</h4><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。<strong>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中</strong>。</p>\n<p><strong>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键</strong>。</p>\n<h4 id=\"第三范式-确保每列都和主键列直接相关-而不是间接相关\"><a href=\"#第三范式-确保每列都和主键列直接相关-而不是间接相关\" class=\"headerlink\" title=\"第三范式(确保每列都和主键列直接相关,而不是间接相关)\"></a>第三范式(确保每列都和主键列直接相关,而不是间接相关)</h4><p>第三范式需要确保数据表中的<strong>每一列数据都和主键直接相关，而不能间接相关</strong>。</p>\n<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>\n<h3 id=\"MySQL-高并发环境解决方案？\"><a href=\"#MySQL-高并发环境解决方案？\" class=\"headerlink\" title=\"MySQL 高并发环境解决方案？\"></a>MySQL 高并发环境解决方案？</h3><p>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。</p>\n<p><strong>需求分析</strong>：互联网单位 每天大量数据读取，写入，并发性高。</p>\n<ul>\n<li><strong>现有解决方式</strong>：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</li>\n<li><strong>集群方案</strong>：解决 DB 宕机带来的单点 DB 不能访问问题。</li>\n<li><strong>读写分离策略</strong>：极大限度提高了应用中 Read 数据的速度和并发量。无法解决高写入压力。</li>\n</ul>\n<h3 id=\"数据库崩溃时事务的恢复机制（REDO-日志和-UNDO-日志）？\"><a href=\"#数据库崩溃时事务的恢复机制（REDO-日志和-UNDO-日志）？\" class=\"headerlink\" title=\"数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）？\"></a>数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）？</h3><h4 id=\"Undo-Log\"><a href=\"#Undo-Log\" class=\"headerlink\" title=\"Undo Log\"></a>Undo Log</h4><p><strong>Undo Log 是为了实现事务的原子性</strong>，在 MySQL 数据库 InnoDB 存储引擎中，还用了 Undo Log 来实现多版本并发控制(简称：MVCC)。</p>\n<ul>\n<li><strong>事务的原子性</strong>(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。</li>\n<li><strong>原理</strong>Undo Log 的原理很简单，<strong>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 UndoLog）</strong>。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，<strong>系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态</strong>。</li>\n</ul>\n<p><strong>之所以能同时保证原子性和持久化，是因为以下特点</strong>：</p>\n<ul>\n<li>更新数据前记录 Undo log。</li>\n<li>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</li>\n<li><strong>Undo log 必须先于数据持久化到磁盘</strong>。如果在 G,H 之间系统崩溃，<strong>undo log 是完整的， 可以用来回滚事务</strong>。</li>\n<li>如果在 A-F 之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</li>\n</ul>\n<p><strong>缺陷</strong>：<strong>每个事务提交前将数据和 Undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低</strong>。</p>\n<p>如果能够将数据缓存一段时间，就能减少 IO 提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。</p>\n<h4 id=\"Redo-Log\"><a href=\"#Redo-Log\" class=\"headerlink\" title=\"Redo Log\"></a>Redo Log</h4><ul>\n<li><strong>原理和 Undo Log 相反</strong>，<strong>Redo Log 记录的是新数据的备份</strong>。<strong>在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态</strong>。</li>\n</ul>\n<h3 id=\"Explain-性能分析\"><a href=\"#Explain-性能分析\" class=\"headerlink\" title=\"Explain 性能分析\"></a>Explain 性能分析</h3><p><strong>是什么</strong></p>\n<p>查看执行计划：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。分析查询语句或是表结构的性能瓶颈。</p>\n<p><strong>能干嘛</strong></p>\n<ul>\n<li>表的读取顺序</li>\n<li>数据读取操作的操作类型</li>\n<li>哪些索引可以使用</li>\n<li>哪些索引被实际使用</li>\n<li>表之间的引用</li>\n<li>每张表有多少行被优化器查询</li>\n</ul>\n<p><strong>怎么玩</strong></p>\n<p>Explain + SQL 语句。<br>Explain 执行后返回的信息：<br> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131912576.png\" alt=\"image-20220422131912576\" style=\"zoom:50%;\" /></p>\n<p><strong>各字段解释</strong></p>\n<ol>\n<li><p>id：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。</p>\n<ul>\n<li>id 相同，执行顺序由上至下</li>\n<li>id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li>\n<li>id 有相同也有不同：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行</li>\n</ul>\n<blockquote>\n<p>id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。</p>\n</blockquote>\n</li>\n<li><p>select_type：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询，取值范围如下：</p>\n<ul>\n<li>simple：简单的 select 查询，查询中不包含子查询或者 UNION</li>\n<li>primary：查询中若包含任何复杂的子部分，最外层查询则被标记为 primary</li>\n<li>derived：在 FROM 列表中包含的子查询被标记为 DERIVED (衍生)，MySQL 会递归执行这些子查询, 把结果放在临时表里。</li>\n<li>subquery：在 SELECT 或 WHERE 列表中包含了子查询</li>\n<li>depedent subquery：在 SELECT 或 WHERE 列表中包含了子查询，子查询基于外层</li>\n<li>uncacheable subquery：无法使用缓存的子查询</li>\n<li>union：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED</li>\n<li>union result：从 UNION 表获取结果的 SELECT</li>\n</ul>\n</li>\n<li><p>table：这个数据是基于哪张表的。</p>\n</li>\n<li><p>type：是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p>\n<blockquote>\n<p>只需要记住：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 就行了，其他的不常见。</p>\n</blockquote>\n<ul>\n<li>system：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计。</li>\n<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。</li>\n<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li>\n<li>range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在 where 语句中出现了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>\n<li>index：出现 index 是 sql 使用了索引但是没用索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。</li>\n<li>all：将遍历全表以找到匹配的行。</li>\n</ul>\n<blockquote>\n<p>其他 type 如下：</p>\n</blockquote>\n<ul>\n<li>index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 关键字的 sql 中。</li>\n<li>ref_or_null：对于某个字段既需要过滤条件，也需要 null 值的情况下。查询优化器会选择用 ref_or_null 连接查询。</li>\n<li>index_subquery：利用索引来关联子查询，不再全表扫描。</li>\n<li>unique_subquery：该联接类型类似于 index_subquery。子查询中的唯一索引。</li>\n</ul>\n</li>\n<li><p>possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>\n</li>\n<li><p>key：实际使用的索引。如果为 NULL，则没有使用索引。</p>\n</li>\n<li><p>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度。如何计算 key_len？</p>\n<ul>\n<li>先看索引上字段的类型 + 长度，比如：int&#x3D;4; varchar(20)&#x3D;20; char(20)&#x3D;20</li>\n<li>如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3，GBK 要乘 2</li>\n<li>varchar 这种动态字符串要加 2 个字节</li>\n<li>允许为空的字段要加 1 个字节</li>\n</ul>\n</li>\n<li><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>\n</li>\n<li><p>rows：显示 MySQL 认为它执行查询时必须检查的行数。越少越好！</p>\n</li>\n<li><p>Extra：其他的额外重要的信息。</p>\n<ul>\n<li>Using filesort：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。<strong>排序字段若通过索引去访问将大大提高排序速度</strong>。</li>\n<li>Using temporary：使用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li>\n<li>Using index：表示相应的 select 操作中使用了覆盖索引 (Covering Index)，避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。</li>\n<li>Using where：表明使用了 where 过滤。</li>\n<li>Using join buffer：使用了连接缓存。</li>\n<li>impossible where：where 子句的值总是 false，不能用来获取任何数据。</li>\n<li>select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN&#x2F;MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li>\n<li>distinct：优化 distinct 操作，在找到第一匹配的元祖后即停止找同样值的动作。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"length":41593,"excerpt":"<blockquote>\n<p>整理的 MySQL 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"MySQL基础篇\"><a href=\"#MySQL基础篇\" class=\"headerlink\" title=\"MySQL基础篇\"></a>MySQL基础篇</h2><h3 id=\"说一说三个范式\"><a href=\"#说一说三个范式\" class=\"headerlink\" title=\"说一说三个范式\"></a>说一说三个范式</h3><p><strong>第一范式(确保每列保持原子性)</strong></p>\n<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>\n<p>**第二范式(确保表中的每列都和主键相关)**（前提是第一范式）</p>\n<p>在一个数据库表中，一个表中只能保存<strong>一种</strong>数据，不可以把多种数据保存在同一张数据库表中。</p>\n<p>**第三范式(确保表中每列都和主键直接相关,而不是间接相关)**（前提是第一第二范式）</p>\n<p>已经分好了多张表的话，一张表中只能有另一张表的 ID，而不能有其他任何信息（其他任何信息，一律用主键在另一张表中查询）。</p>\n<h3 id=\"说一下-MySQL-执行一条查询语句的内部执行过程？\"><a href=\"#说一下-MySQL-执行一条查询语句的内部执行过程？\" class=\"headerlink\" title=\"说一下 MySQL 执行一条查询语句的内部执行过程？\"></a>说一下 MySQL 执行一条查询语句的内部执行过程？</h3><blockquote>\n<p>连接器 → 查询缓存 → 分析器 → 优化器 → 执行器</p>\n</blockquote>\n<ul>\n<li><p>客户端先通过<strong>连接器</strong>连接到 MySQL 服务器。</p>\n</li>\n<li><p>连接器权限验证通过之后，先查询是否有<strong>查询缓存</strong>，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</p>\n</li>\n<li><p><strong>分析器</strong>会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</p>\n</li>\n<li><p><strong>优化器</strong>对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</p>\n</li>\n<li><p>优化器执行完就进入<strong>执行器</strong>，开始执行查询语句直到查询出满足条件的所有数据，然后进行返回。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-查询缓存的功能有何优缺点？\"><a href=\"#MySQL-查询缓存的功能有何优缺点？\" class=\"headerlink\" title=\"MySQL 查询缓存的功能有何优缺点？\"></a>MySQL 查询缓存的功能有何优缺点？</h3><p>优点是效率高，如果已经有缓存则会直接返回结果。 </p>\n<p>但是，如果数据库表中数据和结构发生变化时（增删改、表结构调整），查询缓存将会失效并被清除，导致缓存命中率比较低。</p>\n<h3 id=\"MySQL-的常用引擎都有哪些？\"><a href=\"#MySQL-的常用引擎都有哪些？\" class=\"headerlink\" title=\"MySQL 的常用引擎都有哪些？\"></a>MySQL 的常用引擎都有哪些？</h3><p>MySQL 的常用引擎有 InnoDB、MyISAM、Memory（所有数据放在内存中） 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p>\n<h3 id=\"MySQL-可以针对表级别设置数据库引擎吗？怎么设置？\"><a href=\"#MySQL-可以针对表级别设置数据库引擎吗？怎么设置？\" class=\"headerlink\" title=\"MySQL 可以针对表级别设置数据库引擎吗？怎么设置？\"></a>MySQL 可以针对表级别设置数据库引擎吗？怎么设置？</h3><p>可以针对不同的表设置不同的引擎。在 create table 语句中使用 engine&#x3D;引擎名（比如 Memory）来设置此表的存储引擎。</p>\n<h3 id=\"InnoDB-v-s-MyISAM\"><a href=\"#InnoDB-v-s-MyISAM\" class=\"headerlink\" title=\"InnoDB v.s. MyISAM\"></a>InnoDB v.s. MyISAM</h3><ul>\n<li><p>最大的区别是 InnoDB 支持<strong>事务</strong>，而 MyISAM 不支持事务；</p>\n</li>\n<li><p>InnoDB 支持<strong>崩溃后安全恢复</strong>，MyISAM 不支持崩溃后安全恢复；</p>\n</li>\n<li><p>InnoDB 支持<strong>行锁</strong>，MyISAM 不支持行锁，只支持表锁；</p>\n</li>\n<li><p>InnoDB 支持<strong>外键</strong>，MyISAM 不支持外键；</p>\n</li>\n</ul>\n<h3 id=\"InnoDB-有哪些特性？\"><a href=\"#InnoDB-有哪些特性？\" class=\"headerlink\" title=\"InnoDB 有哪些特性？\"></a>InnoDB 有哪些特性？</h3><p><strong>1）插入缓冲(insert buffer)<strong>：插入缓冲带来的是</strong>性能</strong>。对于非聚集索引的插入和更新，不是每一次直接插入索引页中，而是首先判断插入的非聚集索引页是否在缓冲池中，如果在，则直接插入，否则，先放入一个插入缓冲区中。好似欺骗数据库这个非聚集的索引已经插入到叶子节点了，然后再以一定的频率执行插入缓冲和非聚集索引叶子节点的合并操作，这时通常能将多个插入合并到一个操作中，这就大大提高了对非聚集索引执行插入和修改操作的性能。（<strong>对于非聚集索引页，不是直接放到索引页中，而是先放到缓冲池中，这时候缓冲池中可能存放了多个非聚集索引页，然后将这多个非聚集索引页的插入合并到一个操作中，取代了之前的一个一个插入</strong>）</p>\n<p><strong>2）两次写(double write)<strong>：两次写带来的是</strong>可靠性</strong>，主要用来解决部分写失败。doublewrite 由两部分组成，一部分是内存中的 doublewrite buffer ，大小为 2M，另外一部分就是物理磁盘上的共享表空间中连续的 128 个页，即两个区，大小同样为 2M。当缓冲池的作业刷新时，并不直接写硬盘，而是通过 memcpy 函数将脏页先拷贝到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次写，每次写入 1M 到共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。<strong>（要进行写操作时，不是直接写硬盘，而是写拷贝到内存中的两次写缓冲区大小2M，然后把两次写缓冲区的内容分两次写（每次写1M）到共享表空间的磁盘上，然后再将共享表空间的内容同步到数据文件上）</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-ad3fb88b0ef6d41d.png\" alt=\"两次写\"> </p>\n<p><strong>3）自适应哈希索引(adaptive hash index)<strong>：由于 InnoDB 不支持 hash 索引，但在某些情况下 hash 索引的效率很高，于是出现了 adaptive hash index 功能， InnoDB 存储引擎会监控对表上索引的查找，如果观察到建立 hash 索引可以提高性能的时候，则自动建立 hash 索引。</strong>（为了提高性能会自动建立一些 hash 索引，查找效率很高，直接通过 hash 值定位到数据）</strong></p>\n<h3 id=\"一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？\"><a href=\"#一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？\" class=\"headerlink\" title=\"一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？\"></a>一张自增表中有三条数据，删除了两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h3><blockquote>\n<p>等价于：自增主键能不能被持久化的问题？</p>\n<p>MyISAM：自增主键会持久化到数据文件中</p>\n<p>InnoDB：<br>    5.7 以及之前：不会持久化<br>    从 8 开始：自增主键会持久化到 redo log</p>\n</blockquote>\n<ol>\n<li><p>如果表的引擎类型是 <strong>MyISAM</strong>，那么这条记录的 ID 就是 4。因为 <strong>MyISAM表会把自增主键的最大ID记录到数据文件里面</strong>，重启 MySQL 后，自增主键的最大 ID 也不会丢失。</p>\n</li>\n<li><p>如果表的引擎类型是 <strong>InnoDB</strong>，那么这条记录的 ID 就是 2。因为 <strong>InnoDB表把自增主键的最大ID记录到内存中</strong>，所以重启数据库后会使最大 ID（其实是 AUTO_INCREMENT 计数器的值）丢失；一旦数据库重新运行，数据库会自动计算自增主键的最大 ID（<strong>其实就是把最后一条记录 ID 加 1 并赋值给 AUTO_INCREMENT</strong>）再次放入到内存中。</p>\n<p> 【注】<strong>这仅仅是 MySQL 8 以前的版本，也就是 MySQL 5.7 以及之前的版本</strong>。因为在 MySQL 8.0 中，<strong>InnoDB 的行为已更改</strong>。每次更改时，当前最大自动增量计数器值（AUTO_INCREMENT）都会写入重做日志 redo log，并保存到每个检查点的引擎专用系统表中。这些更改使当前的最大自动增量计数器值在服务器重新启动后保持不变，与 <strong>MyISAM</strong> 一样了。详见官方文档：<a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-initialization\">InnoDB AUTO_INCREMENT 计数器初始化</a></p>\n<p> 【注】如果删除的不是最后的记录，那么自增的最大 ID 全部都一样，因为自动增量计数器值（AUTO_INCREMENT）不会改变。</p>\n</li>\n</ol>\n<h3 id=\"MySQL-中什么情况会导致自增主键不能连续？\"><a href=\"#MySQL-中什么情况会导致自增主键不能连续？\" class=\"headerlink\" title=\"MySQL 中什么情况会导致自增主键不能连续？\"></a>MySQL 中什么情况会导致自增主键不能连续？</h3><blockquote>\n<ol>\n<li>唯一键冲突</li>\n<li>事务回滚</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>执行器执行插入，自增键+1，但是 innoDB 发现插入时<strong>唯一键冲突</strong>，无法插入，导致的不连续。</p>\n</li>\n<li><p>事务添加自增键+1，但是由于<strong>事务回滚</strong>，数据被清除，导致的不连续。</p>\n</li>\n</ul>\n<h3 id=\"什么是覆盖索引？\"><a href=\"#什么是覆盖索引？\" class=\"headerlink\" title=\"什么是覆盖索引？\"></a>什么是覆盖索引？</h3><p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键上去取数据即回表。</p>\n<h3 id=\"如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\"><a href=\"#如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\" class=\"headerlink\" title=\"如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？\"></a>如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h3><p>如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p>\n<h3 id=\"内存表和临时表有什么区别？\"><a href=\"#内存表和临时表有什么区别？\" class=\"headerlink\" title=\"内存表和临时表有什么区别？\"></a>内存表和临时表有什么区别？</h3><p>内存表，指的是使用 Memory 引擎的表，数据放在内存中，重启会被清空；</p>\n<p>临时表，指的是使用 InnoDB 引擎或者 MyISAM 引擎的表，数据放在磁盘上，重启不会清空。</p>\n<h3 id=\"MySQL-中的字符串类型都有哪些？\"><a href=\"#MySQL-中的字符串类型都有哪些？\" class=\"headerlink\" title=\"MySQL 中的字符串类型都有哪些？\"></a>MySQL 中的字符串类型都有哪些？</h3><table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>取值范围</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CHAR(N)</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td>VARCHAR(N)</td>\n<td>0~65536</td>\n</tr>\n<tr>\n<td>TINYBLOB</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>0~65535</td>\n</tr>\n<tr>\n<td>MEDUIMBLOB</td>\n<td>0~167772150</td>\n</tr>\n<tr>\n<td>LONGBLOB</td>\n<td>0~4294967295</td>\n</tr>\n<tr>\n<td>TINYTEXT</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>0~65535</td>\n</tr>\n<tr>\n<td>MEDIUMTEXT</td>\n<td>0~167772150</td>\n</tr>\n<tr>\n<td>LONGTEXT</td>\n<td>0~4294967295</td>\n</tr>\n<tr>\n<td>VARBINARY(N)</td>\n<td>0~N个字节的变长字节字符集</td>\n</tr>\n<tr>\n<td>BINARY(N)</td>\n<td>0~N个字节的定长字节字符集</td>\n</tr>\n</tbody></table>\n<h3 id=\"VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？\"><a href=\"#VARCHAR-和-CHAR-的区别是什么？分别适用的场景有哪些？\" class=\"headerlink\" title=\"VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？\"></a>VARCHAR 和 CHAR 的区别是什么？分别适用的场景有哪些？</h3><p>VARCHAR 的长度是可变的，而 CHAR 是固定长度。由于它们的特性决定了 CHAR 比较适合长度较短的字段和固定长度的字段，如身份证号、手机号等，反之则适合使用 VARCHAR。</p>\n<h3 id=\"MySQL-存储金额应该使用哪种数据类型？为什么？\"><a href=\"#MySQL-存储金额应该使用哪种数据类型？为什么？\" class=\"headerlink\" title=\"MySQL 存储金额应该使用哪种数据类型？为什么？\"></a>MySQL 存储金额应该使用哪种数据类型？为什么？</h3><p>MySQL 存储金额应该使用 <code>decimal</code> ，因为如果存储其他数据类型，比如 <code>float</code> 有导致小数点后数据丢失的风险。</p>\n<h3 id=\"limit-3-2-的含义是什么？\"><a href=\"#limit-3-2-的含义是什么？\" class=\"headerlink\" title=\"limit 3,2 的含义是什么？\"></a>limit 3,2 的含义是什么？</h3><p>去除前三条数据之后查询两条信息。</p>\n<h3 id=\"lastinsertid-函数功能是什么？有什么特点？\"><a href=\"#lastinsertid-函数功能是什么？有什么特点？\" class=\"headerlink\" title=\"lastinsertid() 函数功能是什么？有什么特点？\"></a><em>lastinsertid()</em> 函数功能是什么？有什么特点？</h3><p><em>lastinsertid()</em> 用于查询最后一次自增表的编号（全局的），它的特点是查询时不需要指定表名，使用 <code>select last_insert_id()</code> 即可查询，因为不需要指定表名所以它始终以最后一条自增编号为主，可以被其它表的自增编号覆盖。比如 A 表的最大编号是 10， <em>lastinsertid()</em> 查询出来的值为 10，这时 B 表插入了一条数据，它的最大编号为 3，这个时候使用 <em>lastinsertid()</em> 查询的值就是 3。</p>\n<h3 id=\"删除表的数据有几种方式？它们有什么区别？\"><a href=\"#删除表的数据有几种方式？它们有什么区别？\" class=\"headerlink\" title=\"删除表的数据有几种方式？它们有什么区别？\"></a>删除表的数据有几种方式？它们有什么区别？</h3><p>删除数据有两种方式：delete 和 truncate，它们的区别如下：</p>\n<ul>\n<li><p>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；</p>\n</li>\n<li><p>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，<br>因此 detele 的信息可以被找回而 truncate 的信息无法被找回；</p>\n</li>\n<li><p>truncate 因为不记录日志所以执行效率比 delete 快。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-中支持几种模糊查询？它们有什么区别？\"><a href=\"#MySQL-中支持几种模糊查询？它们有什么区别？\" class=\"headerlink\" title=\"MySQL 中支持几种模糊查询？它们有什么区别？\"></a>MySQL 中支持几种模糊查询？它们有什么区别？</h3><p>MySQL 中支持两种模糊查询：regexp 和 like<br>like 是对任意多字符匹配或任意单字符进行模糊匹配，<br>而 regexp 则支持正则表达式的匹配方式，提供比 like 更多的匹配方式。<br>regexp 和 like 的使用示例如下： </p>\n<blockquote>\n<p>select * from person where uname like ‘%SQL%’;<br>select * from person where uname regexp ‘.SQL*.’; </p>\n</blockquote>\n<h3 id=\"count-column-和-count-有什么区别？\"><a href=\"#count-column-和-count-有什么区别？\" class=\"headerlink\" title=\"count(column) 和 count(*) 有什么区别？\"></a><em>count(column)</em> 和 <em>count(*)</em> 有什么区别？</h3><p><em>count(column)</em> 统计不会统计列值为 null 的数据，<br>而 <em>count(*)</em> 则会统计所有信息，所以最终的统计结果可能会不同。</p>\n<h3 id=\"为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？\"><a href=\"#为什么-InnoDB-不把总条数记录下来，查询的时候直接返回呢？\" class=\"headerlink\" title=\"为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？\"></a>为什么 InnoDB 不把总条数记录下来，查询的时候直接返回呢？</h3><p>因为 <strong>InnoDB 支持事务</strong>，即使是在同一时间进行查询，得到的结果也可能不相同，所以 InnoDB 不能把结果直接保存下来，因为这样是不准确的。</p>\n<h3 id=\"InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？\"><a href=\"#InnoDB-和-MyISAM-执行-select-count-from-t，哪个效率更高？为什么？\" class=\"headerlink\" title=\"InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？\"></a>InnoDB 和 MyISAM 执行 select count(*) from t，哪个效率更高？为什么？</h3><p>MyISAM 效率最高，因为 MyISAM 内部维护了一个计数器，直接返回总条数，而 InnoDB 要逐行统计。</p>\n<h3 id=\"在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？\"><a href=\"#在-InnoDB-引擎中-count-、count-1-、count-主键-、count-字段-哪个性能最高？\" class=\"headerlink\" title=\"在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？\"></a>在 InnoDB 引擎中 count(*)、count(1)、count(主键)、count(字段) 哪个性能最高？</h3><p>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*) 题目解析：</p>\n<ul>\n<li>对于 count(字段) 来说，遍历整张表，取这个字段，然后判断是否为 null，不为 null 则加 1</li>\n<li>对于 count(主键 id) 来说，遍历整张表，取主键 id，不可能为空，每次加 1。但是可能使用最小的索引树。</li>\n<li>对于 count(1) 来说，遍历整张表，不取值。1 是不可能为空的，每次加 1。</li>\n<li>对于 count(*) 来说，遍历整张表，不取值，直接按行累加。实际上，当使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理。</li>\n</ul>\n<p>所以最后得出的结果是：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)。</p>\n<h3 id=\"MySQL-中内连接、左连接、右连接有什么区别？\"><a href=\"#MySQL-中内连接、左连接、右连接有什么区别？\" class=\"headerlink\" title=\"MySQL 中内连接、左连接、右连接有什么区别？\"></a>MySQL 中内连接、左连接、右连接有什么区别？</h3><ul>\n<li><p>内连（inner join）— 把匹配的关联数据显示出来；</p>\n</li>\n<li><p>左连接（left join）— 把左边的表全部显示出来，右边的表显示出符合条件的数据；</p>\n</li>\n<li><p>右连接（right join）— 把右边的表全部显示出来，左边的表显示出符合条件的数据；</p>\n</li>\n</ul>\n<h2 id=\"MySQL索引篇\"><a href=\"#MySQL索引篇\" class=\"headerlink\" title=\"MySQL索引篇\"></a>MySQL索引篇</h2><h3 id=\"什么是索引？\"><a href=\"#什么是索引？\" class=\"headerlink\" title=\"什么是索引？\"></a>什么是索引？</h3><p>索引是一种能帮助 MySQL 提高查询效率的数据结构。</p>\n<h3 id=\"索引分别有哪些优点和缺点？\"><a href=\"#索引分别有哪些优点和缺点？\" class=\"headerlink\" title=\"索引分别有哪些优点和缺点？\"></a>索引分别有哪些优点和缺点？</h3><p><strong>索引的优点：</strong></p>\n<ul>\n<li>提高查询效率</li>\n</ul>\n<p><strong>索引的缺点：</strong></p>\n<ul>\n<li><p>虽然提高了查询速度，但却降低了更新表的速度，比如 update、insert；<br>因为更新数据时，MySQL 不仅要更新数据，还要更新索引文件；</p>\n</li>\n<li><p>建立索引的索引文件会占用磁盘。</p>\n</li>\n</ul>\n<h3 id=\"MySQL索引的注意事项\"><a href=\"#MySQL索引的注意事项\" class=\"headerlink\" title=\"MySQL索引的注意事项\"></a>MySQL索引的注意事项</h3><p><strong>1、联合索引遵循前缀原则</strong></p>\n<p><strong>2、like模糊查询，%不能在前</strong></p>\n<p><strong>3、</strong>列值为空（NULL）时是可以使用索引的，但 MySQL 难以优化引用了可空列的查询,它会使索引、索引统计和值更加复杂。可空列需要更多的储存空间，还需要在 MySQL 内部进行特殊处理。</p>\n<p><strong>4、</strong> 如果 MySQL 估计使用索引比全表扫描更慢，会放弃使用索引，例如：<br>表中只有 100 条数据左右。对于 SQL 语句 WHERE id &gt; 1 AND id &lt; 100，MySQL 会优先考虑全表扫描。</p>\n<p><strong>5、</strong> <strong>如果关键词or前面的条件中的列有索引，后面的没有，所有列的索引都不会被用到。</strong></p>\n<p><strong>6、</strong> 列类型是字符串，查询时一定要给值加引号，否则索引失效，例如：<br>列 name varchar(16)，存储了字符串”100”<br>WHERE name &#x3D; 100;  （做了自动类型转换）<br>以上 SQL 语句能搜到，但无法用到索引。</p>\n<p><strong>7、不在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描</strong> </p>\n<h3 id=\"为什么-MySQL-官方建议使用自增主键作为表的主键？\"><a href=\"#为什么-MySQL-官方建议使用自增主键作为表的主键？\" class=\"headerlink\" title=\"为什么 MySQL 官方建议使用自增主键作为表的主键？\"></a>为什么 MySQL 官方建议使用自增主键作为表的主键？</h3><p>优点：</p>\n<ol>\n<li><p>页分裂问题。如果使用非自增主键作为表的主键的话，当新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上，以确保索引有序。也就是说造成了页分裂，大量移动数据的过程严重影响插入效率。</p>\n</li>\n<li><p>存储空间问题。自增主键存储空间小，同一个结点内能存放更多的主键，树的高度可能降低，减少 io 次数。</p>\n</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>数据量过大，可能会超出自增长取值范围；</li>\n<li>无法满足分布式存储，分库分表的情况下无法合并表；</li>\n<li>主键有自增规律，容易被破解；</li>\n</ol>\n<p><strong>综上所述：</strong>是否需要使用自增主键，需要根据自己的业务场景来设计。如果是单表单库，则优先考虑自增主键，如果是分布式存储，分库分表，则需要考虑数据合并的业务场景来做数据库设计方案。</p>\n<h3 id=\"索引有几种类型？分别如何创建？\"><a href=\"#索引有几种类型？分别如何创建？\" class=\"headerlink\" title=\"索引有几种类型？分别如何创建？\"></a>索引有几种类型？分别如何创建？</h3><p>**MySQL 的索引有两种分类方式：逻辑分类和物理分类。 **</p>\n<p><strong>按照逻辑分类，索引可分为：</strong></p>\n<ul>\n<li>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</li>\n<li>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</li>\n<li>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</li>\n</ul>\n<p><strong>按照物理分类，索引可分为：</strong></p>\n<ul>\n<li>聚簇索引：InnoDB 的主键索引存储采用聚簇索引，主键值和数据存放在一起</li>\n<li>非聚簇索引：MyISAM 的主键索引存储采用非聚簇索引，主键值和指向数据的指针存放在一起，数据另开空间存储</li>\n</ul>\n<p><strong>各种索引的创建脚本如下：</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建主键索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (column_list);</span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> index_name (column_list);</span><br><span class=\"line\"><span class=\"comment\">-- 创建普通索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> INDEX index_name (column_list);</span><br><span class=\"line\"><span class=\"comment\">-- 创建全文索引</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span> <span class=\"keyword\">ADD</span> FULLTEXT index_name (column_list);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么叫回表查询？\"><a href=\"#什么叫回表查询？\" class=\"headerlink\" title=\"什么叫回表查询？\"></a>什么叫回表查询？</h3><p>普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p>\n<p>也就是说，基于非主键索引的查询需要多扫描一次主键索引树。因此，我们在应用中应该尽量使用主键查询。</p>\n<p>例外就是使用非主键索引时，如果当前索引满足查询需求，则不用回表。</p>\n<h3 id=\"在-InnDB-中主键索引为什么比普通索引的查询性能高？\"><a href=\"#在-InnDB-中主键索引为什么比普通索引的查询性能高？\" class=\"headerlink\" title=\"在 InnDB 中主键索引为什么比普通索引的查询性能高？\"></a>在 InnDB 中主键索引为什么比普通索引的查询性能高？</h3><p>回表。因为普通索引的查询会多执行一次检索操作。比如主键查询 select * from t where id&#x3D;10 只需要搜索 id 的这棵 B+ 树，而普通索引查询 select * from t where f&#x3D;3 会先查询 f 索引树，得到 id 的值之后再去搜索 id 的 B+ 树，因为多执行了一次检索，所以执行效率就比主键索引要低。</p>\n<h3 id=\"MySQL-复合索引应该注意什么？\"><a href=\"#MySQL-复合索引应该注意什么？\" class=\"headerlink\" title=\"MySQL 复合索引应该注意什么？\"></a>MySQL 复合索引应该注意什么？</h3><p>MySQL 中的复合索引，遵循最左匹配原则，比如，联合索引为 key(a,b,c)，则能触发索引的搜索组合是 a|ab|abc 这三种查询。</p>\n<h3 id=\"复合索引的作用是什么？\"><a href=\"#复合索引的作用是什么？\" class=\"headerlink\" title=\"复合索引的作用是什么？\"></a>复合索引的作用是什么？</h3><ul>\n<li>用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了<code>key(a)、key(a,b)、key(a,b,c)</code>等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；</li>\n<li>覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：<code>select a,b,c from table where a=1 and b = 1</code> ，就可以直接通过遍历索引取得数据，而<strong>无需回表查询</strong>，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；</li>\n<li>索引列越多，通过索引筛选出的数据越少。</li>\n</ul>\n<h3 id=\"什么是最左匹配原则？它的生效原则有哪些？\"><a href=\"#什么是最左匹配原则？它的生效原则有哪些？\" class=\"headerlink\" title=\"什么是最左匹配原则？它的生效原则有哪些？\"></a>什么是最左匹配原则？它的生效原则有哪些？</h3><p>最左匹配原则也叫最左前缀原则，是 MySQL 中的一个重要原则，说的是索引以最左边的为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。</p>\n<h3 id=\"以下语句会走索引么？\"><a href=\"#以下语句会走索引么？\" class=\"headerlink\" title=\"以下语句会走索引么？\"></a>以下语句会走索引么？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from t where year(date)&gt;2018;</span><br></pre></td></tr></table></figure>\n\n<p>不会，因为在索引列上涉及到了运算。</p>\n<h3 id=\"能否给手机号的前-6-位创建索引？如何创建？\"><a href=\"#能否给手机号的前-6-位创建索引？如何创建？\" class=\"headerlink\" title=\"能否给手机号的前 6 位创建索引？如何创建？\"></a>能否给手机号的前 6 位创建索引？如何创建？</h3><p>可以，创建方式有两种：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table t add index index_phone(phone(6));</span><br><span class=\"line\">create index index_phone on t(phone(6));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么是前缀索引？\"><a href=\"#什么是前缀索引？\" class=\"headerlink\" title=\"什么是前缀索引？\"></a>什么是前缀索引？</h3><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引。<br>类似这种给某列部分信息添加索引的方式叫做前缀索引。</p>\n<h3 id=\"为什么要用前缀索引？\"><a href=\"#为什么要用前缀索引？\" class=\"headerlink\" title=\"为什么要用前缀索引？\"></a>为什么要用前缀索引？</h3><p>前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p>\n<h3 id=\"什么情况下适合使用前缀索引？\"><a href=\"#什么情况下适合使用前缀索引？\" class=\"headerlink\" title=\"什么情况下适合使用前缀索引？\"></a>什么情况下适合使用前缀索引？</h3><p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引，比如，整个字段的长度为 20，索引选择性（不重复的索引值和表记录数的比值，越大说明索引价值越大）为 0.9，而我们对前 10 个字符建立前缀索引其选择性也只有 0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，就没有创建前缀索引的必要了。</p>\n<h3 id=\"InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？\"><a href=\"#InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？\" class=\"headerlink\" title=\"InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？\"></a>InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h3><p>因为 B 树、Hash、红黑树或二叉树存在以下问题：</p>\n<ul>\n<li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低；</li>\n<li>Hash：虽然可以快速定位，但是没有顺序，无法进行范围查找，IO 复杂度高；</li>\n<li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高；</li>\n<li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li>\n</ul>\n<h3 id=\"MySQL-如何指定查询的索引？\"><a href=\"#MySQL-如何指定查询的索引？\" class=\"headerlink\" title=\"MySQL 如何指定查询的索引？\"></a>MySQL 如何指定查询的索引？</h3><p>在 MySQL 中可以使用 force index 强行选择一个索引，具体查询语句如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t force index(index_t);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在-MySQL-中指定了查询索引，为什么没有生效？\"><a href=\"#在-MySQL-中指定了查询索引，为什么没有生效？\" class=\"headerlink\" title=\"在 MySQL 中指定了查询索引，为什么没有生效？\"></a>在 MySQL 中指定了查询索引，为什么没有生效？</h3><p>我们知道在 MySQL 中使用 force index 可以指定查询的索引，但并不是一定会生效，原因是 MySQL 会根据优化器自己选择索引，如果 force index 指定的索引出现在候选索引上，这个时候 MySQL 不会在判断扫描的行数的多少直接使用指定的索引，如果没在候选索引中，即使 force index 指定了索引也是不会生效的。</p>\n<h3 id=\"如何优化身份证的索引？\"><a href=\"#如何优化身份证的索引？\" class=\"headerlink\" title=\"如何优化身份证的索引？\"></a>如何优化身份证的索引？</h3><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：</p>\n<ul>\n<li><strong>使用身份证倒序存储</strong>，这样设置前六位的意义就很大了；</li>\n<li><strong>使用 hash 值</strong>，新创建一个字段用于存储身份证的 hash 值。</li>\n</ul>\n<h3 id=\"索引的使用场景\"><a href=\"#索引的使用场景\" class=\"headerlink\" title=\"索引的使用场景\"></a>索引的使用场景</h3><ul>\n<li>对于非常小的表，大部分情况下全表扫描效率更高。</li>\n<li>中到大型表，索引非常有效。</li>\n<li>特大型的表，建立和使用索引的代价会随之增大，可以使用分区技术来解决。</li>\n</ul>\n<h3 id=\"聚簇索引和非聚簇索引\"><a href=\"#聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引\"></a>聚簇索引和非聚簇索引</h3><p>Innobd 中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p>\n<p>Innodb 使用的是聚簇索引，MyISam 使用的是非聚簇索引</p>\n<h4 id=\"聚簇索引-聚集索引\"><a href=\"#聚簇索引-聚集索引\" class=\"headerlink\" title=\"聚簇索引(聚集索引)\"></a>聚簇索引(聚集索引)</h4><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145143172-1760681728.png\" alt=\"img\"></p>\n<p>　　Innodb 聚簇索引和 MyIsam 非聚簇索引的比较说明<br>　　参考博客：<a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\">https://www.cnblogs.com/zlcxbb/p/5757245.html</a></p>\n<h4 id=\"InnoDB索引实现\"><a href=\"#InnoDB索引实现\" class=\"headerlink\" title=\"InnoDB索引实现\"></a>InnoDB索引实现</h4><p>　　InnoDB<strong>使用B+Tree作为索引结构</strong>，但具体实现方式却与 MyISAM 截然不同.</p>\n<p>1）主键索引：</p>\n<p><strong>MyISAM索引文件和数据文件是分离的</strong>，<strong>索引文件仅保存数据记录的地址</strong>。而在<strong>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构</strong>，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1464190-20191106145200302-932404581.png\"></p>\n<p>(图 inndb 主键索引）是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则<strong>MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</strong>。</p>\n<p>2）InnoDB 的辅助索引</p>\n<p>   InnoDB 的所有辅助索引都引用主键作为 data 域。例如，下图为定义在 Col3 上的一个辅助索引：</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106145241480-1330791289.png\" alt=\"img\"></p>\n<p>InnoDB 使用的是聚簇索引，将主键组织到一棵 B+树中，而行数据就储存在叶子节点上，若使用”where id &#x3D; 14”这样的条件查找主键，则按照 B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B+树中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B+树中再执行一次 B+树检索操作，最终到达叶子节点即可获取整行数据。</p>\n<h4 id=\"MyISAM索引实现\"><a href=\"#MyISAM索引实现\" class=\"headerlink\" title=\"MyISAM索引实现\"></a>MyISAM索引实现</h4><p>MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</p>\n<p>1）主键索引：</p>\n<p>MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的<strong>data域存放的是数据记录的地址</strong>。下图是 MyISAM 主键索引的原理图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151308457-531875534.png\" alt=\"img\"></p>\n<p>这里设表一共有三列，假设我们以 Col1 为主键，图 myisam1 是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。</p>\n<p>2）辅助索引（Secondary key）</p>\n<p>在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，<strong>只是主索引要求key是唯一的，而辅助索引的key可以重复</strong>。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示。</p>\n<p>同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151427711-625351515.png\" alt=\"img\"></p>\n<p>　　<strong>MyISM使用的是非聚簇索引</strong>，非聚簇索引的两棵 B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引 B+树的节点存储了主键，辅助键索引 B+树存储了辅助键。表数据存储在独立的地方，这两颗 B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>\n<p>为了更形象说明这两种索引的区别，我们假想一个表如下图存储了 4 行数据。其中 Id 作为主索引，Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1464190-20191106151527647-152458631.png\" alt=\"img\"></p>\n<p>🌟<strong>InnoDB聚簇索引：</strong></p>\n<p>主键索引树，根结点存的是主键 id 和对应的数据；</p>\n<p>辅助索引树，根结点存的是辅助索引和对应的主键索引，因此需要根据主键到主键索引树上在遍历一次得到对应的数据。</p>\n<p>🌟<strong>MyISAM非聚簇索引：</strong></p>\n<p>主键索引树，根结点存的是主键到数据地址的映射；</p>\n<p>辅助索引树，根结点存的是辅助索引到数据地址的映射，也可以直接得到数据，不需要回表。</p>\n<h4 id=\"问题：主键索引是聚集索引还是非聚集索引？\"><a href=\"#问题：主键索引是聚集索引还是非聚集索引？\" class=\"headerlink\" title=\"问题：主键索引是聚集索引还是非聚集索引？\"></a>问题：主键索引是聚集索引还是非聚集索引？</h4><p>在 InnoDB 下主键索引是聚集索引，在 MyISAM 下主键索引是非聚集索引</p>\n<h4 id=\"MyISAM索引实现？\"><a href=\"#MyISAM索引实现？\" class=\"headerlink\" title=\"MyISAM索引实现？\"></a>MyISAM索引实现？</h4><p>MyISAM 存储引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。MyISAM 的索引方式也叫做非聚簇索引的，之所以这么称呼是为了与 InnoDB 的聚簇索引区分。</p>\n<h4 id=\"MyISAM索引与InnoDB索引的区别？\"><a href=\"#MyISAM索引与InnoDB索引的区别？\" class=\"headerlink\" title=\"MyISAM索引与InnoDB索引的区别？\"></a>MyISAM索引与InnoDB索引的区别？</h4><ul>\n<li>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。</li>\n<li>InnoDB 的主键索引的叶子节点存储着索引和行数据，因此主键索引非常高效。</li>\n<li>MyISAM 索引的叶子节点存储的是行数据地址，需要根据数据地址访问对应的地址才能得到数据。</li>\n<li><strong>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</strong></li>\n</ul>\n<h3 id=\"简单说一说drop、delete与truncate的区别\"><a href=\"#简单说一说drop、delete与truncate的区别\" class=\"headerlink\" title=\"简单说一说drop、delete与truncate的区别\"></a>简单说一说drop、delete与truncate的区别</h3><p>SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别</p>\n<blockquote>\n<p>1、delete和truncate只删除表的数据不删除表的结构<br>2、速度,一般来说: drop&gt; truncate &gt;delete<br>3、delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;<br>4、如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.</p>\n</blockquote>\n<h3 id=\"delete、truncate和drop分别在什么场景之下使用？\"><a href=\"#delete、truncate和drop分别在什么场景之下使用？\" class=\"headerlink\" title=\"delete、truncate和drop分别在什么场景之下使用？\"></a>delete、truncate和drop分别在什么场景之下使用？</h3><ol>\n<li>想删除部分数据行时候，用 delete，并且带上 where 子句</li>\n<li>保留表而删除所有数据的时候用 truncate</li>\n<li>不再需要一张表的时候，用 drop</li>\n</ol>\n<h3 id=\"⭐为什么-B-Tree-比-B-Tree-更适合实际应用中操作系统的文件索引和数据库索引？\"><a href=\"#⭐为什么-B-Tree-比-B-Tree-更适合实际应用中操作系统的文件索引和数据库索引？\" class=\"headerlink\" title=\"⭐为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？\"></a>⭐为什么 B+Tree 比 B-Tree 更适合实际应用中操作系统的文件索引和数据库索引？</h3><ol>\n<li>B+Tree 的磁盘读写代价更低</li>\n</ol>\n<blockquote>\n<p>B+Tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B-Tree 更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</p>\n</blockquote>\n<ol start=\"2\">\n<li>B+Tree 的查询效率更加稳定</li>\n</ol>\n<blockquote>\n<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>\n</blockquote>\n<h3 id=\"⭐Hash索引和B-树所有有什么区别或者说优劣呢\"><a href=\"#⭐Hash索引和B-树所有有什么区别或者说优劣呢\" class=\"headerlink\" title=\"⭐Hash索引和B+树所有有什么区别或者说优劣呢?\"></a>⭐Hash索引和B+树所有有什么区别或者说优劣呢?</h3><p>首先要知道 Hash 索引和 B+树索引的底层实现原理：</p>\n<p><strong>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.</strong><br>B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p>\n<p>那么可以看出他们有以下的不同：</p>\n<ul>\n<li><p>hash 索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p>\n</li>\n<li><p>hash 索引不支持使用索引进行排序,原理同上.</p>\n</li>\n<li><p>hash 索引不支持模糊查询.</p>\n</li>\n<li><p>hash 索引任何时候都避免不了回表查询数据,而 B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</p>\n</li>\n<li><p>hash 索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生 hash 碰撞,此时效率可能极差.而 B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</p>\n</li>\n</ul>\n<p>因此,在大多数情况下,直接选择 B+树索引可以获得稳定且较好的查询速度.而不需要使用 hash 索引.</p>\n<h3 id=\"非聚簇索引一定会回表查询吗\"><a href=\"#非聚簇索引一定会回表查询吗\" class=\"headerlink\" title=\"非聚簇索引一定会回表查询吗?\"></a>非聚簇索引一定会回表查询吗?</h3><p>有如下一张 InnoDB 表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `<span class=\"keyword\">user</span>` (</span><br><span class=\"line\">`id` <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> ,</span><br><span class=\"line\">`name` <span class=\"type\">VARCHAR</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> ,</span><br><span class=\"line\">`age` <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>其中 id 为自增主键，name 是一个普通索引。在执行 select * from user where id &#x3D; 1 时，会在主键索引对应的 B+树的叶子结点上搜索到关键字 id&#x3D;1 的节点，并读取位于该节点上的整行数据。但是在执行 select * from user where name &#x3D; ‘tom’时，会分为两个步骤：</p>\n<p>先到 name 索引对应的 B+树的叶子结点上搜索到关键字 name&#x3D;’tom’的节点，并从该节点上获取对应的主键 id 值。</p>\n<p>然后再根据 id 值使用主键索引读取到整行数据。</p>\n<p>其中第二个步骤叫作回表查询。需要扫描辅助索引和主键索引两棵 B+树才能拿到整行数据，效率较低。</p>\n<p>如果执行 select id, name from user where name &#x3D; ‘tom’,则只需要扫描 name 索引树就可以获取到所有的字段，因为 id 和 name 都保存在 name 索引 B+树的叶子节点上，所以不需要再去主键索引上查找。这就是所谓的索引覆盖。只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。</p>\n<p>而 select id, name, age from user where name &#x3D; ‘tom’，因为 age 字段没有存储到 name 索引的叶子节点上，所以需要根据主键索引回表查询到 age 列值。如果把 name 索引改成(name，age)的联合索引就可以实现索引覆盖，无需回表了。（覆盖索引，sql 语句中用到的字段都有索引）<br>————————————————<br>版权声明：本文为 CSDN 博主「lmyno」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/weixin_33603681/article/details/113387941\">https://blog.csdn.net/weixin_33603681/article/details/113387941</a></p>\n<h3 id=\"联合索引是什么-为什么需要注意联合索引中的顺序\"><a href=\"#联合索引是什么-为什么需要注意联合索引中的顺序\" class=\"headerlink\" title=\"联合索引是什么?为什么需要注意联合索引中的顺序?\"></a>联合索引是什么?为什么需要注意联合索引中的顺序?</h3><p>因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p>\n<h3 id=\"创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因\"><a href=\"#创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因\" class=\"headerlink\" title=\"创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?\"></a>创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</h3><p>MySQL 提供了 explain 命令来查看语句的执行计划</p>\n<h2 id=\"MySQL事务篇（重点）\"><a href=\"#MySQL事务篇（重点）\" class=\"headerlink\" title=\"MySQL事务篇（重点）\"></a>MySQL事务篇（重点）</h2><h3 id=\"可见性判断\"><a href=\"#可见性判断\" class=\"headerlink\" title=\"可见性判断\"></a>可见性判断</h3><blockquote>\n<p>总结：</p>\n<p>大于等于下一个分配的事务ID不可见</p>\n<p>包含在未提交事务集合中但是和创建read view的事务ID不相等则也不可见。</p>\n</blockquote>\n<p>事务版本号小于当前最小的事务 ID，那么说明它已经提交了，可见。</p>\n<p>事务版本号<strong>大于等于下一个分配的事务ID</strong>，说明这个事务在当前 read view 生成后在生成，<strong>不可见</strong>。</p>\n<p>事务版本号在 [最小事务 ID，下一个分配的事务 ID) 区间内：</p>\n<p>​\t如果未提交事务集合包含该事务版本号，那么判断是否该事务版本号是否等于创建该 read view 的事务 ID，</p>\n<p>​\t\t等于则说明这个版本的数据是当前事务生成的，可见。<strong>不等于则不可见</strong>。</p>\n<p>​\t如果不包含，说明这个事务版本号已经提交，可见。</p>\n<h3 id=\"查询一条记录，基于MVCC，是怎样的流程\"><a href=\"#查询一条记录，基于MVCC，是怎样的流程\" class=\"headerlink\" title=\"查询一条记录，基于MVCC，是怎样的流程\"></a>查询一条记录，基于MVCC，是怎样的流程</h3><ol>\n<li>获取数据版本号即<strong>数据行中的事务id隐藏字段</strong></li>\n<li><strong>执行sql，得到Read View</strong></li>\n<li>根据数据版本号和 read view 进行<strong>可见性判断</strong>，判断当前版本数据是否可见</li>\n<li>如果不符合 Read View 的可见性规则， 即就需要<strong>Undo log</strong>中历史快照重新和 read view 可见性判断</li>\n<li>最后返回符合规则的数据</li>\n</ol>\n<p>InnoDB 实现 MVCC，是通过<code> Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。</p>\n<h3 id=\"RC下可以读到已提交数据，但不能读到未提交数据\"><a href=\"#RC下可以读到已提交数据，但不能读到未提交数据\" class=\"headerlink\" title=\"RC下可以读到已提交数据，但不能读到未提交数据\"></a>RC下可以读到已提交数据，但不能读到未提交数据</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes1.png\" alt=\"1\"></p>\n<h3 id=\"RR下已提交和未提交数据都不能读到\"><a href=\"#RR下已提交和未提交数据都不能读到\" class=\"headerlink\" title=\"RR下已提交和未提交数据都不能读到\"></a>RR下已提交和未提交数据都不能读到</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesTyporaNotes2.png\" alt=\"2\"></p>\n<h3 id=\"为什么RR下解决了不可重复读问题？\"><a href=\"#为什么RR下解决了不可重复读问题？\" class=\"headerlink\" title=\"为什么RR下解决了不可重复读问题？\"></a>为什么RR下解决了不可重复读问题？</h3><p>实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟<strong>Read view工作方式有关</strong>。</p>\n<ul>\n<li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n</tbody></table>\n<ul>\n<li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>共用一个Read View副本</td>\n</tr>\n</tbody></table>\n<h3 id=\"MVCC是否解决了幻读问题呢？\"><a href=\"#MVCC是否解决了幻读问题呢？\" class=\"headerlink\" title=\"MVCC是否解决了幻读问题呢？\"></a>MVCC是否解决了幻读问题呢？</h3><p>对于幻读来说，存在快照读（可以读到多个版本，普通的 select）和当前读（读的是最新的 for update）的情况：</p>\n<ol>\n<li>RR 隔离级别下为了解决幻读问题：<strong>快照读依靠MVCC控制，当前读通过间隙锁解决</strong>；</li>\n<li>间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；</li>\n<li><strong>间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度</strong>。</li>\n</ol>\n<h3 id=\"并发事务有什么什么问题？应该如何解决？\"><a href=\"#并发事务有什么什么问题？应该如何解决？\" class=\"headerlink\" title=\"并发事务有什么什么问题？应该如何解决？\"></a>并发事务有什么什么问题？应该如何解决？</h3><p>并发事务可能造成：脏读、不可重复读和幻读等问题 ，这些问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决，解决方案如下：</p>\n<ul>\n<li><p>加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</p>\n</li>\n<li><p>提供数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取，从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-事务实现原理是什么？\"><a href=\"#MySQL-事务实现原理是什么？\" class=\"headerlink\" title=\"MySQL 事务实现原理是什么？\"></a>MySQL 事务实现原理是什么？</h3><p>以 InnoDB 的事务实现为例，InnoDB 是通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。<br>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。</p>\n<h2 id=\"MVCC详细版\"><a href=\"#MVCC详细版\" class=\"headerlink\" title=\"MVCC详细版\"></a>MVCC详细版</h2><h3 id=\"1-相关数据库知识点回顾\"><a href=\"#1-相关数据库知识点回顾\" class=\"headerlink\" title=\"1. 相关数据库知识点回顾\"></a>1. 相关数据库知识点回顾</h3><h4 id=\"1-1-什么是数据库事务，为什么要有事务\"><a href=\"#1-1-什么是数据库事务，为什么要有事务\" class=\"headerlink\" title=\"1.1 什么是数据库事务，为什么要有事务\"></a>1.1 什么是数据库事务，为什么要有事务</h4><p>事务，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p>\n<p><strong>为什么要有事务呢？</strong> 就是为了保证数据的最终一致性。</p>\n<h4 id=\"1-2-事务包括哪几个特性？\"><a href=\"#1-2-事务包括哪几个特性？\" class=\"headerlink\" title=\"1.2 事务包括哪几个特性？\"></a>1.2 事务包括哪几个特性？</h4><p>事务四个典型特性，即 ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>\n<ul>\n<li>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作<strong>要么全部都执行，要么都不执行</strong>。</li>\n<li>一致性： 指在<strong>事务开始之前和事务结束以后</strong>，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。</li>\n<li>隔离性： 多个事务并发访问时，<strong>事务之间是相互隔离</strong>的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。</li>\n<li>持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将<strong>持久地保存在数据库</strong>之中。</li>\n</ul>\n<h4 id=\"1-3-事务并发存在的问题\"><a href=\"#1-3-事务并发存在的问题\" class=\"headerlink\" title=\"1.3 事务并发存在的问题\"></a>1.3 事务并发存在的问题</h4><p>事务并发会引起<strong>脏读、不可重复读、幻读</strong>问题。</p>\n<h5 id=\"1-3-1-脏读\"><a href=\"#1-3-1-脏读\" class=\"headerlink\" title=\"1.3.1 脏读\"></a>1.3.1 脏读</h5><blockquote>\n<p>如果一个事务读取到了另一个未提交事务修改过的数据，我们就称发生了脏读现象。</p>\n</blockquote>\n<h5 id=\"1-3-2-不可重复读\"><a href=\"#1-3-2-不可重复读\" class=\"headerlink\" title=\"1.3.2 不可重复读\"></a>1.3.2 不可重复读</h5><blockquote>\n<p>同一个事务内，前后多次读取，读取到的数据内容不一致</p>\n</blockquote>\n<h5 id=\"1-3-3-幻读\"><a href=\"#1-3-3-幻读\" class=\"headerlink\" title=\"1.3.3 幻读\"></a>1.3.3 幻读</h5><blockquote>\n<p>如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如insert、delete、update），两次读取到的结果集却不一样了，就意味着发生了<strong>幻读</strong>。</p>\n</blockquote>\n<h4 id=\"1-4-四大隔离级别\"><a href=\"#1-4-四大隔离级别\" class=\"headerlink\" title=\"1.4 四大隔离级别\"></a>1.4 四大隔离级别</h4><p>为了解决并发事务存在的<strong>脏读、不可重复读、幻读</strong>等问题，数据库大叔设计了四种隔离级别。分别是<strong>读未提交，读已提交，可重复读，串行化（Serializable）</strong>。</p>\n<h5 id=\"1-4-1-读未提交\"><a href=\"#1-4-1-读未提交\" class=\"headerlink\" title=\"1.4.1 读未提交\"></a>1.4.1 读未提交</h5><p>读未提交隔离级别，只限制了两个数据<strong>不能同时修改</strong>，但是修改数据的时候，即使事务<strong>未提交</strong>，都是可以被别的事务读取到的，这级别的事务隔离有<strong>脏读、重复读、幻读</strong>的问题；</p>\n<h5 id=\"1-4-2-读已提交\"><a href=\"#1-4-2-读已提交\" class=\"headerlink\" title=\"1.4.2 读已提交\"></a>1.4.2 读已提交</h5><p>读已提交隔离级别，当前事务只能读取到其他事务<strong>提交</strong>的数据，所以这种事务的隔离级别<strong>解决了脏读</strong>问题，但还是会存在<strong>重复读、幻读</strong>问题；</p>\n<h5 id=\"1-4-3-可重复读\"><a href=\"#1-4-3-可重复读\" class=\"headerlink\" title=\"1.4 3 可重复读\"></a>1.4 3 可重复读</h5><p>可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以<strong>解决了重复读</strong>的问题，但是读取范围数据的时候，是可以插入数据，所以还会存在<strong>幻读</strong>问题；</p>\n<h5 id=\"1-4-4-串行化\"><a href=\"#1-4-4-串行化\" class=\"headerlink\" title=\"1.4.4 串行化\"></a>1.4.4 串行化</h5><p>事务最高的隔离级别，在该级别下，所有事务都是进行<strong>串行化顺序</strong>执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。</p>\n<h5 id=\"1-4-5-四大隔离级别，都会存在哪些并发问题呢\"><a href=\"#1-4-5-四大隔离级别，都会存在哪些并发问题呢\" class=\"headerlink\" title=\"1.4.5 四大隔离级别，都会存在哪些并发问题呢\"></a>1.4.5 四大隔离级别，都会存在哪些并发问题呢</h5><table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>读未提交</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>读已提交</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>可重复读</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>串行化</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-5-数据库是如何保证事务的隔离性的呢？\"><a href=\"#1-5-数据库是如何保证事务的隔离性的呢？\" class=\"headerlink\" title=\"1.5 数据库是如何保证事务的隔离性的呢？\"></a>1.5 数据库是如何保证事务的隔离性的呢？</h4><p>数据库是通过<strong>加锁</strong>，来实现事务的隔离性的。这就好像，如果你想一个人静静，不被别人打扰，你就可以在房门上加上一把锁。</p>\n<p>加锁确实好使，可以保证隔离性。比如<strong>串行化隔离级别就是加锁实现的</strong>。但是频繁的加锁，导致读数据时，没办法修改，修改数据时，没办法读取，大大<strong>降低了数据库性能</strong>。</p>\n<p><strong>那么，如何解决加锁后的性能问题的？</strong></p>\n<p>答案就是,<strong>MVCC多版本并发控制</strong>！它实现读取数据不用加锁，可以让读取数据同时修改。修改数据时同时可读取。</p>\n<h3 id=\"2-什么是-MVCC？\"><a href=\"#2-什么是-MVCC？\" class=\"headerlink\" title=\"2. 什么是 MVCC？\"></a>2. 什么是 MVCC？</h3><p>MVCC，即<strong>Multi-Version  Concurrency Control （多版本并发控制）</strong>。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>\n<blockquote>\n<p>通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是某一条记录的多个版本同时存在，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本id，比对事务id并根据事物隔离级别去判断读取哪个版本的数据。</p>\n</blockquote>\n<p>数据库隔离级别<strong>读已提交、可重复读</strong> 都是基于 MVCC 实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。</p>\n<h3 id=\"3-MVCC实现的关键知识点\"><a href=\"#3-MVCC实现的关键知识点\" class=\"headerlink\" title=\"3. MVCC实现的关键知识点\"></a>3. MVCC实现的关键知识点</h3><h4 id=\"3-1-事务版本号\"><a href=\"#3-1-事务版本号\" class=\"headerlink\" title=\"3.1 事务版本号\"></a>3.1 事务版本号</h4><blockquote>\n<p>事务每次开启前，都会从数据库获得一个<strong>自增长</strong>的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p>\n</blockquote>\n<h4 id=\"3-2-隐式字段\"><a href=\"#3-2-隐式字段\" class=\"headerlink\" title=\"3.2 隐式字段\"></a>3.2 隐式字段</h4><p>对于 InnoDB 存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非 NULL 唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p>\n<table>\n<thead>\n<tr>\n<th>列名</th>\n<th>是否必须</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>row_id</td>\n<td>否</td>\n<td>单调递增的行ID，不是必需的，占用6个字节。</td>\n</tr>\n<tr>\n<td>trx_id</td>\n<td>是</td>\n<td>记录操作该数据事务的<strong>事务ID</strong></td>\n</tr>\n<tr>\n<td>roll_pointer</td>\n<td>是</td>\n<td>这个隐藏列就相当于一个<strong>回滚指针</strong>，指向回滚段的undo日志</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-3-undo-log\"><a href=\"#3-3-undo-log\" class=\"headerlink\" title=\"3.3 undo log\"></a>3.3 undo log</h4><p>undo log，<strong>回滚日志</strong>，用于<strong>记录数据被修改前</strong>的信息。在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。</p>\n<p>可以这样认为，当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，当 update 一条记录时，它记录一条对应相反的 update 记录。</p>\n<p>undo log 有什么<strong>用途</strong>呢？</p>\n<ol>\n<li>事务回滚时，保证原子性和一致性。</li>\n<li>用于 MVCC<strong>快照读</strong>。</li>\n</ol>\n<h4 id=\"3-4-版本链\"><a href=\"#3-4-版本链\" class=\"headerlink\" title=\"3.4 版本链\"></a>3.4 版本链</h4><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131424393.png\" alt=\"image-20220422131424393\"></p>\n<p>其实，通过版本链，我们就可以看出<strong>事务版本号、表格隐藏的列和undo log</strong>它们之间的关系。我们再来小分析一下。</p>\n<ol>\n<li><p>假设现在有一张 core_user 表，表里面有一条数据,id 为 1，名字为孙权：</p>\n <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131445316.png\" alt=\"image-20220422131445316\" style=\"zoom: 50%;\" />\n</li>\n<li><p>现在开启一个事务 A： 对 core_user 表执行<code>update core_user set name =&quot;曹操&quot; where id=1</code>,会进行如下流程操作</p>\n</li>\n</ol>\n<ul>\n<li><p>首先获得一个事务 ID&#x3D;100</p>\n</li>\n<li><p>把 core_user 表修改前的数据,拷贝到 undo log</p>\n</li>\n<li><p>修改 core_user 表中，id&#x3D;1 的数据，名字改为曹操</p>\n</li>\n<li><p>把修改后的数据事务 Id&#x3D;101 改成当前事务版本号，并把<strong>roll_pointer</strong>指向 undo log 数据地址。</p>\n  <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131527508.png\" alt=\"image-20220422131527508\" style=\"zoom: 50%;\" /></li>\n</ul>\n<h4 id=\"3-5-快照读和当前读\"><a href=\"#3-5-快照读和当前读\" class=\"headerlink\" title=\"3.5 快照读和当前读\"></a>3.5 快照读和当前读</h4><p><strong>快照读：</strong> 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的 select 语句都是快照读,如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from core_user where id &gt; 2;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from core_user where id &gt; 2 for update;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-6-Read-View\"><a href=\"#3-6-Read-View\" class=\"headerlink\" title=\"3.6 Read View\"></a>3.6 Read View</h4><ul>\n<li><strong>Read View是什么呢？</strong> 它就是事务执行 SQL 语句时，产生的读视图。实际上在 innodb 中，每个 SQL 语句执行前都会得到一个 Read View。</li>\n<li><strong>Read View有什么用呢？</strong> 它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据</li>\n</ul>\n<p>Read View 是如何保证可见性判断的呢？我们先看看 Read view 的几个重要属性</p>\n<ul>\n<li>m_ids:当前系统中那些活跃(<strong>未提交</strong>)的读写事务 ID, 它数据结构为一个 List，[min_limit_id, max_limit_id)</li>\n<li>min_limit_id:表示在生成 ReadView 时，当前系统中活跃的读写事务中最小的事务 id，即 m_ids 中的最小值。</li>\n<li>max_limit_id:表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值，即即 m_ids 中的最大值+1</li>\n<li>creator_trx_id: 创建当前 read view 的事务 ID</li>\n</ul>\n<p><strong>Read view 匹配条件规则</strong>如下：</p>\n<ol>\n<li>如果新的数据事务 ID <code>trx_id &lt; min_limit_id</code>，表明生成该版本的事务在生成 Read View 前，已经提交(因为事务 ID 是递增的)，所以该版本可以被当前事务访问。</li>\n<li>如果<code>trx_id&gt;= max_limit_id</code>，表明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。</li>\n<li>如果 <code>min_limit_id =&lt;trx_id&lt; max_limit_id</code>,需要分 3 种情况讨论</li>\n</ol>\n<blockquote>\n<p>（1）如果<code>m_ids</code>包含<code>trx_id</code>,则代表Read View生成时刻，这个事务还未提交，但是如果数据的<code>trx_id</code>等于<code>creator_trx_id</code>的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</p>\n<p>（2）如果<code>m_ids</code>包含<code>trx_id</code>，并且<code>trx_id</code>不等于<code>creator_trx_id</code>，则Read  View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</p>\n<p>（3）如果<code>m_ids</code>不包含<code>trx_id</code>，则说明你这个事务在Read View生成之前就<strong>已经提交</strong>了，修改的结果，当前事务是能看见的。</p>\n</blockquote>\n<h3 id=\"4-MVCC实现原理分析\"><a href=\"#4-MVCC实现原理分析\" class=\"headerlink\" title=\"4. MVCC实现原理分析\"></a>4. MVCC实现原理分析</h3><img src=\"/Users/yaxing/blog/source/_posts/E:/Markdown%E6%96%87%E6%A1%A3%E5%9B%BE%E7%89%87/8%20MySQL.assets/v2-a086ef515e7d0a023ca3cfcc5759c7f6_720w.jpg\" alt=\"img\" style=\"zoom: 80%;\" />\n\n<h4 id=\"4-1-查询一条记录，基于MVCC，是怎样的流程\"><a href=\"#4-1-查询一条记录，基于MVCC，是怎样的流程\" class=\"headerlink\" title=\"4.1 查询一条记录，基于MVCC，是怎样的流程\"></a>4.1 查询一条记录，基于MVCC，是怎样的流程</h4><ol>\n<li>获取事务 ID</li>\n<li>执行 sql，得到 Read View</li>\n<li>查询得到的数据，然后与 Read View 中的事务 ID 进行比较，帮助判断当前版本的数据是否可见。</li>\n<li>如果不符合 Read View 的可见性规则， 即就需要 Undo log 中历史快照;</li>\n<li>最后返回符合规则的数据</li>\n</ol>\n<p>InnoDB 实现 MVCC，是通过<code> Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见。</p>\n<h4 id=\"4-2-读已提交（RC）隔离级别，存在不可重复读问题的分析历程\"><a href=\"#4-2-读已提交（RC）隔离级别，存在不可重复读问题的分析历程\" class=\"headerlink\" title=\"4.2 读已提交（RC）隔离级别，存在不可重复读问题的分析历程\"></a>4.2 读已提交（RC）隔离级别，存在不可重复读问题的分析历程</h4><ol>\n<li><p>创建 core_user 表，插入一条初始化数据,如下：</p>\n <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131554547.png\" alt=\"image-20220422131554547\" style=\"zoom: 33%;\" />\n</li>\n<li><p>隔离级别设置为读已提交（RC），事务 A 和事务 B 同时对 core_user 表进行查询和修改操作。</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">事务A: select * fom core_user where id=1</span><br><span class=\"line\">事务B: update core_user set name =”曹操”</span><br><span class=\"line\">// 事务A两次读到的数据不一样，事务A会读到其他事务提交的数据，不能读到其他事务未提交的数据。</span><br></pre></td></tr></table></figure>\n\n<p>执行流程如下：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131620047.png\" alt=\"image-20220422131620047\" style=\"zoom: 33%;\" />\n\n<p>最后事务 A 查询到的结果是，<strong>name&#x3D;曹操</strong>的记录，我们<strong>基于MVCC</strong>，来分析一下执行流程：</p>\n<p>(1) A 开启事务，首先得到一个事务 ID 为 100</p>\n<p>(2) B 开启事务，得到事务 ID 为 101</p>\n<p>(3) 事务 A 生成一个 Read View，read view 对应的值如下</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids（未提交的事务ID）</td>\n<td>100，101</td>\n</tr>\n<tr>\n<td>max_limit_id（下一个应该分配的事务ID）</td>\n<td>102</td>\n</tr>\n<tr>\n<td>min_limit_id（当前read view中活跃的未提交事务的最小值）</td>\n<td>100</td>\n</tr>\n<tr>\n<td>creator_trx_id（创建该read view的事务ID）</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>然后回到版本链：开始从版本链中挑选可见的记录：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131642264.png\" alt=\"image-20220422131642264\" style=\"zoom: 33%;\" />\n\n<p>由图可以看出，最新版本的列 name 的内容是<code>孙权</code>，该版本的<code>trx_id</code>值为 100。开始执行 read view 可见性规则校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（100）&lt;102;</span><br><span class=\"line\">creator_trx_id = trx_id =100;</span><br></pre></td></tr></table></figure>\n\n<p>由此可得，trx_id&#x3D;100 的这个记录，当前事务是可见的。所以查到是 name 为<code>孙权</code>的记录。</p>\n<p>(4) 事务 B 进行修改操作，把名字改为曹操。把原数据拷贝到 undo log,然后对数据进行修改，标记事务 ID 和上一个数据版本在 undo log 的地址。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131733370.png\" alt=\"image-20220422131733370\" style=\"zoom:33%;\" />\n\n<p>(5) 提交事务</p>\n<p>(6) 事务 A 再次执行查询操作，<strong>新生成一个Read View</strong>，Read View 对应的值如下</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids（未提交的事务ID）</td>\n<td>100</td>\n</tr>\n<tr>\n<td>max_limit_id（下一个应当分配的事务ID）</td>\n<td>102</td>\n</tr>\n<tr>\n<td>min_limit_id（最小的事务ID）</td>\n<td>100</td>\n</tr>\n<tr>\n<td>creator_trx_id（创建read view的事务ID）</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>然后再次回到版本链：从版本链中挑选可见的记录：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131753554.png\" alt=\"image-20220422131753554\" style=\"zoom:33%;\" />\n\n<p>从图可得，最新版本的列 name 的内容是<code>曹操</code>，该版本的<code>trx_id</code>值为 101。开始执行 Read View 可见性规则校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（101）&lt;max_limit_id（102);</span><br><span class=\"line\">但是,trx_id=101，不属于m_ids集合，说明101这个事务已经提交了，当前事务可见</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>trx_id=101</code>这个记录，对于当前事务是可见的。所以 SQL 查询到的是 name 为<code>曹操</code>的记录。</p>\n<p>综上所述，在<strong>读已提交（RC）隔离级别</strong>下，同一个事务里，两个相同的查询，读取同一条记录（id&#x3D;1），却返回了不同的数据（<strong>第一次查出来是孙权，第二次查出来是曹操那条记录</strong>），因此 RC 隔离级别，存在<strong>不可重复读</strong>并发问题。</p>\n<h4 id=\"4-3-可重复读（RR）隔离级别，解决不可重复读问题的分析\"><a href=\"#4-3-可重复读（RR）隔离级别，解决不可重复读问题的分析\" class=\"headerlink\" title=\"4.3 可重复读（RR）隔离级别，解决不可重复读问题的分析\"></a>4.3 可重复读（RR）隔离级别，解决不可重复读问题的分析</h4><p>在 RR 隔离级别下，是如何解决不可重复读问题的呢？我们一起再来看下，</p>\n<p>还是 4.2 小节那个流程，还是这个事务 A 和事务 B，如下：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131811671.png\" alt=\"image-20220422131811671\" style=\"zoom:33%;\" />\n\n<h5 id=\"4-3-1-不同隔离级别下，Read-view的工作方式不同\"><a href=\"#4-3-1-不同隔离级别下，Read-view的工作方式不同\" class=\"headerlink\" title=\"4.3.1 不同隔离级别下，Read view的工作方式不同\"></a>4.3.1 不同隔离级别下，Read view的工作方式不同</h5><p>实际上，各种事务隔离级别下的 Read view 工作方式，是不一样的，RR 可以解决不可重复读问题，就是跟<strong>Read view工作方式有关</strong>。</p>\n<ul>\n<li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n</tbody></table>\n<ul>\n<li>在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>begin</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>生成一个Read View</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td></td>\n</tr>\n<tr>\n<td>select * from core_user where id &#x3D;1</td>\n<td>共用一个Read View副本</td>\n</tr>\n</tbody></table>\n<h5 id=\"4-3-2-实例分析\"><a href=\"#4-3-2-实例分析\" class=\"headerlink\" title=\"4.3.2 实例分析\"></a>4.3.2 实例分析</h5><p>我们穿越下，回到<strong>刚4.2的例子</strong>，然后执行第 2 个查询的时候：</p>\n<p>事务 A 再次执行查询操作，复用老的 Read View 副本，Read View 对应的值如下</p>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>m_ids</td>\n<td>100，101</td>\n</tr>\n<tr>\n<td>max_limit_id</td>\n<td>102</td>\n</tr>\n<tr>\n<td>min_limit_id</td>\n<td>100</td>\n</tr>\n<tr>\n<td>creator_trx_id</td>\n<td>100</td>\n</tr>\n</tbody></table>\n<p>然后再次回到版本链：从版本链中挑选可见的记录：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131828812.png\" alt=\"image-20220422131828812\" style=\"zoom:33%;\" />\n\n<p>从图可得，最新版本的列 name 的内容是<code>曹操</code>，该版本的<code>trx_id</code>值为 101。开始执行 read view 可见性规则校验：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（101）&lt;max_limit_id（102);</span><br><span class=\"line\">因为m_ids&#123;100,101&#125;包含trx_id（101），</span><br><span class=\"line\">并且creator_trx_id (100) 不等于trx_id（101）</span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>trx_id=101</code>这个记录，对于当前事务是<strong>不可见</strong>的。这时候呢，版本链<code>roll_pointer</code>跳到下一个版本，<code>trx_id=100</code>这个记录，再次校验是否可见：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_limit_id(100)=&lt;trx_id（100）&lt; max_limit_id（102);</span><br><span class=\"line\">因为m_ids&#123;100,101&#125;包含trx_id（100），</span><br><span class=\"line\">并且creator_trx_id (100) 等于trx_id（100）</span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>trx_id=100</code>这个记录，对于当前事务是<strong>可见</strong>的。即在可重复读（RR）隔离级别下，复用老的 Read View 副本，解决了<strong>不可重复读</strong>的问题。</p>\n<h4 id=\"4-4-MVCC是否解决了幻读问题呢？\"><a href=\"#4-4-MVCC是否解决了幻读问题呢？\" class=\"headerlink\" title=\"4.4 MVCC是否解决了幻读问题呢？\"></a>4.4 MVCC是否解决了幻读问题呢？</h4><p>对于幻读来说，存在当前读和快照读的情况：</p>\n<ol>\n<li>RR 隔离级别下为了解决幻读问题：<strong>快照读依靠MVCC控制，当前读通过间隙锁解决</strong>；</li>\n<li>间隙锁和行锁合称 Next-Key Locks，每个 Next-Key Locks 是前开后闭区间；</li>\n<li>间隙锁的引入，可能会导致同样语句锁住更大的范围，影响并发度。</li>\n</ol>\n<p>作者：捡田螺的小男孩</p>\n<p>链接：<a href=\"https://juejin.cn/post/7016165148020703246\">https://juejin.cn/post/7016165148020703246</a></p>\n<p>来源：稀土掘金</p>\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n<h2 id=\"MySQL锁篇\"><a href=\"#MySQL锁篇\" class=\"headerlink\" title=\"MySQL锁篇\"></a>MySQL锁篇</h2><h3 id=\"什么是锁？MySQL-中提供了几类锁？\"><a href=\"#什么是锁？MySQL-中提供了几类锁？\" class=\"headerlink\" title=\"什么是锁？MySQL 中提供了几类锁？\"></a>什么是锁？MySQL 中提供了几类锁？</h3><p>锁是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。</p>\n<p>排他锁（写锁），共享锁（读锁）<br>乐观锁，悲观锁<br>全局锁，表锁，行锁，页锁</p>\n<h3 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h3><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>\n<h3 id=\"如何处理死锁？\"><a href=\"#如何处理死锁？\" class=\"headerlink\" title=\"如何处理死锁？\"></a>如何处理死锁？</h3><p>对待死锁常见的两种策略：</p>\n<ul>\n<li><p>设置超时时间</p>\n</li>\n<li><p>发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</p>\n</li>\n</ul>\n<h3 id=\"如何避免死锁？\"><a href=\"#如何避免死锁？\" class=\"headerlink\" title=\"如何避免死锁？\"></a>如何避免死锁？</h3><p>使用 SELECT … FOR UPDATE 语句来获取必要的锁。</p>\n<h3 id=\"什么是全局锁？它的应用场景有哪些？\"><a href=\"#什么是全局锁？它的应用场景有哪些？\" class=\"headerlink\" title=\"什么是全局锁？它的应用场景有哪些？\"></a>什么是全局锁？它的应用场景有哪些？</h3><p>全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全库逻辑备份。 这个命令可以使整个库处于只读状态。使用该命令之后，数据更新语句、数据定义语句、更新类事务的提交语句等操作都会被阻塞。</p>\n<h3 id=\"什么是共享锁？\"><a href=\"#什么是共享锁？\" class=\"headerlink\" title=\"什么是共享锁？\"></a>什么是共享锁？</h3><p>共享锁又称读锁 (read lock)，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事务对读锁进行修改操作，很可能会造成死锁。</p>\n<h3 id=\"什么是排它锁？\"><a href=\"#什么是排它锁？\" class=\"headerlink\" title=\"什么是排它锁？\"></a>什么是排它锁？</h3><p>排他锁 exclusive lock（也叫 writer lock）又称写锁。</p>\n<p>若某个事物对某一行加上了排他锁，只能这个事务对其进行读写，在此事务结束之前，其他事务不能对其进行加任何锁，其他进程可以读取,不能进行写操作，需等待其释放。</p>\n<p>排它锁是悲观锁的一种实现，在上面悲观锁也介绍过。</p>\n<h3 id=\"使用全局锁会导致什么问题？\"><a href=\"#使用全局锁会导致什么问题？\" class=\"headerlink\" title=\"使用全局锁会导致什么问题？\"></a>使用全局锁会导致什么问题？</h3><p>如果在主库备份，在备份期间不能更新，业务停摆，所以更新业务会处于等待状态。</p>\n<p>如果在从库备份，在备份期间不能执行主库同步的 binlog，导致主从延迟。</p>\n<p>如果使用全局锁进行逻辑备份就会让整个库成为只读状态，幸好官方推出了一个逻辑备份工具 MySQL dump 来解决了这个问题，只需要在使用 MySQLdump 时，使用参数 single-transaction 就会在导入数据之前启动一个事务来保证数据的一致性，并且这个过程是支持数据更新操作的。</p>\n<h3 id=\"悲观锁和乐观锁有什么区别？\"><a href=\"#悲观锁和乐观锁有什么区别？\" class=\"headerlink\" title=\"悲观锁和乐观锁有什么区别？\"></a>悲观锁和乐观锁有什么区别？</h3><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。正因为如此，悲观锁需要耗费较多的时间，另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</p>\n<p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p>\n<p><strong>乐观锁是用数据版本（Version）记录机制实现</strong>，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 version 字段来实现。当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值进行比对，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。</p>\n<h3 id=\"乐观锁有什么优点和缺点？\"><a href=\"#乐观锁有什么优点和缺点？\" class=\"headerlink\" title=\"乐观锁有什么优点和缺点？\"></a>乐观锁有什么优点和缺点？</h3><p>因为没有加锁所以乐观锁的优点就是执行性能高。它的缺点就是有可能产生 ABA 的问题，ABA 问题指的是有一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，会误以为没有被修改会正常的执行修改操作，实际上这段时间它的值可能被改了其他值，之后又改回为 A 值，这个问题被称为 ABA 问题。</p>\n<h3 id=\"⭐InnoDB-存储引擎有几种锁算法？\"><a href=\"#⭐InnoDB-存储引擎有几种锁算法？\" class=\"headerlink\" title=\"⭐InnoDB 存储引擎有几种锁算法？\"></a>⭐InnoDB 存储引擎有几种锁算法？</h3><ul>\n<li><p>Record Lock — 单个行记录上的锁；</p>\n</li>\n<li><p>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</p>\n</li>\n<li><p>Next-Key Lock（包含行锁和间隙锁） — 锁定一个范围，包括记录本身。</p>\n</li>\n</ul>\n<h3 id=\"InnoDB-如何实现行锁？\"><a href=\"#InnoDB-如何实现行锁？\" class=\"headerlink\" title=\"InnoDB 如何实现行锁？\"></a>InnoDB 如何实现行锁？</h3><p>共享锁：<strong>in share mode</strong></p>\n<p>排他锁：<strong>for update</strong></p>\n<h3 id=\"优化锁方面你有什么建议？\"><a href=\"#优化锁方面你有什么建议？\" class=\"headerlink\" title=\"优化锁方面你有什么建议？\"></a>优化锁方面你有什么建议？</h3><ul>\n<li>尽量使用较低的隔离级别。</li>\n<li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</li>\n<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>\n<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>\n<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</li>\n<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>\n<li>不要申请超过实际需要的锁级别。</li>\n<li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</li>\n<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>\n</ul>\n<h3 id=\"MySQL-中有哪几种锁？\"><a href=\"#MySQL-中有哪几种锁？\" class=\"headerlink\" title=\"MySQL 中有哪几种锁？\"></a>MySQL 中有哪几种锁？</h3><p><strong>1、表级锁：</strong> 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 并发度最低。</p>\n<p><strong>2、行级锁：</strong>  开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 并发度也最高。</p>\n<p><strong>3、页锁：</strong>  开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和行锁之间， 并发度一般。</p>\n<h3 id=\"锁机制与InnoDB锁算法\"><a href=\"#锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"锁机制与InnoDB锁算法\"></a>锁机制与InnoDB锁算法</h3><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM 采用表级锁(table-level locking)。</li>\n<li>InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</li>\n</ul>\n<p><strong>表级锁和行级锁对比：</strong></p>\n<ul>\n<li><p><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</p>\n</li>\n<li><p><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>\n</li>\n</ul>\n<h3 id=\"锁的优化策略\"><a href=\"#锁的优化策略\" class=\"headerlink\" title=\"锁的优化策略\"></a>锁的优化策略</h3><p><strong>1、</strong> 读写分离</p>\n<p><strong>2、</strong> 分段加锁</p>\n<p><strong>3、</strong> 减少锁持有的时间</p>\n<p>多个线程尽量以相同的顺序去获取资源</p>\n<p>不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如一次加一把大锁。</p>\n<h2 id=\"MySQL日志篇\"><a href=\"#MySQL日志篇\" class=\"headerlink\" title=\"MySQL日志篇\"></a>MySQL日志篇</h2><h3 id=\"MySQL-有哪些重要的日志文件？\"><a href=\"#MySQL-有哪些重要的日志文件？\" class=\"headerlink\" title=\"MySQL 有哪些重要的日志文件？\"></a>MySQL 有哪些重要的日志文件？</h3><p>MySQL 中的重要日志分为以下几个：</p>\n<p><strong>① 错误日志：</strong>用来记录 MySQL 服务器运行过程中的错误信息</p>\n<p><strong>② 查询日志</strong>：查询日志在 MySQL 中被称为 general log(通用日志)，查询日志里的内容不要被“查询日志”误导，认为里面只存储 select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p>\n<ul>\n<li><p>insert 查询为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</p>\n</li>\n<li><p>update 时也会查询因为更新的时候很可能会更新某一块数据；</p>\n</li>\n<li><p>delete 查询，只删除符合条件的数据；</p>\n</li>\n</ul>\n<p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL 性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p>\n<p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select 语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。</p>\n<p><strong>③ 慢日志</strong>：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让 MySQL 记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global slowquerylog=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>\n\n<p>使用 set global slow<em>query</em>log&#x3D;’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL 数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf，设置 slow<em>query</em>log&#x3D;1 并重启 MySQL 服务器。</p>\n<p><strong>④ redo log（重做日志）</strong>：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL 采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB 采用 redo log 来解决此问题。</p>\n<p><strong>⑤ undo log（回滚日志）</strong>：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。 undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p>\n<p><strong>⑥ bin log（二进制日志）</strong>：是一个二进制文件，主要<strong>记录了对 MySQL 数据库执行更改的所有操作</strong>，比如，CREATE、ALTER TABLE 等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，不记录 SELECT、SHOW 等那些不修改数据或数据库结构的 SQL 语句。</p>\n<p>binlog 的作用如下：</p>\n<ul>\n<li><p>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</p>\n</li>\n<li><p>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者 standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</p>\n</li>\n<li><p>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p>\n</li>\n</ul>\n<p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo 的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和 commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog 中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p>\n<p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin &#x3D; [base-name] 开启记录 binlog 日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p>\n<p>通过以下命令来查询 binlog 是否开启：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show variables like &#x27;log_%&#x27;; </span><br></pre></td></tr></table></figure>\n\n<p>binlog 格式分为: STATEMENT、ROW 和 MIXED 三种：</p>\n<ul>\n<li><p>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL。比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如：InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制；</p>\n</li>\n<li><p>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，所以可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等；</p>\n</li>\n<li><p>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT<em>USER()、ROW</em>COUNT() 等无法确定的函数。</p>\n</li>\n</ul>\n<h3 id=\"redo-log-和-binlog-有什么区别？\"><a href=\"#redo-log-和-binlog-有什么区别？\" class=\"headerlink\" title=\"redo log 和 binlog 有什么区别？\"></a>redo log 和 binlog 有什么区别？</h3><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p>\n<ul>\n<li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p>\n</li>\n<li><p>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</p>\n</li>\n<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>\n</li>\n<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>\n</li>\n</ul>\n<p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p>\n<h3 id=\"什么是-crash-safe？\"><a href=\"#什么是-crash-safe？\" class=\"headerlink\" title=\"什么是 crash-safe？\"></a>什么是 crash-safe？</h3><p>crash-safe 是指发生宕机等意外情况下，服务器重启后数据依然不会丢失的情况。</p>\n<h3 id=\"什么是脏页和干净页？\"><a href=\"#什么是脏页和干净页？\" class=\"headerlink\" title=\"什么是脏页和干净页？\"></a>什么是脏页和干净页？</h3><p>MySQL 为了操作的性能优化，会把数据更新先放入内存中，之后再统一更新到磁盘。当内存数据和磁盘数据内容不一致的时候，我们称这个内存页为脏页；内存数据写到磁盘后，内存的数据和磁盘上的内容就一致了，我们称为“干净页”。</p>\n<h3 id=\"什么情况下会引发-MySQL-刷脏页（flush）的操作？\"><a href=\"#什么情况下会引发-MySQL-刷脏页（flush）的操作？\" class=\"headerlink\" title=\"什么情况下会引发 MySQL 刷脏页（flush）的操作？\"></a>什么情况下会引发 MySQL 刷脏页（flush）的操作？</h3><ul>\n<li><p>内存写满了，这个时候就会引发 flush 操作，对应到 InnoDB 就是 redo log 写满了；</p>\n</li>\n<li><p>系统的内存不足了，当需要新的内存页的时候，就会淘汰一些内存页，如果淘汰的是脏页这个时候就会触发 flush 操作；</p>\n</li>\n<li><p>系统空闲的时候，MySQL 会同步内存中的数据到磁盘也会触发 flush 操作；</p>\n</li>\n<li><p>MySQL 服务关闭的时候也会刷脏页，触发 flush 操作。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-刷脏页的速度很慢可能是什么原因？\"><a href=\"#MySQL-刷脏页的速度很慢可能是什么原因？\" class=\"headerlink\" title=\"MySQL 刷脏页的速度很慢可能是什么原因？\"></a>MySQL 刷脏页的速度很慢可能是什么原因？</h3><p>在 MySQL 中单独刷一个脏页的速度是很快的，如果发现刷脏页的速度很慢，说明触发了 MySQL 刷脏页的“连坐”机制，MySQL 的“连坐”机制是指当 MySQL 刷脏页的时候如果发现相邻的数据页也是脏页也会一起刷掉，而这个动作可以一直蔓延下去，这就是导致 MySQL 刷脏页慢的原因了。</p>\n<h3 id=\"如何控制-MySQL-只刷新当前脏页？\"><a href=\"#如何控制-MySQL-只刷新当前脏页？\" class=\"headerlink\" title=\"如何控制 MySQL 只刷新当前脏页？\"></a>如何控制 MySQL 只刷新当前脏页？</h3><p>在 InnoDB 中设置 innodb<em>flush</em>neighbors 这个参数的值为 0，来规定 MySQL 只刷当前脏页，MySQL 8 这个值默认是 0。</p>\n<h3 id=\"MySQL-的-WAL-技术是解决什么问题的？\"><a href=\"#MySQL-的-WAL-技术是解决什么问题的？\" class=\"headerlink\" title=\"MySQL 的 WAL 技术是解决什么问题的？\"></a>MySQL 的 WAL 技术是解决什么问题的？</h3><p>A.防止误删除，找回数据用的 B.容灾恢复，为了还原异常数据用的 C.事务处理，为了数据库的稳定性 D.为了降低 IO 成本 答：D 题目解析：WAL 技术的全称是 Write Ahead Logging（中文：预写式日志），是先写日志，再写磁盘的方式，因为每次更新都写磁盘的话 IO 成本很高，所以才有了 WAL 技术。</p>\n<h3 id=\"为什么有时候会感觉-MySQL-偶尔卡一下？\"><a href=\"#为什么有时候会感觉-MySQL-偶尔卡一下？\" class=\"headerlink\" title=\"为什么有时候会感觉 MySQL 偶尔卡一下？\"></a>为什么有时候会感觉 MySQL 偶尔卡一下？</h3><p>如果偶尔感觉 MySQL 卡一下，可能是 MySQL 正在刷脏页，正在把内存中的更新操作刷到磁盘中。</p>\n<h3 id=\"redo-log-和-binlog-是怎么关联的\"><a href=\"#redo-log-和-binlog-是怎么关联的\" class=\"headerlink\" title=\"redo log 和 binlog 是怎么关联的?\"></a>redo log 和 binlog 是怎么关联的?</h3><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p>\n<ul>\n<li><p>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</p>\n</li>\n<li><p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-怎么知道-binlog-是完整的\"><a href=\"#MySQL-怎么知道-binlog-是完整的\" class=\"headerlink\" title=\"MySQL 怎么知道 binlog 是完整的?\"></a>MySQL 怎么知道 binlog 是完整的?</h3><ul>\n<li><p>statement 格式的 binlog，完整的标识是最后有 COMMIT 关键字。</p>\n</li>\n<li><p>row 格式的 binlog，完整的标识是最后会有一个 XID event 关键字。</p>\n</li>\n</ul>\n<h3 id=\"MySQL-中可不可以只要-binlog，不要-redo-log？\"><a href=\"#MySQL-中可不可以只要-binlog，不要-redo-log？\" class=\"headerlink\" title=\"MySQL 中可不可以只要 binlog，不要 redo log？\"></a>MySQL 中可不可以只要 binlog，不要 redo log？</h3><p>不可以，binlog 没有崩溃恢复的能力。</p>\n<h3 id=\"MySQL-中可不可以只要-redo-log，不要-binlog？\"><a href=\"#MySQL-中可不可以只要-redo-log，不要-binlog？\" class=\"headerlink\" title=\"MySQL 中可不可以只要 redo log，不要 binlog？\"></a>MySQL 中可不可以只要 redo log，不要 binlog？</h3><p>不可以，原因有以下两个：</p>\n<ul>\n<li><p>redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；</p>\n</li>\n<li><p>binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。</p>\n</li>\n</ul>\n<h3 id=\"为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？\"><a href=\"#为什么-binlog-cache-是每个线程自己维护的，而-redo-log-buffer-是全局共用的？\" class=\"headerlink\" title=\"为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？\"></a>为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</h3><p>因为 binlog 是不能“被打断的”，一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中，redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>\n<h3 id=\"事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？\"><a href=\"#事务执行期间，还未提交，如果发生-crash，redo-log-丢失，会导致主备不一致呢？\" class=\"headerlink\" title=\"事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？\"></a>事务执行期间，还未提交，如果发生 crash，redo log 丢失，会导致主备不一致呢？</h3><p>不会，因为这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。</p>\n<h3 id=\"在-MySQL-中用什么机制来优化随机读-x2F-写磁盘对-IO-的消耗？\"><a href=\"#在-MySQL-中用什么机制来优化随机读-x2F-写磁盘对-IO-的消耗？\" class=\"headerlink\" title=\"在 MySQL 中用什么机制来优化随机读&#x2F;写磁盘对 IO 的消耗？\"></a>在 MySQL 中用什么机制来优化随机读&#x2F;写磁盘对 IO 的消耗？</h3><p>redo log 是用来节省随机写磁盘的 IO 消耗，而 change buffer 主要是节省随机读磁盘的 IO 消耗。redo log 会把 MySQL 的更新操作先记录到内存中，之后再统一更新到磁盘，而 change buffer 也是把关键查询数据先加载到内存中，以便优化 MySQL 的查询。</p>\n<h3 id=\"以下说法错误的是？\"><a href=\"#以下说法错误的是？\" class=\"headerlink\" title=\"以下说法错误的是？\"></a>以下说法错误的是？</h3><p>A.redo log 是 InnoDB 引擎特有的，它的固定大小的 B.redo log 日志是不全的，只有最新的一些日志，这和它的内存大小有关 C.redo log 可以保证数据库异常重启之后，数据不丢失 D.binlog 是 MySQL 自带的日志，它能保证数据库异常重启之后，数据不丢失 答：D 题目解析：binlog 是 MySQL 自带的日志，但它并不能保证数据库异常重启之后数据不丢失。</p>\n<h3 id=\"以下说法正确的是？\"><a href=\"#以下说法正确的是？\" class=\"headerlink\" title=\"以下说法正确的是？\"></a>以下说法正确的是？</h3><p>A.redo log 日志是追加写的，后面的日志并不会覆盖前面的日志 B.binlog 日志是追加写的，后面的日志并不会覆盖前面的日志 C.redo log 和 binlog 日志都是追加写的，后面的日志并不会覆盖前面的日志 D.以上说法都正确 答：B 题目解析：binlog 日志是追加写的，后面的日志并不会覆盖前面的日志，redo log 日志是固定大小的，后面的日志会覆盖前面的日志。</p>\n<h3 id=\"有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？\"><a href=\"#有没有办法把-MySQL-的数据恢复到过去某个指定的时间节点？怎么恢复？\" class=\"headerlink\" title=\"有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？\"></a>有没有办法把 MySQL 的数据恢复到过去某个指定的时间节点？怎么恢复？</h3><p>可以恢复，只要你备份了这段时间的所有 binlog，同时做了全量数据库的定期备份，比如，一天一备，或者三天一备，这取决于你们的备份策略，这个时候你就可以把之前备份的数据库先还原到测试库，从备份的时间点开始，将备份的 binlog 依次取出来，重放到你要恢复数据的那个时刻，这个时候就完成了数据到指定节点的恢复。比如，今天早上 9 点的时候，你想把数据恢复成今天早上 6:00:00 的状态，这个时候你可以先取出今天凌晨（00:01:59）备份的数据库文件，还原到测试库，再从 binlog 文件中依次取出 00:01:59 之后的操作信息，重放到 6:00:00 这个时刻，这就完成了数据库的还原。</p>\n<h2 id=\"MySQL性能优化\"><a href=\"#MySQL性能优化\" class=\"headerlink\" title=\"MySQL性能优化\"></a>MySQL性能优化</h2><h3 id=\"MySQL-性能指标都有哪些？如何得到这些指标？\"><a href=\"#MySQL-性能指标都有哪些？如何得到这些指标？\" class=\"headerlink\" title=\"MySQL 性能指标都有哪些？如何得到这些指标？\"></a>MySQL 性能指标都有哪些？如何得到这些指标？</h3><p>MySQL 的性能指标如下：</p>\n<p><strong>① TPS（Transaction Per Second）</strong> 每秒事务数，即数据库每秒执行的事务数。</p>\n<p>MySQL 本身没有直接提供 TPS 参数值，如果我们想要获得 TPS 的值，只有我们自己计算了，可以根据 MySQL 数据库提供的状态变量，来计算 TPS。</p>\n<p>需要使用的参数：</p>\n<ul>\n<li><p>Com_commit ：表示提交次数，通过命令 <code>show global status like &#39;Com_commit&#39;;</code> 获取；</p>\n</li>\n<li><p>Com_rollback：表示回滚次数，通过命令 <code>show global status like &#39;Com_rollback&#39;;</code> 获取。</p>\n</li>\n</ul>\n<p>我们定义第一次获取的 Com<em>commit 的值与 Com</em>rollback 值的和为 c_r1，时间为 t1；</p>\n<p>第二次获取的 Com<em>commit 的值与 Com</em>rollback 值的和为 c<em>r2，时间为 t2，t1 与 t2 单位为秒。 那么 TPS &#x3D; ( c</em>r2 - c_r1 ) &#x2F; ( t2 - t1 ) 算出来的就是该 MySQL 实例在 t1 与 t2 生命周期之间的平均 TPS。</p>\n<p><strong>② QPS（Query Per Second）</strong> 每秒请求次数，也就是数据库每秒执行的 SQL 数量，包含 INSERT、SELECT、UPDATE、DELETE 等。 QPS &#x3D; Queries &#x2F; Seconds Queries 是系统状态值—总查询次数，可以通过 <code>show status like &#39;queries&#39;;</code> 查询得出 </p>\n<p>Seconds 是监控的时间区间，单位为秒。 比如，采样 10 秒内的查询次数，那么先查询一次 Queries 值（Q1），等待 10 秒，再查询一次 Queries 值（Q2），那么 QPS 就可以通过，如下公式获得：</p>\n<blockquote>\n<p>QPS &#x3D; (Q2 - Q1) &#x2F; 10</p>\n</blockquote>\n<p><strong>③ IOPS（Input&#x2F;Output Operations per Second）</strong> 每秒处理的 I&#x2F;O 请求次数。</p>\n<p>IOPS 是判断磁盘 I&#x2F;O 能力的指标之一，一般来讲 IOPS 指标越高，那么单位时间内能够响应的请求自然也就越多。理论上讲，只要系统实际的请求数低于 IOPS 的能力，就相当于每一个请求都能得到即时响应，那么 I&#x2F;O 就不会是瓶颈了。</p>\n<p>注意：IOPS 与磁盘吞吐量不一样，吞吐量是指单位时间内可以成功传输的数据数量。</p>\n<p>可以使用 iostat 命令，查看磁盘的 IOPS，命令如下：</p>\n<blockquote>\n<p>yum install sysstat iostat -dx 1 10</p>\n</blockquote>\n<p>执行效果如下图所示： </p>\n<p>IOPS &#x3D; r&#x2F;s + w&#x2F;s 其中：</p>\n<ul>\n<li><p>r&#x2F;s：代表每秒读了多少次；</p>\n</li>\n<li><p>w&#x2F;s：代表每秒写了多少次。</p>\n</li>\n</ul>\n<h3 id=\"什么是慢查询？\"><a href=\"#什么是慢查询？\" class=\"headerlink\" title=\"什么是慢查询？\"></a>什么是慢查询？</h3><p>慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 <em>longquerytime</em> 值的 SQL，则会被记录到慢查询日志中。 <em>longquerytime</em> 的默认值为 10，意思是运行 10s 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>\n<p>使用 <code>mysql&gt; show variables like &#39;%slow_query_log%&#39;;</code> 来查询慢查询日志是否开启</p>\n<h3 id=\"如何开启慢查询日志？\"><a href=\"#如何开启慢查询日志？\" class=\"headerlink\" title=\"如何开启慢查询日志？\"></a>如何开启慢查询日志？</h3><p>开启慢查询日志，可以使用如下 MySQL 命令：</p>\n<blockquote>\n<p>mysql&gt; set global slow<em>query</em>log&#x3D;1</p>\n</blockquote>\n<p>不过这种设置方式，只对当前数据库生效，如果 MySQL 重启也会失效，如果要永久生效，就必须修改 MySQL 的配置文件 my.cnf，配置如下：</p>\n<blockquote>\n<p>slow<em>query</em>log &#x3D;1 slow<em>query</em>log<em>file&#x3D;&#x2F;tmp&#x2F;mysql</em>slow.log</p>\n</blockquote>\n<h3 id=\"如何定位慢查询？\"><a href=\"#如何定位慢查询？\" class=\"headerlink\" title=\"如何定位慢查询？\"></a>如何定位慢查询？</h3><p>使用 MySQL 中的 explain 分析执行语句，比如：</p>\n<blockquote>\n<p>explain select * from t where id&#x3D;5;</p>\n</blockquote>\n<p>如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-2ff861def7876a91.png\" alt=\"avatar\"> </p>\n<p>其中：</p>\n<ul>\n<li><p>id — 选择标识符。id 越大优先级越高，越先被执行。</p>\n</li>\n<li><p>select_type — 表示查询的类型。</p>\n</li>\n<li><p>table — 输出结果集的表</p>\n</li>\n<li><p>partitions — 匹配的分区</p>\n</li>\n<li><p>type — 表示表的连接类型</p>\n</li>\n<li><p>possible_keys — 表示查询时，可能使用的索引</p>\n</li>\n<li><p>key — 表示实际使用的索引</p>\n</li>\n<li><p>key_len — 索引字段的长度</p>\n</li>\n<li><p>ref— 列与索引的比较</p>\n</li>\n<li><p>rows — 大概估算的行数</p>\n</li>\n<li><p>filtered — 按表条件过滤的行百分比</p>\n</li>\n<li><p>Extra — 执行情况的描述和说明</p>\n</li>\n</ul>\n<p>其中最重要的就是 type 字段，type 值类型如下：</p>\n<ul>\n<li><p>all — 扫描全表数据</p>\n</li>\n<li><p>index — 遍历索引</p>\n</li>\n<li><p>range — 索引范围查找</p>\n</li>\n<li><p>index_subquery — 在子查询中使用 ref</p>\n</li>\n<li><p>uniquesubquery — 在子查询中使用 eq*ref</p>\n</li>\n<li><p>ref<em>or</em>null — 对 null 进行索引的优化的 ref</p>\n</li>\n<li><p>fulltext — 使用全文索引</p>\n</li>\n<li><p>ref — 使用非唯一索引查找数据</p>\n</li>\n<li><p>eq_ref — 在 join 查询中使用主键或唯一索引关联</p>\n</li>\n<li><p>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</p>\n</li>\n</ul>\n<h3 id=\"⭐MySQL-的优化手段都有哪些？\"><a href=\"#⭐MySQL-的优化手段都有哪些？\" class=\"headerlink\" title=\"⭐MySQL 的优化手段都有哪些？\"></a>⭐MySQL 的优化手段都有哪些？</h3><p>MySQL 的常见的优化手段有以下五种：</p>\n<h4 id=\"①-查询优化\"><a href=\"#①-查询优化\" class=\"headerlink\" title=\"① 查询优化\"></a>① 查询优化</h4><ul>\n<li><p>避免 SELECT *，只查询需要的字段。</p>\n</li>\n<li><p>小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p>\n</li>\n<li><p>一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p>\n</li>\n</ul>\n<h4 id=\"②-优化索引的使用\"><a href=\"#②-优化索引的使用\" class=\"headerlink\" title=\"② 优化索引的使用\"></a>② 优化索引的使用</h4><ul>\n<li><p>尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p>\n</li>\n<li><p>不做列运算，把计算都放入各个业务系统实现</p>\n</li>\n<li><p>查询语句尽可能简单，大语句拆小语句，减少锁时间</p>\n</li>\n<li><p>不使用 select * 查询</p>\n</li>\n<li><p>or 查询改写成 in 查询</p>\n</li>\n<li><p>不用函数和触发器</p>\n</li>\n<li><p>避免 %xx 查询</p>\n</li>\n<li><p>少用 join 查询</p>\n</li>\n<li><p>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123</p>\n</li>\n<li><p>尽量避免在 where 子句中使用 !&#x3D; 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描</p>\n</li>\n<li><p>避免在索引列上使用 is null 和 is not null</p>\n</li>\n<li><p>尽量使用主键查询</p>\n</li>\n<li><p>避免在 where 子句中对字段进行表达式操作</p>\n</li>\n<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p>\n</li>\n</ul>\n<h4 id=\"③-表结构设计优化\"><a href=\"#③-表结构设计优化\" class=\"headerlink\" title=\"③ 表结构设计优化\"></a>③ 表结构设计优化</h4><ul>\n<li><p>使用可以存下数据最小的数据类型。</p>\n</li>\n<li><p>使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p>\n</li>\n<li><p>尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p>\n</li>\n<li><p>尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p>\n</li>\n<li><p>尽量少用 text 类型，非用不可时最好考虑分表。</p>\n</li>\n<li><p>尽量使用 timestamp，而非 datetime。</p>\n</li>\n<li><p>单表不要有太多字段，建议在 20 个字段以内。</p>\n</li>\n</ul>\n<h4 id=\"④-表拆分\"><a href=\"#④-表拆分\" class=\"headerlink\" title=\"④ 表拆分\"></a>④ 表拆分</h4><p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 </p>\n<p><strong>a）垂直拆分</strong>：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。 垂直拆分的原则：</p>\n<ul>\n<li><p>把不常用的字段单独放在一张表；</p>\n</li>\n<li><p>把 text，blob 等大字段拆分出来放在附表中；</p>\n</li>\n<li><p>经常组合查询的列放在一张表中。</p>\n</li>\n</ul>\n<p><strong>b）水平拆分</strong>：指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p>\n<p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p>\n<h4 id=\"⑤-读写分离\"><a href=\"#⑤-读写分离\" class=\"headerlink\" title=\"⑤ 读写分离\"></a>⑤ 读写分离</h4><p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p>\n<h3 id=\"MySQL-常见读写分离方案有哪些？\"><a href=\"#MySQL-常见读写分离方案有哪些？\" class=\"headerlink\" title=\"MySQL 常见读写分离方案有哪些？\"></a>MySQL 常见读写分离方案有哪些？</h3><p>MySQL 常见的读写分离方案，如下列表：</p>\n<p><strong>1）应用层解决方案</strong> 可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。 优点：路由策略的扩展性和可控性较强。 缺点：需要在 Spring 中添加耦合控制代码。</p>\n<p><strong>2）中间件解决方案</strong> 通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。 优点：与应用层解耦。 缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。</p>\n<h3 id=\"怎样保证确保备库无延迟？\"><a href=\"#怎样保证确保备库无延迟？\" class=\"headerlink\" title=\"怎样保证确保备库无延迟？\"></a>怎样保证确保备库无延迟？</h3><p>通常保证主备无延迟有以下三种方法：</p>\n<ul>\n<li><p>每次从库执行查询请求前，先判断 seconds<em>behind</em>master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds<em>behind</em>master 参数是用来衡量主备延迟时间的长短；</p>\n</li>\n<li><p>对比位点确保主备无延迟。Master<em>Log</em>File 和 Read<em>Master</em>Log<em>Pos，表示的是读到的主库的最新位点，Relay</em>Master<em>Log</em>File 和 Exec<em>Master</em>Log_Pos，表示的是备库执行的最新位点；</p>\n</li>\n<li><p>对比 GTID 集合确保主备无延迟。Auto<em>Position&#x3D;1 ，表示这对主备关系使用了 GTID 协议；Retrieved</em>Gtid<em>Set，是备库收到的所有日志的 GTID 集合；Executed</em>Gtid_Set，是备库所有已经执行完成的 GTID 集合。</p>\n</li>\n</ul>\n<h2 id=\"MySQL开放问题\"><a href=\"#MySQL开放问题\" class=\"headerlink\" title=\"MySQL开放问题\"></a>MySQL开放问题</h2><h3 id=\"有一个超级大表，如何优化分页查询？\"><a href=\"#有一个超级大表，如何优化分页查询？\" class=\"headerlink\" title=\"有一个超级大表，如何优化分页查询？\"></a>有一个超级大表，如何优化分页查询？</h3><p>超级大表的分页优化分有以下两种方式：</p>\n<ul>\n<li><p>数据库层面优化：利用子查询优化超多分页场景，比如：<code>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code> ，先快速定位需要获取的 id 段，然后再关联查询。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写，<br><strong>利用子查询先快速定位需要获取的 id 段，然后再关联查询，就是对分页进行 SQL 改写的具体实现</strong>；</p>\n</li>\n<li><p>程序层面优化：可以利用<strong>缓存</strong>把查询的结果缓存起来，这样再下一次查询的时候性能就非常高了。</p>\n</li>\n</ul>\n<h3 id=\"⭐查询长时间不返回可能是什么原因？应该如何处理？\"><a href=\"#⭐查询长时间不返回可能是什么原因？应该如何处理？\" class=\"headerlink\" title=\"⭐查询长时间不返回可能是什么原因？应该如何处理？\"></a>⭐查询长时间不返回可能是什么原因？应该如何处理？</h3><p>查询速度慢的原因很多，常见如下几种：</p>\n<p> 1）查询字段没有索引或者没有触发索引查询，没有触发索引查询的情况如下： </p>\n<ul>\n<li><p>以 % 开头的 like 查询</p>\n</li>\n<li><p>数据类型出现隐式转换时不会使用索引</p>\n</li>\n<li><p>不符合最左前缀原则；</p>\n</li>\n<li><p>如果查询条件有 or 分割，如果有 or 的字段没有索引，会引起全表查询；</p>\n</li>\n<li><p>如果 MySQL 认为使用索引会比全表查询更慢，则不会使用索引。</p>\n</li>\n</ul>\n<p>2）I&#x2F;O 压力大，读取磁盘速度变慢，df 看硬盘</p>\n<p>3）内存不足，free 看内存（top 看 cpu）</p>\n<p>4）网络速度慢 </p>\n<p>5）查询出的数据量过大，可以采用多次查询或其他的方法降低数据量 </p>\n<p>6）死锁，一般碰到这种情况的话，大概率是表被锁住了，可以使用 <code>show processlist;</code> 命令，看看 SQL 语句的状态，再针对不同的状态做相应的处理。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes11474088-1a918d44eacc26e6.png\" alt=\"avatar\"> </p>\n<p>其中，当 State 列值为 Locked 时，表示被锁定。</p>\n<p>以上问题的解决方案如下：</p>\n<p>1）正确创建和使用索引。 </p>\n<p>2）把数据、日志、索引放到不同的 IO 设备上，减少主数据库的 IO 操作。更换 MySQL 的磁盘为固态硬盘，以提高磁盘的 IO 性能。 </p>\n<p>3）升级内存，更换更大的内存。 </p>\n<p>4）提升网速，升级带宽。 </p>\n<p>5）用 Profiler 来跟踪查询，得到查询所需的时间，找出有问题的 SQL 语句，优化 SQL。 </p>\n<p>6）查询时值返回需要的字段。 </p>\n<p>7）设置死锁的超时时间，限制和避免死锁消耗过多服务器的资源。 8）尽量少用视图，它的效率低，对视图操作比直接对表操作慢,可以用存储过程来代替视图。不要用视图嵌套，嵌套视图增加了寻找原始数据的难度。</p>\n<h3 id=\"MySQL-主从延迟的原因有哪些？\"><a href=\"#MySQL-主从延迟的原因有哪些？\" class=\"headerlink\" title=\"MySQL 主从延迟的原因有哪些？\"></a>MySQL 主从延迟的原因有哪些？</h3><p>主从延迟可以根据 MySQL 提供的命令判断，比如，在从服务器使用命令： <code>show slave status;</code>，其中 Seconds<em>Behind</em>Master 如果为 0 表示主从复制状态正常。 导致主从延迟的原因有以下几个：</p>\n<ul>\n<li><p>主库有大事务处理；</p>\n</li>\n<li><p>主库做大量的增、删、改操作；</p>\n</li>\n<li><p>主库对大表进行字段新增、修改或添加索引等操作；</p>\n</li>\n<li><p>主库的从库太多，导致复制延迟。从库数量一般 3-5 个为宜，要复制的节点过多，导致复制延迟；</p>\n</li>\n<li><p>从库硬件配置比主库差，导致延迟。查看 Master 和 Slave 的配置，可能因为从库的配置过低，执行时间长，由此导致的复制延迟时间长；</p>\n</li>\n<li><p>主库读写压力大，导致复制延迟；</p>\n</li>\n<li><p>从库之间的网络延迟。主从库网卡、网线、连接的交换机等网络设备都可能成为复制的瓶颈，导致复制延迟，另外跨公网主从复制很容易导致主从复制延迟。</p>\n</li>\n</ul>\n<h3 id=\"如何保证数据不被误删？\"><a href=\"#如何保证数据不被误删？\" class=\"headerlink\" title=\"如何保证数据不被误删？\"></a>如何保证数据不被误删？</h3><p>保证数据不被误删的方法如下列表：</p>\n<ul>\n<li><p>权限控制与分配（数据库和服务器权限）</p>\n</li>\n<li><p>避免数据库账号信息泄露，在生产环境中，业务代码不要使用明文保存数据库连接信息；</p>\n</li>\n<li><p>重要的数据库操作，通过平台型工具自动实施，减少人工操作；</p>\n</li>\n<li><p>部署延迟复制从库，万一误删除时用于数据回档，且从库设置为 read-only；</p>\n</li>\n<li><p>确认备份制度及时有效；</p>\n</li>\n<li><p>启用 SQL 审计功能，养成良好 SQL 习惯；</p>\n</li>\n<li><p>启用 sql<em>safe</em>updates 选项，不允许没 where 条件的更新&#x2F;删除；</p>\n</li>\n<li><p>将系统层的 rm 改为 mv；</p>\n</li>\n<li><p>线上不进行物理删除，改为逻辑删除（将 row data 标记为不可用）；</p>\n</li>\n<li><p>启用堡垒机，屏蔽高危 SQL；</p>\n</li>\n<li><p>降低数据库中普通账号的权限级别；</p>\n</li>\n<li><p>开启 binlog，方便追溯数据。</p>\n</li>\n</ul>\n<h3 id=\"⭐MySQL-服务器-CPU-飙升应该如何处理？\"><a href=\"#⭐MySQL-服务器-CPU-飙升应该如何处理？\" class=\"headerlink\" title=\"⭐MySQL 服务器 CPU 飙升应该如何处理？\"></a>⭐MySQL 服务器 CPU 飙升应该如何处理？</h3><p>使用 <code>show full processlist;</code> 查出慢查询，为了缓解数据库服务器压力，先使用 kill 命令杀掉慢查询的客户端，然后再去项目中找到执行慢的 SQL 语句进行修改和优化。</p>\n<h3 id=\"MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？\"><a href=\"#MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？\" class=\"headerlink\" title=\"MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？\"></a>MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h3><p>可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL 中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p>\n<ul>\n<li><p>定期断开空闲的长连接；</p>\n</li>\n<li><p>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql<em>reset</em>connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</p>\n</li>\n</ul>\n<h3 id=\"如何实现一个高并发的系统？\"><a href=\"#如何实现一个高并发的系统？\" class=\"headerlink\" title=\"如何实现一个高并发的系统？\"></a>如何实现一个高并发的系统？</h3><p>这道面试题涉及的知识点比较多，主要考察的是面试者的综合技术能力。高并发系统的设计手段有很多，主要体现在以下五个方面。</p>\n<h4 id=\"1）前端优化\"><a href=\"#1）前端优化\" class=\"headerlink\" title=\"1）前端优化\"></a>1）前端优化</h4><p>① 静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过 CDN、浏览器缓存，来减少客户端向服务器端的数据请求。<br>② 禁止重复提交：用户提交之后按钮置灰，禁止重复提交。<br>③ 用户限流：在某一时间段内只允许用户提交一次请求，比如，采取 IP 限流。</p>\n<h4 id=\"2）中间层负载分发\"><a href=\"#2）中间层负载分发\" class=\"headerlink\" title=\"2）中间层负载分发\"></a>2）中间层负载分发</h4><p>可利用负载均衡，比如 nginx 等工具，可以将并发请求分配到不同的服务器，从而提高了系统处理并发的能力。 nginx 负载分发的五种方式：</p>\n<p>① 轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器不能正常响应，nginx 能自动剔除故障服务器。 ② 按权重（weight） 使用 weight 参数，指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    server 192.168.0.14 weight=10; </span><br><span class=\"line\">    server 192.168.0.15 weight=10; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>③ IP 哈希值（ip_hash） 每个请求按访问 IP 的哈希值分配，这样每个访客固定访问一个后端服务器，可以解决 session 共享的问题，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    ip_hash; </span><br><span class=\"line\">    server 192.168.0.14:88; </span><br><span class=\"line\">    server 192.168.0.15:80; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>④ 响应时间（fair） 按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    fair; </span><br><span class=\"line\">    server server1.com; </span><br><span class=\"line\">    server server2.com; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>⑤ URL 哈希值（url_hash） 按访问 url 的 hash 结果来分配请求，和 IP 哈希值类似。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123;</span><br><span class=\"line\">    hash $request_uri;</span><br><span class=\"line\">    server server1.com; </span><br><span class=\"line\">    server server2.com;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）控制层（网关层）\"><a href=\"#3）控制层（网关层）\" class=\"headerlink\" title=\"3）控制层（网关层）\"></a>3）控制层（网关层）</h4><p>限制同一个用户的访问频率，限制访问次数，防止多次恶意请求。</p>\n<h4 id=\"4）服务层\"><a href=\"#4）服务层\" class=\"headerlink\" title=\"4）服务层\"></a>4）服务层</h4><p>① 业务服务器分离：比如，将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。<br>② 采用 MQ（消息队列）缓存请求：MQ 具有削峰填谷的作用，可以把客户端的请求先导流到 MQ，程序在从 MQ 中进行消费（执行请求），这样可以避免短时间内大量请求，导致服务器程序无法响应的问题。<br>③ 利用缓存应对读请求，比如，使用 Redis 等缓存，利用 Redis 可以分担数据库很大一部分压力。</p>\n<h4 id=\"5）数据库层\"><a href=\"#5）数据库层\" class=\"headerlink\" title=\"5）数据库层\"></a>5）数据库层</h4><p>① 合理使用数据库引擎 ② 合理设置事务隔离级别，合理使用事务 ③ 正确使用 SQL 语句和查询索引 ④ 合理分库分表 ⑤ 使用数据库中间件实现数据库读写分离 ⑥ 设置数据库主从读写分离</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"查询语句不同元素（where、jion、limit、group-by、having-等等）执行先后顺序？\"><a href=\"#查询语句不同元素（where、jion、limit、group-by、having-等等）执行先后顺序？\" class=\"headerlink\" title=\"查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？\"></a>查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？</h3><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为 <code>select--from--where--group by--having--order by</code></p>\n<p>其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序 与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行</p>\n<ul>\n<li>from:需要从哪个数据表检索数据</li>\n<li>where:过滤表中数据的条件</li>\n<li>group by:如何将上面过滤出的数据分组</li>\n<li>having:对上面已经分组的数据进行过滤的条件</li>\n<li>select:查看结果集中的哪个列，或列的计算结果</li>\n<li>order by :按照什么样的顺序来查看返回的数据</li>\n</ul>\n<p>from 后面的表关联，是自右向左解析 而 where 条件的解析顺序是自下而上的。</p>\n<p>也就是说，在写 SQL 文的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在 where 语句的最左边 （用小表去匹配大表）</p>\n<h3 id=\"非关系型数据库和关系型数据库区别，优势比较？\"><a href=\"#非关系型数据库和关系型数据库区别，优势比较？\" class=\"headerlink\" title=\"非关系型数据库和关系型数据库区别，优势比较？\"></a>非关系型数据库和关系型数据库区别，优势比较？</h3><h4 id=\"非关系型数据库的优势\"><a href=\"#非关系型数据库的优势\" class=\"headerlink\" title=\"非关系型数据库的优势\"></a>非关系型数据库的优势</h4><p><strong>1. 性能</strong></p>\n<p>NOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。</p>\n<p><strong>2. 可扩展性</strong></p>\n<p>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>\n<h4 id=\"关系型数据库的优势\"><a href=\"#关系型数据库的优势\" class=\"headerlink\" title=\"关系型数据库的优势\"></a>关系型数据库的优势</h4><p><strong>1. 复杂查询</strong></p>\n<p>可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。</p>\n<p><strong>2. 事务支持</strong></p>\n<p>使得对于安全性能很高的数据访问要求得以实现。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><strong>对于这两类数据库，对方的优势就是自己的弱势，反之亦然</strong>。</p>\n<p>NOSQL 数据库慢慢开始具备 SQL 数据库的一些复杂查询功能，比如 MongoDB。</p>\n<p>对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如 Redis set nx。</p>\n<h3 id=\"数据库三范式，根据某个场景设计数据表？\"><a href=\"#数据库三范式，根据某个场景设计数据表？\" class=\"headerlink\" title=\"数据库三范式，根据某个场景设计数据表？\"></a>数据库三范式，根据某个场景设计数据表？</h3><ul>\n<li>所有字段值都是不可分解的原子值。</li>\n<li>在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li>\n<li>数据表中的每一列数据都和主键直接相关，而不能间接相关。</li>\n</ul>\n<h4 id=\"第一范式-确保每列保持原子性\"><a href=\"#第一范式-确保每列保持原子性\" class=\"headerlink\" title=\"第一范式(确保每列保持原子性)\"></a>第一范式(确保每列保持原子性)</h4><p><strong>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式</strong>。</p>\n<p>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。</p>\n<p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p>\n<h4 id=\"第二范式-确保表中的每列都和主键相关\"><a href=\"#第二范式-确保表中的每列都和主键相关\" class=\"headerlink\" title=\"第二范式(确保表中的每列都和主键相关)\"></a>第二范式(确保表中的每列都和主键相关)</h4><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。<strong>也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中</strong>。</p>\n<p><strong>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键</strong>。</p>\n<h4 id=\"第三范式-确保每列都和主键列直接相关-而不是间接相关\"><a href=\"#第三范式-确保每列都和主键列直接相关-而不是间接相关\" class=\"headerlink\" title=\"第三范式(确保每列都和主键列直接相关,而不是间接相关)\"></a>第三范式(确保每列都和主键列直接相关,而不是间接相关)</h4><p>第三范式需要确保数据表中的<strong>每一列数据都和主键直接相关，而不能间接相关</strong>。</p>\n<p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p>\n<h3 id=\"MySQL-高并发环境解决方案？\"><a href=\"#MySQL-高并发环境解决方案？\" class=\"headerlink\" title=\"MySQL 高并发环境解决方案？\"></a>MySQL 高并发环境解决方案？</h3><p>MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。</p>\n<p><strong>需求分析</strong>：互联网单位 每天大量数据读取，写入，并发性高。</p>\n<ul>\n<li><strong>现有解决方式</strong>：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</li>\n<li><strong>集群方案</strong>：解决 DB 宕机带来的单点 DB 不能访问问题。</li>\n<li><strong>读写分离策略</strong>：极大限度提高了应用中 Read 数据的速度和并发量。无法解决高写入压力。</li>\n</ul>\n<h3 id=\"数据库崩溃时事务的恢复机制（REDO-日志和-UNDO-日志）？\"><a href=\"#数据库崩溃时事务的恢复机制（REDO-日志和-UNDO-日志）？\" class=\"headerlink\" title=\"数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）？\"></a>数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）？</h3><h4 id=\"Undo-Log\"><a href=\"#Undo-Log\" class=\"headerlink\" title=\"Undo Log\"></a>Undo Log</h4><p><strong>Undo Log 是为了实现事务的原子性</strong>，在 MySQL 数据库 InnoDB 存储引擎中，还用了 Undo Log 来实现多版本并发控制(简称：MVCC)。</p>\n<ul>\n<li><strong>事务的原子性</strong>(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。</li>\n<li><strong>原理</strong>Undo Log 的原理很简单，<strong>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 UndoLog）</strong>。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，<strong>系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态</strong>。</li>\n</ul>\n<p><strong>之所以能同时保证原子性和持久化，是因为以下特点</strong>：</p>\n<ul>\n<li>更新数据前记录 Undo log。</li>\n<li>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。</li>\n<li><strong>Undo log 必须先于数据持久化到磁盘</strong>。如果在 G,H 之间系统崩溃，<strong>undo log 是完整的， 可以用来回滚事务</strong>。</li>\n<li>如果在 A-F 之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</li>\n</ul>\n<p><strong>缺陷</strong>：<strong>每个事务提交前将数据和 Undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低</strong>。</p>\n<p>如果能够将数据缓存一段时间，就能减少 IO 提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。</p>\n<h4 id=\"Redo-Log\"><a href=\"#Redo-Log\" class=\"headerlink\" title=\"Redo Log\"></a>Redo Log</h4><ul>\n<li><strong>原理和 Undo Log 相反</strong>，<strong>Redo Log 记录的是新数据的备份</strong>。<strong>在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态</strong>。</li>\n</ul>\n<h3 id=\"Explain-性能分析\"><a href=\"#Explain-性能分析\" class=\"headerlink\" title=\"Explain 性能分析\"></a>Explain 性能分析</h3><p><strong>是什么</strong></p>\n<p>查看执行计划：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理 SQL 语句的。分析查询语句或是表结构的性能瓶颈。</p>\n<p><strong>能干嘛</strong></p>\n<ul>\n<li>表的读取顺序</li>\n<li>数据读取操作的操作类型</li>\n<li>哪些索引可以使用</li>\n<li>哪些索引被实际使用</li>\n<li>表之间的引用</li>\n<li>每张表有多少行被优化器查询</li>\n</ul>\n<p><strong>怎么玩</strong></p>\n<p>Explain + SQL 语句。<br>Explain 执行后返回的信息：<br> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422131912576.png\" alt=\"image-20220422131912576\" style=\"zoom:50%;\" /></p>\n<p><strong>各字段解释</strong></p>\n<ol>\n<li><p>id：select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序。</p>\n<ul>\n<li>id 相同，执行顺序由上至下</li>\n<li>id 不同，如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行</li>\n<li>id 有相同也有不同：id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行</li>\n</ul>\n<blockquote>\n<p>id 号每个号码，表示一趟独立的查询。一个 sql 的查询趟数越少越好。</p>\n</blockquote>\n</li>\n<li><p>select_type：代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询，取值范围如下：</p>\n<ul>\n<li>simple：简单的 select 查询，查询中不包含子查询或者 UNION</li>\n<li>primary：查询中若包含任何复杂的子部分，最外层查询则被标记为 primary</li>\n<li>derived：在 FROM 列表中包含的子查询被标记为 DERIVED (衍生)，MySQL 会递归执行这些子查询, 把结果放在临时表里。</li>\n<li>subquery：在 SELECT 或 WHERE 列表中包含了子查询</li>\n<li>depedent subquery：在 SELECT 或 WHERE 列表中包含了子查询，子查询基于外层</li>\n<li>uncacheable subquery：无法使用缓存的子查询</li>\n<li>union：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为：DERIVED</li>\n<li>union result：从 UNION 表获取结果的 SELECT</li>\n</ul>\n</li>\n<li><p>table：这个数据是基于哪张表的。</p>\n</li>\n<li><p>type：是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL，一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p>\n<blockquote>\n<p>只需要记住：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 就行了，其他的不常见。</p>\n</blockquote>\n<ul>\n<li>system：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个也可以忽略不计。</li>\n<li>const：表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。</li>\n<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</li>\n<li>range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在 where 语句中出现了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>\n<li>index：出现 index 是 sql 使用了索引但是没用索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组。</li>\n<li>all：将遍历全表以找到匹配的行。</li>\n</ul>\n<blockquote>\n<p>其他 type 如下：</p>\n</blockquote>\n<ul>\n<li>index_merge：在查询过程中需要多个索引组合使用，通常出现在有 or 关键字的 sql 中。</li>\n<li>ref_or_null：对于某个字段既需要过滤条件，也需要 null 值的情况下。查询优化器会选择用 ref_or_null 连接查询。</li>\n<li>index_subquery：利用索引来关联子查询，不再全表扫描。</li>\n<li>unique_subquery：该联接类型类似于 index_subquery。子查询中的唯一索引。</li>\n</ul>\n</li>\n<li><p>possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>\n</li>\n<li><p>key：实际使用的索引。如果为 NULL，则没有使用索引。</p>\n</li>\n<li><p>key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度。如何计算 key_len？</p>\n<ul>\n<li>先看索引上字段的类型 + 长度，比如：int&#x3D;4; varchar(20)&#x3D;20; char(20)&#x3D;20</li>\n<li>如果是 varchar 或者 char 这种字符串字段，视字符集要乘不同的值，比如 utf-8 要乘 3，GBK 要乘 2</li>\n<li>varchar 这种动态字符串要加 2 个字节</li>\n<li>允许为空的字段要加 1 个字节</li>\n</ul>\n</li>\n<li><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>\n</li>\n<li><p>rows：显示 MySQL 认为它执行查询时必须检查的行数。越少越好！</p>\n</li>\n<li><p>Extra：其他的额外重要的信息。</p>\n<ul>\n<li>Using filesort：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”。<strong>排序字段若通过索引去访问将大大提高排序速度</strong>。</li>\n<li>Using temporary：使用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li>\n<li>Using index：表示相应的 select 操作中使用了覆盖索引 (Covering Index)，避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。</li>\n<li>Using where：表明使用了 where 过滤。</li>\n<li>Using join buffer：使用了连接缓存。</li>\n<li>impossible where：where 子句的值总是 false，不能用来获取任何数据。</li>\n<li>select tables optimized away：在没有 group by 子句的情况下，基于索引优化 MIN&#x2F;MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li>\n<li>distinct：优化 distinct 操作，在找到第一匹配的元祖后即停止找同样值的动作。</li>\n</ul>\n</li>\n</ol>"},{"title":"Java八股文 - Linux","copyright":true,"mathjax":false,"date":"2023-01-25T05:45:06.000Z","toc":true,"urlname":"linux","_content":"\n> 整理的 Linux 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Linux 概述\n\n### 什么是Linux\n\nLinux 是一套**免费使用和自由传播的类 Unix 操作系统**，是一个基于 POSIX 和 Unix 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n\n### Unix和Linux有什么区别？\n\nLinux 和 Unix 都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为 Unix 和 Linux 操作系统是一样的，然而，事实并非如此，以下是两者的区别。\n\n1. 开源性\n\tLinux 是一款开源操作系统，不需要付费，即可使用；Unix 是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。\n2. 跨平台性\n\tLinux 操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix 操作系统跨平台性能较弱，大多需与硬件配套使用。\n3. 可视化界面\n\tLinux 除了进行命令行操作，还有窗体管理系统；Unix 只是命令行下的系统。\n4. 硬件环境\n\tLinux 操作系统对硬件的要求较低，安装方法更易掌握；Unix 对硬件要求比较苛刻，按照难度较大。\n5. 用户群体\n\tLinux 的用户群体很广泛，个人和企业均可使用；Unix 的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者 Unix 硬件厂商使用，如 Sun 等。\n\t相比于 Unix 操作系统，Linux 操作系统更受广大计算机爱好者的喜爱，主要原因是 Linux 操作系统具有 Unix 操作系统的全部功能，并且能够在普通 PC 计算机上实现全部的 Unix 特性，开源免费的特性，更容易普及使用！\n\n### 什么是 Linux 内核？\n\nLinux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。\n\n1. 系统内存管理\n2. 应用程序管理\n3. 硬件设备管理\n4. 文件系统管理\n\n### Linux的基本组件是什么？\n\n就像任何其他典型的操作系统一样，Linux 拥有所有这些组件：内核，shell 和 GUI，系统实用程序和应用程序。Linux 比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。\n\n### Linux 的体系结构\n\n从大的方面讲，Linux 体系结构可以分为两块：\n\n![Linux 体系结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70.png)\n\n- 用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。\n- 内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。\n\n**为什么 Linux 体系结构要分为用户空间和内核空间的原因？**\n\n1. 现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。\n2. Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。\n\n用户空间和内核空间是程序执行的**两种不同的状态**，我们可以通过两种方式完成用户空间到内核空间的转移：\n\n1）系统调用；2）硬件中断。\n\n### BASH和DOS之间的基本区别是什么？\n\nBASH 和 DOS 控制台之间的主要区别在于 3 个方面：\n\n- BASH 命令区分大小写，而 DOS 命令则不区分；\n- 在 BASH 下，/ character 是目录分隔符，\\作为转义字符。在 DOS 下，/用作命令参数分隔符，\\是目录分隔符；\n- DOS 遵循命名文件中的约定，即 8 个字符的文件名后跟一个点，扩展名为 3 个字符。BASH 没有遵循这样的惯例。\n\n### Linux 开机启动过程？\n\n> 了解即可。\n\n1、主机加电自检，加载 BIOS 硬件信息。\n\n2、读取 MBR 的引导文件(GRUB、LILO)。\n\n3、引导 Linux 内核。\n\n4、运行第一个进程 init (进程号永远为 1 )。\n\n5、进入相应的运行级别。\n\n6、运行终端，输入用户名和密码。\n\n### Linux系统缺省的运行级别？\n\n- 关机。\n- 单机用户模式。\n- 字符界面的多用户模式(不支持网络)。\n- 字符界面的多用户模式。\n- 未分配使用。\n- 图形界面的多用户模式。\n- 重启。\n\n### Linux 使用的进程间通信方式？\n\n> 了解即可，不需要太深入。\n\n- 管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。\n- 信号(signal) 。\n- 消息队列。\n- 共享内存。\n- 信号量。\n- 套接字(socket) 。\n\n### Linux 有哪些系统日志文件？\n\n比较重要的是 `/var/log/messages` 日志文件。\n\n该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。\n\n### 什么是交换空间？\n\n交换空间是 Linux 使用的一定空间，用于临时保存一些并发运行的程序。当 RAM 没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。\n\n### 什么是root帐户\n\nroot 帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装 Linux 时都是默认帐户。\n\n### 什么是LILO？\n\nLILO 是 Linux 的引导加载程序。它主要用于将 Linux 操作系统加载到主内存中，以便它可以开始运行。\n\n### 什么是BASH？\n\nBASH 是 Bourne Again SHell 的缩写。它由 Steve Bourne 编写，作为原始 Bourne Shell（由/ bin / sh 表示）的替代品。它结合了原始版本的 Bourne Shell 的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行 Linux 的大多数系统的默认 shell。\n\n### 什么是CLI？\n\n**命令行界面**（英语**：command-line interface**，缩写]**：CLI**）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为**字符用户界面**（CUI）。\n\n通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。\n\n### 什么是GUI？\n\n图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。\n\n图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。\n\n### 开源的优势是什么？\n\n开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。\n\n### GNU项目的重要性是什么？\n\n这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。\n\n## 磁盘、目录、文件\n\n### 简单 Linux 文件系统？\n\n**在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。**\n\n也就是说在 Linux 系统中有一个重要的概念**：一切都是文件**。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就**可以用读写文件的方式实现对硬件的访问**。\n\nLinux 支持 5 种文件类型，如下图所示：\n\n![5 种文件类型](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png.png)\n\n### Linux 的目录结构是怎样的？\n\n> 这个问题，一般不会问。更多是实际使用时，需要知道。\n\nLinux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n![Linux 的目录结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806288.png)\n\n**常见目录说明**：\n\n- **/bin**： 存放二进制可执行文件(ls,cat,mkdir 等)，常用命令一般都在这里；\n- **/etc**： 存放系统管理和配置文件；\n- **/home**： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；\n- **/usr **： 用于存放系统应用程序；\n- **/opt**： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n- **/proc**： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n- **/root**： 超级用户（系统管理员）的主目录（特权阶级 o）；\n- **/sbin:** 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n- **/dev**： 用于存放设备文件；\n- **/mnt**： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n- **/boot**： 存放用于系统引导时使用的各种文件；\n- **/lib **： 存放着和系统运行相关的库文件 ；\n- **/tmp**： 用于存放各种临时文件，是公用的临时文件存储点；\n- **/var**： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；\n- **/lost+found**： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。\n\n### 什么是 inode ？\n\n> 一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix/Linux 文件系统和硬盘储存的基础。\n\n理解 inode，要从文件储存说起。\n\n文件储存在硬盘上，硬盘的最小存储单位叫做\"扇区\"（Sector）。每个扇区储存 512 字节（相当于 0.5KB）。\n\n操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个\"块\"（block）。这种由多个扇区组成的\"块\"，是文件存取的最小单位。\"块\"的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。\n\n文件数据都储存在\"块\"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做 inode，中文译名为\"索引节点\"。\n\n每一个文件都有对应的 inode，里面包含了与该文件有关的一些信息。\n\n**简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？**\n\n> 如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。\n\nLinux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。\n\n- inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。\n- Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。\n\n### 什么是硬链接和软链接？\n\n1）硬链接\n\n由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。\n\n- 不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。\n\n2）软链接\n\n软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。\n\n- 不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。\n\n**实际场景下，基本是使用软链接**。总结区别如下：\n\n- 硬链接不可以跨分区，软件链可以跨分区。\n- 硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。\n- 删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。\n\n### RAID 是什么?\n\n> RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。\n>\n> RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。\n\n当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。\n\n## 安全\n\n### 一台 Linux 系统初始化环境后需要做一些什么安全工作？\n\n1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。\n\n> 修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l\n\n2、服务器使用密钥登陆，禁止密码登陆。\n\n3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。\n\n4、装 fail2ban 这种防止 SSH 暴力破击的软件。\n\n5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)\n\n> 也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。\n\n6、修改历史命令记录的条数为 10 条。\n\n7、只允许有需要的服务器可以访问外网，其它全部禁止。\n\n8、做好软件层面的防护。\n\n- 8.1 设置 nginx_waf 模块防止 SQL 注入。\n- 8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。\n\n### 什么叫 CC 攻击？什么叫 DDOS 攻击？\n\n- CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。\n\n- DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。\n\n\t> 攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。\n\n**怎么预防 CC 攻击和 DDOS 攻击？**\n\n防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。\n\n> 流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。\n\n### 什么是网站数据库注入？\n\n- 由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。\n- 应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。\n- SQL 注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。\n\n**如何过滤与预防？**\n\n数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。\n\n## Shell\n\n### Shell 脚本是什么？\n\n一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。\n\n**什么是默认登录 Shell ？**\n\n在 Linux 操作系统，`\"/bin/bash\"` 是默认登录 Shell，是在创建用户时分配的。\n\n使用 chsh 命令可以改变默认的 Shell 。示例如下所示：\n\n```bash\nchsh <用户名> -s <新shell>\nchsh ThinkWon -s /bin/sh\n```\n\n**在 Shell 脚本中，如何写入注释？**\n\n注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 `#` 开头。例子如下：\n\n```bash\n#!/bin/bash\n# This is a command\necho “I am logged in as $USER”\n```\n\n### 语法级\n\n#### 可以在 Shell 脚本中使用哪些类型的变量？\n\n在 Shell 脚本，我们可以使用两种类型的变量：\n\n- 系统定义变量\n\n\t> 系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 `set` 命令查看。\n\n- 用户定义变量\n\n\t> 用户变量由系统用户来生成和定义，变量的值可以通过命令 `\"echo $<变量名>\"` 查看。\n\n**Shell脚本中 $? 标记的用途是什么？**\n\n在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 `if` 条件中使用 `$?` 可以来检查前一命令的结束状态。\n\n- 如果结束状态是 0 ，说明前一个命令执行成功。例如：\n\n\t```bash\n\troot@localhost:~## ls /usr/bin/shar\n\t/usr/bin/shar\n\troot@localhost:~## echo $?\n\t0\n\t```\n\n- 如果结束状态不是 0，说明命令执行失败。例如：\n\n\t```bash\n\troot@localhost:~## ls /usr/bin/share\n\tls: cannot access /usr/bin/share: No such file or directory\n\troot@localhost:~## echo $?\n\t2\n\t```\n\n**Bourne Shell(bash) 中有哪些特殊的变量？**\n\n下面的表列出了 Bourne Shell 为命令行设置的特殊变量。\n\n```bash\n内建变量    解释\n$0    命令行中的脚本名字\n$1    第一个命令行参数\n$2    第二个命令行参数\n…..    …….\n$9    第九个命令行参数\n$##    命令行参数的数量\n$*    所有命令行参数，以空格隔开\n```\n\n**如何取消变量或取消变量赋值？**\n\n`unset` 命令用于取消变量或取消变量赋值。语法如下所示：\n\n```bash\n## unset <变量名>\n```\n\n#### Shell 脚本中 `if` 语法如何嵌套?\n\n```bash\nif [ 条件 ]\nthen\n命令1\n命令2\n…..\nelse\nif [ 条件 ]\nthen\n命令1\n命令2\n….\nelse\n命令1\n命令2\n…..\nfi\nfi\n```\n\n**在 Shell 脚本中如何比较两个数字？**\n\n在 `if-then` 中使用测试命令（ `-gt` 等）来比较两个数字。例如：\n\n```bash\n#!/bin/bash\nx=10\ny=20\nif [ $x -gt $y ]\nthen\necho “x is greater than y”\nelse\necho “y is greater than x”\nfi\n```\n\n#### Shell 脚本中 `case` 语句的语法?\n\n基础语法如下：\n\n```bash\ncase 变量 in\n值1)\n命令1\n命令2\n…..\n最后命令\n!!\n值2)\n命令1\n命令2\n……\n最后命令\n;;\nesac\n```\n\n#### Shell 脚本中 `for` 循环语法？\n\n基础语法如下：\n\n```bash\nfor 变量 in 循环列表\ndo\n命令1\n命令2\n….\n最后命令\ndone\n```\n\n#### Shell 脚本中 `while` 循环语法？\n\n如同 `for` 循环，`while` 循环只要条件成立就重复它的命令块。\n不同于 `for`循环，`while` 循环会不断迭代，直到它的条件不为真。\n\n基础语法：\n\n```bash\nwhile [ 条件 ]\ndo\n命令…\ndone\n```\n\n**do-while 语句的基本格式？**\n\n`do-while` 语句类似于 `while` 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 `do-while` 语句的语法：\n\n```bash\ndo\n{\n命令\n} while (条件)\n```\n\n**Shell 脚本中 break 命令的作用？**\n\n`break` 命令一个简单的用途是退出执行中的循环。我们可以在 `while` 和 `until` 循环中使用 `break` 命令跳出循环。\n\n**Shell 脚本中 continue 命令的作用？**\n\n`continue` 命令不同于 `break` 命令，它只跳出当前循环的迭代，而不是整个循环。`continue` 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。\n\n#### 如何使脚本可执行?\n\n使用 chmod 命令来使脚本可执行。例子如下：`chmod a+x myscript.sh` 。\n\n**#!/bin/bash 的作用？**\n\n`#!/bin/bash` 是 Shell 脚本的第一行，称为释伴（shebang）行。\n\n- 这里 `#` 符号叫做 hash ，而 `!` 叫做 bang。\n- 它的意思是命令通过 `/bin/bash` 来执行。\n\n**如何调试 Shell脚本？**\n\n- 使用 `-x'` 数（`sh -x myscript.sh`）可以调试 Shell 脚本。\n- 另一个种方法是使用 `-nv` 参数(`sh -nv myscript.sh`)。\n\n**如何将标准输出和错误输出同时重定向到同一位置?**\n\n- 方法一：`2>&1 (如## ls /usr/share/doc > out.txt 2>&1 )` 。\n- 方法二：`&> (如## ls /usr/share/doc &> out.txt )` 。\n\n**在 Shell 脚本中，如何测试文件？**\n\ntest 命令可以用来测试文件。基础用法如下表格：\n\n```bash\nTest         用法\n-d 文件名    如果文件存在并且是目录，返回true\n-e 文件名    如果文件存在，返回true\n-f 文件名    如果文件存在并且是普通文件，返回true\n-r 文件名    如果文件存在并可读，返回true\n-s 文件名    如果文件存在并且不为空，返回true\n-w 文件名    如果文件存在并可写，返回true\n-x 文件名    如果文件存在并可执行，返回true\n```\n\n#### 在 Shell 脚本如何定义函数呢？\n\n函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：\n\n```bash\n$ diskusage () { df -h ; }\n译注：下面是我给的shell函数语法，原文没有\n[ function ] 函数名 [()]\n{\n命令;\n[return int;]\n}\n```\n\n**如何让 Shell 就脚本得到来自终端的输入?**\n\nread 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：\n\n```bash\n## vi /tmp/test.sh\n#!/bin/bash\necho ‘Please enter your name’\nread name\necho “My Name is $name”\n## ./test.sh\nPlease enter your name\nThinkWon\nMy Name is ThinkWon\n```\n\n**如何执行算术运算？**\n\n有两种方法来执行算术运算：\n\n- 1、使用 expr 命令：`## expr 5 + 2` 。\n- 2、用一个美元符号和方括号（`$[ 表达式 ]`）：`test=$[16 + 4] ; test=$[16 + 4]` 。\n\n### 编程题\n\n#### 判断一文件是不是字符设备文件，如果是将其拷贝到 `/dev` 目录下？\n\n```bash\n#!/bin/bash\nread -p \"Input file name: \" FILENAME\nif [ -c \"$FILENAME\" ];then\n　　cp $FILENAME /dev\nfi\n```\n\n#### 添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？\n\n```bash\n#!/bin/bash\ngroupadd class1\nfor((i=1;i<31;i++))\ndo\n        if [ $i -le 10 ];then\n                useradd -g class1 std0$i\n        else\n                useradd -g class1 std$i\n        fi\ndone\n```\n\n**编写 Shell 程序，实现自动删除 50 个账号的功能，账号名为stud1 至 stud50 ？**\n\n```bash\n#!/bin/bash\nfor((i=1;i<51;i++))\ndo\n                userdel -r stud$i\ndone\n```\n\n#### 写一个 sed 命令，修改 `/tmp/input.txt` 文件的内容？\n\n要求：\n\n- 删除所有空行。\n- 一行中，如果包含 “11111”，则在 “11111” 前面插入 “AAA”，在 “11111” 后面插入 “BBB” 。比如：将内容为 0000111112222 的一行改为 0000AAA11111BBB2222 。\n\n```bash\n[root@~]## cat -n /tmp/input.txt\n     1  000011111222\n     2\n     3  000011111222222\n     4  11111000000222\n     5\n     6\n     7  111111111111122222222222\n     8  2211111111\n     9  112222222\n    10  1122\n    11\n\n## 删除所有空行命令\n[root@~]## sed '/^$/d' /tmp/input.txt\n000011111222\n000011111222222\n11111000000222\n111111111111122222222222\n2211111111\n112222222\n1122\n\n## 插入指定的字符\n[root@~]## sed 's#\\(11111\\)#AAA\\1BBB#g' /tmp/input.txt\n0000AAA11111BBB222\n0000AAA11111BBB222222\nAAA11111BBB000000222\nAAA11111BBBAAA11111BBB11122222222222\n22AAA11111BBB111\n112222222\n1122\n```\n\n## 实战\n\n### 如何选择 Linux 操作系统版本?\n\n一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。\n\n根据具体要求：\n\n- 安全性要求较高，则选择 Debian 或者 FreeBSD 。\n\n- 需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。\n\n- 想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。\n\n- 【重点】**根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束**。\n\n\t> CentOS 7 系列，也慢慢使用的会比较多了。\n\n### 如何规划一台 Linux 主机，步骤是怎样？\n\n1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。\n\n> 不同的用途，机器的配置会有所不同。\n\n2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。\n\n3、需要优化系统的哪些参数，需要创建哪些用户等等的。\n\n### 请问当用户反馈网站访问慢，你会如何处理？\n\n**有哪些方面的因素会导致网站网站访问慢？**\n\n1、服务器出口带宽不够用\n\n> - 本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。\n> - 跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。\n\n2、服务器负载过大，导致响应不过来\n\n> 可以从两个方面入手分析：\n>\n> - 分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。\n> - 如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。\n\n3、数据库瓶颈\n\n> - 如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。\n> - 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。\n\n4、网站开发代码没有优化好\n\n> - 例如 SQL 语句没有优化，导致数据库读写相当耗时。\n\n**针对网站访问慢，怎么去排查？**\n\n1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。\n\n> 不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。\n\n2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。\n\n3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。\n\n4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL 慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。\n\n**怎么去解决？**\n\n1、如果是出口带宽问题，那么久申请加大出口带宽。\n\n2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。\n\n3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。\n\n4、申请购买 CDN 服务，加载用户的访问。\n\n5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。\n\n### Linux 性能调优都有哪几种方法？\n\n1、Disabling daemons (关闭 daemons)。\n\n2、Shutting down the GUI (关闭 GUI)。\n\n3、Changing kernel parameters (改变内核参数)。\n\n4、Kernel parameters (内核参数)。\n\n5、Tuning the processor subsystem (处理器子系统调优)。\n\n6、Tuning the memory subsystem (内存子系统调优)。\n\n7、Tuning the file system (文件系统子系统调优)。\n\n8、Tuning the network subsystem（网络子系统调优)。\n\n## 文件管理命令\n\n### cat 命令\n\ncat 命令用于连接文件并打印到标准输出设备上。\n\ncat 主要有三大功能：\n\n1、一次显示整个文件:\n\n```sh\ncat filename\n```\n\n2、从键盘创建一个文件:\n\n```shell\ncat > filename\n```\n\n只能创建新文件，不能编辑已有文件。\n\n3、将几个文件合并为一个文件：\n\n```shell\ncat file1 file2 > file\n```\n\n- -b 对非空输出行号\n- -n 输出所有行号\n\n**实例**：\n\n（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里\n\n```shell\ncat -n log2012.log > log2013.log\n```\n\n（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里\n\n```shell\ncat -b log2012.log log2013.log > log.log\n```\n\n### chmod 命令\n\nLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。\n\n用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n\n每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件**属主**的读、写和执行权限；与属主**同组**的用户的读、写和执行权限；系统中**其他用户**的读、写和执行权限。可使用 ls -l test.txt 查找。\n\n以文件 log2012.log 为例：\n\n```shell\n-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log\n```\n\n第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读(4)，w 代表写(2)，x 代表可执行(1)。\n\n**常用参数**：\n\n```\n-c 当发生改变时，报告处理信息\n-R 处理指定目录以及其子目录下所有文件\n```\n\n权限范围：\n\n```\nu ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组\n```\n\n权限代号：\n\n```\nr ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n- ：删除权限，用数字0表示\ns ：特殊权限\n```\n\n**实例**：\n\n（1）增加文件 t.log 所有用户可执行权限\n\n```shell\nchmod a+x t.log\n```\n\n（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息\n\n```shell\nchmod u=r t.log -c\n```\n\n（3）给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限\n\n```shell\nchmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c\n```\n\n（4）将 test 目录及其子目录所有文件添加可读权限\n\n```shell\nchmod u+r,g+r,o+r -R text/ -c\n```\n\n### chown 命令\n\nchown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。\n\n```\n-c 显示更改的部分的信息\n-R 处理指定目录及子目录\n```\n\n**实例**：\n\n（1）改变拥有者和群组 并显示改变信息\n\n```shell\nchown -c mail:mail log2012.log\n```\n\n（2）改变文件群组\n\n```shell\nchown -c :mail t.log\n```\n\n（3）改变文件夹及子文件目录属主及属组为 mail\n\n```shell\nchown -cR mail: test/\n```\n\n### cp 命令\n\n将源文件复制至目标文件，或将多个源文件复制至目标目录。\n\n注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！\n\n```\n-i 提示\n-r 复制目录及目录内所有项目\n-a 复制的文件与原文件时间一样\n```\n\n**实例**：\n\n（1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。\n\n```shell\ncp -ai a.txt test\n```\n\n（2）为 a.txt 建议一个链接（快捷方式）\n\n```shell\ncp -s a.txt link_a.txt\n```\n\n### find 命令\n\n用于在文件树中查找文件，并作出相应的处理。\n\n命令格式：\n\n```shell\nfind pathname -options [-print -exec -ok ...]\n```\n\n命令参数：\n\n```\npathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。\n-print： find命令将匹配的文件输出到标准输出。\n-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \\;，注意{   }和\\；之间的空格。\n-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\n```\n\n**命令选项**：\n\n```\n-name 按照文件名查找文件\n-perm 按文件权限查找文件\n-user 按文件属主查找文件\n-group  按照文件所属的组来查找文件。\n-type  查找某一类型的文件，诸如：\n   b - 块设备文件\n   d - 目录\n   c - 字符设备文件\n   l - 符号链接文件\n   p - 管道文件\n   f - 普通文件\n```\n\n**实例**：\n\n（1）查找 48 小时内修改过的文件\n\n```shell\nfind -atime -2\n```\n\n（2）在当前目录查找 以 .log 结尾的文件。 **.** 代表当前目录\n\n```shell\nfind ./ -name '*.log'\n```\n\n（3）查找 /opt 目录下 权限为 777 的文件\n\n```shell\nfind /opt -perm 777\n```\n\n（4）查找大于 1K 的文件\n\n```shell\nfind -size +1000c\n```\n\n查找等于 1000 字符的文件\n\n```shell\nfind -size 1000c \n```\n\n-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面 find 查找出来的文件名。\n\n### head 命令\n\nhead 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。\n\n**常用参数**：\n\n```\n-n<行数> 显示的行数（行数为复数表示从最后向前数）\n```\n\n**实例**：\n\n（1）显示 1.log 文件中前 20 行\n\n```shell\nhead 1.log -n 20\n```\n\n（2）显示 1.log 文件前 20 字节\n\n```shell\nhead 1.log -c 20 \n1\n```\n\n（3）显示 1.log 最后 10 行\n\n```shell\nhead 1.log -n -10\n```\n\n### less 命令\n\nless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n\n**常用命令参数**：\n\n```\n-i  忽略搜索时的大小写\n-N  显示每行的行号\n-o  <文件名> 将less 输出的内容在指定文件中保存起来\n-s  显示连续空行为一行\n/字符串：向下搜索“字符串”的功能\n?字符串：向上搜索“字符串”的功能\nn：重复前一个搜索（与 / 或 ? 有关）\nN：反向重复前一个搜索（与 / 或 ? 有关）\n-x <数字> 将“tab”键显示为规定的数字空格\nb  向后翻一页\nd  向后翻半页\nh  显示帮助界面\nQ  退出less 命令\nu  向前滚动半页\ny  向前滚动一行\n空格键 滚动一行\n回车键 滚动一页\n[pagedown]： 向下翻动一页\n[pageup]：   向上翻动一页\n```\n\n**实例**：\n\n（1）ps 查看进程信息并通过 less 分页显示\n\n```shell\nps -aux | less -N\n```\n\n（2）查看多个文件\n\n```shell\nless 1.log 2.log\n```\n\n可以使用 n 查看下一个，使用 p 查看前一个。\n\n### ln 命令\n\n功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。\n\n链接分类：软件链接及硬链接\n\n软链接：\n\n- 1.软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式\n- 2.软链接可以 跨文件系统 ，硬链接不可以\n- 3.软链接可以对一个不存在的文件名进行链接\n- 4.软链接可以对目录进行链接\n\n硬链接:\n\n- 1.硬链接，以文件副本的形式存在。但不占用实际空间。\n- 2.不允许给目录创建硬链接\n- 3.硬链接只有在同一个文件系统中才能创建\n\n**需要注意**：\n\n- 第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；\n- 第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。\n- 第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。\n\n**常用参数**：\n\n```\n-b 删除，覆盖以前建立的链接\n-s 软链接（符号链接）\n-v 显示详细处理过程\n```\n\n**实例**：\n\n（1）给文件创建软链接，并显示操作信息\n\n```shell\nln -sv source.log link.log\n```\n\n（2）给文件创建硬链接，并显示操作信息\n\n```shell\nln -v source.log link1.log\n```\n\n（3）给目录创建软链接\n\n```shell\nln -sv /opt/soft/test/test3 /opt/soft/test/test5\n```\n\n### locate 命令\n\nlocate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。\n\nlocate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找\n\n**常用参数**：\n\n```\n-l num（要显示的行数）\n-f   将特定的档案系统排除在外，如将proc排除在外\n-r   使用正则运算式做为寻找条件\n```\n\n**实例**：\n\n（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）\n\n```shell\nlocate pwd\n```\n\n（2）搜索 etc 目录下所有以 sh 开头的文件\n\n```shell\nlocate /etc/sh\n```\n\n（3）查找 /var 目录下，以 reason 结尾的文件\n\n```shell\nlocate -r '^/var.*reason$'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）\n```\n\n### more 命令\n\n功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。\n\n**命令参数**：\n\n```\n+n      从笫 n 行开始显示\n-n       定义屏幕大小为n行\n+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 \n-c       从顶部清屏，然后显示\n-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能\n-l        忽略Ctrl+l（换页）字符\n-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似\n-s       把连续的多个空行显示为一行\n-u       把文件内容中的下画线去掉\n```\n\n**常用操作命令**：\n\n```\nEnter    向下 n 行，需要定义。默认为 1 行\nCtrl+F   向下滚动一屏\n空格键  向下滚动一屏\nCtrl+B  返回上一屏\n=       输出当前行的行号\n:f     输出文件名和当前行的行号\nV      调用vi编辑器\n!命令   调用Shell，并执行命令\nq       退出more\n```\n\n**实例**：\n\n（1）显示文件中从第 3 行起的内容\n\n```shell\nmore +3 text.txt\n```\n\n（2）在所列出文件目录详细信息，借助管道使每次显示 5 行\n\n```shell\nls -l | more -5\n```\n\n按空格显示下 5 行。\n\n### mv 命令\n\n移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。\n\n当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。\n\n**实例**：\n\n（1）将文件 test.log 重命名为 test1.txt\n\n```shell\nmv test.log test1.txt\n```\n\n（2）将文件 log1.txt、log2.txt、log3.txt 移动到根的 test3 目录中\n\n```shell\nmv llog1.txt log2.txt log3.txt /test3\n```\n\n（3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖\n\n```shell\nmv -i log1.txt log2.txt\n```\n\n（4）移动当前文件夹下的所有文件到上一级目录\n\n```shell\nmv * ../\n```\n\n### rm 命令\n\n删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。\n\n```shell\nrm [选项] 文件…\n```\n\n**实例**：\n\n（1）删除任何 .log 文件，删除前逐一询问确认：\n\n```shell\nrm -i *.log\n```\n\n（2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认：\n\n```shell\nrm -rf test\n```\n\n（3）删除以 -f 开头的文件\n\n```shell\nrm -- -f*\n```\n\n### tail 命令\n\n用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。\n\n**常用参数**：\n\n```\n-f 循环读取（常用于查看递增的日志文件）\n-n<行数> 显示行数（从后向前）\n```\n\n（1）循环读取逐渐增加的文件内容\n\n```shell\nping 127.0.0.1 > ping.log &\n```\n\n后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。\n\n```shell\ntail -f ping.log\n```\n\n（查看日志）\n\n### touch 命令\n\nLinux touch 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\n\nls -l 可以显示档案的时间记录。\n\n**语法**\n\n```\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\n```\n\n- **参数说明**：\n- a 改变档案的读取时间记录。\n- m 改变档案的修改时间记录。\n- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\n- f 不使用，是为了与其他 unix 系统的相容性而保留。\n- r 使用参考档的时间记录，与 --file 的效果一样。\n- d 设定时间与日期，可以使用各种不同的格式。\n- t 设定档案的时间记录，格式与 date 指令相同。\n- –no-create 不会建立新档案。\n- –help 列出指令格式。\n- –version 列出版本讯息。\n\n**实例**\n\n使用指令\"touch\"修改文件\"testfile\"的时间属性为当前系统时间，输入如下命令：\n\n```shell\n$ touch testfile                #修改文件的时间属性 \n```\n\n首先，使用 ls 命令查看 testfile 文件的属性，如下所示：\n\n```shell\n$ ls -l testfile                #查看文件的时间属性  \n#原来文件的修改时间为16:09  \n-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  \n```\n\n执行指令\"touch\"修改文件属性以后，并再次查看该文件的时间属性，如下所示：\n\n```shell\n$ touch testfile                #修改文件时间属性为当前系统时间  \n$ ls -l testfile                #查看文件的时间属性  \n#修改后文件的时间属性为当前系统时间  \n-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  \n```\n\n使用指令\"touch\"时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件\"file\"，输入如下命令：\n\n```shell\n$ touch file            #创建一个名为“file”的新的空白文件 \n```\n\n### vim 命令\n\nVim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\n- 打开文件并跳到第 10 行：`vim +10 filename.txt` 。\n- 打开文件跳到第一个匹配的行：`vim +/search-term filename.txt` 。\n- 以只读模式打开文件：`vim -R /etc/passwd` 。\n\n基本上 vi/vim 共分为三种模式，分别是**命令模式（Command mode）**，**输入模式（Insert mode）\\**和\\**底线命令模式（Last line mode）**。\n\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n![vim 工作模式](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806349.png)\n\n### whereis 命令\n\nwhereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。\n\n**常用参数**：\n\n```\n-b   定位可执行文件。\n-m   定位帮助文件。\n-s   定位源代码文件。\n-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。\n```\n\n**实例**：\n\n（1）查找 locate 程序相关文件\n\n```shell\nwhereis locate\n```\n\n（2）查找 locate 的源码文件\n\n```shell\nwhereis -s locate\n```\n\n（3）查找 lcoate 的帮助文件\n\n```shell\nwhereis -m locate\n```\n\n### which 命令\n\n在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：\n\n```\nwhich     查看可执行文件的位置。\nwhereis 查看文件的位置。\nlocate  配合数据库查看文件位置。\nfind        实际搜寻硬盘查询文件名称。\n```\n\nwhich 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n**常用参数**：\n\n```\n-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n```\n\n**实例**：\n\n（1）查看 ls 命令是否存在，执行哪个\n\n```shell\nwhich ls\n```\n\n（2）查看 which\n\n```shell\nwhich which\n```\n\n（3）查看 cd\n\n```shell\nwhich cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）\n```\n\n查看当前 PATH 配置：\n\n```shell\necho $PATH\n```\n\n或使用 env 查看所有环境变量及对应值\n\n## 文档编辑命令\n\n### grep 命令\n\n强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。\n\ngrep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。\n\n命令格式：\n\n```\ngrep [option] pattern file|dir\n```\n\n**常用参数**：\n\n```\n-A n --after-context显示匹配字符后n行\n-B n --before-context显示匹配字符前n行\n-C n --context 显示匹配字符前后n行\n-c --count 计算符合样式的列数\n-i 忽略大小写\n-l 只列出文件内容符合指定的样式的文件名称\n-f 从文件中读取关键词\n-n 显示匹配内容的所在文件中行数\n-R 递归查找文件夹\n```\n\ngrep 的规则表达式:\n\n```\n^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。 \n$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 \n.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。  \n*  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。\n.*   #一起用代表任意字符。  \n[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。 \n[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  \n\\(..\\)  #标记匹配字符，如'\\(love\\)'，love被标记为1。   \n\\<      #锚定单词的开始，如:'\\<grep'匹配包含以grep开头的单词的行。\n\\>      #锚定单词的结束，如'grep\\>'匹配包含以grep结尾的单词的行。\nx\\{m\\}  #重复字符x，m次，如：'0\\{5\\}'匹配包含5个o的行。 \nx\\{m,\\}  #重复字符x,至少m次，如：'o\\{5,\\}'匹配至少有5个o的行。  \nx\\{m,n\\}  #重复字符x，至少m次，不多于n次，如：'o\\{5,10\\}'匹配5--10个o的行。  \n\\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。  \n\\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  \n\\b    #单词锁定符，如: '\\bgrep\\b'只匹配grep。\n```\n\n**实例**：\n\n（1）查找指定进程\n\n```shell\nps -ef | grep svn\n```\n\n（2）查找指定进程个数\n\n```shell\nps -ef | grep svn -c\n```\n\n（3）从文件中读取关键词\n\n```shell\ncat test1.txt | grep -f key.log\n```\n\n（4）从文件夹中递归查找以 grep 开头的行，并只列出文件\n\n```shell\ngrep -lR '^grep' /tmp\n```\n\n（5）查找非 x 开关的行内容\n\n```shell\ngrep '^[^x]' test.txt\n```\n\n（6）显示包含 ed 或者 at 字符的内容行\n\n```shell\ngrep -E 'ed|at' test.txt\n```\n\n### wc 命令\n\nwc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出\n\n命令格式：\n\n```\nwc [option] file..\n```\n\n**命令参数**：\n\n```\n-c 统计字节数\n-l 统计行数\n-m 统计字符数\n-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串\n```\n\n**实例**：\n\n（1）查找文件的 行数 单词数 字节数 文件名\n\n```shell\nwc text.txt\n```\n\n结果：\n\n```shell\n7     8     70     test.txt\n```\n\n（2）统计输出结果的行数\n\n```shell\ncat test.txt | wc -l\n```\n\n## 磁盘管理命令\n\n### cd 命令\n\ncd(changeDirectory) 命令语法：\n\n```\ncd [目录名]\n```\n\n说明：切换当前目录至 dirName。\n\n**实例**：\n\n（1）进入要目录\n\n```shell\ncd /\n```\n\n（2）进入 “home” 目录\n\n```shell\ncd ~\n```\n\n（3）进入上一次工作路径\n\n```shell\ncd -\n```\n\n（4）把上个命令的参数作为 cd 参数使用。\n\n```shell\ncd !$\n```\n\n### df 命令\n\n显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示：\n\n```\n-a 全部文件系统列表\n-h 以方便阅读的方式显示信息\n-i 显示inode信息\n-k 区块为1024字节\n-l 只显示本地磁盘\n-T 列出文件系统类型\n```\n\n**实例**：\n\n（1）显示磁盘使用情况\n\n```shell\ndf -l\n```\n\n（2）以易读方式列出所有文件系统及其类型\n\n```shell\ndf -haT\n```\n\n### du 命令\n\ndu 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：\n\n命令格式：\n\n```\ndu [选项] [文件]\n1\n```\n\n**常用参数**：\n\n```\n-a 显示目录中所有文件大小\n-k 以KB为单位显示文件大小\n-m 以MB为单位显示文件大小\n-g 以GB为单位显示文件大小\n-h 以易读方式显示文件大小\n-s 仅显示总计\n-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和\n```\n\n**实例**：\n\n（1）以易读方式显示文件夹内及子文件夹大小\n\n```shell\ndu -h scf/\n```\n\n（2）以易读方式显示文件夹内所有文件大小\n\n```shell\ndu -ah scf/\n```\n\n（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和\n\n```shell\ndu -hc test/ scf/\n```\n\n（4）输出当前目录下各个子目录所使用的空间\n\n```shell\ndu -hc --max-depth=1 scf/\n```\n\n### ls命令\n\n就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。\n\n**常用参数搭配**：\n\n```\nls -a 列出目录所有文件，包含以.开始的隐藏文件\nls -A 列出除.及..的其它文件\nls -r 反序排列\nls -t 以文件修改时间排序\nls -S 以文件大小排序\nls -h 以易读大小显示\nls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来\n```\n\n**实例**：\n\n(1) 按易读方式按时间反序排序，并显示文件详细信息\n\n```shell\nls -lhrt\n```\n\n(2) 按大小反序显示文件详细信息\n\n```shell\nls -lrS\n```\n\n(3)列出当前目录中所有以\"t\"开头的目录的详细内容\n\n```shell\nls -l t*\n```\n\n(4) 列出文件绝对路径（不包含隐藏文件）\n\n```shell\nls | sed \"s:^:`pwd`/:\"\n```\n\n(5) 列出文件绝对路径（包含隐藏文件）\n\n```shell\nfind $pwd -maxdepth 1 | xargs ls -ld\n```\n\n### mkdir 命令\n\nmkdir 命令用于创建文件夹。\n\n可用选项：\n\n- **-m**: 对新建目录设置存取权限，也可以用 chmod 命令设置;\n- **-p**: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。\n\n**实例**：\n\n（1）当前工作目录下创建名为 t 的文件夹\n\n```shell\nmkdir t\n```\n\n（2）在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：\n\n```shell\nmkdir -p /tmp/test/t1/t\n```\n\n### pwd 命令\n\npwd 命令用于查看当前工作目录路径。\n\n**实例**：\n\n（1）查看当前路径\n\n```shell\npwd\n```\n\n（2）查看软链接的实际路径\n\n```shell\npwd -P\n```\n\n### rmdir 命令\n\n从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。\n\n**注意**：不能删除非空目录\n\n**实例**：\n\n（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：\n\n```shell\nrmdir -p parent/child/child11\n```\n\n## 网络通讯命令\n\n### ifconfig 命令\n\n- ifconfig 用于查看和配置 Linux 系统的网络接口。\n- 查看所有网络接口及其状态：`ifconfig -a` 。\n- 使用 up 和 down 命令启动或停止某个接口：`ifconfig eth0 up` 和 `ifconfig eth0 down` 。\n\n### iptables 命令\n\niptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：\n\n- 把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：`iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT` 。\n\n- 开启 80 端口，因为 web 对外都是这个端口\n\n\t```shell\n\tiptables -A INPUT -p tcp --dport 80 -j ACCEP\n\t```\n\n- 另外，要注意使用 `iptables save` 命令，进行保存。否则，服务器重启后，配置的规则将丢失。\n\n### netstat 命令\n\nLinux netstat 命令用于显示网络状态。\n\n利用 netstat 指令可让你得知整个 Linux 系统的网络情况。\n\n语法\n\n```\nnetstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]\n```\n\n**参数说明**：\n\n- -a 或–all 显示所有连线中的 Socket。\n- -A<网络类型>或–<网络类型> 列出该网络类型连线中的相关地址。\n- -c 或–continuous 持续列出网络状态。\n- -C 或–cache 显示路由器配置的快取信息。\n- -e 或–extend 显示网络其他相关信息。\n- -F 或–fib 显示 FIB。\n- -g 或–groups 显示多重广播功能群组组员名单。\n- -h 或–help 在线帮助。\n- -i 或–interfaces 显示网络界面信息表单。\n- -l 或–listening 显示监控中的服务器的 Socket。\n- -M 或–masquerade 显示伪装的网络连线。\n- -n 或–numeric 直接使用 IP 地址，而不通过域名服务器。\n- -N 或–netlink 或–symbolic 显示网络硬件外围设备的符号连接名称。\n- -o 或–timers 显示计时器。\n- -p 或–programs 显示正在使用 Socket 的程序识别码和程序名称。\n- -r 或–route 显示 Routing Table。\n- -s 或–statistice 显示网络工作信息统计表。\n- -t 或–tcp 显示 TCP 传输协议的连线状况。\n- -u 或–udp 显示 UDP 传输协议的连线状况。\n- -v 或–verbose 显示指令执行过程。\n- -V 或–version 显示版本信息。\n- -w 或–raw 显示 RAW 传输协议的连线状况。\n- -x 或–unix 此参数的效果和指定\"-A unix\"参数相同。\n- –ip 或–inet 此参数的效果和指定\"-A inet\"参数相同。\n\n**实例**\n\n**如何查看系统都开启了哪些端口？**\n\n```shell\n[root@centos6 ~ 13:20 #55]# netstat -lnp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name\ntcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      1035/sshd\ntcp        0      0 :::22                       :::*                        LISTEN      1035/sshd\nudp        0      0 0.0.0.0:68                  0.0.0.0:*                               931/dhclient\nActive UNIX domain sockets (only servers)\nProto RefCnt Flags       Type       State         I-Node PID/Program name    Path\nunix  2      [ ACC ]     STREAM     LISTENING     6825   1/init              @/com/ubuntu/upstart\nunix  2      [ ACC ]     STREAM     LISTENING     8429   1003/dbus-daemon    /var/run/dbus/system_bus_socket\n```\n\n**如何查看网络连接状况？**\n\n```shell\n[root@centos6 ~ 13:22 #58]# netstat -an\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address               Foreign Address             State\ntcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN\ntcp        0      0 192.168.147.130:22          192.168.147.1:23893         ESTABLISHED\ntcp        0      0 :::22                       :::*                        LISTEN\nudp        0      0 0.0.0.0:68                  0.0.0.0:*\n```\n\n**如何统计系统当前进程连接数？**\n\n- 输入命令 `netstat -an | grep ESTABLISHED | wc -l` 。\n- 输出结果 `177` 。一共有 177 连接数。\n\n**用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 ESTABLISHED 状态链接的个数？**\n\n> 严格来说，这个题目考验的是对 awk 的使用。\n\n首先，使用 `netstat -an|grep ESTABLISHED` 命令。结果如下：\n\n```shell\ntcp        0      0 120.27.146.122:80       113.65.18.33:62721      ESTABLISHED\ntcp        0      0 120.27.146.122:80       27.43.83.115:47148      ESTABLISHED\ntcp        0      0 120.27.146.122:58838    106.39.162.96:443       ESTABLISHED\ntcp        0      0 120.27.146.122:52304    203.208.40.121:443      ESTABLISHED\ntcp        0      0 120.27.146.122:33194    203.208.40.122:443      ESTABLISHED\ntcp        0      0 120.27.146.122:53758    101.37.183.144:443      ESTABLISHED\ntcp        0      0 120.27.146.122:27017    23.105.193.30:50556     ESTABLISHED\n```\n\n### ping 命令\n\nLinux ping 命令用于检测主机。\n\n执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\n\n指定接收包的次数\n\n```shell\nping -c 2 www.baidu.com\n```\n\n### telnet 命令\n\nLinux telnet 命令用于远端登入。\n\n执行 telnet 指令开启终端机阶段作业，并登入远端主机。\n\n语法\n\n```\ntelnet [-8acdEfFKLrx][-b<主机别名>][-e<脱离字符>][-k<域名>][-l<用户名称>][-n<记录文件>][-S<服务类型>][-X<认证形态>][主机名称或IP地址<通信端口>]\n```\n\n**参数说明**：\n\n- -8 允许使用 8 位字符资料，包括输入与输出。\n- -a 尝试自动登入远端系统。\n- -b<主机别名> 使用别名指定远端主机名称。\n- -c 不读取用户专属目录里的.telnetrc 文件。\n- -d 启动排错模式。\n- -e<脱离字符> 设置脱离字符。\n- -E 滤除脱离字符。\n- -f 此参数的效果和指定\"-F\"参数相同。\n- -F 使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机。\n- -k<域名> 使用 Kerberos 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。\n- -K 不自动登入远端主机。\n- -l<用户名称> 指定要登入远端主机的用户名称。\n- -L 允许输出 8 位字符资料。\n- -n<记录文件> 指定文件记录相关信息。\n- -r 使用类似 rlogin 指令的用户界面。\n- -S<服务类型> 设置 telnet 连线所需的 IP TOS 信息。\n- -x 假设主机有支持数据加密的功能，就使用它。\n- -X<认证形态> 关闭指定的认证形态。\n\n**实例**\n\n登录远程主机\n\n```shell\n# 登录IP为 192.168.0.5 的远程主机\ntelnet 192.168.0.5 \n```\n\n## 系统管理命令\n\n### date 命令\n\n显示或设定系统的日期与时间。\n\n命令参数：\n\n```\n-d<字符串> 　显示字符串所指的日期与时间。字符串前后必须加上双引号。\n-s<字符串> 　根据字符串来设置日期与时间。字符串前后必须加上双引号。\n-u 　显示GMT。\n%H 小时(00-23)\n%I 小时(00-12)\n%M 分钟(以00-59来表示)\n%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。\n%S 秒(以本地的惯用法来表示)\n%a 星期的缩写。\n%A 星期的完整名称。\n%d 日期(以01-31来表示)。\n%D 日期(含年月日)。\n%m 月份(以01-12来表示)。\n%y 年份(以00-99来表示)。\n%Y 年份(以四位数来表示)。\n```\n\n**实例**：\n\n（1）显示下一天\n\n```shell\ndate +%Y%m%d --date=\"+1 day\"  //显示下一天的日期\n```\n\n（2）-d 参数使用\n\n```shell\ndate -d \"nov 22\"  今年的 11 月 22 日是星期三\ndate -d '2 weeks' 2周后的日期\ndate -d 'next monday' (下周一的日期)\ndate -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d\ndate -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d\ndate -d last-month +%Y%m(上个月是几月)\ndate -d next-month +%Y%m(下个月是几月)\n```\n\n### free 命令\n\n显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。\n\n**命令参数**：\n\n```\n-b 以Byte显示内存使用情况\n-k 以kb为单位显示内存使用情况\n-m 以mb为单位显示内存使用情况\n-g 以gb为单位显示内存使用情况\n-s<间隔秒数> 持续显示内存\n-t 显示内存使用总合\n```\n\n**实例**：\n\n（1）显示内存使用情况\n\n```shell\nfree\nfree -k\nfree -m\n```\n\n（2）以总和的形式显示内存的使用信息\n\n```shell\nfree -t\n```\n\n（3）周期性查询内存使用情况\n\n```shell\nfree -s 10\n```\n\n### kill 命令\n\n发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用\"-KILL\" 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。\n\n**常用参数**：\n\n```\n-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称\n-a  当处理当前进程时，不限制命令名和进程号的对应关系\n-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号\n-s  指定发送信号\n-u  指定用户\n```\n\n**实例**：\n\n（1）先使用 ps 查找进程 pro1，然后用 kill 杀掉\n\n```shell\nkill -9 $(ps -ef | grep pro1)\n```\n\n### ps 命令\n\nps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top\n\nlinux 上进程有 5 种状态:\n\n1. 运行(正在运行或在运行队列中等待)\n2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)\n3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)\n4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)\n5. 停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行)\n\nps 工具标识进程的 5 种状态码:\n\n```\nD 不可中断 uninterruptible sleep (usually IO)\nR 运行 runnable (on run queue)\nS 中断 sleeping\nT 停止 traced or stopped\nZ 僵死 a defunct (”zombie”) process\n```\n\n**命令参数**：\n\n```\n-A 显示所有进程\na 显示所有进程\n-a 显示同一终端下所有进程\nc 显示进程真实名称\ne 显示环境变量\nf 显示进程间的关系\nr 显示当前终端运行的进程\n-aux 显示所有包含其它使用的进程\n```\n\n**实例**：\n\n（1）显示当前所有进程环境变量及进程间关系\n\n```shell\nps -ef\n```\n\n（2）显示当前所有进程\n\n```shell\nps -A\n```\n\n（3）与 grep 联用查找某进程\n\n```shell\nps -aux | grep apache\n```\n\n（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码\n\n```shell\nps aux | grep '(cron|syslog)'\n```\n\n### rpm 命令\n\nLinux rpm 命令用于管理套件。\n\nrpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\n\n```shell\n# 查看系统自带jdk\nrpm -qa | grep jdk\n# 删除系统自带jdk\nrpm -e --nodeps 查看jdk显示的数据\n# 安装jdk\nrpm -ivh jdk-7u80-linux-x64.rpm\n```\n\n### top 命令\n\n显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等\n\n**常用参数**：\n\n```\n-c 显示完整的进程命令\n-s 保密模式\n-p <进程号> 指定进程显示\n-n <次数>循环显示次数\n```\n\n**实例**：\n\n```shell\ntop - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35\nTasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie\nCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st\nMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers\nSwap: 32764556k total,        0k used, 32764556k free,  3612636k cached\nPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  \n28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  \n```\n\n前五行是当前系统情况整体的统计信息区。\n\n**第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下**：\n\n14:06:23 — 当前系统时间\n\nup 70 days, 16:44 — 系统已经运行了 70 天 16 小时 44 分钟（在这期间系统没有重启过的吆！）\n\n2 users — 当前有 2 个用户登录系统\n\nload average: 1.15, 1.42, 1.44 — load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。\n\nload average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。\n\n**第二行，Tasks — 任务（进程），具体信息说明如下**：\n\n系统现在共有 206 个进程，其中处于运行中的有 1 个，205 个在休眠（sleep），stoped 状态的有 0 个，zombie 状态（僵尸）的有 0 个。\n\n**第三行，cpu状态信息，具体属性说明如下**：\n\n```\n5.9%us — 用户空间占用CPU的百分比。\n3.4% sy — 内核空间占用CPU的百分比。\n0.0% ni — 改变过优先级的进程占用CPU的百分比\n90.4% id — 空闲CPU百分比\n0.0% wa — IO等待占用CPU的百分比\n0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比\n0.2% si — 软中断（Software Interrupts）占用CPU的百分比\n```\n\n**备注**：在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！\n\n第四行，内存状态，具体信息如下：\n\n```\n32949016k total — 物理内存总量（32GB）\n14411180k used — 使用中的内存总量（14GB）\n18537836k free — 空闲内存总量（18GB）\n169884k buffers — 缓存的内存量 （169M）\n```\n\n**第五行，swap交换分区信息，具体信息说明如下**：\n\n```\n32764556k total — 交换区总量（32GB）\n0k used — 使用的交换区总量（0K）\n32764556k free — 空闲交换区总量（32GB）\n3612636k cached — 缓冲的交换区总量（3.6GB）\n```\n\n**第六行，空行。**\n\n**第七行以下：各进程（任务）的状态监控，项目列信息说明如下**：\n\n```\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\nCOMMAND — 进程名称（命令名/命令行）\n```\n\n**top 交互命令**\n\n```\nh 显示top交互命令帮助信息\nc 切换显示命令名称和完整命令行\nm 以内存使用率排序\nP 根据CPU使用百分比大小进行排序\nT 根据时间/累计时间进行排序\nW 将当前设置写入~/.toprc文件中\no或者O 改变显示项目的顺序\n```\n\n### yum 命令\n\nyum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。\n\n基於 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\nyum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n- 1.列出所有可更新的软件清单命令：yum check-update\n- 2.更新所有软件命令：yum update\n- 3.仅安装指定的软件命令：yum install <package_name>\n- 4.仅更新指定的软件命令：yum update <package_name>\n- 5.列出所有可安裝的软件清单命令：yum list\n- 6.删除软件包命令：yum remove <package_name>\n- 7.查找软件包 命令：yum search\n- 8.清除缓存命令:\n\t- yum clean packages: 清除缓存目录下的软件包\n\t- yum clean headers: 清除缓存目录下的 headers\n\t- yum clean oldheaders: 清除缓存目录下旧的 headers\n\t- yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers\n\n**实例**\n\n安装 pam-devel\n\n```shell\n[root@www ~]# yum install pam-devel\n```\n\n## 备份压缩命令\n\n### bzip2 命令\n\n- 创建 `*.bz2` 压缩文件：`bzip2 test.txt` 。\n- 解压 `*.bz2` 文件：`bzip2 -d test.txt.bz2` 。\n\n### gzip 命令\n\n- 创建一个 `*.gz` 的压缩文件：`gzip test.txt` 。\n- 解压 `*.gz` 文件：`gzip -d test.txt.gz` 。\n- 显示压缩的比率：`gzip -l *.gz` 。\n\n### tar 命令\n\n用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。\n\n弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件\n\n**常用参数**：\n\n```\n-c 建立新的压缩文件\n-f 指定压缩文件\n-r 添加文件到已经压缩文件包中\n-u 添加改了和现有的文件到压缩包中\n-x 从压缩包中抽取文件\n-t 显示压缩文件中的内容\n-z 支持gzip压缩\n-j 支持bzip2压缩\n-Z 支持compress解压文件\n-v 显示操作过程\n```\n\n有关 gzip 及 bzip2 压缩:\n\n```\ngzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz\n          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz\n\nbz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2\n       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2\n```\n\n**实例**：\n\n（1）将文件全部打包成 tar 包\n\n```shell\ntar -cvf log.tar 1.log,2.log 或tar -cvf log.*\n```\n\n（2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩\n\n```shell\ntar -zcvf /tmp/etc.tar.gz /etc\n```\n\n（3）查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的）\n\n```shell\ntar -ztvf /tmp/etc.tar.gz\n```\n\n（4）要压缩打包 /home, /etc ，但不要 /home/dmtsai\n\n```shell\ntar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc\n```\n\n### unzip 命令\n\n- 解压 `*.zip` 文件：`unzip test.zip` 。\n- 查看 `*.zip` 文件的内容：`unzip -l jasper.zip` 。\n\n","source":"_posts/Java八股文-Linux.md","raw":"---\ntitle: Java八股文 - Linux\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-25 13:45:06\ntags:\ntoc: true\nurlname: linux\n---\n\n> 整理的 Linux 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## Linux 概述\n\n### 什么是Linux\n\nLinux 是一套**免费使用和自由传播的类 Unix 操作系统**，是一个基于 POSIX 和 Unix 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n\n### Unix和Linux有什么区别？\n\nLinux 和 Unix 都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为 Unix 和 Linux 操作系统是一样的，然而，事实并非如此，以下是两者的区别。\n\n1. 开源性\n\tLinux 是一款开源操作系统，不需要付费，即可使用；Unix 是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。\n2. 跨平台性\n\tLinux 操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix 操作系统跨平台性能较弱，大多需与硬件配套使用。\n3. 可视化界面\n\tLinux 除了进行命令行操作，还有窗体管理系统；Unix 只是命令行下的系统。\n4. 硬件环境\n\tLinux 操作系统对硬件的要求较低，安装方法更易掌握；Unix 对硬件要求比较苛刻，按照难度较大。\n5. 用户群体\n\tLinux 的用户群体很广泛，个人和企业均可使用；Unix 的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者 Unix 硬件厂商使用，如 Sun 等。\n\t相比于 Unix 操作系统，Linux 操作系统更受广大计算机爱好者的喜爱，主要原因是 Linux 操作系统具有 Unix 操作系统的全部功能，并且能够在普通 PC 计算机上实现全部的 Unix 特性，开源免费的特性，更容易普及使用！\n\n### 什么是 Linux 内核？\n\nLinux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。\n\n1. 系统内存管理\n2. 应用程序管理\n3. 硬件设备管理\n4. 文件系统管理\n\n### Linux的基本组件是什么？\n\n就像任何其他典型的操作系统一样，Linux 拥有所有这些组件：内核，shell 和 GUI，系统实用程序和应用程序。Linux 比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。\n\n### Linux 的体系结构\n\n从大的方面讲，Linux 体系结构可以分为两块：\n\n![Linux 体系结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70.png)\n\n- 用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。\n- 内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。\n\n**为什么 Linux 体系结构要分为用户空间和内核空间的原因？**\n\n1. 现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。\n2. Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。\n\n用户空间和内核空间是程序执行的**两种不同的状态**，我们可以通过两种方式完成用户空间到内核空间的转移：\n\n1）系统调用；2）硬件中断。\n\n### BASH和DOS之间的基本区别是什么？\n\nBASH 和 DOS 控制台之间的主要区别在于 3 个方面：\n\n- BASH 命令区分大小写，而 DOS 命令则不区分；\n- 在 BASH 下，/ character 是目录分隔符，\\作为转义字符。在 DOS 下，/用作命令参数分隔符，\\是目录分隔符；\n- DOS 遵循命名文件中的约定，即 8 个字符的文件名后跟一个点，扩展名为 3 个字符。BASH 没有遵循这样的惯例。\n\n### Linux 开机启动过程？\n\n> 了解即可。\n\n1、主机加电自检，加载 BIOS 硬件信息。\n\n2、读取 MBR 的引导文件(GRUB、LILO)。\n\n3、引导 Linux 内核。\n\n4、运行第一个进程 init (进程号永远为 1 )。\n\n5、进入相应的运行级别。\n\n6、运行终端，输入用户名和密码。\n\n### Linux系统缺省的运行级别？\n\n- 关机。\n- 单机用户模式。\n- 字符界面的多用户模式(不支持网络)。\n- 字符界面的多用户模式。\n- 未分配使用。\n- 图形界面的多用户模式。\n- 重启。\n\n### Linux 使用的进程间通信方式？\n\n> 了解即可，不需要太深入。\n\n- 管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。\n- 信号(signal) 。\n- 消息队列。\n- 共享内存。\n- 信号量。\n- 套接字(socket) 。\n\n### Linux 有哪些系统日志文件？\n\n比较重要的是 `/var/log/messages` 日志文件。\n\n该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。\n\n### 什么是交换空间？\n\n交换空间是 Linux 使用的一定空间，用于临时保存一些并发运行的程序。当 RAM 没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。\n\n### 什么是root帐户\n\nroot 帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装 Linux 时都是默认帐户。\n\n### 什么是LILO？\n\nLILO 是 Linux 的引导加载程序。它主要用于将 Linux 操作系统加载到主内存中，以便它可以开始运行。\n\n### 什么是BASH？\n\nBASH 是 Bourne Again SHell 的缩写。它由 Steve Bourne 编写，作为原始 Bourne Shell（由/ bin / sh 表示）的替代品。它结合了原始版本的 Bourne Shell 的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行 Linux 的大多数系统的默认 shell。\n\n### 什么是CLI？\n\n**命令行界面**（英语**：command-line interface**，缩写]**：CLI**）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为**字符用户界面**（CUI）。\n\n通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。\n\n### 什么是GUI？\n\n图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。\n\n图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。\n\n### 开源的优势是什么？\n\n开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。\n\n### GNU项目的重要性是什么？\n\n这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。\n\n## 磁盘、目录、文件\n\n### 简单 Linux 文件系统？\n\n**在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。**\n\n也就是说在 Linux 系统中有一个重要的概念**：一切都是文件**。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就**可以用读写文件的方式实现对硬件的访问**。\n\nLinux 支持 5 种文件类型，如下图所示：\n\n![5 种文件类型](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png.png)\n\n### Linux 的目录结构是怎样的？\n\n> 这个问题，一般不会问。更多是实际使用时，需要知道。\n\nLinux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：\n![Linux 的目录结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806288.png)\n\n**常见目录说明**：\n\n- **/bin**： 存放二进制可执行文件(ls,cat,mkdir 等)，常用命令一般都在这里；\n- **/etc**： 存放系统管理和配置文件；\n- **/home**： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；\n- **/usr **： 用于存放系统应用程序；\n- **/opt**： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；\n- **/proc**： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；\n- **/root**： 超级用户（系统管理员）的主目录（特权阶级 o）；\n- **/sbin:** 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；\n- **/dev**： 用于存放设备文件；\n- **/mnt**： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；\n- **/boot**： 存放用于系统引导时使用的各种文件；\n- **/lib **： 存放着和系统运行相关的库文件 ；\n- **/tmp**： 用于存放各种临时文件，是公用的临时文件存储点；\n- **/var**： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；\n- **/lost+found**： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。\n\n### 什么是 inode ？\n\n> 一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix/Linux 文件系统和硬盘储存的基础。\n\n理解 inode，要从文件储存说起。\n\n文件储存在硬盘上，硬盘的最小存储单位叫做\"扇区\"（Sector）。每个扇区储存 512 字节（相当于 0.5KB）。\n\n操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个\"块\"（block）。这种由多个扇区组成的\"块\"，是文件存取的最小单位。\"块\"的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。\n\n文件数据都储存在\"块\"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做 inode，中文译名为\"索引节点\"。\n\n每一个文件都有对应的 inode，里面包含了与该文件有关的一些信息。\n\n**简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？**\n\n> 如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。\n\nLinux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。\n\n- inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。\n- Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。\n\n### 什么是硬链接和软链接？\n\n1）硬链接\n\n由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。\n\n- 不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。\n\n2）软链接\n\n软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。\n\n- 不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。\n\n**实际场景下，基本是使用软链接**。总结区别如下：\n\n- 硬链接不可以跨分区，软件链可以跨分区。\n- 硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。\n- 删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。\n\n### RAID 是什么?\n\n> RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。\n>\n> RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。\n\n当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。\n\n## 安全\n\n### 一台 Linux 系统初始化环境后需要做一些什么安全工作？\n\n1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。\n\n> 修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l\n\n2、服务器使用密钥登陆，禁止密码登陆。\n\n3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。\n\n4、装 fail2ban 这种防止 SSH 暴力破击的软件。\n\n5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)\n\n> 也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。\n\n6、修改历史命令记录的条数为 10 条。\n\n7、只允许有需要的服务器可以访问外网，其它全部禁止。\n\n8、做好软件层面的防护。\n\n- 8.1 设置 nginx_waf 模块防止 SQL 注入。\n- 8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。\n\n### 什么叫 CC 攻击？什么叫 DDOS 攻击？\n\n- CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。\n\n- DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。\n\n\t> 攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。\n\n**怎么预防 CC 攻击和 DDOS 攻击？**\n\n防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。\n\n> 流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。\n\n### 什么是网站数据库注入？\n\n- 由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。\n- 应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。\n- SQL 注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。\n\n**如何过滤与预防？**\n\n数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。\n\n## Shell\n\n### Shell 脚本是什么？\n\n一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。\n\n**什么是默认登录 Shell ？**\n\n在 Linux 操作系统，`\"/bin/bash\"` 是默认登录 Shell，是在创建用户时分配的。\n\n使用 chsh 命令可以改变默认的 Shell 。示例如下所示：\n\n```bash\nchsh <用户名> -s <新shell>\nchsh ThinkWon -s /bin/sh\n```\n\n**在 Shell 脚本中，如何写入注释？**\n\n注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 `#` 开头。例子如下：\n\n```bash\n#!/bin/bash\n# This is a command\necho “I am logged in as $USER”\n```\n\n### 语法级\n\n#### 可以在 Shell 脚本中使用哪些类型的变量？\n\n在 Shell 脚本，我们可以使用两种类型的变量：\n\n- 系统定义变量\n\n\t> 系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 `set` 命令查看。\n\n- 用户定义变量\n\n\t> 用户变量由系统用户来生成和定义，变量的值可以通过命令 `\"echo $<变量名>\"` 查看。\n\n**Shell脚本中 $? 标记的用途是什么？**\n\n在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 `if` 条件中使用 `$?` 可以来检查前一命令的结束状态。\n\n- 如果结束状态是 0 ，说明前一个命令执行成功。例如：\n\n\t```bash\n\troot@localhost:~## ls /usr/bin/shar\n\t/usr/bin/shar\n\troot@localhost:~## echo $?\n\t0\n\t```\n\n- 如果结束状态不是 0，说明命令执行失败。例如：\n\n\t```bash\n\troot@localhost:~## ls /usr/bin/share\n\tls: cannot access /usr/bin/share: No such file or directory\n\troot@localhost:~## echo $?\n\t2\n\t```\n\n**Bourne Shell(bash) 中有哪些特殊的变量？**\n\n下面的表列出了 Bourne Shell 为命令行设置的特殊变量。\n\n```bash\n内建变量    解释\n$0    命令行中的脚本名字\n$1    第一个命令行参数\n$2    第二个命令行参数\n…..    …….\n$9    第九个命令行参数\n$##    命令行参数的数量\n$*    所有命令行参数，以空格隔开\n```\n\n**如何取消变量或取消变量赋值？**\n\n`unset` 命令用于取消变量或取消变量赋值。语法如下所示：\n\n```bash\n## unset <变量名>\n```\n\n#### Shell 脚本中 `if` 语法如何嵌套?\n\n```bash\nif [ 条件 ]\nthen\n命令1\n命令2\n…..\nelse\nif [ 条件 ]\nthen\n命令1\n命令2\n….\nelse\n命令1\n命令2\n…..\nfi\nfi\n```\n\n**在 Shell 脚本中如何比较两个数字？**\n\n在 `if-then` 中使用测试命令（ `-gt` 等）来比较两个数字。例如：\n\n```bash\n#!/bin/bash\nx=10\ny=20\nif [ $x -gt $y ]\nthen\necho “x is greater than y”\nelse\necho “y is greater than x”\nfi\n```\n\n#### Shell 脚本中 `case` 语句的语法?\n\n基础语法如下：\n\n```bash\ncase 变量 in\n值1)\n命令1\n命令2\n…..\n最后命令\n!!\n值2)\n命令1\n命令2\n……\n最后命令\n;;\nesac\n```\n\n#### Shell 脚本中 `for` 循环语法？\n\n基础语法如下：\n\n```bash\nfor 变量 in 循环列表\ndo\n命令1\n命令2\n….\n最后命令\ndone\n```\n\n#### Shell 脚本中 `while` 循环语法？\n\n如同 `for` 循环，`while` 循环只要条件成立就重复它的命令块。\n不同于 `for`循环，`while` 循环会不断迭代，直到它的条件不为真。\n\n基础语法：\n\n```bash\nwhile [ 条件 ]\ndo\n命令…\ndone\n```\n\n**do-while 语句的基本格式？**\n\n`do-while` 语句类似于 `while` 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 `do-while` 语句的语法：\n\n```bash\ndo\n{\n命令\n} while (条件)\n```\n\n**Shell 脚本中 break 命令的作用？**\n\n`break` 命令一个简单的用途是退出执行中的循环。我们可以在 `while` 和 `until` 循环中使用 `break` 命令跳出循环。\n\n**Shell 脚本中 continue 命令的作用？**\n\n`continue` 命令不同于 `break` 命令，它只跳出当前循环的迭代，而不是整个循环。`continue` 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。\n\n#### 如何使脚本可执行?\n\n使用 chmod 命令来使脚本可执行。例子如下：`chmod a+x myscript.sh` 。\n\n**#!/bin/bash 的作用？**\n\n`#!/bin/bash` 是 Shell 脚本的第一行，称为释伴（shebang）行。\n\n- 这里 `#` 符号叫做 hash ，而 `!` 叫做 bang。\n- 它的意思是命令通过 `/bin/bash` 来执行。\n\n**如何调试 Shell脚本？**\n\n- 使用 `-x'` 数（`sh -x myscript.sh`）可以调试 Shell 脚本。\n- 另一个种方法是使用 `-nv` 参数(`sh -nv myscript.sh`)。\n\n**如何将标准输出和错误输出同时重定向到同一位置?**\n\n- 方法一：`2>&1 (如## ls /usr/share/doc > out.txt 2>&1 )` 。\n- 方法二：`&> (如## ls /usr/share/doc &> out.txt )` 。\n\n**在 Shell 脚本中，如何测试文件？**\n\ntest 命令可以用来测试文件。基础用法如下表格：\n\n```bash\nTest         用法\n-d 文件名    如果文件存在并且是目录，返回true\n-e 文件名    如果文件存在，返回true\n-f 文件名    如果文件存在并且是普通文件，返回true\n-r 文件名    如果文件存在并可读，返回true\n-s 文件名    如果文件存在并且不为空，返回true\n-w 文件名    如果文件存在并可写，返回true\n-x 文件名    如果文件存在并可执行，返回true\n```\n\n#### 在 Shell 脚本如何定义函数呢？\n\n函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：\n\n```bash\n$ diskusage () { df -h ; }\n译注：下面是我给的shell函数语法，原文没有\n[ function ] 函数名 [()]\n{\n命令;\n[return int;]\n}\n```\n\n**如何让 Shell 就脚本得到来自终端的输入?**\n\nread 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：\n\n```bash\n## vi /tmp/test.sh\n#!/bin/bash\necho ‘Please enter your name’\nread name\necho “My Name is $name”\n## ./test.sh\nPlease enter your name\nThinkWon\nMy Name is ThinkWon\n```\n\n**如何执行算术运算？**\n\n有两种方法来执行算术运算：\n\n- 1、使用 expr 命令：`## expr 5 + 2` 。\n- 2、用一个美元符号和方括号（`$[ 表达式 ]`）：`test=$[16 + 4] ; test=$[16 + 4]` 。\n\n### 编程题\n\n#### 判断一文件是不是字符设备文件，如果是将其拷贝到 `/dev` 目录下？\n\n```bash\n#!/bin/bash\nread -p \"Input file name: \" FILENAME\nif [ -c \"$FILENAME\" ];then\n　　cp $FILENAME /dev\nfi\n```\n\n#### 添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？\n\n```bash\n#!/bin/bash\ngroupadd class1\nfor((i=1;i<31;i++))\ndo\n        if [ $i -le 10 ];then\n                useradd -g class1 std0$i\n        else\n                useradd -g class1 std$i\n        fi\ndone\n```\n\n**编写 Shell 程序，实现自动删除 50 个账号的功能，账号名为stud1 至 stud50 ？**\n\n```bash\n#!/bin/bash\nfor((i=1;i<51;i++))\ndo\n                userdel -r stud$i\ndone\n```\n\n#### 写一个 sed 命令，修改 `/tmp/input.txt` 文件的内容？\n\n要求：\n\n- 删除所有空行。\n- 一行中，如果包含 “11111”，则在 “11111” 前面插入 “AAA”，在 “11111” 后面插入 “BBB” 。比如：将内容为 0000111112222 的一行改为 0000AAA11111BBB2222 。\n\n```bash\n[root@~]## cat -n /tmp/input.txt\n     1  000011111222\n     2\n     3  000011111222222\n     4  11111000000222\n     5\n     6\n     7  111111111111122222222222\n     8  2211111111\n     9  112222222\n    10  1122\n    11\n\n## 删除所有空行命令\n[root@~]## sed '/^$/d' /tmp/input.txt\n000011111222\n000011111222222\n11111000000222\n111111111111122222222222\n2211111111\n112222222\n1122\n\n## 插入指定的字符\n[root@~]## sed 's#\\(11111\\)#AAA\\1BBB#g' /tmp/input.txt\n0000AAA11111BBB222\n0000AAA11111BBB222222\nAAA11111BBB000000222\nAAA11111BBBAAA11111BBB11122222222222\n22AAA11111BBB111\n112222222\n1122\n```\n\n## 实战\n\n### 如何选择 Linux 操作系统版本?\n\n一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。\n\n根据具体要求：\n\n- 安全性要求较高，则选择 Debian 或者 FreeBSD 。\n\n- 需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。\n\n- 想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。\n\n- 【重点】**根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束**。\n\n\t> CentOS 7 系列，也慢慢使用的会比较多了。\n\n### 如何规划一台 Linux 主机，步骤是怎样？\n\n1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。\n\n> 不同的用途，机器的配置会有所不同。\n\n2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。\n\n3、需要优化系统的哪些参数，需要创建哪些用户等等的。\n\n### 请问当用户反馈网站访问慢，你会如何处理？\n\n**有哪些方面的因素会导致网站网站访问慢？**\n\n1、服务器出口带宽不够用\n\n> - 本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。\n> - 跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。\n\n2、服务器负载过大，导致响应不过来\n\n> 可以从两个方面入手分析：\n>\n> - 分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。\n> - 如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。\n\n3、数据库瓶颈\n\n> - 如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。\n> - 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。\n\n4、网站开发代码没有优化好\n\n> - 例如 SQL 语句没有优化，导致数据库读写相当耗时。\n\n**针对网站访问慢，怎么去排查？**\n\n1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。\n\n> 不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。\n\n2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。\n\n3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。\n\n4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL 慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。\n\n**怎么去解决？**\n\n1、如果是出口带宽问题，那么久申请加大出口带宽。\n\n2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。\n\n3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。\n\n4、申请购买 CDN 服务，加载用户的访问。\n\n5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。\n\n### Linux 性能调优都有哪几种方法？\n\n1、Disabling daemons (关闭 daemons)。\n\n2、Shutting down the GUI (关闭 GUI)。\n\n3、Changing kernel parameters (改变内核参数)。\n\n4、Kernel parameters (内核参数)。\n\n5、Tuning the processor subsystem (处理器子系统调优)。\n\n6、Tuning the memory subsystem (内存子系统调优)。\n\n7、Tuning the file system (文件系统子系统调优)。\n\n8、Tuning the network subsystem（网络子系统调优)。\n\n## 文件管理命令\n\n### cat 命令\n\ncat 命令用于连接文件并打印到标准输出设备上。\n\ncat 主要有三大功能：\n\n1、一次显示整个文件:\n\n```sh\ncat filename\n```\n\n2、从键盘创建一个文件:\n\n```shell\ncat > filename\n```\n\n只能创建新文件，不能编辑已有文件。\n\n3、将几个文件合并为一个文件：\n\n```shell\ncat file1 file2 > file\n```\n\n- -b 对非空输出行号\n- -n 输出所有行号\n\n**实例**：\n\n（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里\n\n```shell\ncat -n log2012.log > log2013.log\n```\n\n（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里\n\n```shell\ncat -b log2012.log log2013.log > log.log\n```\n\n### chmod 命令\n\nLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。\n\n用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。\n\n每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件**属主**的读、写和执行权限；与属主**同组**的用户的读、写和执行权限；系统中**其他用户**的读、写和执行权限。可使用 ls -l test.txt 查找。\n\n以文件 log2012.log 为例：\n\n```shell\n-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log\n```\n\n第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读(4)，w 代表写(2)，x 代表可执行(1)。\n\n**常用参数**：\n\n```\n-c 当发生改变时，报告处理信息\n-R 处理指定目录以及其子目录下所有文件\n```\n\n权限范围：\n\n```\nu ：目录或者文件的当前的用户\ng ：目录或者文件的当前的群组\no ：除了目录或者文件的当前用户或群组之外的用户或者群组\na ：所有的用户及群组\n```\n\n权限代号：\n\n```\nr ：读权限，用数字4表示\nw ：写权限，用数字2表示\nx ：执行权限，用数字1表示\n- ：删除权限，用数字0表示\ns ：特殊权限\n```\n\n**实例**：\n\n（1）增加文件 t.log 所有用户可执行权限\n\n```shell\nchmod a+x t.log\n```\n\n（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息\n\n```shell\nchmod u=r t.log -c\n```\n\n（3）给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限\n\n```shell\nchmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c\n```\n\n（4）将 test 目录及其子目录所有文件添加可读权限\n\n```shell\nchmod u+r,g+r,o+r -R text/ -c\n```\n\n### chown 命令\n\nchown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。\n\n```\n-c 显示更改的部分的信息\n-R 处理指定目录及子目录\n```\n\n**实例**：\n\n（1）改变拥有者和群组 并显示改变信息\n\n```shell\nchown -c mail:mail log2012.log\n```\n\n（2）改变文件群组\n\n```shell\nchown -c :mail t.log\n```\n\n（3）改变文件夹及子文件目录属主及属组为 mail\n\n```shell\nchown -cR mail: test/\n```\n\n### cp 命令\n\n将源文件复制至目标文件，或将多个源文件复制至目标目录。\n\n注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！\n\n```\n-i 提示\n-r 复制目录及目录内所有项目\n-a 复制的文件与原文件时间一样\n```\n\n**实例**：\n\n（1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。\n\n```shell\ncp -ai a.txt test\n```\n\n（2）为 a.txt 建议一个链接（快捷方式）\n\n```shell\ncp -s a.txt link_a.txt\n```\n\n### find 命令\n\n用于在文件树中查找文件，并作出相应的处理。\n\n命令格式：\n\n```shell\nfind pathname -options [-print -exec -ok ...]\n```\n\n命令参数：\n\n```\npathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。\n-print： find命令将匹配的文件输出到标准输出。\n-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \\;，注意{   }和\\；之间的空格。\n-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。\n```\n\n**命令选项**：\n\n```\n-name 按照文件名查找文件\n-perm 按文件权限查找文件\n-user 按文件属主查找文件\n-group  按照文件所属的组来查找文件。\n-type  查找某一类型的文件，诸如：\n   b - 块设备文件\n   d - 目录\n   c - 字符设备文件\n   l - 符号链接文件\n   p - 管道文件\n   f - 普通文件\n```\n\n**实例**：\n\n（1）查找 48 小时内修改过的文件\n\n```shell\nfind -atime -2\n```\n\n（2）在当前目录查找 以 .log 结尾的文件。 **.** 代表当前目录\n\n```shell\nfind ./ -name '*.log'\n```\n\n（3）查找 /opt 目录下 权限为 777 的文件\n\n```shell\nfind /opt -perm 777\n```\n\n（4）查找大于 1K 的文件\n\n```shell\nfind -size +1000c\n```\n\n查找等于 1000 字符的文件\n\n```shell\nfind -size 1000c \n```\n\n-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面 find 查找出来的文件名。\n\n### head 命令\n\nhead 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。\n\n**常用参数**：\n\n```\n-n<行数> 显示的行数（行数为复数表示从最后向前数）\n```\n\n**实例**：\n\n（1）显示 1.log 文件中前 20 行\n\n```shell\nhead 1.log -n 20\n```\n\n（2）显示 1.log 文件前 20 字节\n\n```shell\nhead 1.log -c 20 \n1\n```\n\n（3）显示 1.log 最后 10 行\n\n```shell\nhead 1.log -n -10\n```\n\n### less 命令\n\nless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n\n**常用命令参数**：\n\n```\n-i  忽略搜索时的大小写\n-N  显示每行的行号\n-o  <文件名> 将less 输出的内容在指定文件中保存起来\n-s  显示连续空行为一行\n/字符串：向下搜索“字符串”的功能\n?字符串：向上搜索“字符串”的功能\nn：重复前一个搜索（与 / 或 ? 有关）\nN：反向重复前一个搜索（与 / 或 ? 有关）\n-x <数字> 将“tab”键显示为规定的数字空格\nb  向后翻一页\nd  向后翻半页\nh  显示帮助界面\nQ  退出less 命令\nu  向前滚动半页\ny  向前滚动一行\n空格键 滚动一行\n回车键 滚动一页\n[pagedown]： 向下翻动一页\n[pageup]：   向上翻动一页\n```\n\n**实例**：\n\n（1）ps 查看进程信息并通过 less 分页显示\n\n```shell\nps -aux | less -N\n```\n\n（2）查看多个文件\n\n```shell\nless 1.log 2.log\n```\n\n可以使用 n 查看下一个，使用 p 查看前一个。\n\n### ln 命令\n\n功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。\n\n链接分类：软件链接及硬链接\n\n软链接：\n\n- 1.软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式\n- 2.软链接可以 跨文件系统 ，硬链接不可以\n- 3.软链接可以对一个不存在的文件名进行链接\n- 4.软链接可以对目录进行链接\n\n硬链接:\n\n- 1.硬链接，以文件副本的形式存在。但不占用实际空间。\n- 2.不允许给目录创建硬链接\n- 3.硬链接只有在同一个文件系统中才能创建\n\n**需要注意**：\n\n- 第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；\n- 第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。\n- 第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。\n\n**常用参数**：\n\n```\n-b 删除，覆盖以前建立的链接\n-s 软链接（符号链接）\n-v 显示详细处理过程\n```\n\n**实例**：\n\n（1）给文件创建软链接，并显示操作信息\n\n```shell\nln -sv source.log link.log\n```\n\n（2）给文件创建硬链接，并显示操作信息\n\n```shell\nln -v source.log link1.log\n```\n\n（3）给目录创建软链接\n\n```shell\nln -sv /opt/soft/test/test3 /opt/soft/test/test5\n```\n\n### locate 命令\n\nlocate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。\n\nlocate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找\n\n**常用参数**：\n\n```\n-l num（要显示的行数）\n-f   将特定的档案系统排除在外，如将proc排除在外\n-r   使用正则运算式做为寻找条件\n```\n\n**实例**：\n\n（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）\n\n```shell\nlocate pwd\n```\n\n（2）搜索 etc 目录下所有以 sh 开头的文件\n\n```shell\nlocate /etc/sh\n```\n\n（3）查找 /var 目录下，以 reason 结尾的文件\n\n```shell\nlocate -r '^/var.*reason$'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）\n```\n\n### more 命令\n\n功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。\n\n**命令参数**：\n\n```\n+n      从笫 n 行开始显示\n-n       定义屏幕大小为n行\n+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 \n-c       从顶部清屏，然后显示\n-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能\n-l        忽略Ctrl+l（换页）字符\n-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似\n-s       把连续的多个空行显示为一行\n-u       把文件内容中的下画线去掉\n```\n\n**常用操作命令**：\n\n```\nEnter    向下 n 行，需要定义。默认为 1 行\nCtrl+F   向下滚动一屏\n空格键  向下滚动一屏\nCtrl+B  返回上一屏\n=       输出当前行的行号\n:f     输出文件名和当前行的行号\nV      调用vi编辑器\n!命令   调用Shell，并执行命令\nq       退出more\n```\n\n**实例**：\n\n（1）显示文件中从第 3 行起的内容\n\n```shell\nmore +3 text.txt\n```\n\n（2）在所列出文件目录详细信息，借助管道使每次显示 5 行\n\n```shell\nls -l | more -5\n```\n\n按空格显示下 5 行。\n\n### mv 命令\n\n移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。\n\n当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。\n\n**实例**：\n\n（1）将文件 test.log 重命名为 test1.txt\n\n```shell\nmv test.log test1.txt\n```\n\n（2）将文件 log1.txt、log2.txt、log3.txt 移动到根的 test3 目录中\n\n```shell\nmv llog1.txt log2.txt log3.txt /test3\n```\n\n（3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖\n\n```shell\nmv -i log1.txt log2.txt\n```\n\n（4）移动当前文件夹下的所有文件到上一级目录\n\n```shell\nmv * ../\n```\n\n### rm 命令\n\n删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。\n\n```shell\nrm [选项] 文件…\n```\n\n**实例**：\n\n（1）删除任何 .log 文件，删除前逐一询问确认：\n\n```shell\nrm -i *.log\n```\n\n（2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认：\n\n```shell\nrm -rf test\n```\n\n（3）删除以 -f 开头的文件\n\n```shell\nrm -- -f*\n```\n\n### tail 命令\n\n用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。\n\n**常用参数**：\n\n```\n-f 循环读取（常用于查看递增的日志文件）\n-n<行数> 显示行数（从后向前）\n```\n\n（1）循环读取逐渐增加的文件内容\n\n```shell\nping 127.0.0.1 > ping.log &\n```\n\n后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。\n\n```shell\ntail -f ping.log\n```\n\n（查看日志）\n\n### touch 命令\n\nLinux touch 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\n\nls -l 可以显示档案的时间记录。\n\n**语法**\n\n```\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\n```\n\n- **参数说明**：\n- a 改变档案的读取时间记录。\n- m 改变档案的修改时间记录。\n- c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\n- f 不使用，是为了与其他 unix 系统的相容性而保留。\n- r 使用参考档的时间记录，与 --file 的效果一样。\n- d 设定时间与日期，可以使用各种不同的格式。\n- t 设定档案的时间记录，格式与 date 指令相同。\n- –no-create 不会建立新档案。\n- –help 列出指令格式。\n- –version 列出版本讯息。\n\n**实例**\n\n使用指令\"touch\"修改文件\"testfile\"的时间属性为当前系统时间，输入如下命令：\n\n```shell\n$ touch testfile                #修改文件的时间属性 \n```\n\n首先，使用 ls 命令查看 testfile 文件的属性，如下所示：\n\n```shell\n$ ls -l testfile                #查看文件的时间属性  \n#原来文件的修改时间为16:09  \n-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  \n```\n\n执行指令\"touch\"修改文件属性以后，并再次查看该文件的时间属性，如下所示：\n\n```shell\n$ touch testfile                #修改文件时间属性为当前系统时间  \n$ ls -l testfile                #查看文件的时间属性  \n#修改后文件的时间属性为当前系统时间  \n-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  \n```\n\n使用指令\"touch\"时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件\"file\"，输入如下命令：\n\n```shell\n$ touch file            #创建一个名为“file”的新的空白文件 \n```\n\n### vim 命令\n\nVim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\n- 打开文件并跳到第 10 行：`vim +10 filename.txt` 。\n- 打开文件跳到第一个匹配的行：`vim +/search-term filename.txt` 。\n- 以只读模式打开文件：`vim -R /etc/passwd` 。\n\n基本上 vi/vim 共分为三种模式，分别是**命令模式（Command mode）**，**输入模式（Insert mode）\\**和\\**底线命令模式（Last line mode）**。\n\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n\n![vim 工作模式](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806349.png)\n\n### whereis 命令\n\nwhereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。\n\n**常用参数**：\n\n```\n-b   定位可执行文件。\n-m   定位帮助文件。\n-s   定位源代码文件。\n-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。\n```\n\n**实例**：\n\n（1）查找 locate 程序相关文件\n\n```shell\nwhereis locate\n```\n\n（2）查找 locate 的源码文件\n\n```shell\nwhereis -s locate\n```\n\n（3）查找 lcoate 的帮助文件\n\n```shell\nwhereis -m locate\n```\n\n### which 命令\n\n在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：\n\n```\nwhich     查看可执行文件的位置。\nwhereis 查看文件的位置。\nlocate  配合数据库查看文件位置。\nfind        实际搜寻硬盘查询文件名称。\n```\n\nwhich 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n**常用参数**：\n\n```\n-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n```\n\n**实例**：\n\n（1）查看 ls 命令是否存在，执行哪个\n\n```shell\nwhich ls\n```\n\n（2）查看 which\n\n```shell\nwhich which\n```\n\n（3）查看 cd\n\n```shell\nwhich cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）\n```\n\n查看当前 PATH 配置：\n\n```shell\necho $PATH\n```\n\n或使用 env 查看所有环境变量及对应值\n\n## 文档编辑命令\n\n### grep 命令\n\n强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。\n\ngrep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。\n\n命令格式：\n\n```\ngrep [option] pattern file|dir\n```\n\n**常用参数**：\n\n```\n-A n --after-context显示匹配字符后n行\n-B n --before-context显示匹配字符前n行\n-C n --context 显示匹配字符前后n行\n-c --count 计算符合样式的列数\n-i 忽略大小写\n-l 只列出文件内容符合指定的样式的文件名称\n-f 从文件中读取关键词\n-n 显示匹配内容的所在文件中行数\n-R 递归查找文件夹\n```\n\ngrep 的规则表达式:\n\n```\n^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。 \n$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 \n.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。  \n*  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。\n.*   #一起用代表任意字符。  \n[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。 \n[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  \n\\(..\\)  #标记匹配字符，如'\\(love\\)'，love被标记为1。   \n\\<      #锚定单词的开始，如:'\\<grep'匹配包含以grep开头的单词的行。\n\\>      #锚定单词的结束，如'grep\\>'匹配包含以grep结尾的单词的行。\nx\\{m\\}  #重复字符x，m次，如：'0\\{5\\}'匹配包含5个o的行。 \nx\\{m,\\}  #重复字符x,至少m次，如：'o\\{5,\\}'匹配至少有5个o的行。  \nx\\{m,n\\}  #重复字符x，至少m次，不多于n次，如：'o\\{5,10\\}'匹配5--10个o的行。  \n\\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。  \n\\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  \n\\b    #单词锁定符，如: '\\bgrep\\b'只匹配grep。\n```\n\n**实例**：\n\n（1）查找指定进程\n\n```shell\nps -ef | grep svn\n```\n\n（2）查找指定进程个数\n\n```shell\nps -ef | grep svn -c\n```\n\n（3）从文件中读取关键词\n\n```shell\ncat test1.txt | grep -f key.log\n```\n\n（4）从文件夹中递归查找以 grep 开头的行，并只列出文件\n\n```shell\ngrep -lR '^grep' /tmp\n```\n\n（5）查找非 x 开关的行内容\n\n```shell\ngrep '^[^x]' test.txt\n```\n\n（6）显示包含 ed 或者 at 字符的内容行\n\n```shell\ngrep -E 'ed|at' test.txt\n```\n\n### wc 命令\n\nwc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出\n\n命令格式：\n\n```\nwc [option] file..\n```\n\n**命令参数**：\n\n```\n-c 统计字节数\n-l 统计行数\n-m 统计字符数\n-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串\n```\n\n**实例**：\n\n（1）查找文件的 行数 单词数 字节数 文件名\n\n```shell\nwc text.txt\n```\n\n结果：\n\n```shell\n7     8     70     test.txt\n```\n\n（2）统计输出结果的行数\n\n```shell\ncat test.txt | wc -l\n```\n\n## 磁盘管理命令\n\n### cd 命令\n\ncd(changeDirectory) 命令语法：\n\n```\ncd [目录名]\n```\n\n说明：切换当前目录至 dirName。\n\n**实例**：\n\n（1）进入要目录\n\n```shell\ncd /\n```\n\n（2）进入 “home” 目录\n\n```shell\ncd ~\n```\n\n（3）进入上一次工作路径\n\n```shell\ncd -\n```\n\n（4）把上个命令的参数作为 cd 参数使用。\n\n```shell\ncd !$\n```\n\n### df 命令\n\n显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示：\n\n```\n-a 全部文件系统列表\n-h 以方便阅读的方式显示信息\n-i 显示inode信息\n-k 区块为1024字节\n-l 只显示本地磁盘\n-T 列出文件系统类型\n```\n\n**实例**：\n\n（1）显示磁盘使用情况\n\n```shell\ndf -l\n```\n\n（2）以易读方式列出所有文件系统及其类型\n\n```shell\ndf -haT\n```\n\n### du 命令\n\ndu 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：\n\n命令格式：\n\n```\ndu [选项] [文件]\n1\n```\n\n**常用参数**：\n\n```\n-a 显示目录中所有文件大小\n-k 以KB为单位显示文件大小\n-m 以MB为单位显示文件大小\n-g 以GB为单位显示文件大小\n-h 以易读方式显示文件大小\n-s 仅显示总计\n-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和\n```\n\n**实例**：\n\n（1）以易读方式显示文件夹内及子文件夹大小\n\n```shell\ndu -h scf/\n```\n\n（2）以易读方式显示文件夹内所有文件大小\n\n```shell\ndu -ah scf/\n```\n\n（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和\n\n```shell\ndu -hc test/ scf/\n```\n\n（4）输出当前目录下各个子目录所使用的空间\n\n```shell\ndu -hc --max-depth=1 scf/\n```\n\n### ls命令\n\n就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。\n\n**常用参数搭配**：\n\n```\nls -a 列出目录所有文件，包含以.开始的隐藏文件\nls -A 列出除.及..的其它文件\nls -r 反序排列\nls -t 以文件修改时间排序\nls -S 以文件大小排序\nls -h 以易读大小显示\nls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来\n```\n\n**实例**：\n\n(1) 按易读方式按时间反序排序，并显示文件详细信息\n\n```shell\nls -lhrt\n```\n\n(2) 按大小反序显示文件详细信息\n\n```shell\nls -lrS\n```\n\n(3)列出当前目录中所有以\"t\"开头的目录的详细内容\n\n```shell\nls -l t*\n```\n\n(4) 列出文件绝对路径（不包含隐藏文件）\n\n```shell\nls | sed \"s:^:`pwd`/:\"\n```\n\n(5) 列出文件绝对路径（包含隐藏文件）\n\n```shell\nfind $pwd -maxdepth 1 | xargs ls -ld\n```\n\n### mkdir 命令\n\nmkdir 命令用于创建文件夹。\n\n可用选项：\n\n- **-m**: 对新建目录设置存取权限，也可以用 chmod 命令设置;\n- **-p**: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。\n\n**实例**：\n\n（1）当前工作目录下创建名为 t 的文件夹\n\n```shell\nmkdir t\n```\n\n（2）在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：\n\n```shell\nmkdir -p /tmp/test/t1/t\n```\n\n### pwd 命令\n\npwd 命令用于查看当前工作目录路径。\n\n**实例**：\n\n（1）查看当前路径\n\n```shell\npwd\n```\n\n（2）查看软链接的实际路径\n\n```shell\npwd -P\n```\n\n### rmdir 命令\n\n从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。\n\n**注意**：不能删除非空目录\n\n**实例**：\n\n（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：\n\n```shell\nrmdir -p parent/child/child11\n```\n\n## 网络通讯命令\n\n### ifconfig 命令\n\n- ifconfig 用于查看和配置 Linux 系统的网络接口。\n- 查看所有网络接口及其状态：`ifconfig -a` 。\n- 使用 up 和 down 命令启动或停止某个接口：`ifconfig eth0 up` 和 `ifconfig eth0 down` 。\n\n### iptables 命令\n\niptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：\n\n- 把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：`iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT` 。\n\n- 开启 80 端口，因为 web 对外都是这个端口\n\n\t```shell\n\tiptables -A INPUT -p tcp --dport 80 -j ACCEP\n\t```\n\n- 另外，要注意使用 `iptables save` 命令，进行保存。否则，服务器重启后，配置的规则将丢失。\n\n### netstat 命令\n\nLinux netstat 命令用于显示网络状态。\n\n利用 netstat 指令可让你得知整个 Linux 系统的网络情况。\n\n语法\n\n```\nnetstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]\n```\n\n**参数说明**：\n\n- -a 或–all 显示所有连线中的 Socket。\n- -A<网络类型>或–<网络类型> 列出该网络类型连线中的相关地址。\n- -c 或–continuous 持续列出网络状态。\n- -C 或–cache 显示路由器配置的快取信息。\n- -e 或–extend 显示网络其他相关信息。\n- -F 或–fib 显示 FIB。\n- -g 或–groups 显示多重广播功能群组组员名单。\n- -h 或–help 在线帮助。\n- -i 或–interfaces 显示网络界面信息表单。\n- -l 或–listening 显示监控中的服务器的 Socket。\n- -M 或–masquerade 显示伪装的网络连线。\n- -n 或–numeric 直接使用 IP 地址，而不通过域名服务器。\n- -N 或–netlink 或–symbolic 显示网络硬件外围设备的符号连接名称。\n- -o 或–timers 显示计时器。\n- -p 或–programs 显示正在使用 Socket 的程序识别码和程序名称。\n- -r 或–route 显示 Routing Table。\n- -s 或–statistice 显示网络工作信息统计表。\n- -t 或–tcp 显示 TCP 传输协议的连线状况。\n- -u 或–udp 显示 UDP 传输协议的连线状况。\n- -v 或–verbose 显示指令执行过程。\n- -V 或–version 显示版本信息。\n- -w 或–raw 显示 RAW 传输协议的连线状况。\n- -x 或–unix 此参数的效果和指定\"-A unix\"参数相同。\n- –ip 或–inet 此参数的效果和指定\"-A inet\"参数相同。\n\n**实例**\n\n**如何查看系统都开启了哪些端口？**\n\n```shell\n[root@centos6 ~ 13:20 #55]# netstat -lnp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name\ntcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      1035/sshd\ntcp        0      0 :::22                       :::*                        LISTEN      1035/sshd\nudp        0      0 0.0.0.0:68                  0.0.0.0:*                               931/dhclient\nActive UNIX domain sockets (only servers)\nProto RefCnt Flags       Type       State         I-Node PID/Program name    Path\nunix  2      [ ACC ]     STREAM     LISTENING     6825   1/init              @/com/ubuntu/upstart\nunix  2      [ ACC ]     STREAM     LISTENING     8429   1003/dbus-daemon    /var/run/dbus/system_bus_socket\n```\n\n**如何查看网络连接状况？**\n\n```shell\n[root@centos6 ~ 13:22 #58]# netstat -an\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address               Foreign Address             State\ntcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN\ntcp        0      0 192.168.147.130:22          192.168.147.1:23893         ESTABLISHED\ntcp        0      0 :::22                       :::*                        LISTEN\nudp        0      0 0.0.0.0:68                  0.0.0.0:*\n```\n\n**如何统计系统当前进程连接数？**\n\n- 输入命令 `netstat -an | grep ESTABLISHED | wc -l` 。\n- 输出结果 `177` 。一共有 177 连接数。\n\n**用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 ESTABLISHED 状态链接的个数？**\n\n> 严格来说，这个题目考验的是对 awk 的使用。\n\n首先，使用 `netstat -an|grep ESTABLISHED` 命令。结果如下：\n\n```shell\ntcp        0      0 120.27.146.122:80       113.65.18.33:62721      ESTABLISHED\ntcp        0      0 120.27.146.122:80       27.43.83.115:47148      ESTABLISHED\ntcp        0      0 120.27.146.122:58838    106.39.162.96:443       ESTABLISHED\ntcp        0      0 120.27.146.122:52304    203.208.40.121:443      ESTABLISHED\ntcp        0      0 120.27.146.122:33194    203.208.40.122:443      ESTABLISHED\ntcp        0      0 120.27.146.122:53758    101.37.183.144:443      ESTABLISHED\ntcp        0      0 120.27.146.122:27017    23.105.193.30:50556     ESTABLISHED\n```\n\n### ping 命令\n\nLinux ping 命令用于检测主机。\n\n执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。\n\n指定接收包的次数\n\n```shell\nping -c 2 www.baidu.com\n```\n\n### telnet 命令\n\nLinux telnet 命令用于远端登入。\n\n执行 telnet 指令开启终端机阶段作业，并登入远端主机。\n\n语法\n\n```\ntelnet [-8acdEfFKLrx][-b<主机别名>][-e<脱离字符>][-k<域名>][-l<用户名称>][-n<记录文件>][-S<服务类型>][-X<认证形态>][主机名称或IP地址<通信端口>]\n```\n\n**参数说明**：\n\n- -8 允许使用 8 位字符资料，包括输入与输出。\n- -a 尝试自动登入远端系统。\n- -b<主机别名> 使用别名指定远端主机名称。\n- -c 不读取用户专属目录里的.telnetrc 文件。\n- -d 启动排错模式。\n- -e<脱离字符> 设置脱离字符。\n- -E 滤除脱离字符。\n- -f 此参数的效果和指定\"-F\"参数相同。\n- -F 使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机。\n- -k<域名> 使用 Kerberos 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。\n- -K 不自动登入远端主机。\n- -l<用户名称> 指定要登入远端主机的用户名称。\n- -L 允许输出 8 位字符资料。\n- -n<记录文件> 指定文件记录相关信息。\n- -r 使用类似 rlogin 指令的用户界面。\n- -S<服务类型> 设置 telnet 连线所需的 IP TOS 信息。\n- -x 假设主机有支持数据加密的功能，就使用它。\n- -X<认证形态> 关闭指定的认证形态。\n\n**实例**\n\n登录远程主机\n\n```shell\n# 登录IP为 192.168.0.5 的远程主机\ntelnet 192.168.0.5 \n```\n\n## 系统管理命令\n\n### date 命令\n\n显示或设定系统的日期与时间。\n\n命令参数：\n\n```\n-d<字符串> 　显示字符串所指的日期与时间。字符串前后必须加上双引号。\n-s<字符串> 　根据字符串来设置日期与时间。字符串前后必须加上双引号。\n-u 　显示GMT。\n%H 小时(00-23)\n%I 小时(00-12)\n%M 分钟(以00-59来表示)\n%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。\n%S 秒(以本地的惯用法来表示)\n%a 星期的缩写。\n%A 星期的完整名称。\n%d 日期(以01-31来表示)。\n%D 日期(含年月日)。\n%m 月份(以01-12来表示)。\n%y 年份(以00-99来表示)。\n%Y 年份(以四位数来表示)。\n```\n\n**实例**：\n\n（1）显示下一天\n\n```shell\ndate +%Y%m%d --date=\"+1 day\"  //显示下一天的日期\n```\n\n（2）-d 参数使用\n\n```shell\ndate -d \"nov 22\"  今年的 11 月 22 日是星期三\ndate -d '2 weeks' 2周后的日期\ndate -d 'next monday' (下周一的日期)\ndate -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d\ndate -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d\ndate -d last-month +%Y%m(上个月是几月)\ndate -d next-month +%Y%m(下个月是几月)\n```\n\n### free 命令\n\n显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。\n\n**命令参数**：\n\n```\n-b 以Byte显示内存使用情况\n-k 以kb为单位显示内存使用情况\n-m 以mb为单位显示内存使用情况\n-g 以gb为单位显示内存使用情况\n-s<间隔秒数> 持续显示内存\n-t 显示内存使用总合\n```\n\n**实例**：\n\n（1）显示内存使用情况\n\n```shell\nfree\nfree -k\nfree -m\n```\n\n（2）以总和的形式显示内存的使用信息\n\n```shell\nfree -t\n```\n\n（3）周期性查询内存使用情况\n\n```shell\nfree -s 10\n```\n\n### kill 命令\n\n发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用\"-KILL\" 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。\n\n**常用参数**：\n\n```\n-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称\n-a  当处理当前进程时，不限制命令名和进程号的对应关系\n-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号\n-s  指定发送信号\n-u  指定用户\n```\n\n**实例**：\n\n（1）先使用 ps 查找进程 pro1，然后用 kill 杀掉\n\n```shell\nkill -9 $(ps -ef | grep pro1)\n```\n\n### ps 命令\n\nps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top\n\nlinux 上进程有 5 种状态:\n\n1. 运行(正在运行或在运行队列中等待)\n2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)\n3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)\n4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)\n5. 停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行)\n\nps 工具标识进程的 5 种状态码:\n\n```\nD 不可中断 uninterruptible sleep (usually IO)\nR 运行 runnable (on run queue)\nS 中断 sleeping\nT 停止 traced or stopped\nZ 僵死 a defunct (”zombie”) process\n```\n\n**命令参数**：\n\n```\n-A 显示所有进程\na 显示所有进程\n-a 显示同一终端下所有进程\nc 显示进程真实名称\ne 显示环境变量\nf 显示进程间的关系\nr 显示当前终端运行的进程\n-aux 显示所有包含其它使用的进程\n```\n\n**实例**：\n\n（1）显示当前所有进程环境变量及进程间关系\n\n```shell\nps -ef\n```\n\n（2）显示当前所有进程\n\n```shell\nps -A\n```\n\n（3）与 grep 联用查找某进程\n\n```shell\nps -aux | grep apache\n```\n\n（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码\n\n```shell\nps aux | grep '(cron|syslog)'\n```\n\n### rpm 命令\n\nLinux rpm 命令用于管理套件。\n\nrpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\n\n```shell\n# 查看系统自带jdk\nrpm -qa | grep jdk\n# 删除系统自带jdk\nrpm -e --nodeps 查看jdk显示的数据\n# 安装jdk\nrpm -ivh jdk-7u80-linux-x64.rpm\n```\n\n### top 命令\n\n显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等\n\n**常用参数**：\n\n```\n-c 显示完整的进程命令\n-s 保密模式\n-p <进程号> 指定进程显示\n-n <次数>循环显示次数\n```\n\n**实例**：\n\n```shell\ntop - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35\nTasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie\nCpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st\nMem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers\nSwap: 32764556k total,        0k used, 32764556k free,  3612636k cached\nPID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  \n28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  \n```\n\n前五行是当前系统情况整体的统计信息区。\n\n**第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下**：\n\n14:06:23 — 当前系统时间\n\nup 70 days, 16:44 — 系统已经运行了 70 天 16 小时 44 分钟（在这期间系统没有重启过的吆！）\n\n2 users — 当前有 2 个用户登录系统\n\nload average: 1.15, 1.42, 1.44 — load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。\n\nload average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。\n\n**第二行，Tasks — 任务（进程），具体信息说明如下**：\n\n系统现在共有 206 个进程，其中处于运行中的有 1 个，205 个在休眠（sleep），stoped 状态的有 0 个，zombie 状态（僵尸）的有 0 个。\n\n**第三行，cpu状态信息，具体属性说明如下**：\n\n```\n5.9%us — 用户空间占用CPU的百分比。\n3.4% sy — 内核空间占用CPU的百分比。\n0.0% ni — 改变过优先级的进程占用CPU的百分比\n90.4% id — 空闲CPU百分比\n0.0% wa — IO等待占用CPU的百分比\n0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比\n0.2% si — 软中断（Software Interrupts）占用CPU的百分比\n```\n\n**备注**：在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！\n\n第四行，内存状态，具体信息如下：\n\n```\n32949016k total — 物理内存总量（32GB）\n14411180k used — 使用中的内存总量（14GB）\n18537836k free — 空闲内存总量（18GB）\n169884k buffers — 缓存的内存量 （169M）\n```\n\n**第五行，swap交换分区信息，具体信息说明如下**：\n\n```\n32764556k total — 交换区总量（32GB）\n0k used — 使用的交换区总量（0K）\n32764556k free — 空闲交换区总量（32GB）\n3612636k cached — 缓冲的交换区总量（3.6GB）\n```\n\n**第六行，空行。**\n\n**第七行以下：各进程（任务）的状态监控，项目列信息说明如下**：\n\n```\nPID — 进程id\nUSER — 进程所有者\nPR — 进程优先级\nNI — nice值。负值表示高优先级，正值表示低优先级\nVIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nSHR — 共享内存大小，单位kb\nS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\n%CPU — 上次更新到现在的CPU时间占用百分比\n%MEM — 进程使用的物理内存百分比\nTIME+ — 进程使用的CPU时间总计，单位1/100秒\nCOMMAND — 进程名称（命令名/命令行）\n```\n\n**top 交互命令**\n\n```\nh 显示top交互命令帮助信息\nc 切换显示命令名称和完整命令行\nm 以内存使用率排序\nP 根据CPU使用百分比大小进行排序\nT 根据时间/累计时间进行排序\nW 将当前设置写入~/.toprc文件中\no或者O 改变显示项目的顺序\n```\n\n### yum 命令\n\nyum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。\n\n基於 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\nyum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\n\n- 1.列出所有可更新的软件清单命令：yum check-update\n- 2.更新所有软件命令：yum update\n- 3.仅安装指定的软件命令：yum install <package_name>\n- 4.仅更新指定的软件命令：yum update <package_name>\n- 5.列出所有可安裝的软件清单命令：yum list\n- 6.删除软件包命令：yum remove <package_name>\n- 7.查找软件包 命令：yum search\n- 8.清除缓存命令:\n\t- yum clean packages: 清除缓存目录下的软件包\n\t- yum clean headers: 清除缓存目录下的 headers\n\t- yum clean oldheaders: 清除缓存目录下旧的 headers\n\t- yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers\n\n**实例**\n\n安装 pam-devel\n\n```shell\n[root@www ~]# yum install pam-devel\n```\n\n## 备份压缩命令\n\n### bzip2 命令\n\n- 创建 `*.bz2` 压缩文件：`bzip2 test.txt` 。\n- 解压 `*.bz2` 文件：`bzip2 -d test.txt.bz2` 。\n\n### gzip 命令\n\n- 创建一个 `*.gz` 的压缩文件：`gzip test.txt` 。\n- 解压 `*.gz` 文件：`gzip -d test.txt.gz` 。\n- 显示压缩的比率：`gzip -l *.gz` 。\n\n### tar 命令\n\n用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。\n\n弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件\n\n**常用参数**：\n\n```\n-c 建立新的压缩文件\n-f 指定压缩文件\n-r 添加文件到已经压缩文件包中\n-u 添加改了和现有的文件到压缩包中\n-x 从压缩包中抽取文件\n-t 显示压缩文件中的内容\n-z 支持gzip压缩\n-j 支持bzip2压缩\n-Z 支持compress解压文件\n-v 显示操作过程\n```\n\n有关 gzip 及 bzip2 压缩:\n\n```\ngzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz\n          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz\n\nbz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2\n       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2\n```\n\n**实例**：\n\n（1）将文件全部打包成 tar 包\n\n```shell\ntar -cvf log.tar 1.log,2.log 或tar -cvf log.*\n```\n\n（2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩\n\n```shell\ntar -zcvf /tmp/etc.tar.gz /etc\n```\n\n（3）查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的）\n\n```shell\ntar -ztvf /tmp/etc.tar.gz\n```\n\n（4）要压缩打包 /home, /etc ，但不要 /home/dmtsai\n\n```shell\ntar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc\n```\n\n### unzip 命令\n\n- 解压 `*.zip` 文件：`unzip test.zip` 。\n- 查看 `*.zip` 文件的内容：`unzip -l jasper.zip` 。\n\n","slug":"Java八股文-Linux","published":1,"updated":"2023-01-29T11:59:41.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw323000kt9t80bu0aizt","content":"<blockquote>\n<p>整理的 Linux 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"Linux-概述\"><a href=\"#Linux-概述\" class=\"headerlink\" title=\"Linux 概述\"></a>Linux 概述</h2><h3 id=\"什么是Linux\"><a href=\"#什么是Linux\" class=\"headerlink\" title=\"什么是Linux\"></a>什么是Linux</h3><p>Linux 是一套<strong>免费使用和自由传播的类 Unix 操作系统</strong>，是一个基于 POSIX 和 Unix 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>\n<h3 id=\"Unix和Linux有什么区别？\"><a href=\"#Unix和Linux有什么区别？\" class=\"headerlink\" title=\"Unix和Linux有什么区别？\"></a>Unix和Linux有什么区别？</h3><p>Linux 和 Unix 都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为 Unix 和 Linux 操作系统是一样的，然而，事实并非如此，以下是两者的区别。</p>\n<ol>\n<li>开源性<br> Linux 是一款开源操作系统，不需要付费，即可使用；Unix 是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。</li>\n<li>跨平台性<br> Linux 操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix 操作系统跨平台性能较弱，大多需与硬件配套使用。</li>\n<li>可视化界面<br> Linux 除了进行命令行操作，还有窗体管理系统；Unix 只是命令行下的系统。</li>\n<li>硬件环境<br> Linux 操作系统对硬件的要求较低，安装方法更易掌握；Unix 对硬件要求比较苛刻，按照难度较大。</li>\n<li>用户群体<br> Linux 的用户群体很广泛，个人和企业均可使用；Unix 的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者 Unix 硬件厂商使用，如 Sun 等。<br> 相比于 Unix 操作系统，Linux 操作系统更受广大计算机爱好者的喜爱，主要原因是 Linux 操作系统具有 Unix 操作系统的全部功能，并且能够在普通 PC 计算机上实现全部的 Unix 特性，开源免费的特性，更容易普及使用！</li>\n</ol>\n<h3 id=\"什么是-Linux-内核？\"><a href=\"#什么是-Linux-内核？\" class=\"headerlink\" title=\"什么是 Linux 内核？\"></a>什么是 Linux 内核？</h3><p>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。</p>\n<ol>\n<li>系统内存管理</li>\n<li>应用程序管理</li>\n<li>硬件设备管理</li>\n<li>文件系统管理</li>\n</ol>\n<h3 id=\"Linux的基本组件是什么？\"><a href=\"#Linux的基本组件是什么？\" class=\"headerlink\" title=\"Linux的基本组件是什么？\"></a>Linux的基本组件是什么？</h3><p>就像任何其他典型的操作系统一样，Linux 拥有所有这些组件：内核，shell 和 GUI，系统实用程序和应用程序。Linux 比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。</p>\n<h3 id=\"Linux-的体系结构\"><a href=\"#Linux-的体系结构\" class=\"headerlink\" title=\"Linux 的体系结构\"></a>Linux 的体系结构</h3><p>从大的方面讲，Linux 体系结构可以分为两块：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70.png\" alt=\"Linux 体系结构\"></p>\n<ul>\n<li>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</li>\n<li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</li>\n</ul>\n<p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p>\n<ol>\n<li>现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。</li>\n<li>Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</li>\n</ol>\n<p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成用户空间到内核空间的转移：</p>\n<p>1）系统调用；2）硬件中断。</p>\n<h3 id=\"BASH和DOS之间的基本区别是什么？\"><a href=\"#BASH和DOS之间的基本区别是什么？\" class=\"headerlink\" title=\"BASH和DOS之间的基本区别是什么？\"></a>BASH和DOS之间的基本区别是什么？</h3><p>BASH 和 DOS 控制台之间的主要区别在于 3 个方面：</p>\n<ul>\n<li>BASH 命令区分大小写，而 DOS 命令则不区分；</li>\n<li>在 BASH 下，&#x2F; character 是目录分隔符，\\作为转义字符。在 DOS 下，&#x2F;用作命令参数分隔符，\\是目录分隔符；</li>\n<li>DOS 遵循命名文件中的约定，即 8 个字符的文件名后跟一个点，扩展名为 3 个字符。BASH 没有遵循这样的惯例。</li>\n</ul>\n<h3 id=\"Linux-开机启动过程？\"><a href=\"#Linux-开机启动过程？\" class=\"headerlink\" title=\"Linux 开机启动过程？\"></a>Linux 开机启动过程？</h3><blockquote>\n<p>了解即可。</p>\n</blockquote>\n<p>1、主机加电自检，加载 BIOS 硬件信息。</p>\n<p>2、读取 MBR 的引导文件(GRUB、LILO)。</p>\n<p>3、引导 Linux 内核。</p>\n<p>4、运行第一个进程 init (进程号永远为 1 )。</p>\n<p>5、进入相应的运行级别。</p>\n<p>6、运行终端，输入用户名和密码。</p>\n<h3 id=\"Linux系统缺省的运行级别？\"><a href=\"#Linux系统缺省的运行级别？\" class=\"headerlink\" title=\"Linux系统缺省的运行级别？\"></a>Linux系统缺省的运行级别？</h3><ul>\n<li>关机。</li>\n<li>单机用户模式。</li>\n<li>字符界面的多用户模式(不支持网络)。</li>\n<li>字符界面的多用户模式。</li>\n<li>未分配使用。</li>\n<li>图形界面的多用户模式。</li>\n<li>重启。</li>\n</ul>\n<h3 id=\"Linux-使用的进程间通信方式？\"><a href=\"#Linux-使用的进程间通信方式？\" class=\"headerlink\" title=\"Linux 使用的进程间通信方式？\"></a>Linux 使用的进程间通信方式？</h3><blockquote>\n<p>了解即可，不需要太深入。</p>\n</blockquote>\n<ul>\n<li>管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li>\n<li>信号(signal) 。</li>\n<li>消息队列。</li>\n<li>共享内存。</li>\n<li>信号量。</li>\n<li>套接字(socket) 。</li>\n</ul>\n<h3 id=\"Linux-有哪些系统日志文件？\"><a href=\"#Linux-有哪些系统日志文件？\" class=\"headerlink\" title=\"Linux 有哪些系统日志文件？\"></a>Linux 有哪些系统日志文件？</h3><p>比较重要的是 <code>/var/log/messages</code> 日志文件。</p>\n<p>该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。</p>\n<h3 id=\"什么是交换空间？\"><a href=\"#什么是交换空间？\" class=\"headerlink\" title=\"什么是交换空间？\"></a>什么是交换空间？</h3><p>交换空间是 Linux 使用的一定空间，用于临时保存一些并发运行的程序。当 RAM 没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</p>\n<h3 id=\"什么是root帐户\"><a href=\"#什么是root帐户\" class=\"headerlink\" title=\"什么是root帐户\"></a>什么是root帐户</h3><p>root 帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装 Linux 时都是默认帐户。</p>\n<h3 id=\"什么是LILO？\"><a href=\"#什么是LILO？\" class=\"headerlink\" title=\"什么是LILO？\"></a>什么是LILO？</h3><p>LILO 是 Linux 的引导加载程序。它主要用于将 Linux 操作系统加载到主内存中，以便它可以开始运行。</p>\n<h3 id=\"什么是BASH？\"><a href=\"#什么是BASH？\" class=\"headerlink\" title=\"什么是BASH？\"></a>什么是BASH？</h3><p>BASH 是 Bourne Again SHell 的缩写。它由 Steve Bourne 编写，作为原始 Bourne Shell（由&#x2F; bin &#x2F; sh 表示）的替代品。它结合了原始版本的 Bourne Shell 的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行 Linux 的大多数系统的默认 shell。</p>\n<h3 id=\"什么是CLI？\"><a href=\"#什么是CLI？\" class=\"headerlink\" title=\"什么是CLI？\"></a>什么是CLI？</h3><p><strong>命令行界面</strong>（英语<strong>：command-line interface</strong>，缩写]<strong>：CLI</strong>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为<strong>字符用户界面</strong>（CUI）。</p>\n<p>通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。</p>\n<h3 id=\"什么是GUI？\"><a href=\"#什么是GUI？\" class=\"headerlink\" title=\"什么是GUI？\"></a>什么是GUI？</h3><p>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</p>\n<p>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</p>\n<h3 id=\"开源的优势是什么？\"><a href=\"#开源的优势是什么？\" class=\"headerlink\" title=\"开源的优势是什么？\"></a>开源的优势是什么？</h3><p>开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。</p>\n<h3 id=\"GNU项目的重要性是什么？\"><a href=\"#GNU项目的重要性是什么？\" class=\"headerlink\" title=\"GNU项目的重要性是什么？\"></a>GNU项目的重要性是什么？</h3><p>这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。</p>\n<h2 id=\"磁盘、目录、文件\"><a href=\"#磁盘、目录、文件\" class=\"headerlink\" title=\"磁盘、目录、文件\"></a>磁盘、目录、文件</h2><h3 id=\"简单-Linux-文件系统？\"><a href=\"#简单-Linux-文件系统？\" class=\"headerlink\" title=\"简单 Linux 文件系统？\"></a>简单 Linux 文件系统？</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p>\n<p>也就是说在 Linux 系统中有一个重要的概念<strong>：一切都是文件</strong>。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就<strong>可以用读写文件的方式实现对硬件的访问</strong>。</p>\n<p>Linux 支持 5 种文件类型，如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png.png\" alt=\"5 种文件类型\"></p>\n<h3 id=\"Linux-的目录结构是怎样的？\"><a href=\"#Linux-的目录结构是怎样的？\" class=\"headerlink\" title=\"Linux 的目录结构是怎样的？\"></a>Linux 的目录结构是怎样的？</h3><blockquote>\n<p>这个问题，一般不会问。更多是实际使用时，需要知道。</p>\n</blockquote>\n<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806288.png\" alt=\"Linux 的目录结构\"></p>\n<p><strong>常见目录说明</strong>：</p>\n<ul>\n<li><strong>&#x2F;bin</strong>： 存放二进制可执行文件(ls,cat,mkdir 等)，常用命令一般都在这里；</li>\n<li><strong>&#x2F;etc</strong>： 存放系统管理和配置文件；</li>\n<li><strong>&#x2F;home</strong>： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li>\n<li>**&#x2F;usr **： 用于存放系统应用程序；</li>\n<li><strong>&#x2F;opt</strong>： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>\n<li><strong>&#x2F;proc</strong>： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>\n<li><strong>&#x2F;root</strong>： 超级用户（系统管理员）的主目录（特权阶级 o）；</li>\n<li><strong>&#x2F;sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>\n<li><strong>&#x2F;dev</strong>： 用于存放设备文件；</li>\n<li><strong>&#x2F;mnt</strong>： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>\n<li><strong>&#x2F;boot</strong>： 存放用于系统引导时使用的各种文件；</li>\n<li>**&#x2F;lib **： 存放着和系统运行相关的库文件 ；</li>\n<li><strong>&#x2F;tmp</strong>： 用于存放各种临时文件，是公用的临时文件存储点；</li>\n<li><strong>&#x2F;var</strong>： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>\n<li><strong>&#x2F;lost+found</strong>： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>\n</ul>\n<h3 id=\"什么是-inode-？\"><a href=\"#什么是-inode-？\" class=\"headerlink\" title=\"什么是 inode ？\"></a>什么是 inode ？</h3><blockquote>\n<p>一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix&#x2F;Linux 文件系统和硬盘储存的基础。</p>\n</blockquote>\n<p>理解 inode，要从文件储存说起。</p>\n<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存 512 字节（相当于 0.5KB）。</p>\n<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。</p>\n<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做 inode，中文译名为”索引节点”。</p>\n<p>每一个文件都有对应的 inode，里面包含了与该文件有关的一些信息。</p>\n<p><strong>简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？</strong></p>\n<blockquote>\n<p>如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。</p>\n</blockquote>\n<p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p>\n<ul>\n<li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li>\n<li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li>\n</ul>\n<h3 id=\"什么是硬链接和软链接？\"><a href=\"#什么是硬链接和软链接？\" class=\"headerlink\" title=\"什么是硬链接和软链接？\"></a>什么是硬链接和软链接？</h3><p>1）硬链接</p>\n<p>由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。</p>\n<ul>\n<li>不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。</li>\n</ul>\n<p>2）软链接</p>\n<p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p>\n<ul>\n<li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li>\n</ul>\n<p><strong>实际场景下，基本是使用软链接</strong>。总结区别如下：</p>\n<ul>\n<li>硬链接不可以跨分区，软件链可以跨分区。</li>\n<li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li>\n<li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li>\n</ul>\n<h3 id=\"RAID-是什么\"><a href=\"#RAID-是什么\" class=\"headerlink\" title=\"RAID 是什么?\"></a>RAID 是什么?</h3><blockquote>\n<p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p>\n<p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p>\n</blockquote>\n<p>当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><h3 id=\"一台-Linux-系统初始化环境后需要做一些什么安全工作？\"><a href=\"#一台-Linux-系统初始化环境后需要做一些什么安全工作？\" class=\"headerlink\" title=\"一台 Linux 系统初始化环境后需要做一些什么安全工作？\"></a>一台 Linux 系统初始化环境后需要做一些什么安全工作？</h3><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p>\n<blockquote>\n<p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p>\n</blockquote>\n<p>2、服务器使用密钥登陆，禁止密码登陆。</p>\n<p>3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p>\n<p>4、装 fail2ban 这种防止 SSH 暴力破击的软件。</p>\n<p>5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p>\n<blockquote>\n<p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p>\n</blockquote>\n<p>6、修改历史命令记录的条数为 10 条。</p>\n<p>7、只允许有需要的服务器可以访问外网，其它全部禁止。</p>\n<p>8、做好软件层面的防护。</p>\n<ul>\n<li>8.1 设置 nginx_waf 模块防止 SQL 注入。</li>\n<li>8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</li>\n</ul>\n<h3 id=\"什么叫-CC-攻击？什么叫-DDOS-攻击？\"><a href=\"#什么叫-CC-攻击？什么叫-DDOS-攻击？\" class=\"headerlink\" title=\"什么叫 CC 攻击？什么叫 DDOS 攻击？\"></a>什么叫 CC 攻击？什么叫 DDOS 攻击？</h3><ul>\n<li><p>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</p>\n</li>\n<li><p>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</p>\n<blockquote>\n<p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>怎么预防 CC 攻击和 DDOS 攻击？</strong></p>\n<p>防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p>\n<blockquote>\n<p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p>\n</blockquote>\n<h3 id=\"什么是网站数据库注入？\"><a href=\"#什么是网站数据库注入？\" class=\"headerlink\" title=\"什么是网站数据库注入？\"></a>什么是网站数据库注入？</h3><ul>\n<li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li>\n<li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li>\n<li>SQL 注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li>\n</ul>\n<p><strong>如何过滤与预防？</strong></p>\n<p>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</p>\n<h2 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h2><h3 id=\"Shell-脚本是什么？\"><a href=\"#Shell-脚本是什么？\" class=\"headerlink\" title=\"Shell 脚本是什么？\"></a>Shell 脚本是什么？</h3><p>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</p>\n<p><strong>什么是默认登录 Shell ？</strong></p>\n<p>在 Linux 操作系统，<code>&quot;/bin/bash&quot;</code> 是默认登录 Shell，是在创建用户时分配的。</p>\n<p>使用 chsh 命令可以改变默认的 Shell 。示例如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh &lt;用户名&gt; -s &lt;新shell&gt;</span><br><span class=\"line\">chsh ThinkWon -s /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Shell 脚本中，如何写入注释？</strong></p>\n<p>注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 <code>#</code> 开头。例子如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># This is a command</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> “I am logged <span class=\"keyword\">in</span> as <span class=\"variable\">$USER</span>”</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法级\"><a href=\"#语法级\" class=\"headerlink\" title=\"语法级\"></a>语法级</h3><h4 id=\"可以在-Shell-脚本中使用哪些类型的变量？\"><a href=\"#可以在-Shell-脚本中使用哪些类型的变量？\" class=\"headerlink\" title=\"可以在 Shell 脚本中使用哪些类型的变量？\"></a>可以在 Shell 脚本中使用哪些类型的变量？</h4><p>在 Shell 脚本，我们可以使用两种类型的变量：</p>\n<ul>\n<li><p>系统定义变量</p>\n<blockquote>\n<p>系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 <code>set</code> 命令查看。</p>\n</blockquote>\n</li>\n<li><p>用户定义变量</p>\n<blockquote>\n<p>用户变量由系统用户来生成和定义，变量的值可以通过命令 <code>&quot;echo $&lt;变量名&gt;&quot;</code> 查看。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>Shell脚本中 $? 标记的用途是什么？</strong></p>\n<p>在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 <code>if</code> 条件中使用 <code>$?</code> 可以来检查前一命令的结束状态。</p>\n<ul>\n<li><p>如果结束状态是 0 ，说明前一个命令执行成功。例如：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@localhost:~<span class=\"comment\">## ls /usr/bin/shar</span></span><br><span class=\"line\">/usr/bin/shar</span><br><span class=\"line\">root@localhost:~<span class=\"comment\">## echo $?</span></span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果结束状态不是 0，说明命令执行失败。例如：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@localhost:~<span class=\"comment\">## ls /usr/bin/share</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span>: cannot access /usr/bin/share: No such file or directory</span><br><span class=\"line\">root@localhost:~<span class=\"comment\">## echo $?</span></span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>Bourne Shell(bash) 中有哪些特殊的变量？</strong></p>\n<p>下面的表列出了 Bourne Shell 为命令行设置的特殊变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内建变量    解释</span><br><span class=\"line\"><span class=\"variable\">$0</span>    命令行中的脚本名字</span><br><span class=\"line\"><span class=\"variable\">$1</span>    第一个命令行参数</span><br><span class=\"line\"><span class=\"variable\">$2</span>    第二个命令行参数</span><br><span class=\"line\">…..    …….</span><br><span class=\"line\"><span class=\"variable\">$9</span>    第九个命令行参数</span><br><span class=\"line\"><span class=\"variable\">$#</span><span class=\"comment\">#    命令行参数的数量</span></span><br><span class=\"line\">$*    所有命令行参数，以空格隔开</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何取消变量或取消变量赋值？</strong></p>\n<p><code>unset</code> 命令用于取消变量或取消变量赋值。语法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## unset &lt;变量名&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-if-语法如何嵌套\"><a href=\"#Shell-脚本中-if-语法如何嵌套\" class=\"headerlink\" title=\"Shell 脚本中 if 语法如何嵌套?\"></a>Shell 脚本中 <code>if</code> 语法如何嵌套?</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ 条件 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">…..</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ 条件 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">….</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">…..</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Shell 脚本中如何比较两个数字？</strong></p>\n<p>在 <code>if-then</code> 中使用测试命令（ <code>-gt</code> 等）来比较两个数字。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">x=10</span><br><span class=\"line\">y=20</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$x</span> -gt <span class=\"variable\">$y</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> “x is greater than y”</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> “y is greater than x”</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-case-语句的语法\"><a href=\"#Shell-脚本中-case-语句的语法\" class=\"headerlink\" title=\"Shell 脚本中 case 语句的语法?\"></a>Shell 脚本中 <code>case</code> 语句的语法?</h4><p>基础语法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> 变量 <span class=\"keyword\">in</span></span><br><span class=\"line\">值1)</span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">…..</span><br><span class=\"line\">最后命令</span><br><span class=\"line\">!!</span><br><span class=\"line\">值2)</span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">……</span><br><span class=\"line\">最后命令</span><br><span class=\"line\">;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-for-循环语法？\"><a href=\"#Shell-脚本中-for-循环语法？\" class=\"headerlink\" title=\"Shell 脚本中 for 循环语法？\"></a>Shell 脚本中 <code>for</code> 循环语法？</h4><p>基础语法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 变量 <span class=\"keyword\">in</span> 循环列表</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">….</span><br><span class=\"line\">最后命令</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-while-循环语法？\"><a href=\"#Shell-脚本中-while-循环语法？\" class=\"headerlink\" title=\"Shell 脚本中 while 循环语法？\"></a>Shell 脚本中 <code>while</code> 循环语法？</h4><p>如同 <code>for</code> 循环，<code>while</code> 循环只要条件成立就重复它的命令块。<br>不同于 <code>for</code>循环，<code>while</code> 循环会不断迭代，直到它的条件不为真。</p>\n<p>基础语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> [ 条件 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">命令…</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>do-while 语句的基本格式？</strong></p>\n<p><code>do-while</code> 语句类似于 <code>while</code> 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 <code>do-while</code> 语句的语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">命令</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (条件)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Shell 脚本中 break 命令的作用？</strong></p>\n<p><code>break</code> 命令一个简单的用途是退出执行中的循环。我们可以在 <code>while</code> 和 <code>until</code> 循环中使用 <code>break</code> 命令跳出循环。</p>\n<p><strong>Shell 脚本中 continue 命令的作用？</strong></p>\n<p><code>continue</code> 命令不同于 <code>break</code> 命令，它只跳出当前循环的迭代，而不是整个循环。<code>continue</code> 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p>\n<h4 id=\"如何使脚本可执行\"><a href=\"#如何使脚本可执行\" class=\"headerlink\" title=\"如何使脚本可执行?\"></a>如何使脚本可执行?</h4><p>使用 chmod 命令来使脚本可执行。例子如下：<code>chmod a+x myscript.sh</code> 。</p>\n<p><strong>#!&#x2F;bin&#x2F;bash 的作用？</strong></p>\n<p><code>#!/bin/bash</code> 是 Shell 脚本的第一行，称为释伴（shebang）行。</p>\n<ul>\n<li>这里 <code>#</code> 符号叫做 hash ，而 <code>!</code> 叫做 bang。</li>\n<li>它的意思是命令通过 <code>/bin/bash</code> 来执行。</li>\n</ul>\n<p><strong>如何调试 Shell脚本？</strong></p>\n<ul>\n<li>使用 <code>-x&#39;</code> 数（<code>sh -x myscript.sh</code>）可以调试 Shell 脚本。</li>\n<li>另一个种方法是使用 <code>-nv</code> 参数(<code>sh -nv myscript.sh</code>)。</li>\n</ul>\n<p><strong>如何将标准输出和错误输出同时重定向到同一位置?</strong></p>\n<ul>\n<li>方法一：<code>2&gt;&amp;1 (如## ls /usr/share/doc &gt; out.txt 2&gt;&amp;1 )</code> 。</li>\n<li>方法二：<code>&amp;&gt; (如## ls /usr/share/doc &amp;&gt; out.txt )</code> 。</li>\n</ul>\n<p><strong>在 Shell 脚本中，如何测试文件？</strong></p>\n<p>test 命令可以用来测试文件。基础用法如下表格：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test         用法</span><br><span class=\"line\">-d 文件名    如果文件存在并且是目录，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-e 文件名    如果文件存在，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-f 文件名    如果文件存在并且是普通文件，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-r 文件名    如果文件存在并可读，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-s 文件名    如果文件存在并且不为空，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-w 文件名    如果文件存在并可写，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-x 文件名    如果文件存在并可执行，返回<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在-Shell-脚本如何定义函数呢？\"><a href=\"#在-Shell-脚本如何定义函数呢？\" class=\"headerlink\" title=\"在 Shell 脚本如何定义函数呢？\"></a>在 Shell 脚本如何定义函数呢？</h4><p>函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"function\"><span class=\"title\">diskusage</span></span> () &#123; <span class=\"built_in\">df</span> -h ; &#125;</span><br><span class=\"line\">译注：下面是我给的shell函数语法，原文没有</span><br><span class=\"line\">[ <span class=\"keyword\">function</span> ] 函数名 [()]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">命令;</span><br><span class=\"line\">[<span class=\"built_in\">return</span> int;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何让 Shell 就脚本得到来自终端的输入?</strong></p>\n<p>read 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## vi /tmp/test.sh</span></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> ‘Please enter your name’</span><br><span class=\"line\"><span class=\"built_in\">read</span> name</span><br><span class=\"line\"><span class=\"built_in\">echo</span> “My Name is <span class=\"variable\">$name</span>”</span><br><span class=\"line\"><span class=\"comment\">## ./test.sh</span></span><br><span class=\"line\">Please enter your name</span><br><span class=\"line\">ThinkWon</span><br><span class=\"line\">My Name is ThinkWon</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何执行算术运算？</strong></p>\n<p>有两种方法来执行算术运算：</p>\n<ul>\n<li>1、使用 expr 命令：<code>## expr 5 + 2</code> 。</li>\n<li>2、用一个美元符号和方括号（<code>$[ 表达式 ]</code>）：<code>test=$[16 + 4] ; test=$[16 + 4]</code> 。</li>\n</ul>\n<h3 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h3><h4 id=\"判断一文件是不是字符设备文件，如果是将其拷贝到-dev-目录下？\"><a href=\"#判断一文件是不是字符设备文件，如果是将其拷贝到-dev-目录下？\" class=\"headerlink\" title=\"判断一文件是不是字符设备文件，如果是将其拷贝到 /dev 目录下？\"></a>判断一文件是不是字符设备文件，如果是将其拷贝到 <code>/dev</code> 目录下？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Input file name: &quot;</span> FILENAME</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -c <span class=\"string\">&quot;<span class=\"variable\">$FILENAME</span>&quot;</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">　　<span class=\"built_in\">cp</span> <span class=\"variable\">$FILENAME</span> /dev</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加一个新组为-class1-，然后添加属于这个组的-30-个用户，用户名的形式为-stdxx-，其中-xx-从-01-到-30-？\"><a href=\"#添加一个新组为-class1-，然后添加属于这个组的-30-个用户，用户名的形式为-stdxx-，其中-xx-从-01-到-30-？\" class=\"headerlink\" title=\"添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？\"></a>添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">groupadd class1</span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">31</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ <span class=\"variable\">$i</span> -le 10 ];<span class=\"keyword\">then</span></span><br><span class=\"line\">                useradd -g class1 std0<span class=\"variable\">$i</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                useradd -g class1 std<span class=\"variable\">$i</span></span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>编写 Shell 程序，实现自动删除 50 个账号的功能，账号名为stud1 至 stud50 ？</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">51</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                userdel -r stud<span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"写一个-sed-命令，修改-tmp-input-txt-文件的内容？\"><a href=\"#写一个-sed-命令，修改-tmp-input-txt-文件的内容？\" class=\"headerlink\" title=\"写一个 sed 命令，修改 /tmp/input.txt 文件的内容？\"></a>写一个 sed 命令，修改 <code>/tmp/input.txt</code> 文件的内容？</h4><p>要求：</p>\n<ul>\n<li>删除所有空行。</li>\n<li>一行中，如果包含 “11111”，则在 “11111” 前面插入 “AAA”，在 “11111” 后面插入 “BBB” 。比如：将内容为 0000111112222 的一行改为 0000AAA11111BBB2222 。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@~]<span class=\"comment\">## cat -n /tmp/input.txt</span></span><br><span class=\"line\">     1  000011111222</span><br><span class=\"line\">     2</span><br><span class=\"line\">     3  000011111222222</span><br><span class=\"line\">     4  11111000000222</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">     7  111111111111122222222222</span><br><span class=\"line\">     8  2211111111</span><br><span class=\"line\">     9  112222222</span><br><span class=\"line\">    10  1122</span><br><span class=\"line\">    11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 删除所有空行命令</span></span><br><span class=\"line\">[root@~]<span class=\"comment\">## sed &#x27;/^$/d&#x27; /tmp/input.txt</span></span><br><span class=\"line\">000011111222</span><br><span class=\"line\">000011111222222</span><br><span class=\"line\">11111000000222</span><br><span class=\"line\">111111111111122222222222</span><br><span class=\"line\">2211111111</span><br><span class=\"line\">112222222</span><br><span class=\"line\">1122</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 插入指定的字符</span></span><br><span class=\"line\">[root@~]<span class=\"comment\">## sed &#x27;s#\\(11111\\)#AAA\\1BBB#g&#x27; /tmp/input.txt</span></span><br><span class=\"line\">0000AAA11111BBB222</span><br><span class=\"line\">0000AAA11111BBB222222</span><br><span class=\"line\">AAA11111BBB000000222</span><br><span class=\"line\">AAA11111BBBAAA11111BBB11122222222222</span><br><span class=\"line\">22AAA11111BBB111</span><br><span class=\"line\">112222222</span><br><span class=\"line\">1122</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"如何选择-Linux-操作系统版本\"><a href=\"#如何选择-Linux-操作系统版本\" class=\"headerlink\" title=\"如何选择 Linux 操作系统版本?\"></a>如何选择 Linux 操作系统版本?</h3><p>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</p>\n<p>根据具体要求：</p>\n<ul>\n<li><p>安全性要求较高，则选择 Debian 或者 FreeBSD 。</p>\n</li>\n<li><p>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</p>\n</li>\n<li><p>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</p>\n</li>\n<li><p>【重点】<strong>根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束</strong>。</p>\n<blockquote>\n<p>CentOS 7 系列，也慢慢使用的会比较多了。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"如何规划一台-Linux-主机，步骤是怎样？\"><a href=\"#如何规划一台-Linux-主机，步骤是怎样？\" class=\"headerlink\" title=\"如何规划一台 Linux 主机，步骤是怎样？\"></a>如何规划一台 Linux 主机，步骤是怎样？</h3><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p>\n<blockquote>\n<p>不同的用途，机器的配置会有所不同。</p>\n</blockquote>\n<p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</p>\n<p>3、需要优化系统的哪些参数，需要创建哪些用户等等的。</p>\n<h3 id=\"请问当用户反馈网站访问慢，你会如何处理？\"><a href=\"#请问当用户反馈网站访问慢，你会如何处理？\" class=\"headerlink\" title=\"请问当用户反馈网站访问慢，你会如何处理？\"></a>请问当用户反馈网站访问慢，你会如何处理？</h3><p><strong>有哪些方面的因素会导致网站网站访问慢？</strong></p>\n<p>1、服务器出口带宽不够用</p>\n<blockquote>\n<ul>\n<li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li>\n<li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li>\n</ul>\n</blockquote>\n<p>2、服务器负载过大，导致响应不过来</p>\n<blockquote>\n<p>可以从两个方面入手分析：</p>\n<ul>\n<li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li>\n<li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li>\n</ul>\n</blockquote>\n<p>3、数据库瓶颈</p>\n<blockquote>\n<ul>\n<li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>\n<li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>\n</ul>\n</blockquote>\n<p>4、网站开发代码没有优化好</p>\n<blockquote>\n<ul>\n<li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li>\n</ul>\n</blockquote>\n<p><strong>针对网站访问慢，怎么去排查？</strong></p>\n<p>1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p>\n<blockquote>\n<p>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p>\n</blockquote>\n<p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p>\n<p>3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p>\n<p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL 慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p>\n<p><strong>怎么去解决？</strong></p>\n<p>1、如果是出口带宽问题，那么久申请加大出口带宽。</p>\n<p>2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</p>\n<p>3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</p>\n<p>4、申请购买 CDN 服务，加载用户的访问。</p>\n<p>5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</p>\n<h3 id=\"Linux-性能调优都有哪几种方法？\"><a href=\"#Linux-性能调优都有哪几种方法？\" class=\"headerlink\" title=\"Linux 性能调优都有哪几种方法？\"></a>Linux 性能调优都有哪几种方法？</h3><p>1、Disabling daemons (关闭 daemons)。</p>\n<p>2、Shutting down the GUI (关闭 GUI)。</p>\n<p>3、Changing kernel parameters (改变内核参数)。</p>\n<p>4、Kernel parameters (内核参数)。</p>\n<p>5、Tuning the processor subsystem (处理器子系统调优)。</p>\n<p>6、Tuning the memory subsystem (内存子系统调优)。</p>\n<p>7、Tuning the file system (文件系统子系统调优)。</p>\n<p>8、Tuning the network subsystem（网络子系统调优)。</p>\n<h2 id=\"文件管理命令\"><a href=\"#文件管理命令\" class=\"headerlink\" title=\"文件管理命令\"></a>文件管理命令</h2><h3 id=\"cat-命令\"><a href=\"#cat-命令\" class=\"headerlink\" title=\"cat 命令\"></a>cat 命令</h3><p>cat 命令用于连接文件并打印到标准输出设备上。</p>\n<p>cat 主要有三大功能：</p>\n<p>1、一次显示整个文件:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> filename</span><br></pre></td></tr></table></figure>\n\n<p>2、从键盘创建一个文件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &gt; filename</span><br></pre></td></tr></table></figure>\n\n<p>只能创建新文件，不能编辑已有文件。</p>\n<p>3、将几个文件合并为一个文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-b 对非空输出行号</li>\n<li>-n 输出所有行号</li>\n</ul>\n<p><strong>实例</strong>：</p>\n<p>（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -n log2012.log &gt; log2013.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -b log2012.log log2013.log &gt; log.log</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"chmod-命令\"><a href=\"#chmod-命令\" class=\"headerlink\" title=\"chmod 命令\"></a>chmod 命令</h3><p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。</p>\n<p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>\n<p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件<strong>属主</strong>的读、写和执行权限；与属主<strong>同组</strong>的用户的读、写和执行权限；系统中<strong>其他用户</strong>的读、写和执行权限。可使用 ls -l test.txt 查找。</p>\n<p>以文件 log2012.log 为例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br></pre></td></tr></table></figure>\n\n<p>第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读(4)，w 代表写(2)，x 代表可执行(1)。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 当发生改变时，报告处理信息</span><br><span class=\"line\">-R 处理指定目录以及其子目录下所有文件</span><br></pre></td></tr></table></figure>\n\n<p>权限范围：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u ：目录或者文件的当前的用户</span><br><span class=\"line\">g ：目录或者文件的当前的群组</span><br><span class=\"line\">o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class=\"line\">a ：所有的用户及群组</span><br></pre></td></tr></table></figure>\n\n<p>权限代号：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r ：读权限，用数字4表示</span><br><span class=\"line\">w ：写权限，用数字2表示</span><br><span class=\"line\">x ：执行权限，用数字1表示</span><br><span class=\"line\">- ：删除权限，用数字0表示</span><br><span class=\"line\">s ：特殊权限</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）增加文件 t.log 所有用户可执行权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod a+x t.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u=r t.log -c</span><br></pre></td></tr></table></figure>\n\n<p>（3）给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c</span><br></pre></td></tr></table></figure>\n\n<p>（4）将 test 目录及其子目录所有文件添加可读权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u+r,g+r,o+r -R text/ -c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"chown-命令\"><a href=\"#chown-命令\" class=\"headerlink\" title=\"chown 命令\"></a>chown 命令</h3><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 显示更改的部分的信息</span><br><span class=\"line\">-R 处理指定目录及子目录</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）改变拥有者和群组 并显示改变信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -c mail:mail log2012.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）改变文件群组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -c :mail t.log</span><br></pre></td></tr></table></figure>\n\n<p>（3）改变文件夹及子文件目录属主及属组为 mail</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -cR mail: test/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"cp-命令\"><a href=\"#cp-命令\" class=\"headerlink\" title=\"cp 命令\"></a>cp 命令</h3><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>\n<p>注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i 提示</span><br><span class=\"line\">-r 复制目录及目录内所有项目</span><br><span class=\"line\">-a 复制的文件与原文件时间一样</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -ai a.txt test</span><br></pre></td></tr></table></figure>\n\n<p>（2）为 a.txt 建议一个链接（快捷方式）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -s a.txt link_a.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"find-命令\"><a href=\"#find-命令\" class=\"headerlink\" title=\"find 命令\"></a>find 命令</h3><p>用于在文件树中查找文件，并作出相应的处理。</p>\n<p>命令格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find pathname -options [-print -exec -ok ...]</span><br></pre></td></tr></table></figure>\n\n<p>命令参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</span><br><span class=\"line\">-print： find命令将匹配的文件输出到标准输出。</span><br><span class=\"line\">-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;command&#x27; &#123;  &#125; \\;，注意&#123;   &#125;和\\；之间的空格。</span><br><span class=\"line\">-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令选项</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-name 按照文件名查找文件</span><br><span class=\"line\">-perm 按文件权限查找文件</span><br><span class=\"line\">-user 按文件属主查找文件</span><br><span class=\"line\">-group  按照文件所属的组来查找文件。</span><br><span class=\"line\">-type  查找某一类型的文件，诸如：</span><br><span class=\"line\">   b - 块设备文件</span><br><span class=\"line\">   d - 目录</span><br><span class=\"line\">   c - 字符设备文件</span><br><span class=\"line\">   l - 符号链接文件</span><br><span class=\"line\">   p - 管道文件</span><br><span class=\"line\">   f - 普通文件</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找 48 小时内修改过的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find -atime -2</span><br></pre></td></tr></table></figure>\n\n<p>（2）在当前目录查找 以 .log 结尾的文件。 <strong>.</strong> 代表当前目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ./ -name &#x27;*.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>（3）查找 &#x2F;opt 目录下 权限为 777 的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /opt -perm 777</span><br></pre></td></tr></table></figure>\n\n<p>（4）查找大于 1K 的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find -size +1000c</span><br></pre></td></tr></table></figure>\n\n<p>查找等于 1000 字符的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find -size 1000c </span><br></pre></td></tr></table></figure>\n\n<p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面 find 查找出来的文件名。</p>\n<h3 id=\"head-命令\"><a href=\"#head-命令\" class=\"headerlink\" title=\"head 命令\"></a>head 命令</h3><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示 1.log 文件中前 20 行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head 1.log -n 20</span><br></pre></td></tr></table></figure>\n\n<p>（2）显示 1.log 文件前 20 字节</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head 1.log -c 20 </span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>（3）显示 1.log 最后 10 行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head 1.log -n -10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"less-命令\"><a href=\"#less-命令\" class=\"headerlink\" title=\"less 命令\"></a>less 命令</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>\n<p><strong>常用命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i  忽略搜索时的大小写</span><br><span class=\"line\">-N  显示每行的行号</span><br><span class=\"line\">-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class=\"line\">-s  显示连续空行为一行</span><br><span class=\"line\">/字符串：向下搜索“字符串”的功能</span><br><span class=\"line\">?字符串：向上搜索“字符串”的功能</span><br><span class=\"line\">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class=\"line\">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class=\"line\">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class=\"line\">b  向后翻一页</span><br><span class=\"line\">d  向后翻半页</span><br><span class=\"line\">h  显示帮助界面</span><br><span class=\"line\">Q  退出less 命令</span><br><span class=\"line\">u  向前滚动半页</span><br><span class=\"line\">y  向前滚动一行</span><br><span class=\"line\">空格键 滚动一行</span><br><span class=\"line\">回车键 滚动一页</span><br><span class=\"line\">[pagedown]： 向下翻动一页</span><br><span class=\"line\">[pageup]：   向上翻动一页</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）ps 查看进程信息并通过 less 分页显示</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | less -N</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看多个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less 1.log 2.log</span><br></pre></td></tr></table></figure>\n\n<p>可以使用 n 查看下一个，使用 p 查看前一个。</p>\n<h3 id=\"ln-命令\"><a href=\"#ln-命令\" class=\"headerlink\" title=\"ln 命令\"></a>ln 命令</h3><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p>\n<p>链接分类：软件链接及硬链接</p>\n<p>软链接：</p>\n<ul>\n<li>1.软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式</li>\n<li>2.软链接可以 跨文件系统 ，硬链接不可以</li>\n<li>3.软链接可以对一个不存在的文件名进行链接</li>\n<li>4.软链接可以对目录进行链接</li>\n</ul>\n<p>硬链接:</p>\n<ul>\n<li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li>\n<li>2.不允许给目录创建硬链接</li>\n<li>3.硬链接只有在同一个文件系统中才能创建</li>\n</ul>\n<p><strong>需要注意</strong>：</p>\n<ul>\n<li>第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</li>\n<li>第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</li>\n<li>第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</li>\n</ul>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b 删除，覆盖以前建立的链接</span><br><span class=\"line\">-s 软链接（符号链接）</span><br><span class=\"line\">-v 显示详细处理过程</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）给文件创建软链接，并显示操作信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sv source.log link.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）给文件创建硬链接，并显示操作信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -v source.log link1.log</span><br></pre></td></tr></table></figure>\n\n<p>（3）给目录创建软链接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sv /opt/soft/test/test3 /opt/soft/test/test5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"locate-命令\"><a href=\"#locate-命令\" class=\"headerlink\" title=\"locate 命令\"></a>locate 命令</h3><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc&#x2F;crontab)。</p>\n<p>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-l num（要显示的行数）</span><br><span class=\"line\">-f   将特定的档案系统排除在外，如将proc排除在外</span><br><span class=\"line\">-r   使用正则运算式做为寻找条件</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate pwd</span><br></pre></td></tr></table></figure>\n\n<p>（2）搜索 etc 目录下所有以 sh 开头的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate /etc/sh</span><br></pre></td></tr></table></figure>\n\n<p>（3）查找 &#x2F;var 目录下，以 reason 结尾的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate -r &#x27;^/var.*reason$&#x27;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"more-命令\"><a href=\"#more-命令\" class=\"headerlink\" title=\"more 命令\"></a>more 命令</h3><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p>\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+n      从笫 n 行开始显示</span><br><span class=\"line\">-n       定义屏幕大小为n行</span><br><span class=\"line\">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class=\"line\">-c       从顶部清屏，然后显示</span><br><span class=\"line\">-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class=\"line\">-l        忽略Ctrl+l（换页）字符</span><br><span class=\"line\">-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class=\"line\">-s       把连续的多个空行显示为一行</span><br><span class=\"line\">-u       把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用操作命令</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter    向下 n 行，需要定义。默认为 1 行</span><br><span class=\"line\">Ctrl+F   向下滚动一屏</span><br><span class=\"line\">空格键  向下滚动一屏</span><br><span class=\"line\">Ctrl+B  返回上一屏</span><br><span class=\"line\">=       输出当前行的行号</span><br><span class=\"line\">:f     输出文件名和当前行的行号</span><br><span class=\"line\">V      调用vi编辑器</span><br><span class=\"line\">!命令   调用Shell，并执行命令</span><br><span class=\"line\">q       退出more</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示文件中从第 3 行起的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more +3 text.txt</span><br></pre></td></tr></table></figure>\n\n<p>（2）在所列出文件目录详细信息，借助管道使每次显示 5 行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l | more -5</span><br></pre></td></tr></table></figure>\n\n<p>按空格显示下 5 行。</p>\n<h3 id=\"mv-命令\"><a href=\"#mv-命令\" class=\"headerlink\" title=\"mv 命令\"></a>mv 命令</h3><p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p>\n<p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p>\n<p><strong>实例</strong>：</p>\n<p>（1）将文件 test.log 重命名为 test1.txt</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv test.log test1.txt</span><br></pre></td></tr></table></figure>\n\n<p>（2）将文件 log1.txt、log2.txt、log3.txt 移动到根的 test3 目录中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv llog1.txt log2.txt log3.txt /test3</span><br></pre></td></tr></table></figure>\n\n<p>（3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -i log1.txt log2.txt</span><br></pre></td></tr></table></figure>\n\n<p>（4）移动当前文件夹下的所有文件到上一级目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv * ../</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rm-命令\"><a href=\"#rm-命令\" class=\"headerlink\" title=\"rm 命令\"></a>rm 命令</h3><p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm [选项] 文件…</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）删除任何 .log 文件，删除前逐一询问确认：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -i *.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf test</span><br></pre></td></tr></table></figure>\n\n<p>（3）删除以 -f 开头的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -- -f*</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tail-命令\"><a href=\"#tail-命令\" class=\"headerlink\" title=\"tail 命令\"></a>tail 命令</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-f 循环读取（常用于查看递增的日志文件）</span><br><span class=\"line\">-n&lt;行数&gt; 显示行数（从后向前）</span><br></pre></td></tr></table></figure>\n\n<p>（1）循环读取逐渐增加的文件内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping 127.0.0.1 &gt; ping.log &amp;</span><br></pre></td></tr></table></figure>\n\n<p>后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f ping.log</span><br></pre></td></tr></table></figure>\n\n<p>（查看日志）</p>\n<h3 id=\"touch-命令\"><a href=\"#touch-命令\" class=\"headerlink\" title=\"touch 命令\"></a>touch 命令</h3><p>Linux touch 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>\n<p>ls -l 可以显示档案的时间记录。</p>\n<p><strong>语法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>参数说明</strong>：</li>\n<li>a 改变档案的读取时间记录。</li>\n<li>m 改变档案的修改时间记录。</li>\n<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>\n<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>\n<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>\n<li>d 设定时间与日期，可以使用各种不同的格式。</li>\n<li>t 设定档案的时间记录，格式与 date 指令相同。</li>\n<li>–no-create 不会建立新档案。</li>\n<li>–help 列出指令格式。</li>\n<li>–version 列出版本讯息。</li>\n</ul>\n<p><strong>实例</strong></p>\n<p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> testfile                <span class=\"comment\">#修改文件的时间属性</span></span> </span><br></pre></td></tr></table></figure>\n\n<p>首先，使用 ls 命令查看 testfile 文件的属性，如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> -l testfile                <span class=\"comment\">#查看文件的时间属性</span></span>  </span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">原来文件的修改时间为16:09</span>  </span><br><span class=\"line\">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  </span><br></pre></td></tr></table></figure>\n\n<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> testfile                <span class=\"comment\">#修改文件时间属性为当前系统时间</span></span>  </span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> -l testfile                <span class=\"comment\">#查看文件的时间属性</span></span>  </span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">修改后文件的时间属性为当前系统时间</span>  </span><br><span class=\"line\">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  </span><br></pre></td></tr></table></figure>\n\n<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> file            <span class=\"comment\">#创建一个名为“file”的新的空白文件</span></span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vim-命令\"><a href=\"#vim-命令\" class=\"headerlink\" title=\"vim 命令\"></a>vim 命令</h3><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<ul>\n<li>打开文件并跳到第 10 行：<code>vim +10 filename.txt</code> 。</li>\n<li>打开文件跳到第一个匹配的行：<code>vim +/search-term filename.txt</code> 。</li>\n<li>以只读模式打开文件：<code>vim -R /etc/passwd</code> 。</li>\n</ul>\n<p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，**输入模式（Insert mode）**和**底线命令模式（Last line mode）**。</p>\n<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806349.png\" alt=\"vim 工作模式\"></p>\n<h3 id=\"whereis-命令\"><a href=\"#whereis-命令\" class=\"headerlink\" title=\"whereis 命令\"></a>whereis 命令</h3><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b   定位可执行文件。</span><br><span class=\"line\">-m   定位帮助文件。</span><br><span class=\"line\">-s   定位源代码文件。</span><br><span class=\"line\">-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找 locate 程序相关文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis locate</span><br></pre></td></tr></table></figure>\n\n<p>（2）查找 locate 的源码文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -s locate</span><br></pre></td></tr></table></figure>\n\n<p>（3）查找 lcoate 的帮助文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -m locate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"which-命令\"><a href=\"#which-命令\" class=\"headerlink\" title=\"which 命令\"></a>which 命令</h3><p>在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which     查看可执行文件的位置。</span><br><span class=\"line\">whereis 查看文件的位置。</span><br><span class=\"line\">locate  配合数据库查看文件位置。</span><br><span class=\"line\">find        实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure>\n\n<p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查看 ls 命令是否存在，执行哪个</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which ls</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看 which</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which which</span><br></pre></td></tr></table></figure>\n\n<p>（3）查看 cd</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）</span><br></pre></td></tr></table></figure>\n\n<p>查看当前 PATH 配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $PATH</span><br></pre></td></tr></table></figure>\n\n<p>或使用 env 查看所有环境变量及对应值</p>\n<h2 id=\"文档编辑命令\"><a href=\"#文档编辑命令\" class=\"headerlink\" title=\"文档编辑命令\"></a>文档编辑命令</h2><h3 id=\"grep-命令\"><a href=\"#grep-命令\" class=\"headerlink\" title=\"grep 命令\"></a>grep 命令</h3><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p>\n<p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>\n<p>命令格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [option] pattern file|dir</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A n --after-context显示匹配字符后n行</span><br><span class=\"line\">-B n --before-context显示匹配字符前n行</span><br><span class=\"line\">-C n --context 显示匹配字符前后n行</span><br><span class=\"line\">-c --count 计算符合样式的列数</span><br><span class=\"line\">-i 忽略大小写</span><br><span class=\"line\">-l 只列出文件内容符合指定的样式的文件名称</span><br><span class=\"line\">-f 从文件中读取关键词</span><br><span class=\"line\">-n 显示匹配内容的所在文件中行数</span><br><span class=\"line\">-R 递归查找文件夹</span><br></pre></td></tr></table></figure>\n\n<p>grep 的规则表达式:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^  #锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。 </span><br><span class=\"line\">$  #锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。 </span><br><span class=\"line\">.  #匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。  </span><br><span class=\"line\">*  #匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。</span><br><span class=\"line\">.*   #一起用代表任意字符。  </span><br><span class=\"line\">[]   #匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。 </span><br><span class=\"line\">[^]  #匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  </span><br><span class=\"line\">\\(..\\)  #标记匹配字符，如&#x27;\\(love\\)&#x27;，love被标记为1。   </span><br><span class=\"line\">\\&lt;      #锚定单词的开始，如:&#x27;\\&lt;grep&#x27;匹配包含以grep开头的单词的行。</span><br><span class=\"line\">\\&gt;      #锚定单词的结束，如&#x27;grep\\&gt;&#x27;匹配包含以grep结尾的单词的行。</span><br><span class=\"line\">x\\&#123;m\\&#125;  #重复字符x，m次，如：&#x27;0\\&#123;5\\&#125;&#x27;匹配包含5个o的行。 </span><br><span class=\"line\">x\\&#123;m,\\&#125;  #重复字符x,至少m次，如：&#x27;o\\&#123;5,\\&#125;&#x27;匹配至少有5个o的行。  </span><br><span class=\"line\">x\\&#123;m,n\\&#125;  #重复字符x，至少m次，不多于n次，如：&#x27;o\\&#123;5,10\\&#125;&#x27;匹配5--10个o的行。  </span><br><span class=\"line\">\\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。  </span><br><span class=\"line\">\\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  </span><br><span class=\"line\">\\b    #单词锁定符，如: &#x27;\\bgrep\\b&#x27;只匹配grep。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找指定进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep svn</span><br></pre></td></tr></table></figure>\n\n<p>（2）查找指定进程个数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep svn -c</span><br></pre></td></tr></table></figure>\n\n<p>（3）从文件中读取关键词</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat test1.txt | grep -f key.log</span><br></pre></td></tr></table></figure>\n\n<p>（4）从文件夹中递归查找以 grep 开头的行，并只列出文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -lR &#x27;^grep&#x27; /tmp</span><br></pre></td></tr></table></figure>\n\n<p>（5）查找非 x 开关的行内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep &#x27;^[^x]&#x27; test.txt</span><br></pre></td></tr></table></figure>\n\n<p>（6）显示包含 ed 或者 at 字符的内容行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -E &#x27;ed|at&#x27; test.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"wc-命令\"><a href=\"#wc-命令\" class=\"headerlink\" title=\"wc 命令\"></a>wc 命令</h3><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p>\n<p>命令格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc [option] file..</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 统计字节数</span><br><span class=\"line\">-l 统计行数</span><br><span class=\"line\">-m 统计字符数</span><br><span class=\"line\">-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找文件的 行数 单词数 字节数 文件名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc text.txt</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7     8     70     test.txt</span><br></pre></td></tr></table></figure>\n\n<p>（2）统计输出结果的行数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat test.txt | wc -l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"磁盘管理命令\"><a href=\"#磁盘管理命令\" class=\"headerlink\" title=\"磁盘管理命令\"></a>磁盘管理命令</h2><h3 id=\"cd-命令\"><a href=\"#cd-命令\" class=\"headerlink\" title=\"cd 命令\"></a>cd 命令</h3><p>cd(changeDirectory) 命令语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd [目录名]</span><br></pre></td></tr></table></figure>\n\n<p>说明：切换当前目录至 dirName。</p>\n<p><strong>实例</strong>：</p>\n<p>（1）进入要目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /</span><br></pre></td></tr></table></figure>\n\n<p>（2）进入 “home” 目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n\n<p>（3）进入上一次工作路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd -</span><br></pre></td></tr></table></figure>\n\n<p>（4）把上个命令的参数作为 cd 参数使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd !$</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"df-命令\"><a href=\"#df-命令\" class=\"headerlink\" title=\"df 命令\"></a>df 命令</h3><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a 全部文件系统列表</span><br><span class=\"line\">-h 以方便阅读的方式显示信息</span><br><span class=\"line\">-i 显示inode信息</span><br><span class=\"line\">-k 区块为1024字节</span><br><span class=\"line\">-l 只显示本地磁盘</span><br><span class=\"line\">-T 列出文件系统类型</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示磁盘使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n\n<p>（2）以易读方式列出所有文件系统及其类型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -haT</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"du-命令\"><a href=\"#du-命令\" class=\"headerlink\" title=\"du 命令\"></a>du 命令</h3><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：</p>\n<p>命令格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du [选项] [文件]</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a 显示目录中所有文件大小</span><br><span class=\"line\">-k 以KB为单位显示文件大小</span><br><span class=\"line\">-m 以MB为单位显示文件大小</span><br><span class=\"line\">-g 以GB为单位显示文件大小</span><br><span class=\"line\">-h 以易读方式显示文件大小</span><br><span class=\"line\">-s 仅显示总计</span><br><span class=\"line\">-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）以易读方式显示文件夹内及子文件夹大小</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -h scf/</span><br></pre></td></tr></table></figure>\n\n<p>（2）以易读方式显示文件夹内所有文件大小</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -ah scf/</span><br></pre></td></tr></table></figure>\n\n<p>（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -hc test/ scf/</span><br></pre></td></tr></table></figure>\n\n<p>（4）输出当前目录下各个子目录所使用的空间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -hc --max-depth=1 scf/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ls命令\"><a href=\"#ls命令\" class=\"headerlink\" title=\"ls命令\"></a>ls命令</h3><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p>\n<p><strong>常用参数搭配</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class=\"line\">ls -A 列出除.及..的其它文件</span><br><span class=\"line\">ls -r 反序排列</span><br><span class=\"line\">ls -t 以文件修改时间排序</span><br><span class=\"line\">ls -S 以文件大小排序</span><br><span class=\"line\">ls -h 以易读大小显示</span><br><span class=\"line\">ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lhrt</span><br></pre></td></tr></table></figure>\n\n<p>(2) 按大小反序显示文件详细信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lrS</span><br></pre></td></tr></table></figure>\n\n<p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l t*</span><br></pre></td></tr></table></figure>\n\n<p>(4) 列出文件绝对路径（不包含隐藏文件）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls | sed &quot;s:^:`pwd`/:&quot;</span><br></pre></td></tr></table></figure>\n\n<p>(5) 列出文件绝对路径（包含隐藏文件）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find $pwd -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mkdir-命令\"><a href=\"#mkdir-命令\" class=\"headerlink\" title=\"mkdir 命令\"></a>mkdir 命令</h3><p>mkdir 命令用于创建文件夹。</p>\n<p>可用选项：</p>\n<ul>\n<li><strong>-m</strong>: 对新建目录设置存取权限，也可以用 chmod 命令设置;</li>\n<li><strong>-p</strong>: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</li>\n</ul>\n<p><strong>实例</strong>：</p>\n<p>（1）当前工作目录下创建名为 t 的文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir t</span><br></pre></td></tr></table></figure>\n\n<p>（2）在 tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /tmp/test/t1/t</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"pwd-命令\"><a href=\"#pwd-命令\" class=\"headerlink\" title=\"pwd 命令\"></a>pwd 命令</h3><p>pwd 命令用于查看当前工作目录路径。</p>\n<p><strong>实例</strong>：</p>\n<p>（1）查看当前路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看软链接的实际路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -P</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rmdir-命令\"><a href=\"#rmdir-命令\" class=\"headerlink\" title=\"rmdir 命令\"></a>rmdir 命令</h3><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p>\n<p><strong>注意</strong>：不能删除非空目录</p>\n<p><strong>实例</strong>：</p>\n<p>（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir -p parent/child/child11</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络通讯命令\"><a href=\"#网络通讯命令\" class=\"headerlink\" title=\"网络通讯命令\"></a>网络通讯命令</h2><h3 id=\"ifconfig-命令\"><a href=\"#ifconfig-命令\" class=\"headerlink\" title=\"ifconfig 命令\"></a>ifconfig 命令</h3><ul>\n<li>ifconfig 用于查看和配置 Linux 系统的网络接口。</li>\n<li>查看所有网络接口及其状态：<code>ifconfig -a</code> 。</li>\n<li>使用 up 和 down 命令启动或停止某个接口：<code>ifconfig eth0 up</code> 和 <code>ifconfig eth0 down</code> 。</li>\n</ul>\n<h3 id=\"iptables-命令\"><a href=\"#iptables-命令\" class=\"headerlink\" title=\"iptables 命令\"></a>iptables 命令</h3><p>iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：</p>\n<ul>\n<li><p>把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：<code>iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT</code> 。</p>\n</li>\n<li><p>开启 80 端口，因为 web 对外都是这个端口</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 80 -j ACCEP</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外，要注意使用 <code>iptables save</code> 命令，进行保存。否则，服务器重启后，配置的规则将丢失。</p>\n</li>\n</ul>\n<h3 id=\"netstat-命令\"><a href=\"#netstat-命令\" class=\"headerlink\" title=\"netstat 命令\"></a>netstat 命令</h3><p>Linux netstat 命令用于显示网络状态。</p>\n<p>利用 netstat 指令可让你得知整个 Linux 系统的网络情况。</p>\n<p>语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>-a 或–all 显示所有连线中的 Socket。</li>\n<li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li>\n<li>-c 或–continuous 持续列出网络状态。</li>\n<li>-C 或–cache 显示路由器配置的快取信息。</li>\n<li>-e 或–extend 显示网络其他相关信息。</li>\n<li>-F 或–fib 显示 FIB。</li>\n<li>-g 或–groups 显示多重广播功能群组组员名单。</li>\n<li>-h 或–help 在线帮助。</li>\n<li>-i 或–interfaces 显示网络界面信息表单。</li>\n<li>-l 或–listening 显示监控中的服务器的 Socket。</li>\n<li>-M 或–masquerade 显示伪装的网络连线。</li>\n<li>-n 或–numeric 直接使用 IP 地址，而不通过域名服务器。</li>\n<li>-N 或–netlink 或–symbolic 显示网络硬件外围设备的符号连接名称。</li>\n<li>-o 或–timers 显示计时器。</li>\n<li>-p 或–programs 显示正在使用 Socket 的程序识别码和程序名称。</li>\n<li>-r 或–route 显示 Routing Table。</li>\n<li>-s 或–statistice 显示网络工作信息统计表。</li>\n<li>-t 或–tcp 显示 TCP 传输协议的连线状况。</li>\n<li>-u 或–udp 显示 UDP 传输协议的连线状况。</li>\n<li>-v 或–verbose 显示指令执行过程。</li>\n<li>-V 或–version 显示版本信息。</li>\n<li>-w 或–raw 显示 RAW 传输协议的连线状况。</li>\n<li>-x 或–unix 此参数的效果和指定”-A unix”参数相同。</li>\n<li>–ip 或–inet 此参数的效果和指定”-A inet”参数相同。</li>\n</ul>\n<p><strong>实例</strong></p>\n<p><strong>如何查看系统都开启了哪些端口？</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@centos6 ~ 13:20 #55]# netstat -lnp</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      1035/sshd</span><br><span class=\"line\">tcp        0      0 :::22                       :::*                        LISTEN      1035/sshd</span><br><span class=\"line\">udp        0      0 0.0.0.0:68                  0.0.0.0:*                               931/dhclient</span><br><span class=\"line\">Active UNIX domain sockets (only servers)</span><br><span class=\"line\">Proto RefCnt Flags       Type       State         I-Node PID/Program name    Path</span><br><span class=\"line\">unix  2      [ ACC ]     STREAM     LISTENING     6825   1/init              @/com/ubuntu/upstart</span><br><span class=\"line\">unix  2      [ ACC ]     STREAM     LISTENING     8429   1003/dbus-daemon    /var/run/dbus/system_bus_socket</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何查看网络连接状况？</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@centos6 ~ 13:22 #58]# netstat -an</span><br><span class=\"line\">Active Internet connections (servers and established)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address               Foreign Address             State</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class=\"line\">tcp        0      0 192.168.147.130:22          192.168.147.1:23893         ESTABLISHED</span><br><span class=\"line\">tcp        0      0 :::22                       :::*                        LISTEN</span><br><span class=\"line\">udp        0      0 0.0.0.0:68                  0.0.0.0:*</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何统计系统当前进程连接数？</strong></p>\n<ul>\n<li>输入命令 <code>netstat -an | grep ESTABLISHED | wc -l</code> 。</li>\n<li>输出结果 <code>177</code> 。一共有 177 连接数。</li>\n</ul>\n<p><strong>用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 ESTABLISHED 状态链接的个数？</strong></p>\n<blockquote>\n<p>严格来说，这个题目考验的是对 awk 的使用。</p>\n</blockquote>\n<p>首先，使用 <code>netstat -an|grep ESTABLISHED</code> 命令。结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp        0      0 120.27.146.122:80       113.65.18.33:62721      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:80       27.43.83.115:47148      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:58838    106.39.162.96:443       ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:52304    203.208.40.121:443      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:33194    203.208.40.122:443      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:53758    101.37.183.144:443      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:27017    23.105.193.30:50556     ESTABLISHED</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ping-命令\"><a href=\"#ping-命令\" class=\"headerlink\" title=\"ping 命令\"></a>ping 命令</h3><p>Linux ping 命令用于检测主机。</p>\n<p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>\n<p>指定接收包的次数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping -c 2 www.baidu.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"telnet-命令\"><a href=\"#telnet-命令\" class=\"headerlink\" title=\"telnet 命令\"></a>telnet 命令</h3><p>Linux telnet 命令用于远端登入。</p>\n<p>执行 telnet 指令开启终端机阶段作业，并登入远端主机。</p>\n<p>语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet [-8acdEfFKLrx][-b&lt;主机别名&gt;][-e&lt;脱离字符&gt;][-k&lt;域名&gt;][-l&lt;用户名称&gt;][-n&lt;记录文件&gt;][-S&lt;服务类型&gt;][-X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>-8 允许使用 8 位字符资料，包括输入与输出。</li>\n<li>-a 尝试自动登入远端系统。</li>\n<li>-b&lt;主机别名&gt; 使用别名指定远端主机名称。</li>\n<li>-c 不读取用户专属目录里的.telnetrc 文件。</li>\n<li>-d 启动排错模式。</li>\n<li>-e&lt;脱离字符&gt; 设置脱离字符。</li>\n<li>-E 滤除脱离字符。</li>\n<li>-f 此参数的效果和指定”-F”参数相同。</li>\n<li>-F 使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li>\n<li>-k&lt;域名&gt; 使用 Kerberos 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li>\n<li>-K 不自动登入远端主机。</li>\n<li>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</li>\n<li>-L 允许输出 8 位字符资料。</li>\n<li>-n&lt;记录文件&gt; 指定文件记录相关信息。</li>\n<li>-r 使用类似 rlogin 指令的用户界面。</li>\n<li>-S&lt;服务类型&gt; 设置 telnet 连线所需的 IP TOS 信息。</li>\n<li>-x 假设主机有支持数据加密的功能，就使用它。</li>\n<li>-X&lt;认证形态&gt; 关闭指定的认证形态。</li>\n</ul>\n<p><strong>实例</strong></p>\n<p>登录远程主机</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">登录IP为 192.168.0.5 的远程主机</span></span><br><span class=\"line\">telnet 192.168.0.5 </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系统管理命令\"><a href=\"#系统管理命令\" class=\"headerlink\" title=\"系统管理命令\"></a>系统管理命令</h2><h3 id=\"date-命令\"><a href=\"#date-命令\" class=\"headerlink\" title=\"date 命令\"></a>date 命令</h3><p>显示或设定系统的日期与时间。</p>\n<p>命令参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。</span><br><span class=\"line\">-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。</span><br><span class=\"line\">-u 　显示GMT。</span><br><span class=\"line\">%H 小时(00-23)</span><br><span class=\"line\">%I 小时(00-12)</span><br><span class=\"line\">%M 分钟(以00-59来表示)</span><br><span class=\"line\">%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。</span><br><span class=\"line\">%S 秒(以本地的惯用法来表示)</span><br><span class=\"line\">%a 星期的缩写。</span><br><span class=\"line\">%A 星期的完整名称。</span><br><span class=\"line\">%d 日期(以01-31来表示)。</span><br><span class=\"line\">%D 日期(含年月日)。</span><br><span class=\"line\">%m 月份(以01-12来表示)。</span><br><span class=\"line\">%y 年份(以00-99来表示)。</span><br><span class=\"line\">%Y 年份(以四位数来表示)。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示下一天</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date +%Y%m%d --date=&quot;+1 day&quot;  //显示下一天的日期</span><br></pre></td></tr></table></figure>\n\n<p>（2）-d 参数使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -d &quot;nov 22&quot;  今年的 11 月 22 日是星期三</span><br><span class=\"line\">date -d &#x27;2 weeks&#x27; 2周后的日期</span><br><span class=\"line\">date -d &#x27;next monday&#x27; (下周一的日期)</span><br><span class=\"line\">date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d</span><br><span class=\"line\">date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d</span><br><span class=\"line\">date -d last-month +%Y%m(上个月是几月)</span><br><span class=\"line\">date -d next-month +%Y%m(下个月是几月)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"free-命令\"><a href=\"#free-命令\" class=\"headerlink\" title=\"free 命令\"></a>free 命令</h3><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p>\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b 以Byte显示内存使用情况</span><br><span class=\"line\">-k 以kb为单位显示内存使用情况</span><br><span class=\"line\">-m 以mb为单位显示内存使用情况</span><br><span class=\"line\">-g 以gb为单位显示内存使用情况</span><br><span class=\"line\">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class=\"line\">-t 显示内存使用总合</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示内存使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free</span><br><span class=\"line\">free -k</span><br><span class=\"line\">free -m</span><br></pre></td></tr></table></figure>\n\n<p>（2）以总和的形式显示内存的使用信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -t</span><br></pre></td></tr></table></figure>\n\n<p>（3）周期性查询内存使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -s 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"kill-命令\"><a href=\"#kill-命令\" class=\"headerlink\" title=\"kill 命令\"></a>kill 命令</h3><p>发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class=\"line\">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class=\"line\">-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class=\"line\">-s  指定发送信号</span><br><span class=\"line\">-u  指定用户</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）先使用 ps 查找进程 pro1，然后用 kill 杀掉</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -9 $(ps -ef | grep pro1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ps-命令\"><a href=\"#ps-命令\" class=\"headerlink\" title=\"ps 命令\"></a>ps 命令</h3><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top</p>\n<p>linux 上进程有 5 种状态:</p>\n<ol>\n<li>运行(正在运行或在运行队列中等待)</li>\n<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>\n<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>\n<li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)</li>\n<li>停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行)</li>\n</ol>\n<p>ps 工具标识进程的 5 种状态码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D 不可中断 uninterruptible sleep (usually IO)</span><br><span class=\"line\">R 运行 runnable (on run queue)</span><br><span class=\"line\">S 中断 sleeping</span><br><span class=\"line\">T 停止 traced or stopped</span><br><span class=\"line\">Z 僵死 a defunct (”zombie”) process</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A 显示所有进程</span><br><span class=\"line\">a 显示所有进程</span><br><span class=\"line\">-a 显示同一终端下所有进程</span><br><span class=\"line\">c 显示进程真实名称</span><br><span class=\"line\">e 显示环境变量</span><br><span class=\"line\">f 显示进程间的关系</span><br><span class=\"line\">r 显示当前终端运行的进程</span><br><span class=\"line\">-aux 显示所有包含其它使用的进程</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示当前所有进程环境变量及进程间关系</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef</span><br></pre></td></tr></table></figure>\n\n<p>（2）显示当前所有进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -A</span><br></pre></td></tr></table></figure>\n\n<p>（3）与 grep 联用查找某进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep apache</span><br></pre></td></tr></table></figure>\n\n<p>（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux | grep &#x27;(cron|syslog)&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rpm-命令\"><a href=\"#rpm-命令\" class=\"headerlink\" title=\"rpm 命令\"></a>rpm 命令</h3><p>Linux rpm 命令用于管理套件。</p>\n<p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看系统自带jdk</span></span><br><span class=\"line\">rpm -qa | grep jdk</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除系统自带jdk</span></span><br><span class=\"line\">rpm -e --nodeps 查看jdk显示的数据</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装jdk</span></span><br><span class=\"line\">rpm -ivh jdk-7u80-linux-x64.rpm</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"top-命令\"><a href=\"#top-命令\" class=\"headerlink\" title=\"top 命令\"></a>top 命令</h3><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 显示完整的进程命令</span><br><span class=\"line\">-s 保密模式</span><br><span class=\"line\">-p &lt;进程号&gt; 指定进程显示</span><br><span class=\"line\">-n &lt;次数&gt;循环显示次数</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35</span><br><span class=\"line\">Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st</span><br><span class=\"line\">Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers</span><br><span class=\"line\">Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached</span><br><span class=\"line\">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  </span><br><span class=\"line\">28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  </span><br></pre></td></tr></table></figure>\n\n<p>前五行是当前系统情况整体的统计信息区。</p>\n<p><strong>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下</strong>：</p>\n<p>14:06:23 — 当前系统时间</p>\n<p>up 70 days, 16:44 — 系统已经运行了 70 天 16 小时 44 分钟（在这期间系统没有重启过的吆！）</p>\n<p>2 users — 当前有 2 个用户登录系统</p>\n<p>load average: 1.15, 1.42, 1.44 — load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。</p>\n<p>load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。</p>\n<p><strong>第二行，Tasks — 任务（进程），具体信息说明如下</strong>：</p>\n<p>系统现在共有 206 个进程，其中处于运行中的有 1 个，205 个在休眠（sleep），stoped 状态的有 0 个，zombie 状态（僵尸）的有 0 个。</p>\n<p><strong>第三行，cpu状态信息，具体属性说明如下</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5.9%us — 用户空间占用CPU的百分比。</span><br><span class=\"line\">3.4% sy — 内核空间占用CPU的百分比。</span><br><span class=\"line\">0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class=\"line\">90.4% id — 空闲CPU百分比</span><br><span class=\"line\">0.0% wa — IO等待占用CPU的百分比</span><br><span class=\"line\">0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class=\"line\">0.2% si — 软中断（Software Interrupts）占用CPU的百分比</span><br></pre></td></tr></table></figure>\n\n<p><strong>备注</strong>：在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！</p>\n<p>第四行，内存状态，具体信息如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32949016k total — 物理内存总量（32GB）</span><br><span class=\"line\">14411180k used — 使用中的内存总量（14GB）</span><br><span class=\"line\">18537836k free — 空闲内存总量（18GB）</span><br><span class=\"line\">169884k buffers — 缓存的内存量 （169M）</span><br></pre></td></tr></table></figure>\n\n<p><strong>第五行，swap交换分区信息，具体信息说明如下</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32764556k total — 交换区总量（32GB）</span><br><span class=\"line\">0k used — 使用的交换区总量（0K）</span><br><span class=\"line\">32764556k free — 空闲交换区总量（32GB）</span><br><span class=\"line\">3612636k cached — 缓冲的交换区总量（3.6GB）</span><br></pre></td></tr></table></figure>\n\n<p><strong>第六行，空行。</strong></p>\n<p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PID — 进程id</span><br><span class=\"line\">USER — 进程所有者</span><br><span class=\"line\">PR — 进程优先级</span><br><span class=\"line\">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class=\"line\">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class=\"line\">RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class=\"line\">SHR — 共享内存大小，单位kb</span><br><span class=\"line\">S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class=\"line\">%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class=\"line\">%MEM — 进程使用的物理内存百分比</span><br><span class=\"line\">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class=\"line\">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure>\n\n<p><strong>top 交互命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h 显示top交互命令帮助信息</span><br><span class=\"line\">c 切换显示命令名称和完整命令行</span><br><span class=\"line\">m 以内存使用率排序</span><br><span class=\"line\">P 根据CPU使用百分比大小进行排序</span><br><span class=\"line\">T 根据时间/累计时间进行排序</span><br><span class=\"line\">W 将当前设置写入~/.toprc文件中</span><br><span class=\"line\">o或者O 改变显示项目的顺序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yum-命令\"><a href=\"#yum-命令\" class=\"headerlink\" title=\"yum 命令\"></a>yum 命令</h3><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>\n<p>基於 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n<p>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<ul>\n<li>1.列出所有可更新的软件清单命令：yum check-update</li>\n<li>2.更新所有软件命令：yum update</li>\n<li>3.仅安装指定的软件命令：yum install <package_name></li>\n<li>4.仅更新指定的软件命令：yum update <package_name></li>\n<li>5.列出所有可安裝的软件清单命令：yum list</li>\n<li>6.删除软件包命令：yum remove <package_name></li>\n<li>7.查找软件包 命令：yum search</li>\n<li>8.清除缓存命令:<ul>\n<li>yum clean packages: 清除缓存目录下的软件包</li>\n<li>yum clean headers: 清除缓存目录下的 headers</li>\n<li>yum clean oldheaders: 清除缓存目录下旧的 headers</li>\n<li>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers</li>\n</ul>\n</li>\n</ul>\n<p><strong>实例</strong></p>\n<p>安装 pam-devel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@www ~]# yum install pam-devel</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"备份压缩命令\"><a href=\"#备份压缩命令\" class=\"headerlink\" title=\"备份压缩命令\"></a>备份压缩命令</h2><h3 id=\"bzip2-命令\"><a href=\"#bzip2-命令\" class=\"headerlink\" title=\"bzip2 命令\"></a>bzip2 命令</h3><ul>\n<li>创建 <code>*.bz2</code> 压缩文件：<code>bzip2 test.txt</code> 。</li>\n<li>解压 <code>*.bz2</code> 文件：<code>bzip2 -d test.txt.bz2</code> 。</li>\n</ul>\n<h3 id=\"gzip-命令\"><a href=\"#gzip-命令\" class=\"headerlink\" title=\"gzip 命令\"></a>gzip 命令</h3><ul>\n<li>创建一个 <code>*.gz</code> 的压缩文件：<code>gzip test.txt</code> 。</li>\n<li>解压 <code>*.gz</code> 文件：<code>gzip -d test.txt.gz</code> 。</li>\n<li>显示压缩的比率：<code>gzip -l *.gz</code> 。</li>\n</ul>\n<h3 id=\"tar-命令\"><a href=\"#tar-命令\" class=\"headerlink\" title=\"tar 命令\"></a>tar 命令</h3><p>用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p>\n<p>弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 建立新的压缩文件</span><br><span class=\"line\">-f 指定压缩文件</span><br><span class=\"line\">-r 添加文件到已经压缩文件包中</span><br><span class=\"line\">-u 添加改了和现有的文件到压缩包中</span><br><span class=\"line\">-x 从压缩包中抽取文件</span><br><span class=\"line\">-t 显示压缩文件中的内容</span><br><span class=\"line\">-z 支持gzip压缩</span><br><span class=\"line\">-j 支持bzip2压缩</span><br><span class=\"line\">-Z 支持compress解压文件</span><br><span class=\"line\">-v 显示操作过程</span><br></pre></td></tr></table></figure>\n\n<p>有关 gzip 及 bzip2 压缩:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz</span><br><span class=\"line\">          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2</span><br><span class=\"line\">       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）将文件全部打包成 tar 包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf log.tar 1.log,2.log 或tar -cvf log.*</span><br></pre></td></tr></table></figure>\n\n<p>（2）将 &#x2F;etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zcvf /tmp/etc.tar.gz /etc</span><br></pre></td></tr></table></figure>\n\n<p>（3）查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -ztvf /tmp/etc.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>（4）要压缩打包 &#x2F;home, &#x2F;etc ，但不要 &#x2F;home&#x2F;dmtsai</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unzip-命令\"><a href=\"#unzip-命令\" class=\"headerlink\" title=\"unzip 命令\"></a>unzip 命令</h3><ul>\n<li>解压 <code>*.zip</code> 文件：<code>unzip test.zip</code> 。</li>\n<li>查看 <code>*.zip</code> 文件的内容：<code>unzip -l jasper.zip</code> 。</li>\n</ul>\n","site":{"data":{}},"length":31287,"excerpt":"<blockquote>\n<p>整理的 Linux 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"Linux-概述\"><a href=\"#Linux-概述\" class=\"headerlink\" title=\"Linux 概述\"></a>Linux 概述</h2><h3 id=\"什么是Linux\"><a href=\"#什么是Linux\" class=\"headerlink\" title=\"什么是Linux\"></a>什么是Linux</h3><p>Linux 是一套<strong>免费使用和自由传播的类 Unix 操作系统</strong>，是一个基于 POSIX 和 Unix 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>\n<h3 id=\"Unix和Linux有什么区别？\"><a href=\"#Unix和Linux有什么区别？\" class=\"headerlink\" title=\"Unix和Linux有什么区别？\"></a>Unix和Linux有什么区别？</h3><p>Linux 和 Unix 都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为 Unix 和 Linux 操作系统是一样的，然而，事实并非如此，以下是两者的区别。</p>\n<ol>\n<li>开源性<br> Linux 是一款开源操作系统，不需要付费，即可使用；Unix 是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。</li>\n<li>跨平台性<br> Linux 操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix 操作系统跨平台性能较弱，大多需与硬件配套使用。</li>\n<li>可视化界面<br> Linux 除了进行命令行操作，还有窗体管理系统；Unix 只是命令行下的系统。</li>\n<li>硬件环境<br> Linux 操作系统对硬件的要求较低，安装方法更易掌握；Unix 对硬件要求比较苛刻，按照难度较大。</li>\n<li>用户群体<br> Linux 的用户群体很广泛，个人和企业均可使用；Unix 的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者 Unix 硬件厂商使用，如 Sun 等。<br> 相比于 Unix 操作系统，Linux 操作系统更受广大计算机爱好者的喜爱，主要原因是 Linux 操作系统具有 Unix 操作系统的全部功能，并且能够在普通 PC 计算机上实现全部的 Unix 特性，开源免费的特性，更容易普及使用！</li>\n</ol>\n<h3 id=\"什么是-Linux-内核？\"><a href=\"#什么是-Linux-内核？\" class=\"headerlink\" title=\"什么是 Linux 内核？\"></a>什么是 Linux 内核？</h3><p>Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。</p>\n<ol>\n<li>系统内存管理</li>\n<li>应用程序管理</li>\n<li>硬件设备管理</li>\n<li>文件系统管理</li>\n</ol>\n<h3 id=\"Linux的基本组件是什么？\"><a href=\"#Linux的基本组件是什么？\" class=\"headerlink\" title=\"Linux的基本组件是什么？\"></a>Linux的基本组件是什么？</h3><p>就像任何其他典型的操作系统一样，Linux 拥有所有这些组件：内核，shell 和 GUI，系统实用程序和应用程序。Linux 比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费下载。</p>\n<h3 id=\"Linux-的体系结构\"><a href=\"#Linux-的体系结构\" class=\"headerlink\" title=\"Linux 的体系结构\"></a>Linux 的体系结构</h3><p>从大的方面讲，Linux 体系结构可以分为两块：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70.png\" alt=\"Linux 体系结构\"></p>\n<ul>\n<li>用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。</li>\n<li>内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code) 。</li>\n</ul>\n<p><strong>为什么 Linux 体系结构要分为用户空间和内核空间的原因？</strong></p>\n<ol>\n<li>现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。</li>\n<li>Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。</li>\n</ol>\n<p>用户空间和内核空间是程序执行的<strong>两种不同的状态</strong>，我们可以通过两种方式完成用户空间到内核空间的转移：</p>\n<p>1）系统调用；2）硬件中断。</p>\n<h3 id=\"BASH和DOS之间的基本区别是什么？\"><a href=\"#BASH和DOS之间的基本区别是什么？\" class=\"headerlink\" title=\"BASH和DOS之间的基本区别是什么？\"></a>BASH和DOS之间的基本区别是什么？</h3><p>BASH 和 DOS 控制台之间的主要区别在于 3 个方面：</p>\n<ul>\n<li>BASH 命令区分大小写，而 DOS 命令则不区分；</li>\n<li>在 BASH 下，&#x2F; character 是目录分隔符，\\作为转义字符。在 DOS 下，&#x2F;用作命令参数分隔符，\\是目录分隔符；</li>\n<li>DOS 遵循命名文件中的约定，即 8 个字符的文件名后跟一个点，扩展名为 3 个字符。BASH 没有遵循这样的惯例。</li>\n</ul>\n<h3 id=\"Linux-开机启动过程？\"><a href=\"#Linux-开机启动过程？\" class=\"headerlink\" title=\"Linux 开机启动过程？\"></a>Linux 开机启动过程？</h3><blockquote>\n<p>了解即可。</p>\n</blockquote>\n<p>1、主机加电自检，加载 BIOS 硬件信息。</p>\n<p>2、读取 MBR 的引导文件(GRUB、LILO)。</p>\n<p>3、引导 Linux 内核。</p>\n<p>4、运行第一个进程 init (进程号永远为 1 )。</p>\n<p>5、进入相应的运行级别。</p>\n<p>6、运行终端，输入用户名和密码。</p>\n<h3 id=\"Linux系统缺省的运行级别？\"><a href=\"#Linux系统缺省的运行级别？\" class=\"headerlink\" title=\"Linux系统缺省的运行级别？\"></a>Linux系统缺省的运行级别？</h3><ul>\n<li>关机。</li>\n<li>单机用户模式。</li>\n<li>字符界面的多用户模式(不支持网络)。</li>\n<li>字符界面的多用户模式。</li>\n<li>未分配使用。</li>\n<li>图形界面的多用户模式。</li>\n<li>重启。</li>\n</ul>\n<h3 id=\"Linux-使用的进程间通信方式？\"><a href=\"#Linux-使用的进程间通信方式？\" class=\"headerlink\" title=\"Linux 使用的进程间通信方式？\"></a>Linux 使用的进程间通信方式？</h3><blockquote>\n<p>了解即可，不需要太深入。</p>\n</blockquote>\n<ul>\n<li>管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。</li>\n<li>信号(signal) 。</li>\n<li>消息队列。</li>\n<li>共享内存。</li>\n<li>信号量。</li>\n<li>套接字(socket) 。</li>\n</ul>\n<h3 id=\"Linux-有哪些系统日志文件？\"><a href=\"#Linux-有哪些系统日志文件？\" class=\"headerlink\" title=\"Linux 有哪些系统日志文件？\"></a>Linux 有哪些系统日志文件？</h3><p>比较重要的是 <code>/var/log/messages</code> 日志文件。</p>\n<p>该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。</p>\n<h3 id=\"什么是交换空间？\"><a href=\"#什么是交换空间？\" class=\"headerlink\" title=\"什么是交换空间？\"></a>什么是交换空间？</h3><p>交换空间是 Linux 使用的一定空间，用于临时保存一些并发运行的程序。当 RAM 没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。</p>\n<h3 id=\"什么是root帐户\"><a href=\"#什么是root帐户\" class=\"headerlink\" title=\"什么是root帐户\"></a>什么是root帐户</h3><p>root 帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装 Linux 时都是默认帐户。</p>\n<h3 id=\"什么是LILO？\"><a href=\"#什么是LILO？\" class=\"headerlink\" title=\"什么是LILO？\"></a>什么是LILO？</h3><p>LILO 是 Linux 的引导加载程序。它主要用于将 Linux 操作系统加载到主内存中，以便它可以开始运行。</p>\n<h3 id=\"什么是BASH？\"><a href=\"#什么是BASH？\" class=\"headerlink\" title=\"什么是BASH？\"></a>什么是BASH？</h3><p>BASH 是 Bourne Again SHell 的缩写。它由 Steve Bourne 编写，作为原始 Bourne Shell（由&#x2F; bin &#x2F; sh 表示）的替代品。它结合了原始版本的 Bourne Shell 的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行 Linux 的大多数系统的默认 shell。</p>\n<h3 id=\"什么是CLI？\"><a href=\"#什么是CLI？\" class=\"headerlink\" title=\"什么是CLI？\"></a>什么是CLI？</h3><p><strong>命令行界面</strong>（英语<strong>：command-line interface</strong>，缩写]<strong>：CLI</strong>）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为<strong>字符用户界面</strong>（CUI）。</p>\n<p>通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。</p>\n<h3 id=\"什么是GUI？\"><a href=\"#什么是GUI？\" class=\"headerlink\" title=\"什么是GUI？\"></a>什么是GUI？</h3><p>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。</p>\n<p>图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。</p>\n<h3 id=\"开源的优势是什么？\"><a href=\"#开源的优势是什么？\" class=\"headerlink\" title=\"开源的优势是什么？\"></a>开源的优势是什么？</h3><p>开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益。</p>\n<h3 id=\"GNU项目的重要性是什么？\"><a href=\"#GNU项目的重要性是什么？\" class=\"headerlink\" title=\"GNU项目的重要性是什么？\"></a>GNU项目的重要性是什么？</h3><p>这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。</p>\n<h2 id=\"磁盘、目录、文件\"><a href=\"#磁盘、目录、文件\" class=\"headerlink\" title=\"磁盘、目录、文件\"></a>磁盘、目录、文件</h2><h3 id=\"简单-Linux-文件系统？\"><a href=\"#简单-Linux-文件系统？\" class=\"headerlink\" title=\"简单 Linux 文件系统？\"></a>简单 Linux 文件系统？</h3><p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p>\n<p>也就是说在 Linux 系统中有一个重要的概念<strong>：一切都是文件</strong>。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX 系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就<strong>可以用读写文件的方式实现对硬件的访问</strong>。</p>\n<p>Linux 支持 5 种文件类型，如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png.png\" alt=\"5 种文件类型\"></p>\n<h3 id=\"Linux-的目录结构是怎样的？\"><a href=\"#Linux-的目录结构是怎样的？\" class=\"headerlink\" title=\"Linux 的目录结构是怎样的？\"></a>Linux 的目录结构是怎样的？</h3><blockquote>\n<p>这个问题，一般不会问。更多是实际使用时，需要知道。</p>\n</blockquote>\n<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：<br><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806288.png\" alt=\"Linux 的目录结构\"></p>\n<p><strong>常见目录说明</strong>：</p>\n<ul>\n<li><strong>&#x2F;bin</strong>： 存放二进制可执行文件(ls,cat,mkdir 等)，常用命令一般都在这里；</li>\n<li><strong>&#x2F;etc</strong>： 存放系统管理和配置文件；</li>\n<li><strong>&#x2F;home</strong>： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li>\n<li>**&#x2F;usr **： 用于存放系统应用程序；</li>\n<li><strong>&#x2F;opt</strong>： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>\n<li><strong>&#x2F;proc</strong>： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>\n<li><strong>&#x2F;root</strong>： 超级用户（系统管理员）的主目录（特权阶级 o）；</li>\n<li><strong>&#x2F;sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>\n<li><strong>&#x2F;dev</strong>： 用于存放设备文件；</li>\n<li><strong>&#x2F;mnt</strong>： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>\n<li><strong>&#x2F;boot</strong>： 存放用于系统引导时使用的各种文件；</li>\n<li>**&#x2F;lib **： 存放着和系统运行相关的库文件 ；</li>\n<li><strong>&#x2F;tmp</strong>： 用于存放各种临时文件，是公用的临时文件存储点；</li>\n<li><strong>&#x2F;var</strong>： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>\n<li><strong>&#x2F;lost+found</strong>： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>\n</ul>\n<h3 id=\"什么是-inode-？\"><a href=\"#什么是-inode-？\" class=\"headerlink\" title=\"什么是 inode ？\"></a>什么是 inode ？</h3><blockquote>\n<p>一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix&#x2F;Linux 文件系统和硬盘储存的基础。</p>\n</blockquote>\n<p>理解 inode，要从文件储存说起。</p>\n<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存 512 字节（相当于 0.5KB）。</p>\n<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。</p>\n<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做 inode，中文译名为”索引节点”。</p>\n<p>每一个文件都有对应的 inode，里面包含了与该文件有关的一些信息。</p>\n<p><strong>简述 Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？</strong></p>\n<blockquote>\n<p>如果看的一脸懵逼，也没关系。一般来说，面试官不太会问这个题目。</p>\n</blockquote>\n<p>Linux 通过 inode 节点表将文件的逻辑结构和物理结构进行转换。</p>\n<ul>\n<li>inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。</li>\n<li>Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。</li>\n</ul>\n<h3 id=\"什么是硬链接和软链接？\"><a href=\"#什么是硬链接和软链接？\" class=\"headerlink\" title=\"什么是硬链接和软链接？\"></a>什么是硬链接和软链接？</h3><p>1）硬链接</p>\n<p>由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。</p>\n<ul>\n<li>不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。</li>\n</ul>\n<p>2）软链接</p>\n<p>软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。</p>\n<ul>\n<li>不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。</li>\n</ul>\n<p><strong>实际场景下，基本是使用软链接</strong>。总结区别如下：</p>\n<ul>\n<li>硬链接不可以跨分区，软件链可以跨分区。</li>\n<li>硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。</li>\n<li>删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。</li>\n</ul>\n<h3 id=\"RAID-是什么\"><a href=\"#RAID-是什么\" class=\"headerlink\" title=\"RAID 是什么?\"></a>RAID 是什么?</h3><blockquote>\n<p>RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。</p>\n<p>RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案。</p>\n</blockquote>\n<p>当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、SSD 云盘酱紫的概念。</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><h3 id=\"一台-Linux-系统初始化环境后需要做一些什么安全工作？\"><a href=\"#一台-Linux-系统初始化环境后需要做一些什么安全工作？\" class=\"headerlink\" title=\"一台 Linux 系统初始化环境后需要做一些什么安全工作？\"></a>一台 Linux 系统初始化环境后需要做一些什么安全工作？</h3><p>1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。</p>\n<blockquote>\n<p>修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l</p>\n</blockquote>\n<p>2、服务器使用密钥登陆，禁止密码登陆。</p>\n<p>3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。</p>\n<p>4、装 fail2ban 这种防止 SSH 暴力破击的软件。</p>\n<p>5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)</p>\n<blockquote>\n<p>也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。</p>\n</blockquote>\n<p>6、修改历史命令记录的条数为 10 条。</p>\n<p>7、只允许有需要的服务器可以访问外网，其它全部禁止。</p>\n<p>8、做好软件层面的防护。</p>\n<ul>\n<li>8.1 设置 nginx_waf 模块防止 SQL 注入。</li>\n<li>8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。</li>\n</ul>\n<h3 id=\"什么叫-CC-攻击？什么叫-DDOS-攻击？\"><a href=\"#什么叫-CC-攻击？什么叫-DDOS-攻击？\" class=\"headerlink\" title=\"什么叫 CC 攻击？什么叫 DDOS 攻击？\"></a>什么叫 CC 攻击？什么叫 DDOS 攻击？</h3><ul>\n<li><p>CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。</p>\n</li>\n<li><p>DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。</p>\n<blockquote>\n<p>攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>怎么预防 CC 攻击和 DDOS 攻击？</strong></p>\n<p>防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。</p>\n<blockquote>\n<p>流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。</p>\n</blockquote>\n<h3 id=\"什么是网站数据库注入？\"><a href=\"#什么是网站数据库注入？\" class=\"headerlink\" title=\"什么是网站数据库注入？\"></a>什么是网站数据库注入？</h3><ul>\n<li>由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断。</li>\n<li>应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的 SQL 注入。</li>\n<li>SQL 注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。</li>\n</ul>\n<p><strong>如何过滤与预防？</strong></p>\n<p>数据库网页端注入这种，可以考虑使用 nginx_waf 做过滤与预防。</p>\n<h2 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h2><h3 id=\"Shell-脚本是什么？\"><a href=\"#Shell-脚本是什么？\" class=\"headerlink\" title=\"Shell 脚本是什么？\"></a>Shell 脚本是什么？</h3><p>一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。</p>\n<p><strong>什么是默认登录 Shell ？</strong></p>\n<p>在 Linux 操作系统，<code>&quot;/bin/bash&quot;</code> 是默认登录 Shell，是在创建用户时分配的。</p>\n<p>使用 chsh 命令可以改变默认的 Shell 。示例如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chsh &lt;用户名&gt; -s &lt;新shell&gt;</span><br><span class=\"line\">chsh ThinkWon -s /bin/sh</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Shell 脚本中，如何写入注释？</strong></p>\n<p>注释可以用来描述一个脚本可以做什么和它是如何工作的。每一行注释以 <code>#</code> 开头。例子如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># This is a command</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> “I am logged <span class=\"keyword\">in</span> as <span class=\"variable\">$USER</span>”</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"语法级\"><a href=\"#语法级\" class=\"headerlink\" title=\"语法级\"></a>语法级</h3><h4 id=\"可以在-Shell-脚本中使用哪些类型的变量？\"><a href=\"#可以在-Shell-脚本中使用哪些类型的变量？\" class=\"headerlink\" title=\"可以在 Shell 脚本中使用哪些类型的变量？\"></a>可以在 Shell 脚本中使用哪些类型的变量？</h4><p>在 Shell 脚本，我们可以使用两种类型的变量：</p>\n<ul>\n<li><p>系统定义变量</p>\n<blockquote>\n<p>系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 <code>set</code> 命令查看。</p>\n</blockquote>\n</li>\n<li><p>用户定义变量</p>\n<blockquote>\n<p>用户变量由系统用户来生成和定义，变量的值可以通过命令 <code>&quot;echo $&lt;变量名&gt;&quot;</code> 查看。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>Shell脚本中 $? 标记的用途是什么？</strong></p>\n<p>在写一个 Shell 脚本时，如果你想要检查前一命令是否执行成功，在 <code>if</code> 条件中使用 <code>$?</code> 可以来检查前一命令的结束状态。</p>\n<ul>\n<li><p>如果结束状态是 0 ，说明前一个命令执行成功。例如：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@localhost:~<span class=\"comment\">## ls /usr/bin/shar</span></span><br><span class=\"line\">/usr/bin/shar</span><br><span class=\"line\">root@localhost:~<span class=\"comment\">## echo $?</span></span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果结束状态不是 0，说明命令执行失败。例如：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@localhost:~<span class=\"comment\">## ls /usr/bin/share</span></span><br><span class=\"line\"><span class=\"built_in\">ls</span>: cannot access /usr/bin/share: No such file or directory</span><br><span class=\"line\">root@localhost:~<span class=\"comment\">## echo $?</span></span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>Bourne Shell(bash) 中有哪些特殊的变量？</strong></p>\n<p>下面的表列出了 Bourne Shell 为命令行设置的特殊变量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内建变量    解释</span><br><span class=\"line\"><span class=\"variable\">$0</span>    命令行中的脚本名字</span><br><span class=\"line\"><span class=\"variable\">$1</span>    第一个命令行参数</span><br><span class=\"line\"><span class=\"variable\">$2</span>    第二个命令行参数</span><br><span class=\"line\">…..    …….</span><br><span class=\"line\"><span class=\"variable\">$9</span>    第九个命令行参数</span><br><span class=\"line\"><span class=\"variable\">$#</span><span class=\"comment\">#    命令行参数的数量</span></span><br><span class=\"line\">$*    所有命令行参数，以空格隔开</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何取消变量或取消变量赋值？</strong></p>\n<p><code>unset</code> 命令用于取消变量或取消变量赋值。语法如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## unset &lt;变量名&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-if-语法如何嵌套\"><a href=\"#Shell-脚本中-if-语法如何嵌套\" class=\"headerlink\" title=\"Shell 脚本中 if 语法如何嵌套?\"></a>Shell 脚本中 <code>if</code> 语法如何嵌套?</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> [ 条件 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">…..</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ 条件 ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">….</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">…..</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>在 Shell 脚本中如何比较两个数字？</strong></p>\n<p>在 <code>if-then</code> 中使用测试命令（ <code>-gt</code> 等）来比较两个数字。例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">x=10</span><br><span class=\"line\">y=20</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$x</span> -gt <span class=\"variable\">$y</span> ]</span><br><span class=\"line\"><span class=\"keyword\">then</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> “x is greater than y”</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> “y is greater than x”</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-case-语句的语法\"><a href=\"#Shell-脚本中-case-语句的语法\" class=\"headerlink\" title=\"Shell 脚本中 case 语句的语法?\"></a>Shell 脚本中 <code>case</code> 语句的语法?</h4><p>基础语法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> 变量 <span class=\"keyword\">in</span></span><br><span class=\"line\">值1)</span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">…..</span><br><span class=\"line\">最后命令</span><br><span class=\"line\">!!</span><br><span class=\"line\">值2)</span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">……</span><br><span class=\"line\">最后命令</span><br><span class=\"line\">;;</span><br><span class=\"line\"><span class=\"keyword\">esac</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-for-循环语法？\"><a href=\"#Shell-脚本中-for-循环语法？\" class=\"headerlink\" title=\"Shell 脚本中 for 循环语法？\"></a>Shell 脚本中 <code>for</code> 循环语法？</h4><p>基础语法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 变量 <span class=\"keyword\">in</span> 循环列表</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">命令1</span><br><span class=\"line\">命令2</span><br><span class=\"line\">….</span><br><span class=\"line\">最后命令</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Shell-脚本中-while-循环语法？\"><a href=\"#Shell-脚本中-while-循环语法？\" class=\"headerlink\" title=\"Shell 脚本中 while 循环语法？\"></a>Shell 脚本中 <code>while</code> 循环语法？</h4><p>如同 <code>for</code> 循环，<code>while</code> 循环只要条件成立就重复它的命令块。<br>不同于 <code>for</code>循环，<code>while</code> 循环会不断迭代，直到它的条件不为真。</p>\n<p>基础语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> [ 条件 ]</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">命令…</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>do-while 语句的基本格式？</strong></p>\n<p><code>do-while</code> 语句类似于 <code>while</code> 语句，但检查条件语句之前先执行命令（LCTT 译注：意即至少执行一次。）。下面是用 <code>do-while</code> 语句的语法：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">命令</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> (条件)</span><br></pre></td></tr></table></figure>\n\n<p><strong>Shell 脚本中 break 命令的作用？</strong></p>\n<p><code>break</code> 命令一个简单的用途是退出执行中的循环。我们可以在 <code>while</code> 和 <code>until</code> 循环中使用 <code>break</code> 命令跳出循环。</p>\n<p><strong>Shell 脚本中 continue 命令的作用？</strong></p>\n<p><code>continue</code> 命令不同于 <code>break</code> 命令，它只跳出当前循环的迭代，而不是整个循环。<code>continue</code> 命令很多时候是很有用的，例如错误发生，但我们依然希望继续执行大循环的时候。</p>\n<h4 id=\"如何使脚本可执行\"><a href=\"#如何使脚本可执行\" class=\"headerlink\" title=\"如何使脚本可执行?\"></a>如何使脚本可执行?</h4><p>使用 chmod 命令来使脚本可执行。例子如下：<code>chmod a+x myscript.sh</code> 。</p>\n<p><strong>#!&#x2F;bin&#x2F;bash 的作用？</strong></p>\n<p><code>#!/bin/bash</code> 是 Shell 脚本的第一行，称为释伴（shebang）行。</p>\n<ul>\n<li>这里 <code>#</code> 符号叫做 hash ，而 <code>!</code> 叫做 bang。</li>\n<li>它的意思是命令通过 <code>/bin/bash</code> 来执行。</li>\n</ul>\n<p><strong>如何调试 Shell脚本？</strong></p>\n<ul>\n<li>使用 <code>-x&#39;</code> 数（<code>sh -x myscript.sh</code>）可以调试 Shell 脚本。</li>\n<li>另一个种方法是使用 <code>-nv</code> 参数(<code>sh -nv myscript.sh</code>)。</li>\n</ul>\n<p><strong>如何将标准输出和错误输出同时重定向到同一位置?</strong></p>\n<ul>\n<li>方法一：<code>2&gt;&amp;1 (如## ls /usr/share/doc &gt; out.txt 2&gt;&amp;1 )</code> 。</li>\n<li>方法二：<code>&amp;&gt; (如## ls /usr/share/doc &amp;&gt; out.txt )</code> 。</li>\n</ul>\n<p><strong>在 Shell 脚本中，如何测试文件？</strong></p>\n<p>test 命令可以用来测试文件。基础用法如下表格：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Test         用法</span><br><span class=\"line\">-d 文件名    如果文件存在并且是目录，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-e 文件名    如果文件存在，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-f 文件名    如果文件存在并且是普通文件，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-r 文件名    如果文件存在并可读，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-s 文件名    如果文件存在并且不为空，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-w 文件名    如果文件存在并可写，返回<span class=\"literal\">true</span></span><br><span class=\"line\">-x 文件名    如果文件存在并可执行，返回<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在-Shell-脚本如何定义函数呢？\"><a href=\"#在-Shell-脚本如何定义函数呢？\" class=\"headerlink\" title=\"在 Shell 脚本如何定义函数呢？\"></a>在 Shell 脚本如何定义函数呢？</h4><p>函数是拥有名字的代码块。当我们定义代码块，我们就可以在我们的脚本调用函数名字，该块就会被执行。示例如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"function\"><span class=\"title\">diskusage</span></span> () &#123; <span class=\"built_in\">df</span> -h ; &#125;</span><br><span class=\"line\">译注：下面是我给的shell函数语法，原文没有</span><br><span class=\"line\">[ <span class=\"keyword\">function</span> ] 函数名 [()]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">命令;</span><br><span class=\"line\">[<span class=\"built_in\">return</span> int;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何让 Shell 就脚本得到来自终端的输入?</strong></p>\n<p>read 命令可以读取来自终端（使用键盘）的数据。read 命令得到用户的输入并置于你给出的变量中。例子如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## vi /tmp/test.sh</span></span><br><span class=\"line\"><span class=\"comment\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> ‘Please enter your name’</span><br><span class=\"line\"><span class=\"built_in\">read</span> name</span><br><span class=\"line\"><span class=\"built_in\">echo</span> “My Name is <span class=\"variable\">$name</span>”</span><br><span class=\"line\"><span class=\"comment\">## ./test.sh</span></span><br><span class=\"line\">Please enter your name</span><br><span class=\"line\">ThinkWon</span><br><span class=\"line\">My Name is ThinkWon</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何执行算术运算？</strong></p>\n<p>有两种方法来执行算术运算：</p>\n<ul>\n<li>1、使用 expr 命令：<code>## expr 5 + 2</code> 。</li>\n<li>2、用一个美元符号和方括号（<code>$[ 表达式 ]</code>）：<code>test=$[16 + 4] ; test=$[16 + 4]</code> 。</li>\n</ul>\n<h3 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h3><h4 id=\"判断一文件是不是字符设备文件，如果是将其拷贝到-dev-目录下？\"><a href=\"#判断一文件是不是字符设备文件，如果是将其拷贝到-dev-目录下？\" class=\"headerlink\" title=\"判断一文件是不是字符设备文件，如果是将其拷贝到 /dev 目录下？\"></a>判断一文件是不是字符设备文件，如果是将其拷贝到 <code>/dev</code> 目录下？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">read</span> -p <span class=\"string\">&quot;Input file name: &quot;</span> FILENAME</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ -c <span class=\"string\">&quot;<span class=\"variable\">$FILENAME</span>&quot;</span> ];<span class=\"keyword\">then</span></span><br><span class=\"line\">　　<span class=\"built_in\">cp</span> <span class=\"variable\">$FILENAME</span> /dev</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"添加一个新组为-class1-，然后添加属于这个组的-30-个用户，用户名的形式为-stdxx-，其中-xx-从-01-到-30-？\"><a href=\"#添加一个新组为-class1-，然后添加属于这个组的-30-个用户，用户名的形式为-stdxx-，其中-xx-从-01-到-30-？\" class=\"headerlink\" title=\"添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？\"></a>添加一个新组为 class1 ，然后添加属于这个组的 30 个用户，用户名的形式为 stdxx ，其中 xx 从 01 到 30 ？</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">groupadd class1</span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">31</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ <span class=\"variable\">$i</span> -le 10 ];<span class=\"keyword\">then</span></span><br><span class=\"line\">                useradd -g class1 std0<span class=\"variable\">$i</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                useradd -g class1 std<span class=\"variable\">$i</span></span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>编写 Shell 程序，实现自动删除 50 个账号的功能，账号名为stud1 至 stud50 ？</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>((i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">51</span>;i++))</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">                userdel -r stud<span class=\"variable\">$i</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"写一个-sed-命令，修改-tmp-input-txt-文件的内容？\"><a href=\"#写一个-sed-命令，修改-tmp-input-txt-文件的内容？\" class=\"headerlink\" title=\"写一个 sed 命令，修改 /tmp/input.txt 文件的内容？\"></a>写一个 sed 命令，修改 <code>/tmp/input.txt</code> 文件的内容？</h4><p>要求：</p>\n<ul>\n<li>删除所有空行。</li>\n<li>一行中，如果包含 “11111”，则在 “11111” 前面插入 “AAA”，在 “11111” 后面插入 “BBB” 。比如：将内容为 0000111112222 的一行改为 0000AAA11111BBB2222 。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@~]<span class=\"comment\">## cat -n /tmp/input.txt</span></span><br><span class=\"line\">     1  000011111222</span><br><span class=\"line\">     2</span><br><span class=\"line\">     3  000011111222222</span><br><span class=\"line\">     4  11111000000222</span><br><span class=\"line\">     5</span><br><span class=\"line\">     6</span><br><span class=\"line\">     7  111111111111122222222222</span><br><span class=\"line\">     8  2211111111</span><br><span class=\"line\">     9  112222222</span><br><span class=\"line\">    10  1122</span><br><span class=\"line\">    11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 删除所有空行命令</span></span><br><span class=\"line\">[root@~]<span class=\"comment\">## sed &#x27;/^$/d&#x27; /tmp/input.txt</span></span><br><span class=\"line\">000011111222</span><br><span class=\"line\">000011111222222</span><br><span class=\"line\">11111000000222</span><br><span class=\"line\">111111111111122222222222</span><br><span class=\"line\">2211111111</span><br><span class=\"line\">112222222</span><br><span class=\"line\">1122</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 插入指定的字符</span></span><br><span class=\"line\">[root@~]<span class=\"comment\">## sed &#x27;s#\\(11111\\)#AAA\\1BBB#g&#x27; /tmp/input.txt</span></span><br><span class=\"line\">0000AAA11111BBB222</span><br><span class=\"line\">0000AAA11111BBB222222</span><br><span class=\"line\">AAA11111BBB000000222</span><br><span class=\"line\">AAA11111BBBAAA11111BBB11122222222222</span><br><span class=\"line\">22AAA11111BBB111</span><br><span class=\"line\">112222222</span><br><span class=\"line\">1122</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"如何选择-Linux-操作系统版本\"><a href=\"#如何选择-Linux-操作系统版本\" class=\"headerlink\" title=\"如何选择 Linux 操作系统版本?\"></a>如何选择 Linux 操作系统版本?</h3><p>一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。</p>\n<p>根据具体要求：</p>\n<ul>\n<li><p>安全性要求较高，则选择 Debian 或者 FreeBSD 。</p>\n</li>\n<li><p>需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。</p>\n</li>\n<li><p>想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。</p>\n</li>\n<li><p>【重点】<strong>根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束</strong>。</p>\n<blockquote>\n<p>CentOS 7 系列，也慢慢使用的会比较多了。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"如何规划一台-Linux-主机，步骤是怎样？\"><a href=\"#如何规划一台-Linux-主机，步骤是怎样？\" class=\"headerlink\" title=\"如何规划一台 Linux 主机，步骤是怎样？\"></a>如何规划一台 Linux 主机，步骤是怎样？</h3><p>1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。</p>\n<blockquote>\n<p>不同的用途，机器的配置会有所不同。</p>\n</blockquote>\n<p>2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。</p>\n<p>3、需要优化系统的哪些参数，需要创建哪些用户等等的。</p>\n<h3 id=\"请问当用户反馈网站访问慢，你会如何处理？\"><a href=\"#请问当用户反馈网站访问慢，你会如何处理？\" class=\"headerlink\" title=\"请问当用户反馈网站访问慢，你会如何处理？\"></a>请问当用户反馈网站访问慢，你会如何处理？</h3><p><strong>有哪些方面的因素会导致网站网站访问慢？</strong></p>\n<p>1、服务器出口带宽不够用</p>\n<blockquote>\n<ul>\n<li>本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。</li>\n<li>跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。</li>\n</ul>\n</blockquote>\n<p>2、服务器负载过大，导致响应不过来</p>\n<blockquote>\n<p>可以从两个方面入手分析：</p>\n<ul>\n<li>分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。</li>\n<li>如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。</li>\n</ul>\n</blockquote>\n<p>3、数据库瓶颈</p>\n<blockquote>\n<ul>\n<li>如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</li>\n<li>如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</li>\n</ul>\n</blockquote>\n<p>4、网站开发代码没有优化好</p>\n<blockquote>\n<ul>\n<li>例如 SQL 语句没有优化，导致数据库读写相当耗时。</li>\n</ul>\n</blockquote>\n<p><strong>针对网站访问慢，怎么去排查？</strong></p>\n<p>1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。</p>\n<blockquote>\n<p>不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。</p>\n</blockquote>\n<p>2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。</p>\n<p>3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。</p>\n<p>4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL 慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。</p>\n<p><strong>怎么去解决？</strong></p>\n<p>1、如果是出口带宽问题，那么久申请加大出口带宽。</p>\n<p>2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。</p>\n<p>3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。</p>\n<p>4、申请购买 CDN 服务，加载用户的访问。</p>\n<p>5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。</p>\n<h3 id=\"Linux-性能调优都有哪几种方法？\"><a href=\"#Linux-性能调优都有哪几种方法？\" class=\"headerlink\" title=\"Linux 性能调优都有哪几种方法？\"></a>Linux 性能调优都有哪几种方法？</h3><p>1、Disabling daemons (关闭 daemons)。</p>\n<p>2、Shutting down the GUI (关闭 GUI)。</p>\n<p>3、Changing kernel parameters (改变内核参数)。</p>\n<p>4、Kernel parameters (内核参数)。</p>\n<p>5、Tuning the processor subsystem (处理器子系统调优)。</p>\n<p>6、Tuning the memory subsystem (内存子系统调优)。</p>\n<p>7、Tuning the file system (文件系统子系统调优)。</p>\n<p>8、Tuning the network subsystem（网络子系统调优)。</p>\n<h2 id=\"文件管理命令\"><a href=\"#文件管理命令\" class=\"headerlink\" title=\"文件管理命令\"></a>文件管理命令</h2><h3 id=\"cat-命令\"><a href=\"#cat-命令\" class=\"headerlink\" title=\"cat 命令\"></a>cat 命令</h3><p>cat 命令用于连接文件并打印到标准输出设备上。</p>\n<p>cat 主要有三大功能：</p>\n<p>1、一次显示整个文件:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> filename</span><br></pre></td></tr></table></figure>\n\n<p>2、从键盘创建一个文件:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &gt; filename</span><br></pre></td></tr></table></figure>\n\n<p>只能创建新文件，不能编辑已有文件。</p>\n<p>3、将几个文件合并为一个文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>-b 对非空输出行号</li>\n<li>-n 输出所有行号</li>\n</ul>\n<p><strong>实例</strong>：</p>\n<p>（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -n log2012.log &gt; log2013.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat -b log2012.log log2013.log &gt; log.log</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"chmod-命令\"><a href=\"#chmod-命令\" class=\"headerlink\" title=\"chmod 命令\"></a>chmod 命令</h3><p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。</p>\n<p>用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>\n<p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件<strong>属主</strong>的读、写和执行权限；与属主<strong>同组</strong>的用户的读、写和执行权限；系统中<strong>其他用户</strong>的读、写和执行权限。可使用 ls -l test.txt 查找。</p>\n<p>以文件 log2012.log 为例：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br></pre></td></tr></table></figure>\n\n<p>第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读(4)，w 代表写(2)，x 代表可执行(1)。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 当发生改变时，报告处理信息</span><br><span class=\"line\">-R 处理指定目录以及其子目录下所有文件</span><br></pre></td></tr></table></figure>\n\n<p>权限范围：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u ：目录或者文件的当前的用户</span><br><span class=\"line\">g ：目录或者文件的当前的群组</span><br><span class=\"line\">o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class=\"line\">a ：所有的用户及群组</span><br></pre></td></tr></table></figure>\n\n<p>权限代号：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r ：读权限，用数字4表示</span><br><span class=\"line\">w ：写权限，用数字2表示</span><br><span class=\"line\">x ：执行权限，用数字1表示</span><br><span class=\"line\">- ：删除权限，用数字0表示</span><br><span class=\"line\">s ：特殊权限</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）增加文件 t.log 所有用户可执行权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod a+x t.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u=r t.log -c</span><br></pre></td></tr></table></figure>\n\n<p>（3）给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c</span><br></pre></td></tr></table></figure>\n\n<p>（4）将 test 目录及其子目录所有文件添加可读权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod u+r,g+r,o+r -R text/ -c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"chown-命令\"><a href=\"#chown-命令\" class=\"headerlink\" title=\"chown 命令\"></a>chown 命令</h3><p>chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 显示更改的部分的信息</span><br><span class=\"line\">-R 处理指定目录及子目录</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）改变拥有者和群组 并显示改变信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -c mail:mail log2012.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）改变文件群组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -c :mail t.log</span><br></pre></td></tr></table></figure>\n\n<p>（3）改变文件夹及子文件目录属主及属组为 mail</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -cR mail: test/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"cp-命令\"><a href=\"#cp-命令\" class=\"headerlink\" title=\"cp 命令\"></a>cp 命令</h3><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>\n<p>注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i 提示</span><br><span class=\"line\">-r 复制目录及目录内所有项目</span><br><span class=\"line\">-a 复制的文件与原文件时间一样</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -ai a.txt test</span><br></pre></td></tr></table></figure>\n\n<p>（2）为 a.txt 建议一个链接（快捷方式）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp -s a.txt link_a.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"find-命令\"><a href=\"#find-命令\" class=\"headerlink\" title=\"find 命令\"></a>find 命令</h3><p>用于在文件树中查找文件，并作出相应的处理。</p>\n<p>命令格式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find pathname -options [-print -exec -ok ...]</span><br></pre></td></tr></table></figure>\n\n<p>命令参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</span><br><span class=\"line\">-print： find命令将匹配的文件输出到标准输出。</span><br><span class=\"line\">-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;command&#x27; &#123;  &#125; \\;，注意&#123;   &#125;和\\；之间的空格。</span><br><span class=\"line\">-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令选项</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-name 按照文件名查找文件</span><br><span class=\"line\">-perm 按文件权限查找文件</span><br><span class=\"line\">-user 按文件属主查找文件</span><br><span class=\"line\">-group  按照文件所属的组来查找文件。</span><br><span class=\"line\">-type  查找某一类型的文件，诸如：</span><br><span class=\"line\">   b - 块设备文件</span><br><span class=\"line\">   d - 目录</span><br><span class=\"line\">   c - 字符设备文件</span><br><span class=\"line\">   l - 符号链接文件</span><br><span class=\"line\">   p - 管道文件</span><br><span class=\"line\">   f - 普通文件</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找 48 小时内修改过的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find -atime -2</span><br></pre></td></tr></table></figure>\n\n<p>（2）在当前目录查找 以 .log 结尾的文件。 <strong>.</strong> 代表当前目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ./ -name &#x27;*.log&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>（3）查找 &#x2F;opt 目录下 权限为 777 的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find /opt -perm 777</span><br></pre></td></tr></table></figure>\n\n<p>（4）查找大于 1K 的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find -size +1000c</span><br></pre></td></tr></table></figure>\n\n<p>查找等于 1000 字符的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find -size 1000c </span><br></pre></td></tr></table></figure>\n\n<p>-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面 find 查找出来的文件名。</p>\n<h3 id=\"head-命令\"><a href=\"#head-命令\" class=\"headerlink\" title=\"head 命令\"></a>head 命令</h3><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-n&lt;行数&gt; 显示的行数（行数为复数表示从最后向前数）</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示 1.log 文件中前 20 行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head 1.log -n 20</span><br></pre></td></tr></table></figure>\n\n<p>（2）显示 1.log 文件前 20 字节</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head 1.log -c 20 </span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>（3）显示 1.log 最后 10 行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head 1.log -n -10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"less-命令\"><a href=\"#less-命令\" class=\"headerlink\" title=\"less 命令\"></a>less 命令</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>\n<p><strong>常用命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-i  忽略搜索时的大小写</span><br><span class=\"line\">-N  显示每行的行号</span><br><span class=\"line\">-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class=\"line\">-s  显示连续空行为一行</span><br><span class=\"line\">/字符串：向下搜索“字符串”的功能</span><br><span class=\"line\">?字符串：向上搜索“字符串”的功能</span><br><span class=\"line\">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class=\"line\">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class=\"line\">-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class=\"line\">b  向后翻一页</span><br><span class=\"line\">d  向后翻半页</span><br><span class=\"line\">h  显示帮助界面</span><br><span class=\"line\">Q  退出less 命令</span><br><span class=\"line\">u  向前滚动半页</span><br><span class=\"line\">y  向前滚动一行</span><br><span class=\"line\">空格键 滚动一行</span><br><span class=\"line\">回车键 滚动一页</span><br><span class=\"line\">[pagedown]： 向下翻动一页</span><br><span class=\"line\">[pageup]：   向上翻动一页</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）ps 查看进程信息并通过 less 分页显示</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | less -N</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看多个文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">less 1.log 2.log</span><br></pre></td></tr></table></figure>\n\n<p>可以使用 n 查看下一个，使用 p 查看前一个。</p>\n<h3 id=\"ln-命令\"><a href=\"#ln-命令\" class=\"headerlink\" title=\"ln 命令\"></a>ln 命令</h3><p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。</p>\n<p>链接分类：软件链接及硬链接</p>\n<p>软链接：</p>\n<ul>\n<li>1.软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式</li>\n<li>2.软链接可以 跨文件系统 ，硬链接不可以</li>\n<li>3.软链接可以对一个不存在的文件名进行链接</li>\n<li>4.软链接可以对目录进行链接</li>\n</ul>\n<p>硬链接:</p>\n<ul>\n<li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li>\n<li>2.不允许给目录创建硬链接</li>\n<li>3.硬链接只有在同一个文件系统中才能创建</li>\n</ul>\n<p><strong>需要注意</strong>：</p>\n<ul>\n<li>第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</li>\n<li>第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</li>\n<li>第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</li>\n</ul>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b 删除，覆盖以前建立的链接</span><br><span class=\"line\">-s 软链接（符号链接）</span><br><span class=\"line\">-v 显示详细处理过程</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）给文件创建软链接，并显示操作信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sv source.log link.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）给文件创建硬链接，并显示操作信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -v source.log link1.log</span><br></pre></td></tr></table></figure>\n\n<p>（3）给目录创建软链接</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sv /opt/soft/test/test3 /opt/soft/test/test5</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"locate-命令\"><a href=\"#locate-命令\" class=\"headerlink\" title=\"locate 命令\"></a>locate 命令</h3><p>locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc&#x2F;crontab)。</p>\n<p>locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-l num（要显示的行数）</span><br><span class=\"line\">-f   将特定的档案系统排除在外，如将proc排除在外</span><br><span class=\"line\">-r   使用正则运算式做为寻找条件</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找和 pwd 相关的所有文件(文件名中包含 pwd）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate pwd</span><br></pre></td></tr></table></figure>\n\n<p>（2）搜索 etc 目录下所有以 sh 开头的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate /etc/sh</span><br></pre></td></tr></table></figure>\n\n<p>（3）查找 &#x2F;var 目录下，以 reason 结尾的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locate -r &#x27;^/var.*reason$&#x27;（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"more-命令\"><a href=\"#more-命令\" class=\"headerlink\" title=\"more 命令\"></a>more 命令</h3><p>功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。</p>\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+n      从笫 n 行开始显示</span><br><span class=\"line\">-n       定义屏幕大小为n行</span><br><span class=\"line\">+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 </span><br><span class=\"line\">-c       从顶部清屏，然后显示</span><br><span class=\"line\">-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</span><br><span class=\"line\">-l        忽略Ctrl+l（换页）字符</span><br><span class=\"line\">-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class=\"line\">-s       把连续的多个空行显示为一行</span><br><span class=\"line\">-u       把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用操作命令</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter    向下 n 行，需要定义。默认为 1 行</span><br><span class=\"line\">Ctrl+F   向下滚动一屏</span><br><span class=\"line\">空格键  向下滚动一屏</span><br><span class=\"line\">Ctrl+B  返回上一屏</span><br><span class=\"line\">=       输出当前行的行号</span><br><span class=\"line\">:f     输出文件名和当前行的行号</span><br><span class=\"line\">V      调用vi编辑器</span><br><span class=\"line\">!命令   调用Shell，并执行命令</span><br><span class=\"line\">q       退出more</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示文件中从第 3 行起的内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">more +3 text.txt</span><br></pre></td></tr></table></figure>\n\n<p>（2）在所列出文件目录详细信息，借助管道使每次显示 5 行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l | more -5</span><br></pre></td></tr></table></figure>\n\n<p>按空格显示下 5 行。</p>\n<h3 id=\"mv-命令\"><a href=\"#mv-命令\" class=\"headerlink\" title=\"mv 命令\"></a>mv 命令</h3><p>移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。</p>\n<p>当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。</p>\n<p><strong>实例</strong>：</p>\n<p>（1）将文件 test.log 重命名为 test1.txt</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv test.log test1.txt</span><br></pre></td></tr></table></figure>\n\n<p>（2）将文件 log1.txt、log2.txt、log3.txt 移动到根的 test3 目录中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv llog1.txt log2.txt log3.txt /test3</span><br></pre></td></tr></table></figure>\n\n<p>（3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv -i log1.txt log2.txt</span><br></pre></td></tr></table></figure>\n\n<p>（4）移动当前文件夹下的所有文件到上一级目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv * ../</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rm-命令\"><a href=\"#rm-命令\" class=\"headerlink\" title=\"rm 命令\"></a>rm 命令</h3><p>删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm [选项] 文件…</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）删除任何 .log 文件，删除前逐一询问确认：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -i *.log</span><br></pre></td></tr></table></figure>\n\n<p>（2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf test</span><br></pre></td></tr></table></figure>\n\n<p>（3）删除以 -f 开头的文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -- -f*</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tail-命令\"><a href=\"#tail-命令\" class=\"headerlink\" title=\"tail 命令\"></a>tail 命令</h3><p>用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-f 循环读取（常用于查看递增的日志文件）</span><br><span class=\"line\">-n&lt;行数&gt; 显示行数（从后向前）</span><br></pre></td></tr></table></figure>\n\n<p>（1）循环读取逐渐增加的文件内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping 127.0.0.1 &gt; ping.log &amp;</span><br></pre></td></tr></table></figure>\n\n<p>后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f ping.log</span><br></pre></td></tr></table></figure>\n\n<p>（查看日志）</p>\n<h3 id=\"touch-命令\"><a href=\"#touch-命令\" class=\"headerlink\" title=\"touch 命令\"></a>touch 命令</h3><p>Linux touch 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>\n<p>ls -l 可以显示档案的时间记录。</p>\n<p><strong>语法</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>参数说明</strong>：</li>\n<li>a 改变档案的读取时间记录。</li>\n<li>m 改变档案的修改时间记录。</li>\n<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>\n<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>\n<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>\n<li>d 设定时间与日期，可以使用各种不同的格式。</li>\n<li>t 设定档案的时间记录，格式与 date 指令相同。</li>\n<li>–no-create 不会建立新档案。</li>\n<li>–help 列出指令格式。</li>\n<li>–version 列出版本讯息。</li>\n</ul>\n<p><strong>实例</strong></p>\n<p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> testfile                <span class=\"comment\">#修改文件的时间属性</span></span> </span><br></pre></td></tr></table></figure>\n\n<p>首先，使用 ls 命令查看 testfile 文件的属性，如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> -l testfile                <span class=\"comment\">#查看文件的时间属性</span></span>  </span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">原来文件的修改时间为16:09</span>  </span><br><span class=\"line\">-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  </span><br></pre></td></tr></table></figure>\n\n<p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> testfile                <span class=\"comment\">#修改文件时间属性为当前系统时间</span></span>  </span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> -l testfile                <span class=\"comment\">#查看文件的时间属性</span></span>  </span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">修改后文件的时间属性为当前系统时间</span>  </span><br><span class=\"line\">-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  </span><br></pre></td></tr></table></figure>\n\n<p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">touch</span> file            <span class=\"comment\">#创建一个名为“file”的新的空白文件</span></span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"vim-命令\"><a href=\"#vim-命令\" class=\"headerlink\" title=\"vim 命令\"></a>vim 命令</h3><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>\n<ul>\n<li>打开文件并跳到第 10 行：<code>vim +10 filename.txt</code> 。</li>\n<li>打开文件跳到第一个匹配的行：<code>vim +/search-term filename.txt</code> 。</li>\n<li>以只读模式打开文件：<code>vim -R /etc/passwd</code> 。</li>\n</ul>\n<p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，**输入模式（Insert mode）**和**底线命令模式（Last line mode）**。</p>\n<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/format,png-20230125135806349.png\" alt=\"vim 工作模式\"></p>\n<h3 id=\"whereis-命令\"><a href=\"#whereis-命令\" class=\"headerlink\" title=\"whereis 命令\"></a>whereis 命令</h3><p>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b   定位可执行文件。</span><br><span class=\"line\">-m   定位帮助文件。</span><br><span class=\"line\">-s   定位源代码文件。</span><br><span class=\"line\">-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找 locate 程序相关文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis locate</span><br></pre></td></tr></table></figure>\n\n<p>（2）查找 locate 的源码文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -s locate</span><br></pre></td></tr></table></figure>\n\n<p>（3）查找 lcoate 的帮助文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whereis -m locate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"which-命令\"><a href=\"#which-命令\" class=\"headerlink\" title=\"which 命令\"></a>which 命令</h3><p>在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which     查看可执行文件的位置。</span><br><span class=\"line\">whereis 查看文件的位置。</span><br><span class=\"line\">locate  配合数据库查看文件位置。</span><br><span class=\"line\">find        实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure>\n\n<p>which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查看 ls 命令是否存在，执行哪个</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which ls</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看 which</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which which</span><br></pre></td></tr></table></figure>\n\n<p>（3）查看 cd</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）</span><br></pre></td></tr></table></figure>\n\n<p>查看当前 PATH 配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $PATH</span><br></pre></td></tr></table></figure>\n\n<p>或使用 env 查看所有环境变量及对应值</p>\n<h2 id=\"文档编辑命令\"><a href=\"#文档编辑命令\" class=\"headerlink\" title=\"文档编辑命令\"></a>文档编辑命令</h2><h3 id=\"grep-命令\"><a href=\"#grep-命令\" class=\"headerlink\" title=\"grep 命令\"></a>grep 命令</h3><p>强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。</p>\n<p>grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p>\n<p>命令格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep [option] pattern file|dir</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A n --after-context显示匹配字符后n行</span><br><span class=\"line\">-B n --before-context显示匹配字符前n行</span><br><span class=\"line\">-C n --context 显示匹配字符前后n行</span><br><span class=\"line\">-c --count 计算符合样式的列数</span><br><span class=\"line\">-i 忽略大小写</span><br><span class=\"line\">-l 只列出文件内容符合指定的样式的文件名称</span><br><span class=\"line\">-f 从文件中读取关键词</span><br><span class=\"line\">-n 显示匹配内容的所在文件中行数</span><br><span class=\"line\">-R 递归查找文件夹</span><br></pre></td></tr></table></figure>\n\n<p>grep 的规则表达式:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^  #锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。 </span><br><span class=\"line\">$  #锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。 </span><br><span class=\"line\">.  #匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。  </span><br><span class=\"line\">*  #匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。</span><br><span class=\"line\">.*   #一起用代表任意字符。  </span><br><span class=\"line\">[]   #匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。 </span><br><span class=\"line\">[^]  #匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。  </span><br><span class=\"line\">\\(..\\)  #标记匹配字符，如&#x27;\\(love\\)&#x27;，love被标记为1。   </span><br><span class=\"line\">\\&lt;      #锚定单词的开始，如:&#x27;\\&lt;grep&#x27;匹配包含以grep开头的单词的行。</span><br><span class=\"line\">\\&gt;      #锚定单词的结束，如&#x27;grep\\&gt;&#x27;匹配包含以grep结尾的单词的行。</span><br><span class=\"line\">x\\&#123;m\\&#125;  #重复字符x，m次，如：&#x27;0\\&#123;5\\&#125;&#x27;匹配包含5个o的行。 </span><br><span class=\"line\">x\\&#123;m,\\&#125;  #重复字符x,至少m次，如：&#x27;o\\&#123;5,\\&#125;&#x27;匹配至少有5个o的行。  </span><br><span class=\"line\">x\\&#123;m,n\\&#125;  #重复字符x，至少m次，不多于n次，如：&#x27;o\\&#123;5,10\\&#125;&#x27;匹配5--10个o的行。  </span><br><span class=\"line\">\\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。  </span><br><span class=\"line\">\\W    #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。  </span><br><span class=\"line\">\\b    #单词锁定符，如: &#x27;\\bgrep\\b&#x27;只匹配grep。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找指定进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep svn</span><br></pre></td></tr></table></figure>\n\n<p>（2）查找指定进程个数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep svn -c</span><br></pre></td></tr></table></figure>\n\n<p>（3）从文件中读取关键词</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat test1.txt | grep -f key.log</span><br></pre></td></tr></table></figure>\n\n<p>（4）从文件夹中递归查找以 grep 开头的行，并只列出文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -lR &#x27;^grep&#x27; /tmp</span><br></pre></td></tr></table></figure>\n\n<p>（5）查找非 x 开关的行内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep &#x27;^[^x]&#x27; test.txt</span><br></pre></td></tr></table></figure>\n\n<p>（6）显示包含 ed 或者 at 字符的内容行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grep -E &#x27;ed|at&#x27; test.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"wc-命令\"><a href=\"#wc-命令\" class=\"headerlink\" title=\"wc 命令\"></a>wc 命令</h3><p>wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出</p>\n<p>命令格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc [option] file..</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 统计字节数</span><br><span class=\"line\">-l 统计行数</span><br><span class=\"line\">-m 统计字符数</span><br><span class=\"line\">-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）查找文件的 行数 单词数 字节数 文件名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wc text.txt</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7     8     70     test.txt</span><br></pre></td></tr></table></figure>\n\n<p>（2）统计输出结果的行数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat test.txt | wc -l</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"磁盘管理命令\"><a href=\"#磁盘管理命令\" class=\"headerlink\" title=\"磁盘管理命令\"></a>磁盘管理命令</h2><h3 id=\"cd-命令\"><a href=\"#cd-命令\" class=\"headerlink\" title=\"cd 命令\"></a>cd 命令</h3><p>cd(changeDirectory) 命令语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd [目录名]</span><br></pre></td></tr></table></figure>\n\n<p>说明：切换当前目录至 dirName。</p>\n<p><strong>实例</strong>：</p>\n<p>（1）进入要目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /</span><br></pre></td></tr></table></figure>\n\n<p>（2）进入 “home” 目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br></pre></td></tr></table></figure>\n\n<p>（3）进入上一次工作路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd -</span><br></pre></td></tr></table></figure>\n\n<p>（4）把上个命令的参数作为 cd 参数使用。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd !$</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"df-命令\"><a href=\"#df-命令\" class=\"headerlink\" title=\"df 命令\"></a>df 命令</h3><p>显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a 全部文件系统列表</span><br><span class=\"line\">-h 以方便阅读的方式显示信息</span><br><span class=\"line\">-i 显示inode信息</span><br><span class=\"line\">-k 区块为1024字节</span><br><span class=\"line\">-l 只显示本地磁盘</span><br><span class=\"line\">-T 列出文件系统类型</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示磁盘使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -l</span><br></pre></td></tr></table></figure>\n\n<p>（2）以易读方式列出所有文件系统及其类型</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -haT</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"du-命令\"><a href=\"#du-命令\" class=\"headerlink\" title=\"du 命令\"></a>du 命令</h3><p>du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：</p>\n<p>命令格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du [选项] [文件]</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-a 显示目录中所有文件大小</span><br><span class=\"line\">-k 以KB为单位显示文件大小</span><br><span class=\"line\">-m 以MB为单位显示文件大小</span><br><span class=\"line\">-g 以GB为单位显示文件大小</span><br><span class=\"line\">-h 以易读方式显示文件大小</span><br><span class=\"line\">-s 仅显示总计</span><br><span class=\"line\">-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）以易读方式显示文件夹内及子文件夹大小</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -h scf/</span><br></pre></td></tr></table></figure>\n\n<p>（2）以易读方式显示文件夹内所有文件大小</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -ah scf/</span><br></pre></td></tr></table></figure>\n\n<p>（3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -hc test/ scf/</span><br></pre></td></tr></table></figure>\n\n<p>（4）输出当前目录下各个子目录所使用的空间</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">du -hc --max-depth=1 scf/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ls命令\"><a href=\"#ls命令\" class=\"headerlink\" title=\"ls命令\"></a>ls命令</h3><p>就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p>\n<p><strong>常用参数搭配</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -a 列出目录所有文件，包含以.开始的隐藏文件</span><br><span class=\"line\">ls -A 列出除.及..的其它文件</span><br><span class=\"line\">ls -r 反序排列</span><br><span class=\"line\">ls -t 以文件修改时间排序</span><br><span class=\"line\">ls -S 以文件大小排序</span><br><span class=\"line\">ls -h 以易读大小显示</span><br><span class=\"line\">ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>(1) 按易读方式按时间反序排序，并显示文件详细信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lhrt</span><br></pre></td></tr></table></figure>\n\n<p>(2) 按大小反序显示文件详细信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -lrS</span><br></pre></td></tr></table></figure>\n\n<p>(3)列出当前目录中所有以”t”开头的目录的详细内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l t*</span><br></pre></td></tr></table></figure>\n\n<p>(4) 列出文件绝对路径（不包含隐藏文件）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls | sed &quot;s:^:`pwd`/:&quot;</span><br></pre></td></tr></table></figure>\n\n<p>(5) 列出文件绝对路径（包含隐藏文件）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find $pwd -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mkdir-命令\"><a href=\"#mkdir-命令\" class=\"headerlink\" title=\"mkdir 命令\"></a>mkdir 命令</h3><p>mkdir 命令用于创建文件夹。</p>\n<p>可用选项：</p>\n<ul>\n<li><strong>-m</strong>: 对新建目录设置存取权限，也可以用 chmod 命令设置;</li>\n<li><strong>-p</strong>: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。</li>\n</ul>\n<p><strong>实例</strong>：</p>\n<p>（1）当前工作目录下创建名为 t 的文件夹</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir t</span><br></pre></td></tr></table></figure>\n\n<p>（2）在 tmp 目录下创建路径为 test&#x2F;t1&#x2F;t 的目录，若不存在，则创建：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /tmp/test/t1/t</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"pwd-命令\"><a href=\"#pwd-命令\" class=\"headerlink\" title=\"pwd 命令\"></a>pwd 命令</h3><p>pwd 命令用于查看当前工作目录路径。</p>\n<p><strong>实例</strong>：</p>\n<p>（1）查看当前路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看软链接的实际路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwd -P</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rmdir-命令\"><a href=\"#rmdir-命令\" class=\"headerlink\" title=\"rmdir 命令\"></a>rmdir 命令</h3><p>从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。</p>\n<p><strong>注意</strong>：不能删除非空目录</p>\n<p><strong>实例</strong>：</p>\n<p>（1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir -p parent/child/child11</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"网络通讯命令\"><a href=\"#网络通讯命令\" class=\"headerlink\" title=\"网络通讯命令\"></a>网络通讯命令</h2><h3 id=\"ifconfig-命令\"><a href=\"#ifconfig-命令\" class=\"headerlink\" title=\"ifconfig 命令\"></a>ifconfig 命令</h3><ul>\n<li>ifconfig 用于查看和配置 Linux 系统的网络接口。</li>\n<li>查看所有网络接口及其状态：<code>ifconfig -a</code> 。</li>\n<li>使用 up 和 down 命令启动或停止某个接口：<code>ifconfig eth0 up</code> 和 <code>ifconfig eth0 down</code> 。</li>\n</ul>\n<h3 id=\"iptables-命令\"><a href=\"#iptables-命令\" class=\"headerlink\" title=\"iptables 命令\"></a>iptables 命令</h3><p>iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。例如：</p>\n<ul>\n<li><p>把来源 IP 为 192.168.1.101 访问本机 80 端口的包直接拒绝：<code>iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT</code> 。</p>\n</li>\n<li><p>开启 80 端口，因为 web 对外都是这个端口</p>\n  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -A INPUT -p tcp --dport 80 -j ACCEP</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外，要注意使用 <code>iptables save</code> 命令，进行保存。否则，服务器重启后，配置的规则将丢失。</p>\n</li>\n</ul>\n<h3 id=\"netstat-命令\"><a href=\"#netstat-命令\" class=\"headerlink\" title=\"netstat 命令\"></a>netstat 命令</h3><p>Linux netstat 命令用于显示网络状态。</p>\n<p>利用 netstat 指令可让你得知整个 Linux 系统的网络情况。</p>\n<p>语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>-a 或–all 显示所有连线中的 Socket。</li>\n<li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址。</li>\n<li>-c 或–continuous 持续列出网络状态。</li>\n<li>-C 或–cache 显示路由器配置的快取信息。</li>\n<li>-e 或–extend 显示网络其他相关信息。</li>\n<li>-F 或–fib 显示 FIB。</li>\n<li>-g 或–groups 显示多重广播功能群组组员名单。</li>\n<li>-h 或–help 在线帮助。</li>\n<li>-i 或–interfaces 显示网络界面信息表单。</li>\n<li>-l 或–listening 显示监控中的服务器的 Socket。</li>\n<li>-M 或–masquerade 显示伪装的网络连线。</li>\n<li>-n 或–numeric 直接使用 IP 地址，而不通过域名服务器。</li>\n<li>-N 或–netlink 或–symbolic 显示网络硬件外围设备的符号连接名称。</li>\n<li>-o 或–timers 显示计时器。</li>\n<li>-p 或–programs 显示正在使用 Socket 的程序识别码和程序名称。</li>\n<li>-r 或–route 显示 Routing Table。</li>\n<li>-s 或–statistice 显示网络工作信息统计表。</li>\n<li>-t 或–tcp 显示 TCP 传输协议的连线状况。</li>\n<li>-u 或–udp 显示 UDP 传输协议的连线状况。</li>\n<li>-v 或–verbose 显示指令执行过程。</li>\n<li>-V 或–version 显示版本信息。</li>\n<li>-w 或–raw 显示 RAW 传输协议的连线状况。</li>\n<li>-x 或–unix 此参数的效果和指定”-A unix”参数相同。</li>\n<li>–ip 或–inet 此参数的效果和指定”-A inet”参数相同。</li>\n</ul>\n<p><strong>实例</strong></p>\n<p><strong>如何查看系统都开启了哪些端口？</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@centos6 ~ 13:20 #55]# netstat -lnp</span><br><span class=\"line\">Active Internet connections (only servers)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address               Foreign Address             State       PID/Program name</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN      1035/sshd</span><br><span class=\"line\">tcp        0      0 :::22                       :::*                        LISTEN      1035/sshd</span><br><span class=\"line\">udp        0      0 0.0.0.0:68                  0.0.0.0:*                               931/dhclient</span><br><span class=\"line\">Active UNIX domain sockets (only servers)</span><br><span class=\"line\">Proto RefCnt Flags       Type       State         I-Node PID/Program name    Path</span><br><span class=\"line\">unix  2      [ ACC ]     STREAM     LISTENING     6825   1/init              @/com/ubuntu/upstart</span><br><span class=\"line\">unix  2      [ ACC ]     STREAM     LISTENING     8429   1003/dbus-daemon    /var/run/dbus/system_bus_socket</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何查看网络连接状况？</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@centos6 ~ 13:22 #58]# netstat -an</span><br><span class=\"line\">Active Internet connections (servers and established)</span><br><span class=\"line\">Proto Recv-Q Send-Q Local Address               Foreign Address             State</span><br><span class=\"line\">tcp        0      0 0.0.0.0:22                  0.0.0.0:*                   LISTEN</span><br><span class=\"line\">tcp        0      0 192.168.147.130:22          192.168.147.1:23893         ESTABLISHED</span><br><span class=\"line\">tcp        0      0 :::22                       :::*                        LISTEN</span><br><span class=\"line\">udp        0      0 0.0.0.0:68                  0.0.0.0:*</span><br></pre></td></tr></table></figure>\n\n<p><strong>如何统计系统当前进程连接数？</strong></p>\n<ul>\n<li>输入命令 <code>netstat -an | grep ESTABLISHED | wc -l</code> 。</li>\n<li>输出结果 <code>177</code> 。一共有 177 连接数。</li>\n</ul>\n<p><strong>用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 ESTABLISHED 状态链接的个数？</strong></p>\n<blockquote>\n<p>严格来说，这个题目考验的是对 awk 的使用。</p>\n</blockquote>\n<p>首先，使用 <code>netstat -an|grep ESTABLISHED</code> 命令。结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tcp        0      0 120.27.146.122:80       113.65.18.33:62721      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:80       27.43.83.115:47148      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:58838    106.39.162.96:443       ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:52304    203.208.40.121:443      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:33194    203.208.40.122:443      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:53758    101.37.183.144:443      ESTABLISHED</span><br><span class=\"line\">tcp        0      0 120.27.146.122:27017    23.105.193.30:50556     ESTABLISHED</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ping-命令\"><a href=\"#ping-命令\" class=\"headerlink\" title=\"ping 命令\"></a>ping 命令</h3><p>Linux ping 命令用于检测主机。</p>\n<p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>\n<p>指定接收包的次数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ping -c 2 www.baidu.com</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"telnet-命令\"><a href=\"#telnet-命令\" class=\"headerlink\" title=\"telnet 命令\"></a>telnet 命令</h3><p>Linux telnet 命令用于远端登入。</p>\n<p>执行 telnet 指令开启终端机阶段作业，并登入远端主机。</p>\n<p>语法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet [-8acdEfFKLrx][-b&lt;主机别名&gt;][-e&lt;脱离字符&gt;][-k&lt;域名&gt;][-l&lt;用户名称&gt;][-n&lt;记录文件&gt;][-S&lt;服务类型&gt;][-X&lt;认证形态&gt;][主机名称或IP地址&lt;通信端口&gt;]</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>-8 允许使用 8 位字符资料，包括输入与输出。</li>\n<li>-a 尝试自动登入远端系统。</li>\n<li>-b&lt;主机别名&gt; 使用别名指定远端主机名称。</li>\n<li>-c 不读取用户专属目录里的.telnetrc 文件。</li>\n<li>-d 启动排错模式。</li>\n<li>-e&lt;脱离字符&gt; 设置脱离字符。</li>\n<li>-E 滤除脱离字符。</li>\n<li>-f 此参数的效果和指定”-F”参数相同。</li>\n<li>-F 使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机。</li>\n<li>-k&lt;域名&gt; 使用 Kerberos 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</li>\n<li>-K 不自动登入远端主机。</li>\n<li>-l&lt;用户名称&gt; 指定要登入远端主机的用户名称。</li>\n<li>-L 允许输出 8 位字符资料。</li>\n<li>-n&lt;记录文件&gt; 指定文件记录相关信息。</li>\n<li>-r 使用类似 rlogin 指令的用户界面。</li>\n<li>-S&lt;服务类型&gt; 设置 telnet 连线所需的 IP TOS 信息。</li>\n<li>-x 假设主机有支持数据加密的功能，就使用它。</li>\n<li>-X&lt;认证形态&gt; 关闭指定的认证形态。</li>\n</ul>\n<p><strong>实例</strong></p>\n<p>登录远程主机</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">登录IP为 192.168.0.5 的远程主机</span></span><br><span class=\"line\">telnet 192.168.0.5 </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"系统管理命令\"><a href=\"#系统管理命令\" class=\"headerlink\" title=\"系统管理命令\"></a>系统管理命令</h2><h3 id=\"date-命令\"><a href=\"#date-命令\" class=\"headerlink\" title=\"date 命令\"></a>date 命令</h3><p>显示或设定系统的日期与时间。</p>\n<p>命令参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-d&lt;字符串&gt; 　显示字符串所指的日期与时间。字符串前后必须加上双引号。</span><br><span class=\"line\">-s&lt;字符串&gt; 　根据字符串来设置日期与时间。字符串前后必须加上双引号。</span><br><span class=\"line\">-u 　显示GMT。</span><br><span class=\"line\">%H 小时(00-23)</span><br><span class=\"line\">%I 小时(00-12)</span><br><span class=\"line\">%M 分钟(以00-59来表示)</span><br><span class=\"line\">%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。</span><br><span class=\"line\">%S 秒(以本地的惯用法来表示)</span><br><span class=\"line\">%a 星期的缩写。</span><br><span class=\"line\">%A 星期的完整名称。</span><br><span class=\"line\">%d 日期(以01-31来表示)。</span><br><span class=\"line\">%D 日期(含年月日)。</span><br><span class=\"line\">%m 月份(以01-12来表示)。</span><br><span class=\"line\">%y 年份(以00-99来表示)。</span><br><span class=\"line\">%Y 年份(以四位数来表示)。</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示下一天</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date +%Y%m%d --date=&quot;+1 day&quot;  //显示下一天的日期</span><br></pre></td></tr></table></figure>\n\n<p>（2）-d 参数使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">date -d &quot;nov 22&quot;  今年的 11 月 22 日是星期三</span><br><span class=\"line\">date -d &#x27;2 weeks&#x27; 2周后的日期</span><br><span class=\"line\">date -d &#x27;next monday&#x27; (下周一的日期)</span><br><span class=\"line\">date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d</span><br><span class=\"line\">date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d</span><br><span class=\"line\">date -d last-month +%Y%m(上个月是几月)</span><br><span class=\"line\">date -d next-month +%Y%m(下个月是几月)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"free-命令\"><a href=\"#free-命令\" class=\"headerlink\" title=\"free 命令\"></a>free 命令</h3><p>显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p>\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-b 以Byte显示内存使用情况</span><br><span class=\"line\">-k 以kb为单位显示内存使用情况</span><br><span class=\"line\">-m 以mb为单位显示内存使用情况</span><br><span class=\"line\">-g 以gb为单位显示内存使用情况</span><br><span class=\"line\">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class=\"line\">-t 显示内存使用总合</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示内存使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free</span><br><span class=\"line\">free -k</span><br><span class=\"line\">free -m</span><br></pre></td></tr></table></figure>\n\n<p>（2）以总和的形式显示内存的使用信息</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -t</span><br></pre></td></tr></table></figure>\n\n<p>（3）周期性查询内存使用情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">free -s 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"kill-命令\"><a href=\"#kill-命令\" class=\"headerlink\" title=\"kill 命令\"></a>kill 命令</h3><p>发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用”-KILL” 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class=\"line\">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class=\"line\">-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class=\"line\">-s  指定发送信号</span><br><span class=\"line\">-u  指定用户</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）先使用 ps 查找进程 pro1，然后用 kill 杀掉</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -9 $(ps -ef | grep pro1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ps-命令\"><a href=\"#ps-命令\" class=\"headerlink\" title=\"ps 命令\"></a>ps 命令</h3><p>ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top</p>\n<p>linux 上进程有 5 种状态:</p>\n<ol>\n<li>运行(正在运行或在运行队列中等待)</li>\n<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>\n<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>\n<li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)</li>\n<li>停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行)</li>\n</ol>\n<p>ps 工具标识进程的 5 种状态码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D 不可中断 uninterruptible sleep (usually IO)</span><br><span class=\"line\">R 运行 runnable (on run queue)</span><br><span class=\"line\">S 中断 sleeping</span><br><span class=\"line\">T 停止 traced or stopped</span><br><span class=\"line\">Z 僵死 a defunct (”zombie”) process</span><br></pre></td></tr></table></figure>\n\n<p><strong>命令参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A 显示所有进程</span><br><span class=\"line\">a 显示所有进程</span><br><span class=\"line\">-a 显示同一终端下所有进程</span><br><span class=\"line\">c 显示进程真实名称</span><br><span class=\"line\">e 显示环境变量</span><br><span class=\"line\">f 显示进程间的关系</span><br><span class=\"line\">r 显示当前终端运行的进程</span><br><span class=\"line\">-aux 显示所有包含其它使用的进程</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）显示当前所有进程环境变量及进程间关系</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef</span><br></pre></td></tr></table></figure>\n\n<p>（2）显示当前所有进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -A</span><br></pre></td></tr></table></figure>\n\n<p>（3）与 grep 联用查找某进程</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep apache</span><br></pre></td></tr></table></figure>\n\n<p>（4）找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux | grep &#x27;(cron|syslog)&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rpm-命令\"><a href=\"#rpm-命令\" class=\"headerlink\" title=\"rpm 命令\"></a>rpm 命令</h3><p>Linux rpm 命令用于管理套件。</p>\n<p>rpm(redhat package manager) 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看系统自带jdk</span></span><br><span class=\"line\">rpm -qa | grep jdk</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除系统自带jdk</span></span><br><span class=\"line\">rpm -e --nodeps 查看jdk显示的数据</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">安装jdk</span></span><br><span class=\"line\">rpm -ivh jdk-7u80-linux-x64.rpm</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"top-命令\"><a href=\"#top-命令\" class=\"headerlink\" title=\"top 命令\"></a>top 命令</h3><p>显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 显示完整的进程命令</span><br><span class=\"line\">-s 保密模式</span><br><span class=\"line\">-p &lt;进程号&gt; 指定进程显示</span><br><span class=\"line\">-n &lt;次数&gt;循环显示次数</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35</span><br><span class=\"line\">Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie</span><br><span class=\"line\">Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st</span><br><span class=\"line\">Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers</span><br><span class=\"line\">Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached</span><br><span class=\"line\">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  </span><br><span class=\"line\">28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java  </span><br></pre></td></tr></table></figure>\n\n<p>前五行是当前系统情况整体的统计信息区。</p>\n<p><strong>第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下</strong>：</p>\n<p>14:06:23 — 当前系统时间</p>\n<p>up 70 days, 16:44 — 系统已经运行了 70 天 16 小时 44 分钟（在这期间系统没有重启过的吆！）</p>\n<p>2 users — 当前有 2 个用户登录系统</p>\n<p>load average: 1.15, 1.42, 1.44 — load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。</p>\n<p>load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。</p>\n<p><strong>第二行，Tasks — 任务（进程），具体信息说明如下</strong>：</p>\n<p>系统现在共有 206 个进程，其中处于运行中的有 1 个，205 个在休眠（sleep），stoped 状态的有 0 个，zombie 状态（僵尸）的有 0 个。</p>\n<p><strong>第三行，cpu状态信息，具体属性说明如下</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5.9%us — 用户空间占用CPU的百分比。</span><br><span class=\"line\">3.4% sy — 内核空间占用CPU的百分比。</span><br><span class=\"line\">0.0% ni — 改变过优先级的进程占用CPU的百分比</span><br><span class=\"line\">90.4% id — 空闲CPU百分比</span><br><span class=\"line\">0.0% wa — IO等待占用CPU的百分比</span><br><span class=\"line\">0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</span><br><span class=\"line\">0.2% si — 软中断（Software Interrupts）占用CPU的百分比</span><br></pre></td></tr></table></figure>\n\n<p><strong>备注</strong>：在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！</p>\n<p>第四行，内存状态，具体信息如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32949016k total — 物理内存总量（32GB）</span><br><span class=\"line\">14411180k used — 使用中的内存总量（14GB）</span><br><span class=\"line\">18537836k free — 空闲内存总量（18GB）</span><br><span class=\"line\">169884k buffers — 缓存的内存量 （169M）</span><br></pre></td></tr></table></figure>\n\n<p><strong>第五行，swap交换分区信息，具体信息说明如下</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32764556k total — 交换区总量（32GB）</span><br><span class=\"line\">0k used — 使用的交换区总量（0K）</span><br><span class=\"line\">32764556k free — 空闲交换区总量（32GB）</span><br><span class=\"line\">3612636k cached — 缓冲的交换区总量（3.6GB）</span><br></pre></td></tr></table></figure>\n\n<p><strong>第六行，空行。</strong></p>\n<p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PID — 进程id</span><br><span class=\"line\">USER — 进程所有者</span><br><span class=\"line\">PR — 进程优先级</span><br><span class=\"line\">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class=\"line\">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class=\"line\">RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class=\"line\">SHR — 共享内存大小，单位kb</span><br><span class=\"line\">S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class=\"line\">%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class=\"line\">%MEM — 进程使用的物理内存百分比</span><br><span class=\"line\">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class=\"line\">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure>\n\n<p><strong>top 交互命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h 显示top交互命令帮助信息</span><br><span class=\"line\">c 切换显示命令名称和完整命令行</span><br><span class=\"line\">m 以内存使用率排序</span><br><span class=\"line\">P 根据CPU使用百分比大小进行排序</span><br><span class=\"line\">T 根据时间/累计时间进行排序</span><br><span class=\"line\">W 将当前设置写入~/.toprc文件中</span><br><span class=\"line\">o或者O 改变显示项目的顺序</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yum-命令\"><a href=\"#yum-命令\" class=\"headerlink\" title=\"yum 命令\"></a>yum 命令</h3><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>\n<p>基於 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>\n<p>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>\n<ul>\n<li>1.列出所有可更新的软件清单命令：yum check-update</li>\n<li>2.更新所有软件命令：yum update</li>\n<li>3.仅安装指定的软件命令：yum install <package_name></li>\n<li>4.仅更新指定的软件命令：yum update <package_name></li>\n<li>5.列出所有可安裝的软件清单命令：yum list</li>\n<li>6.删除软件包命令：yum remove <package_name></li>\n<li>7.查找软件包 命令：yum search</li>\n<li>8.清除缓存命令:<ul>\n<li>yum clean packages: 清除缓存目录下的软件包</li>\n<li>yum clean headers: 清除缓存目录下的 headers</li>\n<li>yum clean oldheaders: 清除缓存目录下旧的 headers</li>\n<li>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers</li>\n</ul>\n</li>\n</ul>\n<p><strong>实例</strong></p>\n<p>安装 pam-devel</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@www ~]# yum install pam-devel</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"备份压缩命令\"><a href=\"#备份压缩命令\" class=\"headerlink\" title=\"备份压缩命令\"></a>备份压缩命令</h2><h3 id=\"bzip2-命令\"><a href=\"#bzip2-命令\" class=\"headerlink\" title=\"bzip2 命令\"></a>bzip2 命令</h3><ul>\n<li>创建 <code>*.bz2</code> 压缩文件：<code>bzip2 test.txt</code> 。</li>\n<li>解压 <code>*.bz2</code> 文件：<code>bzip2 -d test.txt.bz2</code> 。</li>\n</ul>\n<h3 id=\"gzip-命令\"><a href=\"#gzip-命令\" class=\"headerlink\" title=\"gzip 命令\"></a>gzip 命令</h3><ul>\n<li>创建一个 <code>*.gz</code> 的压缩文件：<code>gzip test.txt</code> 。</li>\n<li>解压 <code>*.gz</code> 文件：<code>gzip -d test.txt.gz</code> 。</li>\n<li>显示压缩的比率：<code>gzip -l *.gz</code> 。</li>\n</ul>\n<h3 id=\"tar-命令\"><a href=\"#tar-命令\" class=\"headerlink\" title=\"tar 命令\"></a>tar 命令</h3><p>用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。</p>\n<p>弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件</p>\n<p><strong>常用参数</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 建立新的压缩文件</span><br><span class=\"line\">-f 指定压缩文件</span><br><span class=\"line\">-r 添加文件到已经压缩文件包中</span><br><span class=\"line\">-u 添加改了和现有的文件到压缩包中</span><br><span class=\"line\">-x 从压缩包中抽取文件</span><br><span class=\"line\">-t 显示压缩文件中的内容</span><br><span class=\"line\">-z 支持gzip压缩</span><br><span class=\"line\">-j 支持bzip2压缩</span><br><span class=\"line\">-Z 支持compress解压文件</span><br><span class=\"line\">-v 显示操作过程</span><br></pre></td></tr></table></figure>\n\n<p>有关 gzip 及 bzip2 压缩:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz</span><br><span class=\"line\">          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2</span><br><span class=\"line\">       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2</span><br></pre></td></tr></table></figure>\n\n<p><strong>实例</strong>：</p>\n<p>（1）将文件全部打包成 tar 包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -cvf log.tar 1.log,2.log 或tar -cvf log.*</span><br></pre></td></tr></table></figure>\n\n<p>（2）将 &#x2F;etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zcvf /tmp/etc.tar.gz /etc</span><br></pre></td></tr></table></figure>\n\n<p>（3）查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -ztvf /tmp/etc.tar.gz</span><br></pre></td></tr></table></figure>\n\n<p>（4）要压缩打包 &#x2F;home, &#x2F;etc ，但不要 &#x2F;home&#x2F;dmtsai</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"unzip-命令\"><a href=\"#unzip-命令\" class=\"headerlink\" title=\"unzip 命令\"></a>unzip 命令</h3><ul>\n<li>解压 <code>*.zip</code> 文件：<code>unzip test.zip</code> 。</li>\n<li>查看 <code>*.zip</code> 文件的内容：<code>unzip -l jasper.zip</code> 。</li>\n</ul>"},{"title":"Mac安装MySQL以及Sequel Pro配置与连接","copyright":true,"mathjax":false,"toc":false,"date":"2023-02-11T02:23:54.000Z","urlname":"mysql-sequel-pro","_content":"\n本文介绍在 Mac 上安装 MySQL 以及使用 Sequel Pro 作为可视化客户端的配置与连接。<!--more-->\n\n1、安装 MySQL\n\n可以在官网下载 .dmg 文件进行安装也可以使用 homebrew 安装 MySQL，以下使用 homebrew 安装。\n\n```sh\nbrew install mysql\n```\n\n注意：设置密码的时候设置的不要太简单，要包含字母、数字、字符（太简单的话后续出问题还要再重新改成一个复杂的）\n\n2、下载 Sequel Pro \n\nSequel Pro下载地址：http://www.sequelpro.com/\n\n下载安装后，出现连接界面，填入信息，此时可能报错 Connection failed MySQL said: Authentication plug ... cannot be loaded ...\n\n解决方法如下：\n\n用终端连接MySQL，然后执行以下命令：\n\n```bash\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '此处填写设置的MySQL密码';\n```\n\n如果报错显示密码简单，则通过以下方式修改密码：\n\n```sh\nmysqladmin -u用户名 -p旧密码 password 新密码 \n```\n\n然后重新执行第一条命令，Sequel Pro 可以正常连接。\n\nP.S. 本机 Sequel Pro 导入 SQL 建表语句 loading 过久，不好用，不如使用 IDEA 自带的数据库工具，或者可以使用 Jet 家的 DataGrip。\n","source":"_posts/Mac安装MySQL以及Sequel-Pro配置与连接.md","raw":"---\ntitle: Mac安装MySQL以及Sequel Pro配置与连接\ncopyright: true\nmathjax: false\ncategories:\n  - Mac开发环境配置\ntoc: false\ndate: 2023-02-11 10:23:54\ntags:\nurlname: mysql-sequel-pro\n---\n\n本文介绍在 Mac 上安装 MySQL 以及使用 Sequel Pro 作为可视化客户端的配置与连接。<!--more-->\n\n1、安装 MySQL\n\n可以在官网下载 .dmg 文件进行安装也可以使用 homebrew 安装 MySQL，以下使用 homebrew 安装。\n\n```sh\nbrew install mysql\n```\n\n注意：设置密码的时候设置的不要太简单，要包含字母、数字、字符（太简单的话后续出问题还要再重新改成一个复杂的）\n\n2、下载 Sequel Pro \n\nSequel Pro下载地址：http://www.sequelpro.com/\n\n下载安装后，出现连接界面，填入信息，此时可能报错 Connection failed MySQL said: Authentication plug ... cannot be loaded ...\n\n解决方法如下：\n\n用终端连接MySQL，然后执行以下命令：\n\n```bash\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '此处填写设置的MySQL密码';\n```\n\n如果报错显示密码简单，则通过以下方式修改密码：\n\n```sh\nmysqladmin -u用户名 -p旧密码 password 新密码 \n```\n\n然后重新执行第一条命令，Sequel Pro 可以正常连接。\n\nP.S. 本机 Sequel Pro 导入 SQL 建表语句 loading 过久，不好用，不如使用 IDEA 自带的数据库工具，或者可以使用 Jet 家的 DataGrip。\n","slug":"Mac安装MySQL以及Sequel-Pro配置与连接","published":1,"updated":"2023-02-11T04:10:08.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw324000lt9t81a19ajys","content":"<p>本文介绍在 Mac 上安装 MySQL 以及使用 Sequel Pro 作为可视化客户端的配置与连接。<span id=\"more\"></span></p>\n<p>1、安装 MySQL</p>\n<p>可以在官网下载 .dmg 文件进行安装也可以使用 homebrew 安装 MySQL，以下使用 homebrew 安装。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mysql</span><br></pre></td></tr></table></figure>\n\n<p>注意：设置密码的时候设置的不要太简单，要包含字母、数字、字符（太简单的话后续出问题还要再重新改成一个复杂的）</p>\n<p>2、下载 Sequel Pro </p>\n<p>Sequel Pro下载地址：<a href=\"http://www.sequelpro.com/\">http://www.sequelpro.com/</a></p>\n<p>下载安装后，出现连接界面，填入信息，此时可能报错 Connection failed MySQL said: Authentication plug … cannot be loaded …</p>\n<p>解决方法如下：</p>\n<p>用终端连接MySQL，然后执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; ALTER USER <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class=\"string\">&#x27;此处填写设置的MySQL密码&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果报错显示密码简单，则通过以下方式修改密码：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqladmin -u用户名 -p旧密码 password 新密码 </span><br></pre></td></tr></table></figure>\n\n<p>然后重新执行第一条命令，Sequel Pro 可以正常连接。</p>\n<p>P.S. 本机 Sequel Pro 导入 SQL 建表语句 loading 过久，不好用，不如使用 IDEA 自带的数据库工具，或者可以使用 Jet 家的 DataGrip。</p>\n","site":{"data":{}},"length":619,"excerpt":"<p>本文介绍在 Mac 上安装 MySQL 以及使用 Sequel Pro 作为可视化客户端的配置与连接。","more":"</p>\n<p>1、安装 MySQL</p>\n<p>可以在官网下载 .dmg 文件进行安装也可以使用 homebrew 安装 MySQL，以下使用 homebrew 安装。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install mysql</span><br></pre></td></tr></table></figure>\n\n<p>注意：设置密码的时候设置的不要太简单，要包含字母、数字、字符（太简单的话后续出问题还要再重新改成一个复杂的）</p>\n<p>2、下载 Sequel Pro </p>\n<p>Sequel Pro下载地址：<a href=\"http://www.sequelpro.com/\">http://www.sequelpro.com/</a></p>\n<p>下载安装后，出现连接界面，填入信息，此时可能报错 Connection failed MySQL said: Authentication plug … cannot be loaded …</p>\n<p>解决方法如下：</p>\n<p>用终端连接MySQL，然后执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; ALTER USER <span class=\"string\">&#x27;root&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class=\"string\">&#x27;此处填写设置的MySQL密码&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果报错显示密码简单，则通过以下方式修改密码：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysqladmin -u用户名 -p旧密码 password 新密码 </span><br></pre></td></tr></table></figure>\n\n<p>然后重新执行第一条命令，Sequel Pro 可以正常连接。</p>\n<p>P.S. 本机 Sequel Pro 导入 SQL 建表语句 loading 过久，不好用，不如使用 IDEA 自带的数据库工具，或者可以使用 Jet 家的 DataGrip。</p>"},{"title":"Typora配置阿里云OSS图床","copyright":true,"mathjax":true,"date":"2022-12-12T14:11:09.000Z","urlname":"image-host","_content":"\n在我们日常使用 Typora 写文档时，一般图片都是放在本地的一个相对路径下，如果将 markdown 文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown 文件中使用该链接访问图片。在本文中我们使用 Typora + PicGo + 阿里云 OSS 图床实现图片自动上传并自由访问。\n\n<!--more-->\n\n## 下载 Typora\n\n[Typora官网](https://typora.io/) 官网拉到最下，点击 [History Releases](https://typora.io/releases/all)，选择 Dev/Beta Releases，拉到最下 More Beta,\n\n选择对应系统的链接 [old Windows / Linux beta](https://typora.io/windows/dev_release.html)，[old macOS beta](https://typora.io/dev_release.html)\n\nWindows x64：[Download old version (Windows x64)](https://download.typora.io/windows/typora-update-x64-1016.exe)\n\nMac OS：[Download v0.11.18](https://download.typora.io/mac/Typora-0.11.18.dmg)\n\n## 常用设置\n\n### 通用\n\n1. 打开自动保存\n2. 关闭自动检查更新\n3. 关闭发送匿名使用数据\n\n### 外观\n\n1. 自定义字体\n\n2. 勾选侧边栏大纲视图折叠和展开\n\n3. 配置 Next 主题\n\n\t1. 官网：https://theme.typora.io/theme/NexT/\n\n\t2. 下载 zip 压缩包：[typora-theme-next.zip](https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip)\n\n\t3. Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹`xxx`\n\n\t4. 把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹`xxx`下\n\t5. 重启 Typora，设置外观选择 Next 即可\n\t6. 如果感觉页面宽度太小，可以打开 next.css，搜索并配置 max-width\n\t7. 如果感觉整体页面偏小，可以`Ctrl Shift +/-`增大/减小整体页面\n\n### 编辑器\n\n1. 设置默认换行符\n2. 取消拼写检查，勾选`不使用拼写检查`\n\n### 图像\n\n1. 插入图片时\n\n\t选择上传图片，勾选`对本地位置的图片应用上述规则`和`对网络位置的图片应用上述规则`\n\n2. 上传服务设定\n\n\t接下来会具体讲到图床的配置\n\n### Markdown\n\n1. 勾选显示代码块行号\n\n## 图床配置\n\n### 1、安装PicGo\n\n下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在 PicGo 中打开 PicGo 设置，找到设置 Server，点击设置，点击开启 Server，点击确定即可。\n\n### 2、配置Typora\n\n文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择 picgo.app，选择 picgo 的安装路径，验证图片上传选项\n\n### 3、阿里云OSS搭建图床\n\n#### 3.1、开通阿里云对象存储\n\n开通阿里云对象存储https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台\n\n#### 3.2、创建bucket\n\n- 在左侧选择概览，然后在右侧 Bucket 管理中创建一个新的 bucket\n\n- 创建 Bucket 具体配置\n\n\t> Bucket名字不能有大写字母、地域就近选择、存储类型选择`标准存储`，读写权限`公共读`\n\n- 创建成功后，可以在 Bucket 列表中查看，记住自己的访问域名和地域节点，后面会用到。\n\n#### 3.3、创建AccessKey\n\n页面右上角，鼠标放在头像处，在弹出的框里选择 AccessKey 管理，在弹出的选项框里，选择`继续使用AccessKey`。\n\n进入后，创建一个`AccessKey`。\n\n在弹出的界面里，记住你的`accessKeyId`和`accessKeySecret`。\n\n#### 3.4、了解收费标准\n\n使用默认的 0.12 元/1GB/1 个月即可。\n\n### 4、配置PicGo\n\n我们打开打开 PicGo 的主界面,在图床设置里面选择阿里云 OSS，依照下面注意事项填写信息。\n\n设定 Keyld：填写我们在第三步中获得的 AccessKeyID\n\n设定 KeySecret：填写我们在第三步中获得的 AccessKeyIDSecret\n\n设定储存空间名：填写我们在第二步中填写的 bucket 名称\n\n确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制 oss-cn-Xxxx 即可，不需要后面的.aliyuncs.com\n\n### 5、测试使用\n\n经过上面的一系列配置之后，我们就完成了 Typora 的图床配置，现在我们可以使用 Markdown 开始写文章了，图片、截图会在粘贴之后，自动通过 PicGo 上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。\n\n## 参考\n\nhttps://blog.csdn.net/qq_51808107/article/details/124044961\n","source":"_posts/Typora配置阿里云OSS图床.md","raw":"---\ntitle: Typora配置阿里云OSS图床\ncopyright: true\nmathjax: true\ndate: 2022-12-12 22:11:09\ncategories: 技术总结\ntags: \nurlname: image-host\n---\n\n在我们日常使用 Typora 写文档时，一般图片都是放在本地的一个相对路径下，如果将 markdown 文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown 文件中使用该链接访问图片。在本文中我们使用 Typora + PicGo + 阿里云 OSS 图床实现图片自动上传并自由访问。\n\n<!--more-->\n\n## 下载 Typora\n\n[Typora官网](https://typora.io/) 官网拉到最下，点击 [History Releases](https://typora.io/releases/all)，选择 Dev/Beta Releases，拉到最下 More Beta,\n\n选择对应系统的链接 [old Windows / Linux beta](https://typora.io/windows/dev_release.html)，[old macOS beta](https://typora.io/dev_release.html)\n\nWindows x64：[Download old version (Windows x64)](https://download.typora.io/windows/typora-update-x64-1016.exe)\n\nMac OS：[Download v0.11.18](https://download.typora.io/mac/Typora-0.11.18.dmg)\n\n## 常用设置\n\n### 通用\n\n1. 打开自动保存\n2. 关闭自动检查更新\n3. 关闭发送匿名使用数据\n\n### 外观\n\n1. 自定义字体\n\n2. 勾选侧边栏大纲视图折叠和展开\n\n3. 配置 Next 主题\n\n\t1. 官网：https://theme.typora.io/theme/NexT/\n\n\t2. 下载 zip 压缩包：[typora-theme-next.zip](https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip)\n\n\t3. Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹`xxx`\n\n\t4. 把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹`xxx`下\n\t5. 重启 Typora，设置外观选择 Next 即可\n\t6. 如果感觉页面宽度太小，可以打开 next.css，搜索并配置 max-width\n\t7. 如果感觉整体页面偏小，可以`Ctrl Shift +/-`增大/减小整体页面\n\n### 编辑器\n\n1. 设置默认换行符\n2. 取消拼写检查，勾选`不使用拼写检查`\n\n### 图像\n\n1. 插入图片时\n\n\t选择上传图片，勾选`对本地位置的图片应用上述规则`和`对网络位置的图片应用上述规则`\n\n2. 上传服务设定\n\n\t接下来会具体讲到图床的配置\n\n### Markdown\n\n1. 勾选显示代码块行号\n\n## 图床配置\n\n### 1、安装PicGo\n\n下载地址：https://github.com/Molunerfinn/PicGo/releases\n\n安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在 PicGo 中打开 PicGo 设置，找到设置 Server，点击设置，点击开启 Server，点击确定即可。\n\n### 2、配置Typora\n\n文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择 picgo.app，选择 picgo 的安装路径，验证图片上传选项\n\n### 3、阿里云OSS搭建图床\n\n#### 3.1、开通阿里云对象存储\n\n开通阿里云对象存储https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台\n\n#### 3.2、创建bucket\n\n- 在左侧选择概览，然后在右侧 Bucket 管理中创建一个新的 bucket\n\n- 创建 Bucket 具体配置\n\n\t> Bucket名字不能有大写字母、地域就近选择、存储类型选择`标准存储`，读写权限`公共读`\n\n- 创建成功后，可以在 Bucket 列表中查看，记住自己的访问域名和地域节点，后面会用到。\n\n#### 3.3、创建AccessKey\n\n页面右上角，鼠标放在头像处，在弹出的框里选择 AccessKey 管理，在弹出的选项框里，选择`继续使用AccessKey`。\n\n进入后，创建一个`AccessKey`。\n\n在弹出的界面里，记住你的`accessKeyId`和`accessKeySecret`。\n\n#### 3.4、了解收费标准\n\n使用默认的 0.12 元/1GB/1 个月即可。\n\n### 4、配置PicGo\n\n我们打开打开 PicGo 的主界面,在图床设置里面选择阿里云 OSS，依照下面注意事项填写信息。\n\n设定 Keyld：填写我们在第三步中获得的 AccessKeyID\n\n设定 KeySecret：填写我们在第三步中获得的 AccessKeyIDSecret\n\n设定储存空间名：填写我们在第二步中填写的 bucket 名称\n\n确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制 oss-cn-Xxxx 即可，不需要后面的.aliyuncs.com\n\n### 5、测试使用\n\n经过上面的一系列配置之后，我们就完成了 Typora 的图床配置，现在我们可以使用 Markdown 开始写文章了，图片、截图会在粘贴之后，自动通过 PicGo 上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。\n\n## 参考\n\nhttps://blog.csdn.net/qq_51808107/article/details/124044961\n","slug":"Typora配置阿里云OSS图床","published":1,"updated":"2023-01-26T12:35:58.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw324000ot9t8gyptfx3q","content":"<p>在我们日常使用 Typora 写文档时，一般图片都是放在本地的一个相对路径下，如果将 markdown 文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown 文件中使用该链接访问图片。在本文中我们使用 Typora + PicGo + 阿里云 OSS 图床实现图片自动上传并自由访问。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"下载-Typora\"><a href=\"#下载-Typora\" class=\"headerlink\" title=\"下载 Typora\"></a>下载 Typora</h2><p><a href=\"https://typora.io/\">Typora官网</a> 官网拉到最下，点击 <a href=\"https://typora.io/releases/all\">History Releases</a>，选择 Dev/Beta Releases，拉到最下 More Beta,</p>\n<p>选择对应系统的链接 <a href=\"https://typora.io/windows/dev_release.html\">old Windows / Linux beta</a>，<a href=\"https://typora.io/dev_release.html\">old macOS beta</a></p>\n<p>Windows x64：<a href=\"https://download.typora.io/windows/typora-update-x64-1016.exe\">Download old version (Windows x64)</a></p>\n<p>Mac OS：<a href=\"https://download.typora.io/mac/Typora-0.11.18.dmg\">Download v0.11.18</a></p>\n<h2 id=\"常用设置\"><a href=\"#常用设置\" class=\"headerlink\" title=\"常用设置\"></a>常用设置</h2><h3 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h3><ol>\n<li>打开自动保存</li>\n<li>关闭自动检查更新</li>\n<li>关闭发送匿名使用数据</li>\n</ol>\n<h3 id=\"外观\"><a href=\"#外观\" class=\"headerlink\" title=\"外观\"></a>外观</h3><ol>\n<li><p>自定义字体</p>\n</li>\n<li><p>勾选侧边栏大纲视图折叠和展开</p>\n</li>\n<li><p>配置 Next 主题</p>\n<ol>\n<li><p>官网：<a href=\"https://theme.typora.io/theme/NexT/\">https://theme.typora.io/theme/NexT/</a></p>\n</li>\n<li><p>下载 zip 压缩包：<a href=\"https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip\">typora-theme-next.zip</a></p>\n</li>\n<li><p>Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹<code>xxx</code></p>\n</li>\n<li><p>把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹<code>xxx</code>下</p>\n</li>\n<li><p>重启 Typora，设置外观选择 Next 即可</p>\n</li>\n<li><p>如果感觉页面宽度太小，可以打开 next.css，搜索并配置 max-width</p>\n</li>\n<li><p>如果感觉整体页面偏小，可以<code>Ctrl Shift +/-</code>增大/减小整体页面</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><ol>\n<li>设置默认换行符</li>\n<li>取消拼写检查，勾选<code>不使用拼写检查</code></li>\n</ol>\n<h3 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h3><ol>\n<li><p>插入图片时</p>\n<p> 选择上传图片，勾选<code>对本地位置的图片应用上述规则</code>和<code>对网络位置的图片应用上述规则</code></p>\n</li>\n<li><p>上传服务设定</p>\n<p> 接下来会具体讲到图床的配置</p>\n</li>\n</ol>\n<h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><ol>\n<li>勾选显示代码块行号</li>\n</ol>\n<h2 id=\"图床配置\"><a href=\"#图床配置\" class=\"headerlink\" title=\"图床配置\"></a>图床配置</h2><h3 id=\"1、安装PicGo\"><a href=\"#1、安装PicGo\" class=\"headerlink\" title=\"1、安装PicGo\"></a>1、安装PicGo</h3><p>下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">https://github.com/Molunerfinn/PicGo/releases</a></p>\n<p>安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在 PicGo 中打开 PicGo 设置，找到设置 Server，点击设置，点击开启 Server，点击确定即可。</p>\n<h3 id=\"2、配置Typora\"><a href=\"#2、配置Typora\" class=\"headerlink\" title=\"2、配置Typora\"></a>2、配置Typora</h3><p>文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择 picgo.app，选择 picgo 的安装路径，验证图片上传选项</p>\n<h3 id=\"3、阿里云OSS搭建图床\"><a href=\"#3、阿里云OSS搭建图床\" class=\"headerlink\" title=\"3、阿里云OSS搭建图床\"></a>3、阿里云OSS搭建图床</h3><h4 id=\"3-1、开通阿里云对象存储\"><a href=\"#3-1、开通阿里云对象存储\" class=\"headerlink\" title=\"3.1、开通阿里云对象存储\"></a>3.1、开通阿里云对象存储</h4><p>开通阿里云对象存储<a href=\"https://www.aliyun.com/product/oss%EF%BC%8C%E6%B3%A8%E5%86%8C%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%A6%E5%8F%B7%E5%90%8E%EF%BC%8C%E5%BC%80%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0\">https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台</a></p>\n<h4 id=\"3-2、创建bucket\"><a href=\"#3-2、创建bucket\" class=\"headerlink\" title=\"3.2、创建bucket\"></a>3.2、创建bucket</h4><ul>\n<li><p>在左侧选择概览，然后在右侧 Bucket 管理中创建一个新的 bucket</p>\n</li>\n<li><p>创建 Bucket 具体配置</p>\n<blockquote>\n<p>Bucket名字不能有大写字母、地域就近选择、存储类型选择<code>标准存储</code>，读写权限<code>公共读</code></p>\n</blockquote>\n</li>\n<li><p>创建成功后，可以在 Bucket 列表中查看，记住自己的访问域名和地域节点，后面会用到。</p>\n</li>\n</ul>\n<h4 id=\"3-3、创建AccessKey\"><a href=\"#3-3、创建AccessKey\" class=\"headerlink\" title=\"3.3、创建AccessKey\"></a>3.3、创建AccessKey</h4><p>页面右上角，鼠标放在头像处，在弹出的框里选择 AccessKey 管理，在弹出的选项框里，选择<code>继续使用AccessKey</code>。</p>\n<p>进入后，创建一个<code>AccessKey</code>。</p>\n<p>在弹出的界面里，记住你的<code>accessKeyId</code>和<code>accessKeySecret</code>。</p>\n<h4 id=\"3-4、了解收费标准\"><a href=\"#3-4、了解收费标准\" class=\"headerlink\" title=\"3.4、了解收费标准\"></a>3.4、了解收费标准</h4><p>使用默认的 0.12 元/1GB/1 个月即可。</p>\n<h3 id=\"4、配置PicGo\"><a href=\"#4、配置PicGo\" class=\"headerlink\" title=\"4、配置PicGo\"></a>4、配置PicGo</h3><p>我们打开打开 PicGo 的主界面,在图床设置里面选择阿里云 OSS，依照下面注意事项填写信息。</p>\n<p>设定 Keyld：填写我们在第三步中获得的 AccessKeyID</p>\n<p>设定 KeySecret：填写我们在第三步中获得的 AccessKeyIDSecret</p>\n<p>设定储存空间名：填写我们在第二步中填写的 bucket 名称</p>\n<p>确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制 oss-cn-Xxxx 即可，不需要后面的.aliyuncs.com</p>\n<h3 id=\"5、测试使用\"><a href=\"#5、测试使用\" class=\"headerlink\" title=\"5、测试使用\"></a>5、测试使用</h3><p>经过上面的一系列配置之后，我们就完成了 Typora 的图床配置，现在我们可以使用 Markdown 开始写文章了，图片、截图会在粘贴之后，自动通过 PicGo 上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qq_51808107/article/details/124044961\">https://blog.csdn.net/qq_51808107/article/details/124044961</a></p>\n","site":{"data":{}},"length":1802,"excerpt":"<p>在我们日常使用 Typora 写文档时，一般图片都是放在本地的一个相对路径下，如果将 markdown 文件发送给别人，那么这个文件中的图片别人自然是访问不到的。图床的作用就是把图片存在网站上，对应的图片生成一个链接，markdown 文件中使用该链接访问图片。在本文中我们使用 Typora + PicGo + 阿里云 OSS 图床实现图片自动上传并自由访问。</p>","more":"<h2 id=\"下载-Typora\"><a href=\"#下载-Typora\" class=\"headerlink\" title=\"下载 Typora\"></a>下载 Typora</h2><p><a href=\"https://typora.io/\">Typora官网</a> 官网拉到最下，点击 <a href=\"https://typora.io/releases/all\">History Releases</a>，选择 Dev/Beta Releases，拉到最下 More Beta,</p>\n<p>选择对应系统的链接 <a href=\"https://typora.io/windows/dev_release.html\">old Windows / Linux beta</a>，<a href=\"https://typora.io/dev_release.html\">old macOS beta</a></p>\n<p>Windows x64：<a href=\"https://download.typora.io/windows/typora-update-x64-1016.exe\">Download old version (Windows x64)</a></p>\n<p>Mac OS：<a href=\"https://download.typora.io/mac/Typora-0.11.18.dmg\">Download v0.11.18</a></p>\n<h2 id=\"常用设置\"><a href=\"#常用设置\" class=\"headerlink\" title=\"常用设置\"></a>常用设置</h2><h3 id=\"通用\"><a href=\"#通用\" class=\"headerlink\" title=\"通用\"></a>通用</h3><ol>\n<li>打开自动保存</li>\n<li>关闭自动检查更新</li>\n<li>关闭发送匿名使用数据</li>\n</ol>\n<h3 id=\"外观\"><a href=\"#外观\" class=\"headerlink\" title=\"外观\"></a>外观</h3><ol>\n<li><p>自定义字体</p>\n</li>\n<li><p>勾选侧边栏大纲视图折叠和展开</p>\n</li>\n<li><p>配置 Next 主题</p>\n<ol>\n<li><p>官网：<a href=\"https://theme.typora.io/theme/NexT/\">https://theme.typora.io/theme/NexT/</a></p>\n</li>\n<li><p>下载 zip 压缩包：<a href=\"https://github.com/BillChen2k/typora-theme-next/releases/download/1.1.1/typora-theme-next.zip\">typora-theme-next.zip</a></p>\n</li>\n<li><p>Typora 左上角，文件 - 偏好设置 - 外观 - 打开主题文件夹<code>xxx</code></p>\n</li>\n<li><p>把 typora-theme-next.zip 解压，将所有文件复制/剪切到主题文件夹<code>xxx</code>下</p>\n</li>\n<li><p>重启 Typora，设置外观选择 Next 即可</p>\n</li>\n<li><p>如果感觉页面宽度太小，可以打开 next.css，搜索并配置 max-width</p>\n</li>\n<li><p>如果感觉整体页面偏小，可以<code>Ctrl Shift +/-</code>增大/减小整体页面</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"编辑器\"><a href=\"#编辑器\" class=\"headerlink\" title=\"编辑器\"></a>编辑器</h3><ol>\n<li>设置默认换行符</li>\n<li>取消拼写检查，勾选<code>不使用拼写检查</code></li>\n</ol>\n<h3 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h3><ol>\n<li><p>插入图片时</p>\n<p> 选择上传图片，勾选<code>对本地位置的图片应用上述规则</code>和<code>对网络位置的图片应用上述规则</code></p>\n</li>\n<li><p>上传服务设定</p>\n<p> 接下来会具体讲到图床的配置</p>\n</li>\n</ol>\n<h3 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h3><ol>\n<li>勾选显示代码块行号</li>\n</ol>\n<h2 id=\"图床配置\"><a href=\"#图床配置\" class=\"headerlink\" title=\"图床配置\"></a>图床配置</h2><h3 id=\"1、安装PicGo\"><a href=\"#1、安装PicGo\" class=\"headerlink\" title=\"1、安装PicGo\"></a>1、安装PicGo</h3><p>下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">https://github.com/Molunerfinn/PicGo/releases</a></p>\n<p>安装 PicGo-Setup-2.3.0-beta.7-ia32.exe，在 PicGo 中打开 PicGo 设置，找到设置 Server，点击设置，点击开启 Server，点击确定即可。</p>\n<h3 id=\"2、配置Typora\"><a href=\"#2、配置Typora\" class=\"headerlink\" title=\"2、配置Typora\"></a>2、配置Typora</h3><p>文件-偏好设置-图像-设置插入图片时 上传图片-上传服务选择 picgo.app，选择 picgo 的安装路径，验证图片上传选项</p>\n<h3 id=\"3、阿里云OSS搭建图床\"><a href=\"#3、阿里云OSS搭建图床\" class=\"headerlink\" title=\"3、阿里云OSS搭建图床\"></a>3、阿里云OSS搭建图床</h3><h4 id=\"3-1、开通阿里云对象存储\"><a href=\"#3-1、开通阿里云对象存储\" class=\"headerlink\" title=\"3.1、开通阿里云对象存储\"></a>3.1、开通阿里云对象存储</h4><p>开通阿里云对象存储<a href=\"https://www.aliyun.com/product/oss%EF%BC%8C%E6%B3%A8%E5%86%8C%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%A6%E5%8F%B7%E5%90%8E%EF%BC%8C%E5%BC%80%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%82%A8%E5%AD%98%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS%E7%9A%84%E6%8E%A7%E5%88%B6%E5%8F%B0\">https://www.aliyun.com/product/oss，注册阿里云账号后，开通对象储存，进入对象存储OSS的控制台</a></p>\n<h4 id=\"3-2、创建bucket\"><a href=\"#3-2、创建bucket\" class=\"headerlink\" title=\"3.2、创建bucket\"></a>3.2、创建bucket</h4><ul>\n<li><p>在左侧选择概览，然后在右侧 Bucket 管理中创建一个新的 bucket</p>\n</li>\n<li><p>创建 Bucket 具体配置</p>\n<blockquote>\n<p>Bucket名字不能有大写字母、地域就近选择、存储类型选择<code>标准存储</code>，读写权限<code>公共读</code></p>\n</blockquote>\n</li>\n<li><p>创建成功后，可以在 Bucket 列表中查看，记住自己的访问域名和地域节点，后面会用到。</p>\n</li>\n</ul>\n<h4 id=\"3-3、创建AccessKey\"><a href=\"#3-3、创建AccessKey\" class=\"headerlink\" title=\"3.3、创建AccessKey\"></a>3.3、创建AccessKey</h4><p>页面右上角，鼠标放在头像处，在弹出的框里选择 AccessKey 管理，在弹出的选项框里，选择<code>继续使用AccessKey</code>。</p>\n<p>进入后，创建一个<code>AccessKey</code>。</p>\n<p>在弹出的界面里，记住你的<code>accessKeyId</code>和<code>accessKeySecret</code>。</p>\n<h4 id=\"3-4、了解收费标准\"><a href=\"#3-4、了解收费标准\" class=\"headerlink\" title=\"3.4、了解收费标准\"></a>3.4、了解收费标准</h4><p>使用默认的 0.12 元/1GB/1 个月即可。</p>\n<h3 id=\"4、配置PicGo\"><a href=\"#4、配置PicGo\" class=\"headerlink\" title=\"4、配置PicGo\"></a>4、配置PicGo</h3><p>我们打开打开 PicGo 的主界面,在图床设置里面选择阿里云 OSS，依照下面注意事项填写信息。</p>\n<p>设定 Keyld：填写我们在第三步中获得的 AccessKeyID</p>\n<p>设定 KeySecret：填写我们在第三步中获得的 AccessKeyIDSecret</p>\n<p>设定储存空间名：填写我们在第二步中填写的 bucket 名称</p>\n<p>确认存储区域：填写我们在第二步中查看的地域节点，注意复制的格式：只需要复制 oss-cn-Xxxx 即可，不需要后面的.aliyuncs.com</p>\n<h3 id=\"5、测试使用\"><a href=\"#5、测试使用\" class=\"headerlink\" title=\"5、测试使用\"></a>5、测试使用</h3><p>经过上面的一系列配置之后，我们就完成了 Typora 的图床配置，现在我们可以使用 Markdown 开始写文章了，图片、截图会在粘贴之后，自动通过 PicGo 上传到了远端图床。同时也可以手动将以前在本地存储的图片上传到图床上。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/qq_51808107/article/details/124044961\">https://blog.csdn.net/qq_51808107/article/details/124044961</a></p>"},{"title":"关于体制内的一些思考","copyright":true,"mathjax":false,"toc":false,"date":"2023-02-05T02:35:33.000Z","urlname":"about-within-the-system","_content":"\n面临秋招毕业季，进体制内还是体制外无疑是摆在毕业生面前的两个大方向选择。本人秋招以来也经历了类似选择，也谈谈我个人的一些思考。<!--more-->\n\n## 体制内/外的对比\n\n### 工作单位\n\n体制内狭义上指公务员和事业编，广义上的体制内还包含一些泛体制内的单位，比如烟草、电网、银行等国央企。\n\n体制外就是指私企了，互联网行业的话比如 \"BAT\"、\"TMD\"，外企如微软、ZOOM、SAP 等。\n\n### 工作内容、时间、压力\n\n体制内的工作一般都不会很难。公务员一般是写材料、整理材料，事业编根据岗位不同具体工作内容也不同，比如教师编也属于事业编，教师一般除了承担教学任务以外，还要被安排一些杂活；加班一般都不会很多，不过疫情期间很多公务员承担防疫角色，加班情况十分严重，甚至半夜被叫醒去单位搞防疫工作；工作压力一般不会很大，就算完成不了也可以躺平摆烂，毕竟辞退一名体制内人员几乎不可能。\n\n体制外的工作一般而言都是和 OKR、KPI 相关，完成 ld、mt 派发的任务；加班一般比较多，资本主义吸血，996、995、10105、12126，互联网行业加班情况就更严重了；工作压力一般而言比较大，如果部门效益不好，有裁员指标，很容易被裁员，因此得不停的卷。\n\n### 薪资待遇\n\n体制内的薪资待遇比较一般，在当地城市一般属于中等偏上的收入，吃得饱但也吃不好。公务员工资一般高于事业编，好的国央企的薪资待遇也还不错。薪资待遇较好的地区比如苏南、浙北一些城市。体制内最近火热跟房地产发展息息相关，土地财政大大增加了体制内的收入。如今房地产业萎靡的情况下，体制内降薪频繁，未来体制内的薪资待遇还会怎样，我们不得而知。\n\n体制外的薪资待遇无非就是看个人能力和个人机遇了，计算机应届生进入互联网大厂薪资好点的都有35+w年薪，一般的也能拿到20+w，在私企干几年跳槽还能收获不错的薪资涨幅。虽然互联网发展停滞，但是未来仍然有大量的数字化人才需求。\n\n## 选择体制内还是体制外\n\n近年来，由于全球经济发展停滞、行业周期、疫情等各种原因，很多人在私企内混的不是很如意，pua、压迫、裁员。近几年体制内的薪资也增加很多，20 年的深圳高中 40w 招高中老师、余杭区街道办办事员录取的学生都是清北等顶尖高校的硕士生甚至博士生。清华的毕业生就业去向也显示 70% 的学生进入了体制内。\n\n那么，体制内真的就无敌嘛，宇宙的尽头真的是体制内嘛，还是选择体制外打拼打拼闯出自己的一片天呢？\n\n应届生在就业选择时一般都会跟家里人商量，听听父母的看法。于父母而言，父母一般都比较想让孩子进入体制内，我们作为子女应当尊重父母，但是不是完全听从父母，因为他们是那个时代的那些经验，在当今这个时代，要有自己的思想。把自己的生命过好了，过出精彩来，才是对父母最大的尊重，也是父母最大的幸福。\n\n很多人毕业时不知道选择什么，盲目从众，随大流进入体制内，进去之后觉得不是自己想要的。这种情况无非是无法在体制内获得自己想要取得的价值感、成就感。投入过的生命才会有温度，不管是体制内还是体制外，这样才会获得巨大的价值感。\n\n我们的社会、生活一直在发展变化，这个才是一直不变的。做选择一定要看清楚自己想要什么，可以想想自己死去的时候，那时候是一个什么样的身份、什么样的职位，因为这其实就是我们心底的追求，明确自己的追求，体制内还是体制外，往自己的追求上靠近就可以了。体制内还是体制外没有对错，只有适合，适合自己、适合自己的未来发展、适合自己的人生追求。\n\n## 参考\n\n以下是一些我觉得讲的很在理的视频，非劝退性质，看完之后感悟很多。\n\n[不适合就别考公务员了](https://www.bilibili.com/video/BV1JT41117Lx/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[“别瞎混了，公务员才是正经工作”进体制真的香吗？【复旦梁永安】](https://www.bilibili.com/video/BV1Ga4y1p7Tw/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[60万年薪比不上公务员月薪4000？同志们，千万别再高估“体制内”的性价比了！【毯叔盘钱】](https://www.bilibili.com/video/BV1RS4y1d7R9/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[【考编？看这一条就够了】8年！！宇宙尽头真不是编制！！](https://www.bilibili.com/video/BV1CM4y1F7PN/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[537万人考公，500万人失业，宇宙的尽头是考编吗？](https://www.bilibili.com/video/BV1VY4y1A7XM/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a) \n","source":"_posts/关于体制内的一些思考.md","raw":"---\ntitle: 关于体制内的一些思考\ncopyright: true\nmathjax: false\ncategories:\n  - 个人思考\ntoc: false\ndate: 2023-02-05 10:35:33\ntags:\nurlname: about-within-the-system\n---\n\n面临秋招毕业季，进体制内还是体制外无疑是摆在毕业生面前的两个大方向选择。本人秋招以来也经历了类似选择，也谈谈我个人的一些思考。<!--more-->\n\n## 体制内/外的对比\n\n### 工作单位\n\n体制内狭义上指公务员和事业编，广义上的体制内还包含一些泛体制内的单位，比如烟草、电网、银行等国央企。\n\n体制外就是指私企了，互联网行业的话比如 \"BAT\"、\"TMD\"，外企如微软、ZOOM、SAP 等。\n\n### 工作内容、时间、压力\n\n体制内的工作一般都不会很难。公务员一般是写材料、整理材料，事业编根据岗位不同具体工作内容也不同，比如教师编也属于事业编，教师一般除了承担教学任务以外，还要被安排一些杂活；加班一般都不会很多，不过疫情期间很多公务员承担防疫角色，加班情况十分严重，甚至半夜被叫醒去单位搞防疫工作；工作压力一般不会很大，就算完成不了也可以躺平摆烂，毕竟辞退一名体制内人员几乎不可能。\n\n体制外的工作一般而言都是和 OKR、KPI 相关，完成 ld、mt 派发的任务；加班一般比较多，资本主义吸血，996、995、10105、12126，互联网行业加班情况就更严重了；工作压力一般而言比较大，如果部门效益不好，有裁员指标，很容易被裁员，因此得不停的卷。\n\n### 薪资待遇\n\n体制内的薪资待遇比较一般，在当地城市一般属于中等偏上的收入，吃得饱但也吃不好。公务员工资一般高于事业编，好的国央企的薪资待遇也还不错。薪资待遇较好的地区比如苏南、浙北一些城市。体制内最近火热跟房地产发展息息相关，土地财政大大增加了体制内的收入。如今房地产业萎靡的情况下，体制内降薪频繁，未来体制内的薪资待遇还会怎样，我们不得而知。\n\n体制外的薪资待遇无非就是看个人能力和个人机遇了，计算机应届生进入互联网大厂薪资好点的都有35+w年薪，一般的也能拿到20+w，在私企干几年跳槽还能收获不错的薪资涨幅。虽然互联网发展停滞，但是未来仍然有大量的数字化人才需求。\n\n## 选择体制内还是体制外\n\n近年来，由于全球经济发展停滞、行业周期、疫情等各种原因，很多人在私企内混的不是很如意，pua、压迫、裁员。近几年体制内的薪资也增加很多，20 年的深圳高中 40w 招高中老师、余杭区街道办办事员录取的学生都是清北等顶尖高校的硕士生甚至博士生。清华的毕业生就业去向也显示 70% 的学生进入了体制内。\n\n那么，体制内真的就无敌嘛，宇宙的尽头真的是体制内嘛，还是选择体制外打拼打拼闯出自己的一片天呢？\n\n应届生在就业选择时一般都会跟家里人商量，听听父母的看法。于父母而言，父母一般都比较想让孩子进入体制内，我们作为子女应当尊重父母，但是不是完全听从父母，因为他们是那个时代的那些经验，在当今这个时代，要有自己的思想。把自己的生命过好了，过出精彩来，才是对父母最大的尊重，也是父母最大的幸福。\n\n很多人毕业时不知道选择什么，盲目从众，随大流进入体制内，进去之后觉得不是自己想要的。这种情况无非是无法在体制内获得自己想要取得的价值感、成就感。投入过的生命才会有温度，不管是体制内还是体制外，这样才会获得巨大的价值感。\n\n我们的社会、生活一直在发展变化，这个才是一直不变的。做选择一定要看清楚自己想要什么，可以想想自己死去的时候，那时候是一个什么样的身份、什么样的职位，因为这其实就是我们心底的追求，明确自己的追求，体制内还是体制外，往自己的追求上靠近就可以了。体制内还是体制外没有对错，只有适合，适合自己、适合自己的未来发展、适合自己的人生追求。\n\n## 参考\n\n以下是一些我觉得讲的很在理的视频，非劝退性质，看完之后感悟很多。\n\n[不适合就别考公务员了](https://www.bilibili.com/video/BV1JT41117Lx/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[“别瞎混了，公务员才是正经工作”进体制真的香吗？【复旦梁永安】](https://www.bilibili.com/video/BV1Ga4y1p7Tw/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[60万年薪比不上公务员月薪4000？同志们，千万别再高估“体制内”的性价比了！【毯叔盘钱】](https://www.bilibili.com/video/BV1RS4y1d7R9/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[【考编？看这一条就够了】8年！！宇宙尽头真不是编制！！](https://www.bilibili.com/video/BV1CM4y1F7PN/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a)\n\n[537万人考公，500万人失业，宇宙的尽头是考编吗？](https://www.bilibili.com/video/BV1VY4y1A7XM/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a) \n","slug":"关于体制内的一些思考","published":1,"updated":"2023-02-08T07:13:07.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw325000qt9t8fhuraug6","content":"<p>面临秋招毕业季，进体制内还是体制外无疑是摆在毕业生面前的两个大方向选择。本人秋招以来也经历了类似选择，也谈谈我个人的一些思考。<span id=\"more\"></span></p>\n<h2 id=\"体制内-x2F-外的对比\"><a href=\"#体制内-x2F-外的对比\" class=\"headerlink\" title=\"体制内&#x2F;外的对比\"></a>体制内&#x2F;外的对比</h2><h3 id=\"工作单位\"><a href=\"#工作单位\" class=\"headerlink\" title=\"工作单位\"></a>工作单位</h3><p>体制内狭义上指公务员和事业编，广义上的体制内还包含一些泛体制内的单位，比如烟草、电网、银行等国央企。</p>\n<p>体制外就是指私企了，互联网行业的话比如 “BAT”、”TMD”，外企如微软、ZOOM、SAP 等。</p>\n<h3 id=\"工作内容、时间、压力\"><a href=\"#工作内容、时间、压力\" class=\"headerlink\" title=\"工作内容、时间、压力\"></a>工作内容、时间、压力</h3><p>体制内的工作一般都不会很难。公务员一般是写材料、整理材料，事业编根据岗位不同具体工作内容也不同，比如教师编也属于事业编，教师一般除了承担教学任务以外，还要被安排一些杂活；加班一般都不会很多，不过疫情期间很多公务员承担防疫角色，加班情况十分严重，甚至半夜被叫醒去单位搞防疫工作；工作压力一般不会很大，就算完成不了也可以躺平摆烂，毕竟辞退一名体制内人员几乎不可能。</p>\n<p>体制外的工作一般而言都是和 OKR、KPI 相关，完成 ld、mt 派发的任务；加班一般比较多，资本主义吸血，996、995、10105、12126，互联网行业加班情况就更严重了；工作压力一般而言比较大，如果部门效益不好，有裁员指标，很容易被裁员，因此得不停的卷。</p>\n<h3 id=\"薪资待遇\"><a href=\"#薪资待遇\" class=\"headerlink\" title=\"薪资待遇\"></a>薪资待遇</h3><p>体制内的薪资待遇比较一般，在当地城市一般属于中等偏上的收入，吃得饱但也吃不好。公务员工资一般高于事业编，好的国央企的薪资待遇也还不错。薪资待遇较好的地区比如苏南、浙北一些城市。体制内最近火热跟房地产发展息息相关，土地财政大大增加了体制内的收入。如今房地产业萎靡的情况下，体制内降薪频繁，未来体制内的薪资待遇还会怎样，我们不得而知。</p>\n<p>体制外的薪资待遇无非就是看个人能力和个人机遇了，计算机应届生进入互联网大厂薪资好点的都有35+w年薪，一般的也能拿到20+w，在私企干几年跳槽还能收获不错的薪资涨幅。虽然互联网发展停滞，但是未来仍然有大量的数字化人才需求。</p>\n<h2 id=\"选择体制内还是体制外\"><a href=\"#选择体制内还是体制外\" class=\"headerlink\" title=\"选择体制内还是体制外\"></a>选择体制内还是体制外</h2><p>近年来，由于全球经济发展停滞、行业周期、疫情等各种原因，很多人在私企内混的不是很如意，pua、压迫、裁员。近几年体制内的薪资也增加很多，20 年的深圳高中 40w 招高中老师、余杭区街道办办事员录取的学生都是清北等顶尖高校的硕士生甚至博士生。清华的毕业生就业去向也显示 70% 的学生进入了体制内。</p>\n<p>那么，体制内真的就无敌嘛，宇宙的尽头真的是体制内嘛，还是选择体制外打拼打拼闯出自己的一片天呢？</p>\n<p>应届生在就业选择时一般都会跟家里人商量，听听父母的看法。于父母而言，父母一般都比较想让孩子进入体制内，我们作为子女应当尊重父母，但是不是完全听从父母，因为他们是那个时代的那些经验，在当今这个时代，要有自己的思想。把自己的生命过好了，过出精彩来，才是对父母最大的尊重，也是父母最大的幸福。</p>\n<p>很多人毕业时不知道选择什么，盲目从众，随大流进入体制内，进去之后觉得不是自己想要的。这种情况无非是无法在体制内获得自己想要取得的价值感、成就感。投入过的生命才会有温度，不管是体制内还是体制外，这样才会获得巨大的价值感。</p>\n<p>我们的社会、生活一直在发展变化，这个才是一直不变的。做选择一定要看清楚自己想要什么，可以想想自己死去的时候，那时候是一个什么样的身份、什么样的职位，因为这其实就是我们心底的追求，明确自己的追求，体制内还是体制外，往自己的追求上靠近就可以了。体制内还是体制外没有对错，只有适合，适合自己、适合自己的未来发展、适合自己的人生追求。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>以下是一些我觉得讲的很在理的视频，非劝退性质，看完之后感悟很多。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1JT41117Lx/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">不适合就别考公务员了</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Ga4y1p7Tw/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">“别瞎混了，公务员才是正经工作”进体制真的香吗？【复旦梁永安】</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1RS4y1d7R9/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">60万年薪比不上公务员月薪4000？同志们，千万别再高估“体制内”的性价比了！【毯叔盘钱】</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1CM4y1F7PN/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">【考编？看这一条就够了】8年！！宇宙尽头真不是编制！！</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1VY4y1A7XM/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">537万人考公，500万人失业，宇宙的尽头是考编吗？</a> </p>\n","site":{"data":{}},"length":1564,"excerpt":"<p>面临秋招毕业季，进体制内还是体制外无疑是摆在毕业生面前的两个大方向选择。本人秋招以来也经历了类似选择，也谈谈我个人的一些思考。","more":"</p>\n<h2 id=\"体制内-x2F-外的对比\"><a href=\"#体制内-x2F-外的对比\" class=\"headerlink\" title=\"体制内&#x2F;外的对比\"></a>体制内&#x2F;外的对比</h2><h3 id=\"工作单位\"><a href=\"#工作单位\" class=\"headerlink\" title=\"工作单位\"></a>工作单位</h3><p>体制内狭义上指公务员和事业编，广义上的体制内还包含一些泛体制内的单位，比如烟草、电网、银行等国央企。</p>\n<p>体制外就是指私企了，互联网行业的话比如 “BAT”、”TMD”，外企如微软、ZOOM、SAP 等。</p>\n<h3 id=\"工作内容、时间、压力\"><a href=\"#工作内容、时间、压力\" class=\"headerlink\" title=\"工作内容、时间、压力\"></a>工作内容、时间、压力</h3><p>体制内的工作一般都不会很难。公务员一般是写材料、整理材料，事业编根据岗位不同具体工作内容也不同，比如教师编也属于事业编，教师一般除了承担教学任务以外，还要被安排一些杂活；加班一般都不会很多，不过疫情期间很多公务员承担防疫角色，加班情况十分严重，甚至半夜被叫醒去单位搞防疫工作；工作压力一般不会很大，就算完成不了也可以躺平摆烂，毕竟辞退一名体制内人员几乎不可能。</p>\n<p>体制外的工作一般而言都是和 OKR、KPI 相关，完成 ld、mt 派发的任务；加班一般比较多，资本主义吸血，996、995、10105、12126，互联网行业加班情况就更严重了；工作压力一般而言比较大，如果部门效益不好，有裁员指标，很容易被裁员，因此得不停的卷。</p>\n<h3 id=\"薪资待遇\"><a href=\"#薪资待遇\" class=\"headerlink\" title=\"薪资待遇\"></a>薪资待遇</h3><p>体制内的薪资待遇比较一般，在当地城市一般属于中等偏上的收入，吃得饱但也吃不好。公务员工资一般高于事业编，好的国央企的薪资待遇也还不错。薪资待遇较好的地区比如苏南、浙北一些城市。体制内最近火热跟房地产发展息息相关，土地财政大大增加了体制内的收入。如今房地产业萎靡的情况下，体制内降薪频繁，未来体制内的薪资待遇还会怎样，我们不得而知。</p>\n<p>体制外的薪资待遇无非就是看个人能力和个人机遇了，计算机应届生进入互联网大厂薪资好点的都有35+w年薪，一般的也能拿到20+w，在私企干几年跳槽还能收获不错的薪资涨幅。虽然互联网发展停滞，但是未来仍然有大量的数字化人才需求。</p>\n<h2 id=\"选择体制内还是体制外\"><a href=\"#选择体制内还是体制外\" class=\"headerlink\" title=\"选择体制内还是体制外\"></a>选择体制内还是体制外</h2><p>近年来，由于全球经济发展停滞、行业周期、疫情等各种原因，很多人在私企内混的不是很如意，pua、压迫、裁员。近几年体制内的薪资也增加很多，20 年的深圳高中 40w 招高中老师、余杭区街道办办事员录取的学生都是清北等顶尖高校的硕士生甚至博士生。清华的毕业生就业去向也显示 70% 的学生进入了体制内。</p>\n<p>那么，体制内真的就无敌嘛，宇宙的尽头真的是体制内嘛，还是选择体制外打拼打拼闯出自己的一片天呢？</p>\n<p>应届生在就业选择时一般都会跟家里人商量，听听父母的看法。于父母而言，父母一般都比较想让孩子进入体制内，我们作为子女应当尊重父母，但是不是完全听从父母，因为他们是那个时代的那些经验，在当今这个时代，要有自己的思想。把自己的生命过好了，过出精彩来，才是对父母最大的尊重，也是父母最大的幸福。</p>\n<p>很多人毕业时不知道选择什么，盲目从众，随大流进入体制内，进去之后觉得不是自己想要的。这种情况无非是无法在体制内获得自己想要取得的价值感、成就感。投入过的生命才会有温度，不管是体制内还是体制外，这样才会获得巨大的价值感。</p>\n<p>我们的社会、生活一直在发展变化，这个才是一直不变的。做选择一定要看清楚自己想要什么，可以想想自己死去的时候，那时候是一个什么样的身份、什么样的职位，因为这其实就是我们心底的追求，明确自己的追求，体制内还是体制外，往自己的追求上靠近就可以了。体制内还是体制外没有对错，只有适合，适合自己、适合自己的未来发展、适合自己的人生追求。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>以下是一些我觉得讲的很在理的视频，非劝退性质，看完之后感悟很多。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1JT41117Lx/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">不适合就别考公务员了</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1Ga4y1p7Tw/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">“别瞎混了，公务员才是正经工作”进体制真的香吗？【复旦梁永安】</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1RS4y1d7R9/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">60万年薪比不上公务员月薪4000？同志们，千万别再高估“体制内”的性价比了！【毯叔盘钱】</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1CM4y1F7PN/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">【考编？看这一条就够了】8年！！宇宙尽头真不是编制！！</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1VY4y1A7XM/?share_source=copy_web&vd_source=0ee37b99b6275b36190f1dd4aff8f80a\">537万人考公，500万人失业，宇宙的尽头是考编吗？</a> </p>"},{"title":"回老家的一周","copyright":true,"mathjax":true,"date":"2022-12-23T10:46:02.000Z","urlname":"week-back-home","_content":"\n上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。\n\n<!--more-->\n\n在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。\n\n在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。\n\n表侄今年六岁了，很可爱，活蹦乱跳的。\n\n爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。\n\n今天下午回到常州了，准备最近搞搞毕业论文的事了。\n\n","source":"_posts/回老家的一周.md","raw":"---\ntitle: 回老家的一周\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2022-12-23 18:46:02\nurlname: week-back-home\n---\n\n上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。\n\n<!--more-->\n\n在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。\n\n在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。\n\n表侄今年六岁了，很可爱，活蹦乱跳的。\n\n爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。\n\n今天下午回到常州了，准备最近搞搞毕业论文的事了。\n\n","slug":"回老家的一周","published":1,"updated":"2023-01-26T12:07:10.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw326000tt9t8h9aa10ku","content":"<p>上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。</p>\n<span id=\"more\"></span>\n\n<p>在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。</p>\n<p>在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。</p>\n<p>表侄今年六岁了，很可爱，活蹦乱跳的。</p>\n<p>爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。</p>\n<p>今天下午回到常州了，准备最近搞搞毕业论文的事了。</p>\n","site":{"data":{}},"length":323,"excerpt":"<p>上周从常州省考回来，当天晚上正好是世界杯决赛，看到了凌晨两点，第二天一大早起床，和爸妈一起开车回老家，然后就开始了在老家的一周生活。</p>","more":"<p>在老家的一周除了吃饭就是喝酒，无聊的很。第一天晚上有点头痛，还以为是阳了，后面一直没什么大的症状，不过每天都是头昏脑胀的，感觉应该只是普通流感（到现在还没好）。老家好多人都有点发烧，诊所里都是老人在挂水，也不知道挂的是什么水，老年人挂水好像会舒服很多。</p>\n<p>在老家还简单过了个小生日，老爸老妈在镇上酒店办了两桌酒席接客，姨妈给买了个大蛋糕，表弟从市里回来还买了一束花，有点小温馨。</p>\n<p>表侄今年六岁了，很可爱，活蹦乱跳的。</p>\n<p>爷爷、奶奶那一辈的好多人年纪都很大了，希望他们健健康康。</p>\n<p>今天下午回到常州了，准备最近搞搞毕业论文的事了。</p>"},{"title":"字节暑期实习同组实习生秋招情况分享","copyright":true,"mathjax":true,"date":"2022-12-13T12:02:14.000Z","urlname":"my-bytedance-internship-friends-offer","_content":"\n突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。\n\n<!--more-->\n\n在字节跳动暑期实习期间，前前后后加上我一共有 5 名实习生。\n\n实习生 A：浙大硕，在我们组从 4 月中干到 7 月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。\n\n实习生 B：山大硕，多段实习（包括量化，字节多段实习）大佬，7 月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大 sp offer 并顺利签约。\n\n实习生 C：重邮本，参加本部门实习转正，顺利收到小 sp offer 并签约。\n\n实习生 D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等 offer，选择 wlb 的农行。\n\n实习生 E（本人），具体情况可见我的[2022秋招总结](https://yaxing97.com/2022-autumn-recruitment-summary.html) 。\n\n这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”\n\n我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的 mentor 比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般 8 点左右就润了。到家什么都不想做，更别提学习了。幸好 618 入手了 ps5，靠战神 4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂 offer 可能无脑去了，经历过才知道自己所能承受的身心压力。\n\n因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。\n\n以上。\n","source":"_posts/字节暑期实习同组实习生秋招情况分享.md","raw":"---\ntitle: 字节暑期实习同组实习生秋招情况分享\ncopyright: true\nmathjax: true\ndate: 2022-12-13 20:02:14\ncategories: \n  - 实习秋招\n  - 实习\ntags: \nurlname: my-bytedance-internship-friends-offer\n---\n\n突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。\n\n<!--more-->\n\n在字节跳动暑期实习期间，前前后后加上我一共有 5 名实习生。\n\n实习生 A：浙大硕，在我们组从 4 月中干到 7 月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。\n\n实习生 B：山大硕，多段实习（包括量化，字节多段实习）大佬，7 月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大 sp offer 并顺利签约。\n\n实习生 C：重邮本，参加本部门实习转正，顺利收到小 sp offer 并签约。\n\n实习生 D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等 offer，选择 wlb 的农行。\n\n实习生 E（本人），具体情况可见我的[2022秋招总结](https://yaxing97.com/2022-autumn-recruitment-summary.html) 。\n\n这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”\n\n我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的 mentor 比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般 8 点左右就润了。到家什么都不想做，更别提学习了。幸好 618 入手了 ps5，靠战神 4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂 offer 可能无脑去了，经历过才知道自己所能承受的身心压力。\n\n因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。\n\n以上。\n","slug":"字节暑期实习同组实习生秋招情况分享","published":1,"updated":"2023-01-26T12:35:58.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw326000vt9t81ihgaxuw","content":"<p>突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。</p>\n<span id=\"more\"></span>\n\n<p>在字节跳动暑期实习期间，前前后后加上我一共有 5 名实习生。</p>\n<p>实习生 A：浙大硕，在我们组从 4 月中干到 7 月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。</p>\n<p>实习生 B：山大硕，多段实习（包括量化，字节多段实习）大佬，7 月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大 sp offer 并顺利签约。</p>\n<p>实习生 C：重邮本，参加本部门实习转正，顺利收到小 sp offer 并签约。</p>\n<p>实习生 D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等 offer，选择 wlb 的农行。</p>\n<p>实习生 E（本人），具体情况可见我的<a href=\"https://yaxing97.com/2022-autumn-recruitment-summary.html\">2022秋招总结</a> 。</p>\n<p>这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”</p>\n<p>我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的 mentor 比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般 8 点左右就润了。到家什么都不想做，更别提学习了。幸好 618 入手了 ps5，靠战神 4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂 offer 可能无脑去了，经历过才知道自己所能承受的身心压力。</p>\n<p>因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。</p>\n<p>以上。</p>\n","site":{"data":{}},"length":664,"excerpt":"<p>突然想起来做这个分享，是因为刚好下午有个字节跳动暑期实习时同组的朋友刚签约三方，和父母也顺便分享了其他同组实习生的签约情况。这边也给大家分享下。</p>","more":"<p>在字节跳动暑期实习期间，前前后后加上我一共有 5 名实习生。</p>\n<p>实习生 A：浙大硕，在我们组从 4 月中干到 7 月中，走字节的活水平台活水到其他部门继续暑期实习了，未能转正成功，后续情况不清楚。</p>\n<p>实习生 B：山大硕，多段实习（包括量化，字节多段实习）大佬，7 月离职，未参加实习转正，投递字节另一个部门的秋招提前批，最终斩获大 sp offer 并顺利签约。</p>\n<p>实习生 C：重邮本，参加本部门实习转正，顺利收到小 sp offer 并签约。</p>\n<p>实习生 D：南开硕，由于实习时间短产出不足未能转正成功，秋招收到华为和农行等 offer，选择 wlb 的农行。</p>\n<p>实习生 E（本人），具体情况可见我的<a href=\"https://yaxing97.com/2022-autumn-recruitment-summary.html\">2022秋招总结</a> 。</p>\n<p>这两天看了很多脉脉，有一个评论我觉得说的很对：“很多暑期实习过的人，都不想再去大厂了，选择去国企。”</p>\n<p>我觉得说的真的很对，实习过体会了大厂的卷，况且还是实习生，当时我的 mentor 比我累多了，每天晚上回去还要干活。我每天回到家感觉整个人都被抽空了，虽说我回家的也很早，一般 8 点左右就润了。到家什么都不想做，更别提学习了。幸好 618 入手了 ps5，靠战神 4、瑞奇与叮当、只狼等游戏度过一个又一个夜晚，不然我觉得我可能会抑郁。说实话，如果没有这段暑期实习，我拿到字节等大厂 offer 可能无脑去了，经历过才知道自己所能承受的身心压力。</p>\n<p>因此，暑期实习还是推荐去大厂的，一方面给秋招简历润色，另一方面看看自己是否能适应大厂工作生活节奏。</p>\n<p>以上。</p>"},{"title":"Java八股文 - 计算机网络","copyright":true,"mathjax":false,"date":"2023-01-25T05:44:16.000Z","toc":true,"urlname":"computer-network","_content":"\n> 整理的计算机网络相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 深入理解HTTPS工作原理\n\n> https://juejin.cn/post/6844903830916694030\n\n### 前言\n\n近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的 HTTP 协议，在逐渐的被 HTTPS 协议所取代，在浏览器、搜索引擎、CA 机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS 加密时代”，HTTPS 将在未来的几年内全面取代 HTTP 成为传输协议的主流。\n\n读完本文，希望你能明白：\n\n- HTTP 通信存在什么问题\n- HTTPS 如何改进 HTTP 存在那些问题\n- HTTPS 工作原理是什么\n\n### 一、什么是HTTPS\n\nHTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\nHTTPS 主要作用是：\n\n（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;\n\n（2）对网站服务器进行真实身份认证。\n\n我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用`http://`，而是改用`https://`。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。\n\n### 二、为什么需要HTTPS\n\n在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP 协议存在的哪些问题：\n\n- 通信使用明文（不加密），内容可能被**窃听** \n\n\t信息加密：使用非对称加密（RSA）交换密钥，使用对称加密（AES）传输报文，兼备安全与效率\n\n- 无法证明报文的完整性，所以可能遭**篡改** \n\n\t完整性校验：数字签名\n\n- 不验证通信方的身份，因此有可能遭遇**伪装** \n\n\t身份验证：数字证书\n\n### 三、HTTPS如何解决HTTP上述问题?\n\n**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132445345.png\" alt=\"image-20220422132445345\" style=\"zoom:33%;\" />\n\n\n\n在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、完整性校验、身份验证这些功能。也就是说**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132508534.png\" alt=\"image-20220422132508534\" style=\"zoom:33%;\" />\n\nHTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，**其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性**。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132525551.png\" alt=\"image-20220422132525551\" style=\"zoom:33%;\" />\n\n\n\n#### 1.解决内容可能被窃听的问题——加密\n\n#### 方法1.对称加密\n\n这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。\n\n以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。\n\n#### 方法2.非对称加密\n\n公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。\n\n使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132541737.png\" alt=\"image-20220422132541737\" style=\"zoom:33%;\" />\n\n非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。\n\n这种方式有以下缺点：\n\n- 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；\n- 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；\n- 使用非对称加密**在数据加密解密过程需要消耗一定时间**，降低了数据传输效率；\n\n#### 方法3.对称加密+非对称加密(HTTPS采用这种方式)\n\n使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。\n\n具体做法是：**发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。\n\n#### 2.解决报文可能遭篡改问题——数字签名\n\n网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。\n\n**数字签名有两种功效**：\n\n- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\n- 数字签名能确定消息的完整性,证明数据是否未被篡改过。\n\n**数字签名如何生成:**\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132605229.png\" alt=\"image-20220422132605229\" style=\"zoom:33%;\" />\n\n将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。\n\n**校验数字签名流程**：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132617982.png\" alt=\"image-20220422132617982\" style=\"zoom:33%;\" />\n\n接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。\n\n假设消息传递在 Kobe，James 两人之间发生。James 将消息连同数字签名一起发送给 Kobe，Kobe 接收到消息后，通过校验数字签名，就可以验证接收到的消息就是 James 发送的。当然，这个过程的前提是 Kobe 知道 James 的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Kobe,或者说拿到的公钥如何证明是 James 的。\n\n此时就需要引入了**证书颁发机构**（Certificate Authority，简称 CA），CA 数量并不多，Kobe 客户端内置了所有受信任 CA 的证书。CA 对 James 的公钥（和其他信息）数字签名后生成证书。\n\n#### 3.解决通信方身份可能被伪装的问题——数字证书\n\n数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。\n\n我们来介绍一下数字证书认证机构的业务流程：\n\n- 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;\n- CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;\n- 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;\n- 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;\n- 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。\n- 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。\n\n### 四、 HTTPS工作流程\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132710862.png\" alt=\"image-20220422132710862\" style=\"zoom:80%;\" />\n\n1.Client 发起一个 HTTPS（比如`https://juejin.cn/user/4283353031252967`）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。\n\n2.Server 把事先配置好的公钥证书（public key certificate）返回给客户端。\n\n3.Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。\n\n4.Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。\n\n5.Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。\n\n6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。\n\n7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。\n\n8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。\n\n### 五、HTTP 与 HTTPS 的区别\n\n- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\n- HTTPS 比 HTTP 更加安全;\n- HTTPS 需要用到 SSL 证书，而 HTTP 不用;\n- HTTPS 标准端口 443，HTTP 标准端口 80;\n- HTTPS 基于传输层，HTTP 基于应用层;\n- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示;\n\n### 六、为何不所有的网站都使用HTTPS\n\n既然 HTTPS 那么安全可靠，那为何不所有的 Web 网站都使用 HTTPS？\n\n首先，很多人还是会觉得 HTTPS 实施有门槛，这个门槛在于需要权威 CA 颁发的 SSL 证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。\n\n其次，HTTPS 普遍认为性能消耗要大于 HTTP，因为**与纯文本通信相比，加密通信会消耗更多的CPU及内存资源**。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。\n\n除此之外，**想要节约购买证书的开销也是原因之一**。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。\n\n最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS 部署趋势是由社会、企业、政府共同去推动的。\n\n## 计算机网络体系结构\n\n### 什么是网络编程\n\n网络编程的本质是多台计算机之间的数据交换。现在的网络编程基本上都是基于请求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻响应连接，则需要一直启动。\n\n### 网络编程中两个主要的问题\n\n**1、**一个是如何准确的定位网络上一台或多台主机，\n\n**2、**另一个就是找到主机后如何可靠高效的进行数据传输。\n\n- 在 TCP/IP 协议中 IP 层网际层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。\n- 而 TCP 层传输层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。\n\n### 网络协议是什么\n\n在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。\n\n### 为什么要对网络协议分层\n\n**1、**简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。\n\n**2、**灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。\n\n**3、**易于实现和维护。\n\n**4、**促进标准化工作。分开后，每层功能可以相对简单地被描述\n\n### 体系结构\n\n**TCP/IP参考模型**\n\nOSI 七层协议：应用（HTTP）、表示（SSL/TLS）、会话（RPC）、传输（TCP）、网络（IP）、链路（ARP）、物理\n\nTCP/IP 四层协议（数据链路层、网络层、传输层、应用层）\n\n**1、**应用层 **为用户提供各种网络服务**。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET 等。（HTTP 协议全称 Hyper Text Transfer Protocol 超文本传输协议，在浏览器与服务器间传送文档）\n\n**2、**传输层 **建立了主机端到端的连接**，传输层的作用是**为上层协议提供端到端的可靠和透明的数据传输服务**，包括处理差错控制和流量控制等问题。（TCP、UDP）\n\n**3、**网络层 **通过IP寻址来建立两个节点之间的连接**，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。（IP）\n\n**4、**数据链路层 **通过一些规则来控制这些数据的传输**，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路。\n\n### 什么是TCP和UDP\n\n|          | TCP                              | UDP                                    |\n| -------- | -------------------------------- | -------------------------------------- |\n| 面向连接 | 面向连接                         | 无连接                                 |\n| 可靠性   | 可靠传输，使用拥塞控制和流量控制 | 可靠传输                               |\n| 连接个数 | 只能一对一通信                   | 支持一对一、一对多、多对一、多对多通信 |\n| 使用场景 | 要求可靠传输的应用（文件传输）   | 实时应用（视频会议、网络直播）         |\n\n### 浏览器中输入：网址后都发生了什么？请详细阐述。\n\n**1、**域名解析，域名→IP 地址，解析过程依次经过了浏览器本地缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。\n\n**2、**建立 TCP/IP 连接（三次握手具体过程）\n\n**3、**由浏览器发送一个 HTTP 请求\n\n**4、**经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器\n\n**5、**服务器处理该 HTTP 请求，返回一个 HTML 文件\n\n**6、**浏览器解析该 HTML 文件，并且显示在浏览器端\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640.webp)\n\n### TCP 协议如何来保证传输的可靠性\n\n**对于可靠性，TCP通过以下方式进行保证：**\n\n> 接收方对数据包进行检查，是否**失序**，失序的话要重排序，是否**重复**，重复的话将重复的数据丢弃，是否**出错**，出错的话将该报文段丢弃。否则的话，接收方会给发送方一个发送一个确认。发送方发送之后如果没有收到这个确认在一定时间后会重发这个报文段。\n\n- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；\n- **对失序数据包重排序**：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；\n- **丢弃重复数据**：对于重复数据，能够丢弃重复数据；\n- **应答机制**：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；\n- **超时重发**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；\n- **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。\n\tTCP 使用的流量控制协议是**可变大小的滑动窗口协议**。\n\n### TCP 的拥塞避免机制\n\nhttps://www.cnblogs.com/hongdada/p/11206679.html\n\n拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。\n\n拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。\n\n拥塞控制的方法：\n\n**1、 慢开始 + 拥塞避免：**\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718131944933-703202720.png)\n\n**慢开始**：拥塞窗口从 1、2、4 以指数规律增长；\n\n**拥塞避免**：到达慢开始阈值后，开始拥塞避免“加法增大”\n\n**2、快重传 + 快恢复：**\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718132020300-1269239957.png)\n\n**快重传**： **快重传要求接收方在收到一个失序的报文段后就立即发出 重复确认 **（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定， **发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段**，而不必继续等待设置的重传计时器时间到期。\n\n**快恢复**：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行**“乘法减小”算法，把 ssthresh 门限减半**，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将拥塞窗口设置为慢开始阈值的大小，**然后执行拥塞避免算法让拥塞窗口线性加1**。\n\n### 什么是Http协议？\n\n- Http 协议属于应用层，是在浏览器与服务器间传送文档的规范，简称为“超文本传输协议”\n\n![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210326001352.png)\n\n### 说说HTTP常用的状态码及其含义？\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518889206.webp)\n\n不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518894201.webp)\n\n\n\n### Http和Https的区别？\n\nHttp 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：\n\n- 端口不同：Http 与 Https 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；\n- 资源消耗：和 HTTP 通信相比，Https 通信会由于加密解密处理消耗更多的 CPU 和内存资源；\n- 开销：Https 通信需要证书，而证书一般需要向认证机构购买；\n\nHttps 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。\n\n### 什么是http的请求体？\n\n**1、**HTTP 请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器拿数据，先要表明我要什么吧\n\n**2、**HTTP 请求体由：**请求行、请求头、请求体** 组成的\n\n> 请求行：请求方法（POST）、URL（character/use.html） 和 HTTP 协议版本（HTTP/1.1）\n>\n> 请求头：\n>\n> * User-Agent：发送请求的浏览器类型;\n> * Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ */* ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型;\n> * Accept-Language：客户端可接受的自然语言;\n> * Accept-Encoding：客户端可接受的编码格式;\n> * Accept-Charset：可接受的应答的字符集;\n> * Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;\n> * Connection：连接方式(close 或 keepalive);\n> * Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;\n\n**3、**注意：GET 请求是没有请求体的\n\n### HTTP的响应报文有哪些？\n\n**1、**http 的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文\n\n**2、**响应报文包含三部分 **状态行、响应头、响应体**\n\n### Http中常见的header字段有哪些？\n\ncookie，请求时传递给服务端的 cookie 信息 \nset-cookie，响应报文首部设置要传递给客户端的 cookie 信息 \nallow，支持什么 HTTP 方法 \nlast-modified，资源的最后修改时间 \nexpires,设置资源缓存的失败日期 \ncontent-language，实体的资源语言 \ncontent-encoding，实体的编码格式 \ncontent-length，实体主体部分的大小单位是字节 \ncontent-range，返回的实体的哪些范围 \ncontent-type，哪些类型 \naccept-ranges，处理的范围请求 \nage，告诉客户端服务器在多久前创建了响应 \nvary，代理服务器的缓存信息 \nlocation，用于指定重定向后的 URI \nIf-Match，值是资源的唯一标识 \nUser-Agent，将创建请求的浏览器和用户代理名称等信息传递给服务器 \nTransfer-Encoding，传输报文的主体编码方式 \nconnection，管理持久连接 keep-alive , close Cache-Control，控制浏览器的强缓存\n\n### HTTPS工作原理\n\n（AES：非对称加密；RSA：对称加密）\n\n**1、**首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA 加密）等进行校验；\n\n**2、**客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA 加密）；\n\n**3、**消息体产生之后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名；\n\n**4、**发送给服务端，此时只有服务端（RSA 私钥）能解密。\n\n**5、**解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。\n\n### ⭐为什么 TCP 链接需要三次握手，两次不可以么？\n\n“三次握手” 的目的是为了防止**已失效的链接请求报文突然又传送到了服务端**，因而产生错误。\n\n- 正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。\n- 假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。\n\n假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求（因为那个是已经失效的请求），因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。\n\n### ⭐为什么要四次挥手？\n\nTCP 是全双工模式，这就意味着，\n当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；当 B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。\n\n所以想要愉快的结束这次对话就需要四次挥手。\n\n### ⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\n\nMSL（Maximum Segment Lifetime）**报文最大寿命**，TCP 允许不同的实现可以设置不同的 MSL 值。\n\n第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。\n\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n————————————————\n原文链接：https://blog.csdn.net/qzcsu/article/details/72861891\n\n### ⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\nTCP 还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个**探测报文段**，以后每隔 75 秒发送一次。若**一连发送10个探测报文仍然没反应**，服务器就认为客户端出了故障，接着就**关闭连接**。\n————————————————\n原文链接：https://blog.csdn.net/qzcsu/article/details/72861891\n\n### IP地址是怎样分类的，你知道吗？\n\n先说一下 IP 的基本特点：\n\n- IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。\n- IP 地址由两部分组成，即**网络地址**和**主机地址**。\n\t网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。\n\nIP 地址根据网络地址进行分类，主要分为 A、B、C 三类及特殊地址 D、E 这五类\n\n**A类：** (1.0.0.0-126.0.0.0)一般用于大型网络。\n\n**B类：** (128.0.0.0-191.255.0.0)一般用于中等规模网络。\n\n**C类：** (192.0.0.0-223.255.255.0)一般用于小型网络。\n\n**D类：** 是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。\n\n**E类：** 是保留地址。地址的网络号取值于 240~255 之间。\n\n### 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？\n\n服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认\n\n**(1) DDos 攻击：**\n\n- 客户端向服务端发送请求链接数据包\n- 服务端向客户端发送确认数据包\n- 客户端却不向服务端发送确认数据包，服务器**一直等待**来自客户端的确认\n\n**(2) DDos 预防：（没有彻底根治的办法，除非不使用TCP）**\n\n- 限制同时打开 SYN 半链接的数目\n- 缩短 SYN 半链接的 Time out 时间\n- 关闭不必要的服务\n\n### GET 与 POST 的区别？\n\nGET 与 POST 是我们常用的两种 HTTP Method，二者之间的区别主要包括如下五个方面：\n\n**1、** 从功能上讲，GET 一般用来**从服务器上获取资源**，POST 一般用来**更新服务器上的资源**；\n\n**2、**从请求参数形式上看，GET请求的数据会**附在URL上**，以?分割 URL 和传输数据，参数之间以&相连；而 POST 请求会把提交的数据则放置在 HTTP 请求报文的 **请求体** 中。\n\n**3、**就安全性而言，POST的**安全性**要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全。\n\n**4、**从请求的大小看，GET请求的**长度**受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。\n\n### DNS的寻址过程你知道吗？\n\n浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。\n\n### 什么是Socket\n\n**1、**网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。\n\n**2、**但是，Socket 所支持的协议种类也不光 TCP/IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。\n\n**3、**socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的\n\n**4、**Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多，\n\n### Socket属于网络的那个层面\n\n![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210325212441.png)\n\nSocket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。\n\n### Socket通讯的过程\n\n**基于TCP：**\n\n服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。\n\n**基于UDP：**\n\nUDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管\n\n### Socket和http的区别和应用场景\n\n**1、**Socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；\n\n**2、**Socket 适用场景：网络游戏，银行持续交互，直播，在线视屏等。\n\n**3、**http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接\n\n**4、**http 适用场景：公司 OA 服务，互联网服务，电商，办公，网站等等等等\n\n### 什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?\n\nHTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。服务器无法判断用户身份。\n\nHTTP 的这种特性有优点也有缺点：\n\n- **优点**：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用\n- **缺点**：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享\n\n解决方案：\n\n1. 使用参数传递机制：\n\t将参数拼接在请求的 URL 后面，实现数据的传递（GET 方式），例如：`/param/list?username=wmyskxz`\n\t**问题**：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有 1kb\n2. 使用 Cookie 技术\n3. 使用 Session 技术\n\nCookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。\n\n### 什么是Cookie\n\nCookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie，而客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器，服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。 \n\n### 什么是Session\n\nsession 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 session。\n\n服务器默认为客户浏览器的 cookie 中设置 sessionid，这个 sessionid 就和 cookie 对应，浏览器在向服务器请求过程中传输的 cookie 包含 sessionid ，服务器根据传输 cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。\n\n### Cookie和Session对于HTTP有什么用？\n\n HTTP 协议本身是无法判断用户身份。所以需要 cookie 或者 session\n\n### Cookie与Session区别\n\n- **实现机制**：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；\n- **大小限制**：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；\n- **安全性**：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；\n- **服务器资源消耗**：Session 是一定时间内保存在服务器端上，如果 session 过多会增加服务器的压力。\n\n### 什么是Token\n\nToken 的引入：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。\n\nToken 的定义：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。\n\n使用 Token 的目的：Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n\nToken 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token **证明自己的合法地位**\n\n### session与token区别\n\n- session 存储在服务器端，token 存储在客户端\n- token 提供认证和授权功能，作为身份认证，token 安全性比 session 好；\n- ⭐session 这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token 适用于项目级的前后端分离（前后端代码运行在不同的服务器下）\n\n### 常用的HTTP方法有哪些？\n\n- **GET：**用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器\n- **POST：**用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。\n- **PUT：**传输文件，报文主体中包含文件内容，保存到对应 URI 位置。\n- **HEAD：**获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。\n- **DELETE：**删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。\n- **OPTIONS：**查询相应 URI 支持的 HTTP 方法。\n\n### 网络层的 ARP 协议工作原理？\n\n网络层的 ARP 协议完成了 IP 地址与物理地址的映射\n\n### IP地址与物理地址\n\n物理地址是数据链路层和物理层使用的地址，IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，其中 ARP 协议用于 IP 地址与物理地址的对应。\n\n### 影响网络传输的因素有哪些？\n\n将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。\n\n1、网络带宽\n2、传输距离\n3、TCP 拥塞控制\n\n### 什是对称加密与非对称加密\n\n对称密钥加密是指**加密和解密使用同一个密钥**的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；\n\n而非对称加密是指使用**一对非对称密钥，即公钥和私钥**，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢\n\n### HTTPS采用对称加密+非对称加密\n\n使用对称加密，优点是加密解密速度快，缺点是不安全；\n使用非对称加密，优点是保证安全性，缺点是速度慢；\n\nHttps 结合两种加密方式的优点，\n在**交换密钥环节**使用非对称加密方式，之后的**建立通信交换报文**阶段则使用对称加密方式。\n\n## TCP/IP 协议族\n\n### 应用层\n\n应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。\n\n对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。\n\n### 传输层\n\n传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。\n\n运输层主要使用一下两种协议\n\n1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。\n2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。\n\n|              | UDP                                        | TCP                                    |\n| ------------ | ------------------------------------------ | -------------------------------------- |\n| 是否连接     | 无连接                                     | 面向连接                               |\n| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |\n| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |\n| 传输方式     | 面向报文                                   | 面向字节流                             |\n| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |\n| 场景         | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |\n\n**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**\n\n运行在`TCP协议`上的协议：\n\n- `HTTP（Hypertext Transfer Protocol，超文本传输协议）`，主要用于普通浏览。\n- `HTTPS（HTTP over SSL，安全超文本传输协议）`,`HTTP`协议的安全版本。\n- `FTP（File Transfer Protocol，文件传输协议）`，用于文件传输。\n- `POP3（Post Office Protocol, version 3，邮局协议）`，收邮件用。\n- `SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）`，用来发送电子邮件。\n- `TELNET（Teletype over the Network，网络电传）`，通过一个`终端（terminal）`登陆到网络。\n- `SSH（Secure Shell，用于替代安全性差的TELNET）`，用于加密安全登陆用。\n\n运行在`UDP协议`上的协议：\n\n- `DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）`，动态配置 IP 地址。\n\n运行在`TCP`和`UDP`协议上：\n\n- `DNS（Domain Name Service，域名服务）`，用于完成地址查找，邮件转发等工作。\n\n### 网络层\n\n网络层的任务就是**选择合适的网间路由和交换结点，确保计算机通信的数据及时传送**。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。\n\n互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。\n\n### 数据链路层\n\n数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。\n\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。\n\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。\n\n一般的 web 应用的通信传输流是这样的：\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzkvMTZhOWM5Y2Q1MjNlMDU5OQ.png)\n\n发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。\n\n### 物理层\n\n在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\n\n### TCP/IP 协议族\n\n在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS80LzcvMTY5ZjY5NjZjMjRhZjM0NQ.png)\n\n\n\nTCP（传输控制协议）和 IP（网际协议）是**最先定义的两个核心协议**，所以才统称为 TCP/IP 协议族\n\n## TCP的三次握手四次挥手\n\nTCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。\n\n一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。**通过三次握手建立一个链接，通过四次挥手来关闭一个连接**。\n\n**当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据**。\n\n### TCP报文的头部结构\n\n有几个字段需要重点介绍下：\n\n（1）序号：seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。\n\n（2）确认序号：ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。\n\n（3）标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：\n\n- ACK：确认序号有效。\n- FIN：释放一个连接。\n- PSH：接收方应该尽快将这个报文交给应用层。\n- RST：重置连接。\n- SYN：发起一个新连接。\n- URG：紧急指针（urgent pointer）有效。\n\n需要注意的是：\n\n- 不要将确认序号 ack 与标志位中的 ACK 搞混了。\n- 确认方 ack=发起方 seq+1，两端配对。\n\n### 三次握手\n\n> 三次握手的本质是确认通信双方收发数据的能力\n\nA->B\n\nA 发送给 B，B 若收到\n\n> 说明B知道：A可以发，B可以收\n\nB 返回给 A，A 若收到：说明 A 之前发给 B 的 B 收到了，同时 B 也能给自己回信，自己能收到这个回信。\n\n> 说明：A知道：A能发能收，B能收能发\n\n但是此时 B 不知道 A 是否可以收，B 是否发送正常\n\n于是 A 发送给 B，B 若收到：说明 B 的发送回信 A 能收到\n\n> 说明：B 知道 A 可以收，B 可以发，结合第一步，得到 B 也知道 A 能发能收，B 能收能发\n\n![三次握手](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA.png)\n\n### 四次挥手\n\n> 四次挥手的目的是关闭一个连接\n\n![四次挥手](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw.png)\n\nA 和 B 打电话，通话即将结束后，\nA 说“我没啥要说的了”，\nB 回答“我知道了”，\n但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，\nA 回答“知道了”，这样通话才算结束。\n","source":"_posts/Java八股文-计算机网络.md","raw":"---\ntitle: Java八股文 - 计算机网络\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-25 13:44:16\ntags:\ntoc: true\nurlname: computer-network\n---\n\n> 整理的计算机网络相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 深入理解HTTPS工作原理\n\n> https://juejin.cn/post/6844903830916694030\n\n### 前言\n\n近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的 HTTP 协议，在逐渐的被 HTTPS 协议所取代，在浏览器、搜索引擎、CA 机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS 加密时代”，HTTPS 将在未来的几年内全面取代 HTTP 成为传输协议的主流。\n\n读完本文，希望你能明白：\n\n- HTTP 通信存在什么问题\n- HTTPS 如何改进 HTTP 存在那些问题\n- HTTPS 工作原理是什么\n\n### 一、什么是HTTPS\n\nHTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\nHTTPS 主要作用是：\n\n（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;\n\n（2）对网站服务器进行真实身份认证。\n\n我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用`http://`，而是改用`https://`。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。\n\n### 二、为什么需要HTTPS\n\n在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP 协议存在的哪些问题：\n\n- 通信使用明文（不加密），内容可能被**窃听** \n\n\t信息加密：使用非对称加密（RSA）交换密钥，使用对称加密（AES）传输报文，兼备安全与效率\n\n- 无法证明报文的完整性，所以可能遭**篡改** \n\n\t完整性校验：数字签名\n\n- 不验证通信方的身份，因此有可能遭遇**伪装** \n\n\t身份验证：数字证书\n\n### 三、HTTPS如何解决HTTP上述问题?\n\n**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132445345.png\" alt=\"image-20220422132445345\" style=\"zoom:33%;\" />\n\n\n\n在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、完整性校验、身份验证这些功能。也就是说**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132508534.png\" alt=\"image-20220422132508534\" style=\"zoom:33%;\" />\n\nHTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，**其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性**。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132525551.png\" alt=\"image-20220422132525551\" style=\"zoom:33%;\" />\n\n\n\n#### 1.解决内容可能被窃听的问题——加密\n\n#### 方法1.对称加密\n\n这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。\n\n以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。\n\n#### 方法2.非对称加密\n\n公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。\n\n使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132541737.png\" alt=\"image-20220422132541737\" style=\"zoom:33%;\" />\n\n非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。\n\n这种方式有以下缺点：\n\n- 公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；\n- 公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；\n- 使用非对称加密**在数据加密解密过程需要消耗一定时间**，降低了数据传输效率；\n\n#### 方法3.对称加密+非对称加密(HTTPS采用这种方式)\n\n使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，**在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式**。\n\n具体做法是：**发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信**。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。\n\n#### 2.解决报文可能遭篡改问题——数字签名\n\n网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？----校验数字签名。\n\n**数字签名有两种功效**：\n\n- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\n- 数字签名能确定消息的完整性,证明数据是否未被篡改过。\n\n**数字签名如何生成:**\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132605229.png\" alt=\"image-20220422132605229\" style=\"zoom:33%;\" />\n\n将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。\n\n**校验数字签名流程**：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132617982.png\" alt=\"image-20220422132617982\" style=\"zoom:33%;\" />\n\n接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。\n\n假设消息传递在 Kobe，James 两人之间发生。James 将消息连同数字签名一起发送给 Kobe，Kobe 接收到消息后，通过校验数字签名，就可以验证接收到的消息就是 James 发送的。当然，这个过程的前提是 Kobe 知道 James 的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Kobe,或者说拿到的公钥如何证明是 James 的。\n\n此时就需要引入了**证书颁发机构**（Certificate Authority，简称 CA），CA 数量并不多，Kobe 客户端内置了所有受信任 CA 的证书。CA 对 James 的公钥（和其他信息）数字签名后生成证书。\n\n#### 3.解决通信方身份可能被伪装的问题——数字证书\n\n数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。\n\n我们来介绍一下数字证书认证机构的业务流程：\n\n- 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;\n- CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;\n- 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;\n- 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;\n- 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。\n- 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。\n\n### 四、 HTTPS工作流程\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132710862.png\" alt=\"image-20220422132710862\" style=\"zoom:80%;\" />\n\n1.Client 发起一个 HTTPS（比如`https://juejin.cn/user/4283353031252967`）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。\n\n2.Server 把事先配置好的公钥证书（public key certificate）返回给客户端。\n\n3.Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。\n\n4.Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。\n\n5.Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。\n\n6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。\n\n7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。\n\n8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。\n\n### 五、HTTP 与 HTTPS 的区别\n\n- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\n- HTTPS 比 HTTP 更加安全;\n- HTTPS 需要用到 SSL 证书，而 HTTP 不用;\n- HTTPS 标准端口 443，HTTP 标准端口 80;\n- HTTPS 基于传输层，HTTP 基于应用层;\n- HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示;\n\n### 六、为何不所有的网站都使用HTTPS\n\n既然 HTTPS 那么安全可靠，那为何不所有的 Web 网站都使用 HTTPS？\n\n首先，很多人还是会觉得 HTTPS 实施有门槛，这个门槛在于需要权威 CA 颁发的 SSL 证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。\n\n其次，HTTPS 普遍认为性能消耗要大于 HTTP，因为**与纯文本通信相比，加密通信会消耗更多的CPU及内存资源**。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。\n\n除此之外，**想要节约购买证书的开销也是原因之一**。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。\n\n最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS 部署趋势是由社会、企业、政府共同去推动的。\n\n## 计算机网络体系结构\n\n### 什么是网络编程\n\n网络编程的本质是多台计算机之间的数据交换。现在的网络编程基本上都是基于请求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻响应连接，则需要一直启动。\n\n### 网络编程中两个主要的问题\n\n**1、**一个是如何准确的定位网络上一台或多台主机，\n\n**2、**另一个就是找到主机后如何可靠高效的进行数据传输。\n\n- 在 TCP/IP 协议中 IP 层网际层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。\n- 而 TCP 层传输层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。\n\n### 网络协议是什么\n\n在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。\n\n### 为什么要对网络协议分层\n\n**1、**简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。\n\n**2、**灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。\n\n**3、**易于实现和维护。\n\n**4、**促进标准化工作。分开后，每层功能可以相对简单地被描述\n\n### 体系结构\n\n**TCP/IP参考模型**\n\nOSI 七层协议：应用（HTTP）、表示（SSL/TLS）、会话（RPC）、传输（TCP）、网络（IP）、链路（ARP）、物理\n\nTCP/IP 四层协议（数据链路层、网络层、传输层、应用层）\n\n**1、**应用层 **为用户提供各种网络服务**。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET 等。（HTTP 协议全称 Hyper Text Transfer Protocol 超文本传输协议，在浏览器与服务器间传送文档）\n\n**2、**传输层 **建立了主机端到端的连接**，传输层的作用是**为上层协议提供端到端的可靠和透明的数据传输服务**，包括处理差错控制和流量控制等问题。（TCP、UDP）\n\n**3、**网络层 **通过IP寻址来建立两个节点之间的连接**，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。（IP）\n\n**4、**数据链路层 **通过一些规则来控制这些数据的传输**，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路。\n\n### 什么是TCP和UDP\n\n|          | TCP                              | UDP                                    |\n| -------- | -------------------------------- | -------------------------------------- |\n| 面向连接 | 面向连接                         | 无连接                                 |\n| 可靠性   | 可靠传输，使用拥塞控制和流量控制 | 可靠传输                               |\n| 连接个数 | 只能一对一通信                   | 支持一对一、一对多、多对一、多对多通信 |\n| 使用场景 | 要求可靠传输的应用（文件传输）   | 实时应用（视频会议、网络直播）         |\n\n### 浏览器中输入：网址后都发生了什么？请详细阐述。\n\n**1、**域名解析，域名→IP 地址，解析过程依次经过了浏览器本地缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。\n\n**2、**建立 TCP/IP 连接（三次握手具体过程）\n\n**3、**由浏览器发送一个 HTTP 请求\n\n**4、**经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器\n\n**5、**服务器处理该 HTTP 请求，返回一个 HTML 文件\n\n**6、**浏览器解析该 HTML 文件，并且显示在浏览器端\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640.webp)\n\n### TCP 协议如何来保证传输的可靠性\n\n**对于可靠性，TCP通过以下方式进行保证：**\n\n> 接收方对数据包进行检查，是否**失序**，失序的话要重排序，是否**重复**，重复的话将重复的数据丢弃，是否**出错**，出错的话将该报文段丢弃。否则的话，接收方会给发送方一个发送一个确认。发送方发送之后如果没有收到这个确认在一定时间后会重发这个报文段。\n\n- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；\n- **对失序数据包重排序**：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；\n- **丢弃重复数据**：对于重复数据，能够丢弃重复数据；\n- **应答机制**：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；\n- **超时重发**：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；\n- **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。\n\tTCP 使用的流量控制协议是**可变大小的滑动窗口协议**。\n\n### TCP 的拥塞避免机制\n\nhttps://www.cnblogs.com/hongdada/p/11206679.html\n\n拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。\n\n拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。\n\n拥塞控制的方法：\n\n**1、 慢开始 + 拥塞避免：**\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718131944933-703202720.png)\n\n**慢开始**：拥塞窗口从 1、2、4 以指数规律增长；\n\n**拥塞避免**：到达慢开始阈值后，开始拥塞避免“加法增大”\n\n**2、快重传 + 快恢复：**\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718132020300-1269239957.png)\n\n**快重传**： **快重传要求接收方在收到一个失序的报文段后就立即发出 重复确认 **（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定， **发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段**，而不必继续等待设置的重传计时器时间到期。\n\n**快恢复**：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行**“乘法减小”算法，把 ssthresh 门限减半**，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将拥塞窗口设置为慢开始阈值的大小，**然后执行拥塞避免算法让拥塞窗口线性加1**。\n\n### 什么是Http协议？\n\n- Http 协议属于应用层，是在浏览器与服务器间传送文档的规范，简称为“超文本传输协议”\n\n![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210326001352.png)\n\n### 说说HTTP常用的状态码及其含义？\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518889206.webp)\n\n不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518894201.webp)\n\n\n\n### Http和Https的区别？\n\nHttp 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：\n\n- 端口不同：Http 与 Https 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；\n- 资源消耗：和 HTTP 通信相比，Https 通信会由于加密解密处理消耗更多的 CPU 和内存资源；\n- 开销：Https 通信需要证书，而证书一般需要向认证机构购买；\n\nHttps 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。\n\n### 什么是http的请求体？\n\n**1、**HTTP 请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器拿数据，先要表明我要什么吧\n\n**2、**HTTP 请求体由：**请求行、请求头、请求体** 组成的\n\n> 请求行：请求方法（POST）、URL（character/use.html） 和 HTTP 协议版本（HTTP/1.1）\n>\n> 请求头：\n>\n> * User-Agent：发送请求的浏览器类型;\n> * Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ */* ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型;\n> * Accept-Language：客户端可接受的自然语言;\n> * Accept-Encoding：客户端可接受的编码格式;\n> * Accept-Charset：可接受的应答的字符集;\n> * Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;\n> * Connection：连接方式(close 或 keepalive);\n> * Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;\n\n**3、**注意：GET 请求是没有请求体的\n\n### HTTP的响应报文有哪些？\n\n**1、**http 的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文\n\n**2、**响应报文包含三部分 **状态行、响应头、响应体**\n\n### Http中常见的header字段有哪些？\n\ncookie，请求时传递给服务端的 cookie 信息 \nset-cookie，响应报文首部设置要传递给客户端的 cookie 信息 \nallow，支持什么 HTTP 方法 \nlast-modified，资源的最后修改时间 \nexpires,设置资源缓存的失败日期 \ncontent-language，实体的资源语言 \ncontent-encoding，实体的编码格式 \ncontent-length，实体主体部分的大小单位是字节 \ncontent-range，返回的实体的哪些范围 \ncontent-type，哪些类型 \naccept-ranges，处理的范围请求 \nage，告诉客户端服务器在多久前创建了响应 \nvary，代理服务器的缓存信息 \nlocation，用于指定重定向后的 URI \nIf-Match，值是资源的唯一标识 \nUser-Agent，将创建请求的浏览器和用户代理名称等信息传递给服务器 \nTransfer-Encoding，传输报文的主体编码方式 \nconnection，管理持久连接 keep-alive , close Cache-Control，控制浏览器的强缓存\n\n### HTTPS工作原理\n\n（AES：非对称加密；RSA：对称加密）\n\n**1、**首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA 加密）等进行校验；\n\n**2、**客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA 加密）；\n\n**3、**消息体产生之后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名；\n\n**4、**发送给服务端，此时只有服务端（RSA 私钥）能解密。\n\n**5、**解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。\n\n### ⭐为什么 TCP 链接需要三次握手，两次不可以么？\n\n“三次握手” 的目的是为了防止**已失效的链接请求报文突然又传送到了服务端**，因而产生错误。\n\n- 正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。\n- 假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。\n\n假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求（因为那个是已经失效的请求），因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。\n\n### ⭐为什么要四次挥手？\n\nTCP 是全双工模式，这就意味着，\n当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；当 B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。\n\n所以想要愉快的结束这次对话就需要四次挥手。\n\n### ⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\n\nMSL（Maximum Segment Lifetime）**报文最大寿命**，TCP 允许不同的实现可以设置不同的 MSL 值。\n\n第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。\n\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n————————————————\n原文链接：https://blog.csdn.net/qzcsu/article/details/72861891\n\n### ⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\nTCP 还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个**探测报文段**，以后每隔 75 秒发送一次。若**一连发送10个探测报文仍然没反应**，服务器就认为客户端出了故障，接着就**关闭连接**。\n————————————————\n原文链接：https://blog.csdn.net/qzcsu/article/details/72861891\n\n### IP地址是怎样分类的，你知道吗？\n\n先说一下 IP 的基本特点：\n\n- IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。\n- IP 地址由两部分组成，即**网络地址**和**主机地址**。\n\t网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。\n\nIP 地址根据网络地址进行分类，主要分为 A、B、C 三类及特殊地址 D、E 这五类\n\n**A类：** (1.0.0.0-126.0.0.0)一般用于大型网络。\n\n**B类：** (128.0.0.0-191.255.0.0)一般用于中等规模网络。\n\n**C类：** (192.0.0.0-223.255.255.0)一般用于小型网络。\n\n**D类：** 是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。\n\n**E类：** 是保留地址。地址的网络号取值于 240~255 之间。\n\n### 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？\n\n服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认\n\n**(1) DDos 攻击：**\n\n- 客户端向服务端发送请求链接数据包\n- 服务端向客户端发送确认数据包\n- 客户端却不向服务端发送确认数据包，服务器**一直等待**来自客户端的确认\n\n**(2) DDos 预防：（没有彻底根治的办法，除非不使用TCP）**\n\n- 限制同时打开 SYN 半链接的数目\n- 缩短 SYN 半链接的 Time out 时间\n- 关闭不必要的服务\n\n### GET 与 POST 的区别？\n\nGET 与 POST 是我们常用的两种 HTTP Method，二者之间的区别主要包括如下五个方面：\n\n**1、** 从功能上讲，GET 一般用来**从服务器上获取资源**，POST 一般用来**更新服务器上的资源**；\n\n**2、**从请求参数形式上看，GET请求的数据会**附在URL上**，以?分割 URL 和传输数据，参数之间以&相连；而 POST 请求会把提交的数据则放置在 HTTP 请求报文的 **请求体** 中。\n\n**3、**就安全性而言，POST的**安全性**要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全。\n\n**4、**从请求的大小看，GET请求的**长度**受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。\n\n### DNS的寻址过程你知道吗？\n\n浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。\n\n### 什么是Socket\n\n**1、**网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。\n\n**2、**但是，Socket 所支持的协议种类也不光 TCP/IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。\n\n**3、**socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的\n\n**4、**Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多，\n\n### Socket属于网络的那个层面\n\n![](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210325212441.png)\n\nSocket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。\n\n### Socket通讯的过程\n\n**基于TCP：**\n\n服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。\n\n**基于UDP：**\n\nUDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管\n\n### Socket和http的区别和应用场景\n\n**1、**Socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；\n\n**2、**Socket 适用场景：网络游戏，银行持续交互，直播，在线视屏等。\n\n**3、**http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接\n\n**4、**http 适用场景：公司 OA 服务，互联网服务，电商，办公，网站等等等等\n\n### 什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?\n\nHTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。服务器无法判断用户身份。\n\nHTTP 的这种特性有优点也有缺点：\n\n- **优点**：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用\n- **缺点**：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享\n\n解决方案：\n\n1. 使用参数传递机制：\n\t将参数拼接在请求的 URL 后面，实现数据的传递（GET 方式），例如：`/param/list?username=wmyskxz`\n\t**问题**：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有 1kb\n2. 使用 Cookie 技术\n3. 使用 Session 技术\n\nCookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。\n\n### 什么是Cookie\n\nCookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie，而客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器，服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。 \n\n### 什么是Session\n\nsession 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 session。\n\n服务器默认为客户浏览器的 cookie 中设置 sessionid，这个 sessionid 就和 cookie 对应，浏览器在向服务器请求过程中传输的 cookie 包含 sessionid ，服务器根据传输 cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。\n\n### Cookie和Session对于HTTP有什么用？\n\n HTTP 协议本身是无法判断用户身份。所以需要 cookie 或者 session\n\n### Cookie与Session区别\n\n- **实现机制**：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；\n- **大小限制**：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；\n- **安全性**：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；\n- **服务器资源消耗**：Session 是一定时间内保存在服务器端上，如果 session 过多会增加服务器的压力。\n\n### 什么是Token\n\nToken 的引入：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。\n\nToken 的定义：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。\n\n使用 Token 的目的：Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。\n\nToken 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token **证明自己的合法地位**\n\n### session与token区别\n\n- session 存储在服务器端，token 存储在客户端\n- token 提供认证和授权功能，作为身份认证，token 安全性比 session 好；\n- ⭐session 这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token 适用于项目级的前后端分离（前后端代码运行在不同的服务器下）\n\n### 常用的HTTP方法有哪些？\n\n- **GET：**用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器\n- **POST：**用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。\n- **PUT：**传输文件，报文主体中包含文件内容，保存到对应 URI 位置。\n- **HEAD：**获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。\n- **DELETE：**删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。\n- **OPTIONS：**查询相应 URI 支持的 HTTP 方法。\n\n### 网络层的 ARP 协议工作原理？\n\n网络层的 ARP 协议完成了 IP 地址与物理地址的映射\n\n### IP地址与物理地址\n\n物理地址是数据链路层和物理层使用的地址，IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，其中 ARP 协议用于 IP 地址与物理地址的对应。\n\n### 影响网络传输的因素有哪些？\n\n将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。\n\n1、网络带宽\n2、传输距离\n3、TCP 拥塞控制\n\n### 什是对称加密与非对称加密\n\n对称密钥加密是指**加密和解密使用同一个密钥**的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；\n\n而非对称加密是指使用**一对非对称密钥，即公钥和私钥**，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢\n\n### HTTPS采用对称加密+非对称加密\n\n使用对称加密，优点是加密解密速度快，缺点是不安全；\n使用非对称加密，优点是保证安全性，缺点是速度慢；\n\nHttps 结合两种加密方式的优点，\n在**交换密钥环节**使用非对称加密方式，之后的**建立通信交换报文**阶段则使用对称加密方式。\n\n## TCP/IP 协议族\n\n### 应用层\n\n应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。\n\n对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。\n\n### 传输层\n\n传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。\n\n运输层主要使用一下两种协议\n\n1. 传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。\n2. 用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。\n\n|              | UDP                                        | TCP                                    |\n| ------------ | ------------------------------------------ | -------------------------------------- |\n| 是否连接     | 无连接                                     | 面向连接                               |\n| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |\n| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |\n| 传输方式     | 面向报文                                   | 面向字节流                             |\n| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |\n| 场景         | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |\n\n**每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：**\n\n运行在`TCP协议`上的协议：\n\n- `HTTP（Hypertext Transfer Protocol，超文本传输协议）`，主要用于普通浏览。\n- `HTTPS（HTTP over SSL，安全超文本传输协议）`,`HTTP`协议的安全版本。\n- `FTP（File Transfer Protocol，文件传输协议）`，用于文件传输。\n- `POP3（Post Office Protocol, version 3，邮局协议）`，收邮件用。\n- `SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）`，用来发送电子邮件。\n- `TELNET（Teletype over the Network，网络电传）`，通过一个`终端（terminal）`登陆到网络。\n- `SSH（Secure Shell，用于替代安全性差的TELNET）`，用于加密安全登陆用。\n\n运行在`UDP协议`上的协议：\n\n- `DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）`，动态配置 IP 地址。\n\n运行在`TCP`和`UDP`协议上：\n\n- `DNS（Domain Name Service，域名服务）`，用于完成地址查找，邮件转发等工作。\n\n### 网络层\n\n网络层的任务就是**选择合适的网间路由和交换结点，确保计算机通信的数据及时传送**。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。\n\n互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。\n\n### 数据链路层\n\n数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。\n\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。\n\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。\n\n一般的 web 应用的通信传输流是这样的：\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzkvMTZhOWM5Y2Q1MjNlMDU5OQ.png)\n\n发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。\n\n### 物理层\n\n在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\n\n### TCP/IP 协议族\n\n在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。\n\n![img](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS80LzcvMTY5ZjY5NjZjMjRhZjM0NQ.png)\n\n\n\nTCP（传输控制协议）和 IP（网际协议）是**最先定义的两个核心协议**，所以才统称为 TCP/IP 协议族\n\n## TCP的三次握手四次挥手\n\nTCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。\n\n一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。**通过三次握手建立一个链接，通过四次挥手来关闭一个连接**。\n\n**当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据**。\n\n### TCP报文的头部结构\n\n有几个字段需要重点介绍下：\n\n（1）序号：seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。\n\n（2）确认序号：ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。\n\n（3）标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：\n\n- ACK：确认序号有效。\n- FIN：释放一个连接。\n- PSH：接收方应该尽快将这个报文交给应用层。\n- RST：重置连接。\n- SYN：发起一个新连接。\n- URG：紧急指针（urgent pointer）有效。\n\n需要注意的是：\n\n- 不要将确认序号 ack 与标志位中的 ACK 搞混了。\n- 确认方 ack=发起方 seq+1，两端配对。\n\n### 三次握手\n\n> 三次握手的本质是确认通信双方收发数据的能力\n\nA->B\n\nA 发送给 B，B 若收到\n\n> 说明B知道：A可以发，B可以收\n\nB 返回给 A，A 若收到：说明 A 之前发给 B 的 B 收到了，同时 B 也能给自己回信，自己能收到这个回信。\n\n> 说明：A知道：A能发能收，B能收能发\n\n但是此时 B 不知道 A 是否可以收，B 是否发送正常\n\n于是 A 发送给 B，B 若收到：说明 B 的发送回信 A 能收到\n\n> 说明：B 知道 A 可以收，B 可以发，结合第一步，得到 B 也知道 A 能发能收，B 能收能发\n\n![三次握手](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA.png)\n\n### 四次挥手\n\n> 四次挥手的目的是关闭一个连接\n\n![四次挥手](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw.png)\n\nA 和 B 打电话，通话即将结束后，\nA 说“我没啥要说的了”，\nB 回答“我知道了”，\n但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，\nA 回答“知道了”，这样通话才算结束。\n","slug":"Java八股文-计算机网络","published":1,"updated":"2023-01-29T12:00:24.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw327000yt9t857gt6vr3","content":"<blockquote>\n<p>整理的计算机网络相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"深入理解HTTPS工作原理\"><a href=\"#深入理解HTTPS工作原理\" class=\"headerlink\" title=\"深入理解HTTPS工作原理\"></a>深入理解HTTPS工作原理</h2><blockquote>\n<p><a href=\"https://juejin.cn/post/6844903830916694030\">https://juejin.cn/post/6844903830916694030</a></p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的 HTTP 协议，在逐渐的被 HTTPS 协议所取代，在浏览器、搜索引擎、CA 机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS 加密时代”，HTTPS 将在未来的几年内全面取代 HTTP 成为传输协议的主流。</p>\n<p>读完本文，希望你能明白：</p>\n<ul>\n<li>HTTP 通信存在什么问题</li>\n<li>HTTPS 如何改进 HTTP 存在那些问题</li>\n<li>HTTPS 工作原理是什么</li>\n</ul>\n<h3 id=\"一、什么是HTTPS\"><a href=\"#一、什么是HTTPS\" class=\"headerlink\" title=\"一、什么是HTTPS\"></a>一、什么是HTTPS</h3><p>HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>\n<p>HTTPS 主要作用是：</p>\n<p>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</p>\n<p>（2）对网站服务器进行真实身份认证。</p>\n<p>我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用<code>http://</code>，而是改用<code>https://</code>。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。</p>\n<h3 id=\"二、为什么需要HTTPS\"><a href=\"#二、为什么需要HTTPS\" class=\"headerlink\" title=\"二、为什么需要HTTPS\"></a>二、为什么需要HTTPS</h3><p>在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP 协议存在的哪些问题：</p>\n<ul>\n<li><p>通信使用明文（不加密），内容可能被<strong>窃听</strong> </p>\n<p>  信息加密：使用非对称加密（RSA）交换密钥，使用对称加密（AES）传输报文，兼备安全与效率</p>\n</li>\n<li><p>无法证明报文的完整性，所以可能遭<strong>篡改</strong> </p>\n<p>  完整性校验：数字签名</p>\n</li>\n<li><p>不验证通信方的身份，因此有可能遭遇<strong>伪装</strong> </p>\n<p>  身份验证：数字证书</p>\n</li>\n</ul>\n<h3 id=\"三、HTTPS如何解决HTTP上述问题\"><a href=\"#三、HTTPS如何解决HTTP上述问题\" class=\"headerlink\" title=\"三、HTTPS如何解决HTTP上述问题?\"></a>三、HTTPS如何解决HTTP上述问题?</h3><p><strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132445345.png\" alt=\"image-20220422132445345\" style=\"zoom:33%;\" />\n\n\n\n<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、完整性校验、身份验证这些功能。也就是说<strong>HTTP加上加密处理和认证以及完整性保护后即是HTTPS</strong>。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132508534.png\" alt=\"image-20220422132508534\" style=\"zoom:33%;\" />\n\n<p>HTTPS 协议的主要功能基本都依赖于 TLS&#x2F;SSL 协议，TLS&#x2F;SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，<strong>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性</strong>。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132525551.png\" alt=\"image-20220422132525551\" style=\"zoom:33%;\" />\n\n\n\n<h4 id=\"1-解决内容可能被窃听的问题——加密\"><a href=\"#1-解决内容可能被窃听的问题——加密\" class=\"headerlink\" title=\"1.解决内容可能被窃听的问题——加密\"></a>1.解决内容可能被窃听的问题——加密</h4><h4 id=\"方法1-对称加密\"><a href=\"#方法1-对称加密\" class=\"headerlink\" title=\"方法1.对称加密\"></a>方法1.对称加密</h4><p>这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。<strong>没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了</strong>。</p>\n<p>以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>\n<h4 id=\"方法2-非对称加密\"><a href=\"#方法2-非对称加密\" class=\"headerlink\" title=\"方法2.非对称加密\"></a>方法2.非对称加密</h4><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，<strong>私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得</strong>。</p>\n<p>使用公开密钥加密方式，发送密文的一方使用<strong>对方的公开密钥</strong>进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132541737.png\" alt=\"image-20220422132541737\" style=\"zoom:33%;\" />\n\n<p>非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。</p>\n<p>这种方式有以下缺点：</p>\n<ul>\n<li>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；</li>\n<li>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</li>\n<li>使用非对称加密<strong>在数据加密解密过程需要消耗一定时间</strong>，降低了数据传输效率；</li>\n</ul>\n<h4 id=\"方法3-对称加密-非对称加密-HTTPS采用这种方式\"><a href=\"#方法3-对称加密-非对称加密-HTTPS采用这种方式\" class=\"headerlink\" title=\"方法3.对称加密+非对称加密(HTTPS采用这种方式)\"></a>方法3.对称加密+非对称加密(HTTPS采用这种方式)</h4><p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，<strong>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式</strong>。</p>\n<p>具体做法是：<strong>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</strong>。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。</p>\n<h4 id=\"2-解决报文可能遭篡改问题——数字签名\"><a href=\"#2-解决报文可能遭篡改问题——数字签名\" class=\"headerlink\" title=\"2.解决报文可能遭篡改问题——数字签名\"></a>2.解决报文可能遭篡改问题——数字签名</h4><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。</p>\n<p><strong>数字签名有两种功效</strong>：</p>\n<ul>\n<li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li>\n<li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li>\n</ul>\n<p><strong>数字签名如何生成:</strong></p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132605229.png\" alt=\"image-20220422132605229\" style=\"zoom:33%;\" />\n\n<p>将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。</p>\n<p><strong>校验数字签名流程</strong>：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132617982.png\" alt=\"image-20220422132617982\" style=\"zoom:33%;\" />\n\n<p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>\n<p>假设消息传递在 Kobe，James 两人之间发生。James 将消息连同数字签名一起发送给 Kobe，Kobe 接收到消息后，通过校验数字签名，就可以验证接收到的消息就是 James 发送的。当然，这个过程的前提是 Kobe 知道 James 的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Kobe,或者说拿到的公钥如何证明是 James 的。</p>\n<p>此时就需要引入了<strong>证书颁发机构</strong>（Certificate Authority，简称 CA），CA 数量并不多，Kobe 客户端内置了所有受信任 CA 的证书。CA 对 James 的公钥（和其他信息）数字签名后生成证书。</p>\n<h4 id=\"3-解决通信方身份可能被伪装的问题——数字证书\"><a href=\"#3-解决通信方身份可能被伪装的问题——数字证书\" class=\"headerlink\" title=\"3.解决通信方身份可能被伪装的问题——数字证书\"></a>3.解决通信方身份可能被伪装的问题——数字证书</h4><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p>\n<p>我们来介绍一下数字证书认证机构的业务流程：</p>\n<ul>\n<li>服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li>\n<li>CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li>\n<li>如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;</li>\n<li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li>\n<li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li>\n<li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</li>\n</ul>\n<h3 id=\"四、-HTTPS工作流程\"><a href=\"#四、-HTTPS工作流程\" class=\"headerlink\" title=\"四、 HTTPS工作流程\"></a>四、 HTTPS工作流程</h3><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132710862.png\" alt=\"image-20220422132710862\" style=\"zoom:80%;\" />\n\n<p>1.Client 发起一个 HTTPS（比如<code>https://juejin.cn/user/4283353031252967</code>）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。</p>\n<p>2.Server 把事先配置好的公钥证书（public key certificate）返回给客户端。</p>\n<p>3.Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。</p>\n<p>4.Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。</p>\n<p>5.Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。</p>\n<p>6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。</p>\n<p>7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。</p>\n<p>8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。</p>\n<h3 id=\"五、HTTP-与-HTTPS-的区别\"><a href=\"#五、HTTP-与-HTTPS-的区别\" class=\"headerlink\" title=\"五、HTTP 与 HTTPS 的区别\"></a>五、HTTP 与 HTTPS 的区别</h3><ul>\n<li><p>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>\n</li>\n<li><p>HTTPS 比 HTTP 更加安全;</p>\n</li>\n<li><p>HTTPS 需要用到 SSL 证书，而 HTTP 不用;</p>\n</li>\n<li><p>HTTPS 标准端口 443，HTTP 标准端口 80;</p>\n</li>\n<li><p>HTTPS 基于传输层，HTTP 基于应用层;</p>\n</li>\n<li><p>HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示;</p>\n</li>\n</ul>\n<h3 id=\"六、为何不所有的网站都使用HTTPS\"><a href=\"#六、为何不所有的网站都使用HTTPS\" class=\"headerlink\" title=\"六、为何不所有的网站都使用HTTPS\"></a>六、为何不所有的网站都使用HTTPS</h3><p>既然 HTTPS 那么安全可靠，那为何不所有的 Web 网站都使用 HTTPS？</p>\n<p>首先，很多人还是会觉得 HTTPS 实施有门槛，这个门槛在于需要权威 CA 颁发的 SSL 证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。</p>\n<p>其次，HTTPS 普遍认为性能消耗要大于 HTTP，因为<strong>与纯文本通信相比，加密通信会消耗更多的CPU及内存资源</strong>。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。</p>\n<p>除此之外，<strong>想要节约购买证书的开销也是原因之一</strong>。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。</p>\n<p>最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS 部署趋势是由社会、企业、政府共同去推动的。</p>\n<h2 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h2><h3 id=\"什么是网络编程\"><a href=\"#什么是网络编程\" class=\"headerlink\" title=\"什么是网络编程\"></a>什么是网络编程</h3><p>网络编程的本质是多台计算机之间的数据交换。现在的网络编程基本上都是基于请求&#x2F;响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻响应连接，则需要一直启动。</p>\n<h3 id=\"网络编程中两个主要的问题\"><a href=\"#网络编程中两个主要的问题\" class=\"headerlink\" title=\"网络编程中两个主要的问题\"></a>网络编程中两个主要的问题</h3><p><strong>1、</strong>一个是如何准确的定位网络上一台或多台主机，</p>\n<p><strong>2、</strong>另一个就是找到主机后如何可靠高效的进行数据传输。</p>\n<ul>\n<li>在 TCP&#x2F;IP 协议中 IP 层网际层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。</li>\n<li>而 TCP 层传输层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。</li>\n</ul>\n<h3 id=\"网络协议是什么\"><a href=\"#网络协议是什么\" class=\"headerlink\" title=\"网络协议是什么\"></a>网络协议是什么</h3><p>在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>\n<h3 id=\"为什么要对网络协议分层\"><a href=\"#为什么要对网络协议分层\" class=\"headerlink\" title=\"为什么要对网络协议分层\"></a>为什么要对网络协议分层</h3><p><strong>1、</strong>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</p>\n<p><strong>2、</strong>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</p>\n<p><strong>3、</strong>易于实现和维护。</p>\n<p><strong>4、</strong>促进标准化工作。分开后，每层功能可以相对简单地被描述</p>\n<h3 id=\"体系结构\"><a href=\"#体系结构\" class=\"headerlink\" title=\"体系结构\"></a>体系结构</h3><p><strong>TCP&#x2F;IP参考模型</strong></p>\n<p>OSI 七层协议：应用（HTTP）、表示（SSL&#x2F;TLS）、会话（RPC）、传输（TCP）、网络（IP）、链路（ARP）、物理</p>\n<p>TCP&#x2F;IP 四层协议（数据链路层、网络层、传输层、应用层）</p>\n<p><strong>1、</strong>应用层 <strong>为用户提供各种网络服务</strong>。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET 等。（HTTP 协议全称 Hyper Text Transfer Protocol 超文本传输协议，在浏览器与服务器间传送文档）</p>\n<p><strong>2、</strong>传输层 <strong>建立了主机端到端的连接</strong>，传输层的作用是<strong>为上层协议提供端到端的可靠和透明的数据传输服务</strong>，包括处理差错控制和流量控制等问题。（TCP、UDP）</p>\n<p><strong>3、</strong>网络层 <strong>通过IP寻址来建立两个节点之间的连接</strong>，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。（IP）</p>\n<p><strong>4、</strong>数据链路层 <strong>通过一些规则来控制这些数据的传输</strong>，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路。</p>\n<h3 id=\"什么是TCP和UDP\"><a href=\"#什么是TCP和UDP\" class=\"headerlink\" title=\"什么是TCP和UDP\"></a>什么是TCP和UDP</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>面向连接</td>\n<td>面向连接</td>\n<td>无连接</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>可靠传输，使用拥塞控制和流量控制</td>\n<td>可靠传输</td>\n</tr>\n<tr>\n<td>连接个数</td>\n<td>只能一对一通信</td>\n<td>支持一对一、一对多、多对一、多对多通信</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>要求可靠传输的应用（文件传输）</td>\n<td>实时应用（视频会议、网络直播）</td>\n</tr>\n</tbody></table>\n<h3 id=\"浏览器中输入：网址后都发生了什么？请详细阐述。\"><a href=\"#浏览器中输入：网址后都发生了什么？请详细阐述。\" class=\"headerlink\" title=\"浏览器中输入：网址后都发生了什么？请详细阐述。\"></a>浏览器中输入：网址后都发生了什么？请详细阐述。</h3><p><strong>1、</strong>域名解析，域名→IP 地址，解析过程依次经过了浏览器本地缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。</p>\n<p><strong>2、</strong>建立 TCP&#x2F;IP 连接（三次握手具体过程）</p>\n<p><strong>3、</strong>由浏览器发送一个 HTTP 请求</p>\n<p><strong>4、</strong>经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器</p>\n<p><strong>5、</strong>服务器处理该 HTTP 请求，返回一个 HTML 文件</p>\n<p><strong>6、</strong>浏览器解析该 HTML 文件，并且显示在浏览器端</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640.webp\" alt=\"图片\"></p>\n<h3 id=\"TCP-协议如何来保证传输的可靠性\"><a href=\"#TCP-协议如何来保证传输的可靠性\" class=\"headerlink\" title=\"TCP 协议如何来保证传输的可靠性\"></a>TCP 协议如何来保证传输的可靠性</h3><p><strong>对于可靠性，TCP通过以下方式进行保证：</strong></p>\n<blockquote>\n<p>接收方对数据包进行检查，是否<strong>失序</strong>，失序的话要重排序，是否<strong>重复</strong>，重复的话将重复的数据丢弃，是否<strong>出错</strong>，出错的话将该报文段丢弃。否则的话，接收方会给发送方一个发送一个确认。发送方发送之后如果没有收到这个确认在一定时间后会重发这个报文段。</p>\n</blockquote>\n<ul>\n<li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</li>\n<li><strong>对失序数据包重排序</strong>：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</li>\n<li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</li>\n<li><strong>应答机制</strong>：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>\n<li><strong>超时重发</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>\n<li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。<br>  TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议</strong>。</li>\n</ul>\n<h3 id=\"TCP-的拥塞避免机制\"><a href=\"#TCP-的拥塞避免机制\" class=\"headerlink\" title=\"TCP 的拥塞避免机制\"></a>TCP 的拥塞避免机制</h3><p><a href=\"https://www.cnblogs.com/hongdada/p/11206679.html\">https://www.cnblogs.com/hongdada/p/11206679.html</a></p>\n<p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。</p>\n<p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p>\n<p>拥塞控制的方法：</p>\n<p><strong>1、 慢开始 + 拥塞避免：</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718131944933-703202720.png\" alt=\"img\"></p>\n<p><strong>慢开始</strong>：拥塞窗口从 1、2、4 以指数规律增长；</p>\n<p><strong>拥塞避免</strong>：到达慢开始阈值后，开始拥塞避免“加法增大”</p>\n<p><strong>2、快重传 + 快恢复：</strong><br><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718132020300-1269239957.png\" alt=\"img\"></p>\n<p><strong>快重传</strong>： **快重传要求接收方在收到一个失序的报文段后就立即发出 重复确认 **（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定， <strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>，而不必继续等待设置的重传计时器时间到期。</p>\n<p><strong>快恢复</strong>：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行<strong>“乘法减小”算法，把 ssthresh 门限减半</strong>，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将拥塞窗口设置为慢开始阈值的大小，<strong>然后执行拥塞避免算法让拥塞窗口线性加1</strong>。</p>\n<h3 id=\"什么是Http协议？\"><a href=\"#什么是Http协议？\" class=\"headerlink\" title=\"什么是Http协议？\"></a>什么是Http协议？</h3><ul>\n<li>Http 协议属于应用层，是在浏览器与服务器间传送文档的规范，简称为“超文本传输协议”</li>\n</ul>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210326001352.png\"></p>\n<h3 id=\"说说HTTP常用的状态码及其含义？\"><a href=\"#说说HTTP常用的状态码及其含义？\" class=\"headerlink\" title=\"说说HTTP常用的状态码及其含义？\"></a>说说HTTP常用的状态码及其含义？</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518889206.webp\" alt=\"图片\"></p>\n<p>不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518894201.webp\" alt=\"图片\"></p>\n<h3 id=\"Http和Https的区别？\"><a href=\"#Http和Https的区别？\" class=\"headerlink\" title=\"Http和Https的区别？\"></a>Http和Https的区别？</h3><p>Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：</p>\n<ul>\n<li>端口不同：Http 与 Https 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</li>\n<li>资源消耗：和 HTTP 通信相比，Https 通信会由于加密解密处理消耗更多的 CPU 和内存资源；</li>\n<li>开销：Https 通信需要证书，而证书一般需要向认证机构购买；</li>\n</ul>\n<p>Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>\n<h3 id=\"什么是http的请求体？\"><a href=\"#什么是http的请求体？\" class=\"headerlink\" title=\"什么是http的请求体？\"></a>什么是http的请求体？</h3><p><strong>1、</strong>HTTP 请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器拿数据，先要表明我要什么吧</p>\n<p><strong>2、</strong>HTTP 请求体由：<strong>请求行、请求头、请求体</strong> 组成的</p>\n<blockquote>\n<p>请求行：请求方法（POST）、URL（character&#x2F;use.html） 和 HTTP 协议版本（HTTP&#x2F;1.1）</p>\n<p>请求头：</p>\n<ul>\n<li>User-Agent：发送请求的浏览器类型;</li>\n<li>Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ <em>&#x2F;</em> ” 指示可接受全部类型，用“ type&#x2F;* ”指示可接受 type 类型的所有子类型;</li>\n<li>Accept-Language：客户端可接受的自然语言;</li>\n<li>Accept-Encoding：客户端可接受的编码格式;</li>\n<li>Accept-Charset：可接受的应答的字符集;</li>\n<li>Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;</li>\n<li>Connection：连接方式(close 或 keepalive);</li>\n<li>Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</li>\n</ul>\n</blockquote>\n<p><strong>3、</strong>注意：GET 请求是没有请求体的</p>\n<h3 id=\"HTTP的响应报文有哪些？\"><a href=\"#HTTP的响应报文有哪些？\" class=\"headerlink\" title=\"HTTP的响应报文有哪些？\"></a>HTTP的响应报文有哪些？</h3><p><strong>1、</strong>http 的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文</p>\n<p><strong>2、</strong>响应报文包含三部分 <strong>状态行、响应头、响应体</strong></p>\n<h3 id=\"Http中常见的header字段有哪些？\"><a href=\"#Http中常见的header字段有哪些？\" class=\"headerlink\" title=\"Http中常见的header字段有哪些？\"></a>Http中常见的header字段有哪些？</h3><p>cookie，请求时传递给服务端的 cookie 信息<br>set-cookie，响应报文首部设置要传递给客户端的 cookie 信息<br>allow，支持什么 HTTP 方法<br>last-modified，资源的最后修改时间<br>expires,设置资源缓存的失败日期<br>content-language，实体的资源语言<br>content-encoding，实体的编码格式<br>content-length，实体主体部分的大小单位是字节<br>content-range，返回的实体的哪些范围<br>content-type，哪些类型<br>accept-ranges，处理的范围请求<br>age，告诉客户端服务器在多久前创建了响应<br>vary，代理服务器的缓存信息<br>location，用于指定重定向后的 URI<br>If-Match，值是资源的唯一标识<br>User-Agent，将创建请求的浏览器和用户代理名称等信息传递给服务器<br>Transfer-Encoding，传输报文的主体编码方式<br>connection，管理持久连接 keep-alive , close Cache-Control，控制浏览器的强缓存</p>\n<h3 id=\"HTTPS工作原理\"><a href=\"#HTTPS工作原理\" class=\"headerlink\" title=\"HTTPS工作原理\"></a>HTTPS工作原理</h3><p>（AES：非对称加密；RSA：对称加密）</p>\n<p><strong>1、</strong>首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA 加密）等进行校验；</p>\n<p><strong>2、</strong>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA 加密）；</p>\n<p><strong>3、</strong>消息体产生之后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名；</p>\n<p><strong>4、</strong>发送给服务端，此时只有服务端（RSA 私钥）能解密。</p>\n<p><strong>5、</strong>解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。</p>\n<h3 id=\"⭐为什么-TCP-链接需要三次握手，两次不可以么？\"><a href=\"#⭐为什么-TCP-链接需要三次握手，两次不可以么？\" class=\"headerlink\" title=\"⭐为什么 TCP 链接需要三次握手，两次不可以么？\"></a>⭐为什么 TCP 链接需要三次握手，两次不可以么？</h3><p>“三次握手” 的目的是为了防止<strong>已失效的链接请求报文突然又传送到了服务端</strong>，因而产生错误。</p>\n<ul>\n<li>正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。</li>\n<li>假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</li>\n</ul>\n<p>假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求（因为那个是已经失效的请求），因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p>\n<h3 id=\"⭐为什么要四次挥手？\"><a href=\"#⭐为什么要四次挥手？\" class=\"headerlink\" title=\"⭐为什么要四次挥手？\"></a>⭐为什么要四次挥手？</h3><p>TCP 是全双工模式，这就意味着，<br>当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；当 B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p>\n<p>所以想要愉快的结束这次对话就需要四次挥手。</p>\n<h3 id=\"⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\"><a href=\"#⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\" class=\"headerlink\" title=\"⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\"></a>⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>MSL（Maximum Segment Lifetime）<strong>报文最大寿命</strong>，TCP 允许不同的实现可以设置不同的 MSL 值。</p>\n<p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</p>\n<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。<br>————————————————<br>原文链接：<a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>\n<h3 id=\"⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a>⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP 还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个<strong>探测报文段</strong>，以后每隔 75 秒发送一次。若<strong>一连发送10个探测报文仍然没反应</strong>，服务器就认为客户端出了故障，接着就<strong>关闭连接</strong>。<br>————————————————<br>原文链接：<a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>\n<h3 id=\"IP地址是怎样分类的，你知道吗？\"><a href=\"#IP地址是怎样分类的，你知道吗？\" class=\"headerlink\" title=\"IP地址是怎样分类的，你知道吗？\"></a>IP地址是怎样分类的，你知道吗？</h3><p>先说一下 IP 的基本特点：</p>\n<ul>\n<li>IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。</li>\n<li>IP 地址由两部分组成，即<strong>网络地址</strong>和<strong>主机地址</strong>。<br>  网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。</li>\n</ul>\n<p>IP 地址根据网络地址进行分类，主要分为 A、B、C 三类及特殊地址 D、E 这五类</p>\n<p><strong>A类：</strong> (1.0.0.0-126.0.0.0)一般用于大型网络。</p>\n<p><strong>B类：</strong> (128.0.0.0-191.255.0.0)一般用于中等规模网络。</p>\n<p><strong>C类：</strong> (192.0.0.0-223.255.255.0)一般用于小型网络。</p>\n<p><strong>D类：</strong> 是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。</p>\n<p><strong>E类：</strong> 是保留地址。地址的网络号取值于 240~255 之间。</p>\n<h3 id=\"客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？\"><a href=\"#客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？\" class=\"headerlink\" title=\"客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？\"></a>客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h3><p>服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>\n<p><strong>(1) DDos 攻击：</strong></p>\n<ul>\n<li>客户端向服务端发送请求链接数据包</li>\n<li>服务端向客户端发送确认数据包</li>\n<li>客户端却不向服务端发送确认数据包，服务器<strong>一直等待</strong>来自客户端的确认</li>\n</ul>\n<p><strong>(2) DDos 预防：（没有彻底根治的办法，除非不使用TCP）</strong></p>\n<ul>\n<li>限制同时打开 SYN 半链接的数目</li>\n<li>缩短 SYN 半链接的 Time out 时间</li>\n<li>关闭不必要的服务</li>\n</ul>\n<h3 id=\"GET-与-POST-的区别？\"><a href=\"#GET-与-POST-的区别？\" class=\"headerlink\" title=\"GET 与 POST 的区别？\"></a>GET 与 POST 的区别？</h3><p>GET 与 POST 是我们常用的两种 HTTP Method，二者之间的区别主要包括如下五个方面：</p>\n<p><strong>1、</strong> 从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</p>\n<p><strong>2、</strong>从请求参数形式上看，GET请求的数据会<strong>附在URL上</strong>，以?分割 URL 和传输数据，参数之间以&amp;相连；而 POST 请求会把提交的数据则放置在 HTTP 请求报文的 <strong>请求体</strong> 中。</p>\n<p><strong>3、</strong>就安全性而言，POST的<strong>安全性</strong>要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全。</p>\n<p><strong>4、</strong>从请求的大小看，GET请求的<strong>长度</strong>受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p>\n<h3 id=\"DNS的寻址过程你知道吗？\"><a href=\"#DNS的寻址过程你知道吗？\" class=\"headerlink\" title=\"DNS的寻址过程你知道吗？\"></a>DNS的寻址过程你知道吗？</h3><p>浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。</p>\n<h3 id=\"什么是Socket\"><a href=\"#什么是Socket\" class=\"headerlink\" title=\"什么是Socket\"></a>什么是Socket</h3><p><strong>1、</strong>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP&#x2F;IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。</p>\n<p><strong>2、</strong>但是，Socket 所支持的协议种类也不光 TCP&#x2F;IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP&#x2F;IP 协议的网络编程。</p>\n<p><strong>3、</strong>socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的</p>\n<p><strong>4、</strong>Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多，</p>\n<h3 id=\"Socket属于网络的那个层面\"><a href=\"#Socket属于网络的那个层面\" class=\"headerlink\" title=\"Socket属于网络的那个层面\"></a>Socket属于网络的那个层面</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210325212441.png\"></p>\n<p>Socket 是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>\n<h3 id=\"Socket通讯的过程\"><a href=\"#Socket通讯的过程\" class=\"headerlink\" title=\"Socket通讯的过程\"></a>Socket通讯的过程</h3><p><strong>基于TCP：</strong></p>\n<p>服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>\n<p><strong>基于UDP：</strong></p>\n<p>UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管</p>\n<h3 id=\"Socket和http的区别和应用场景\"><a href=\"#Socket和http的区别和应用场景\" class=\"headerlink\" title=\"Socket和http的区别和应用场景\"></a>Socket和http的区别和应用场景</h3><p><strong>1、</strong>Socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；</p>\n<p><strong>2、</strong>Socket 适用场景：网络游戏，银行持续交互，直播，在线视屏等。</p>\n<p><strong>3、</strong>http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接</p>\n<p><strong>4、</strong>http 适用场景：公司 OA 服务，互联网服务，电商，办公，网站等等等等</p>\n<h3 id=\"什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议\"><a href=\"#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议\" class=\"headerlink\" title=\"什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?\"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h3><p>HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。服务器无法判断用户身份。</p>\n<p>HTTP 的这种特性有优点也有缺点：</p>\n<ul>\n<li><strong>优点</strong>：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用</li>\n<li><strong>缺点</strong>：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享</li>\n</ul>\n<p>解决方案：</p>\n<ol>\n<li>使用参数传递机制：<br> 将参数拼接在请求的 URL 后面，实现数据的传递（GET 方式），例如：<code>/param/list?username=wmyskxz</code><br> <strong>问题</strong>：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有 1kb</li>\n<li>使用 Cookie 技术</li>\n<li>使用 Session 技术</li>\n</ol>\n<p>Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。</p>\n<h3 id=\"什么是Cookie\"><a href=\"#什么是Cookie\" class=\"headerlink\" title=\"什么是Cookie\"></a>什么是Cookie</h3><p>Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie，而客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器，服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。 </p>\n<h3 id=\"什么是Session\"><a href=\"#什么是Session\" class=\"headerlink\" title=\"什么是Session\"></a>什么是Session</h3><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 session。</p>\n<p>服务器默认为客户浏览器的 cookie 中设置 sessionid，这个 sessionid 就和 cookie 对应，浏览器在向服务器请求过程中传输的 cookie 包含 sessionid ，服务器根据传输 cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p>\n<h3 id=\"Cookie和Session对于HTTP有什么用？\"><a href=\"#Cookie和Session对于HTTP有什么用？\" class=\"headerlink\" title=\"Cookie和Session对于HTTP有什么用？\"></a>Cookie和Session对于HTTP有什么用？</h3><p> HTTP 协议本身是无法判断用户身份。所以需要 cookie 或者 session</p>\n<h3 id=\"Cookie与Session区别\"><a href=\"#Cookie与Session区别\" class=\"headerlink\" title=\"Cookie与Session区别\"></a>Cookie与Session区别</h3><ul>\n<li><strong>实现机制</strong>：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；</li>\n<li><strong>大小限制</strong>：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；</li>\n<li><strong>安全性</strong>：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；</li>\n<li><strong>服务器资源消耗</strong>：Session 是一定时间内保存在服务器端上，如果 session 过多会增加服务器的压力。</li>\n</ul>\n<h3 id=\"什么是Token\"><a href=\"#什么是Token\" class=\"headerlink\" title=\"什么是Token\"></a>什么是Token</h3><p>Token 的引入：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</p>\n<p>Token 的定义：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</p>\n<p>使用 Token 的目的：Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>\n<p>Token 是在服务端产生的。如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token <strong>证明自己的合法地位</strong></p>\n<h3 id=\"session与token区别\"><a href=\"#session与token区别\" class=\"headerlink\" title=\"session与token区别\"></a>session与token区别</h3><ul>\n<li>session 存储在服务器端，token 存储在客户端</li>\n<li>token 提供认证和授权功能，作为身份认证，token 安全性比 session 好；</li>\n<li>⭐session 这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token 适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>\n</ul>\n<h3 id=\"常用的HTTP方法有哪些？\"><a href=\"#常用的HTTP方法有哪些？\" class=\"headerlink\" title=\"常用的HTTP方法有哪些？\"></a>常用的HTTP方法有哪些？</h3><ul>\n<li><strong>GET：</strong>用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器</li>\n<li><strong>POST：</strong>用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。</li>\n<li><strong>PUT：</strong>传输文件，报文主体中包含文件内容，保存到对应 URI 位置。</li>\n<li><strong>HEAD：</strong>获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</li>\n<li><strong>DELETE：</strong>删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。</li>\n<li><strong>OPTIONS：</strong>查询相应 URI 支持的 HTTP 方法。</li>\n</ul>\n<h3 id=\"网络层的-ARP-协议工作原理？\"><a href=\"#网络层的-ARP-协议工作原理？\" class=\"headerlink\" title=\"网络层的 ARP 协议工作原理？\"></a>网络层的 ARP 协议工作原理？</h3><p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射</p>\n<h3 id=\"IP地址与物理地址\"><a href=\"#IP地址与物理地址\" class=\"headerlink\" title=\"IP地址与物理地址\"></a>IP地址与物理地址</h3><p>物理地址是数据链路层和物理层使用的地址，IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，其中 ARP 协议用于 IP 地址与物理地址的对应。</p>\n<h3 id=\"影响网络传输的因素有哪些？\"><a href=\"#影响网络传输的因素有哪些？\" class=\"headerlink\" title=\"影响网络传输的因素有哪些？\"></a>影响网络传输的因素有哪些？</h3><p>将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。</p>\n<p>1、网络带宽<br>2、传输距离<br>3、TCP 拥塞控制</p>\n<h3 id=\"什是对称加密与非对称加密\"><a href=\"#什是对称加密与非对称加密\" class=\"headerlink\" title=\"什是对称加密与非对称加密\"></a>什是对称加密与非对称加密</h3><p>对称密钥加密是指<strong>加密和解密使用同一个密钥</strong>的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</p>\n<p>而非对称加密是指使用<strong>一对非对称密钥，即公钥和私钥</strong>，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p>\n<h3 id=\"HTTPS采用对称加密-非对称加密\"><a href=\"#HTTPS采用对称加密-非对称加密\" class=\"headerlink\" title=\"HTTPS采用对称加密+非对称加密\"></a>HTTPS采用对称加密+非对称加密</h3><p>使用对称加密，优点是加密解密速度快，缺点是不安全；<br>使用非对称加密，优点是保证安全性，缺点是速度慢；</p>\n<p>Https 结合两种加密方式的优点，<br>在<strong>交换密钥环节</strong>使用非对称加密方式，之后的<strong>建立通信交换报文</strong>阶段则使用对称加密方式。</p>\n<h2 id=\"TCP-x2F-IP-协议族\"><a href=\"#TCP-x2F-IP-协议族\" class=\"headerlink\" title=\"TCP&#x2F;IP 协议族\"></a>TCP&#x2F;IP 协议族</h2><h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>\n<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。应用进程利用该服务传送应用层报文。</p>\n<p>运输层主要使用一下两种协议</p>\n<ol>\n<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>\n<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>面向连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠传输，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>支持一对一，一对多，多对一和多对多交互通信</td>\n<td>只能是一对一通信</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向字节流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>首部开销小，仅8字节</td>\n<td>首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>场景</td>\n<td>适用于实时应用（IP电话、视频会议、直播等）</td>\n<td>适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody></table>\n<p><strong>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong></p>\n<p>运行在<code>TCP协议</code>上的协议：</p>\n<ul>\n<li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议）</code>，主要用于普通浏览。</li>\n<li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,<code>HTTP</code>协议的安全版本。</li>\n<li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li>\n<li><code>POP3（Post Office Protocol, version 3，邮局协议）</code>，收邮件用。</li>\n<li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li>\n<li><code>TELNET（Teletype over the Network，网络电传）</code>，通过一个<code>终端（terminal）</code>登陆到网络。</li>\n<li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li>\n</ul>\n<p>运行在<code>UDP协议</code>上的协议：</p>\n<ul>\n<li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置 IP 地址。</li>\n</ul>\n<p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p>\n<ul>\n<li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li>\n</ul>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>网络层的任务就是<strong>选择合适的网间路由和交换结点，确保计算机通信的数据及时传送</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>\n<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>\n<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p>\n<p>一般的 web 应用的通信传输流是这样的：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzkvMTZhOWM5Y2Q1MjNlMDU5OQ.png\" alt=\"img\"></p>\n<p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>\n<h3 id=\"TCP-x2F-IP-协议族-1\"><a href=\"#TCP-x2F-IP-协议族-1\" class=\"headerlink\" title=\"TCP&#x2F;IP 协议族\"></a>TCP&#x2F;IP 协议族</h3><p>在互联网使用的各种协议中最重要和最著名的就是 TCP&#x2F;IP 两个协议。现在人们经常提到的 TCP&#x2F;IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP&#x2F;IP 协议族。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS80LzcvMTY5ZjY5NjZjMjRhZjM0NQ.png\" alt=\"img\"></p>\n<p>TCP（传输控制协议）和 IP（网际协议）是<strong>最先定义的两个核心协议</strong>，所以才统称为 TCP&#x2F;IP 协议族</p>\n<h2 id=\"TCP的三次握手四次挥手\"><a href=\"#TCP的三次握手四次挥手\" class=\"headerlink\" title=\"TCP的三次握手四次挥手\"></a>TCP的三次握手四次挥手</h2><p>TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。</p>\n<p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接</strong>。</p>\n<p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p>\n<h3 id=\"TCP报文的头部结构\"><a href=\"#TCP报文的头部结构\" class=\"headerlink\" title=\"TCP报文的头部结构\"></a>TCP报文的头部结构</h3><p>有几个字段需要重点介绍下：</p>\n<p>（1）序号：seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>\n<p>（2）确认序号：ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack&#x3D;seq+1。</p>\n<p>（3）标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：</p>\n<ul>\n<li>ACK：确认序号有效。</li>\n<li>FIN：释放一个连接。</li>\n<li>PSH：接收方应该尽快将这个报文交给应用层。</li>\n<li>RST：重置连接。</li>\n<li>SYN：发起一个新连接。</li>\n<li>URG：紧急指针（urgent pointer）有效。</li>\n</ul>\n<p>需要注意的是：</p>\n<ul>\n<li>不要将确认序号 ack 与标志位中的 ACK 搞混了。</li>\n<li>确认方 ack&#x3D;发起方 seq+1，两端配对。</li>\n</ul>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><blockquote>\n<p>三次握手的本质是确认通信双方收发数据的能力</p>\n</blockquote>\n<p>A-&gt;B</p>\n<p>A 发送给 B，B 若收到</p>\n<blockquote>\n<p>说明B知道：A可以发，B可以收</p>\n</blockquote>\n<p>B 返回给 A，A 若收到：说明 A 之前发给 B 的 B 收到了，同时 B 也能给自己回信，自己能收到这个回信。</p>\n<blockquote>\n<p>说明：A知道：A能发能收，B能收能发</p>\n</blockquote>\n<p>但是此时 B 不知道 A 是否可以收，B 是否发送正常</p>\n<p>于是 A 发送给 B，B 若收到：说明 B 的发送回信 A 能收到</p>\n<blockquote>\n<p>说明：B 知道 A 可以收，B 可以发，结合第一步，得到 B 也知道 A 能发能收，B 能收能发</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA.png\" alt=\"三次握手\"></p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><blockquote>\n<p>四次挥手的目的是关闭一个连接</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw.png\" alt=\"四次挥手\"></p>\n<p>A 和 B 打电话，通话即将结束后，<br>A 说“我没啥要说的了”，<br>B 回答“我知道了”，<br>但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，<br>A 回答“知道了”，这样通话才算结束。</p>\n","site":{"data":{}},"length":17051,"excerpt":"<blockquote>\n<p>整理的计算机网络相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"深入理解HTTPS工作原理\"><a href=\"#深入理解HTTPS工作原理\" class=\"headerlink\" title=\"深入理解HTTPS工作原理\"></a>深入理解HTTPS工作原理</h2><blockquote>\n<p><a href=\"https://juejin.cn/post/6844903830916694030\">https://juejin.cn/post/6844903830916694030</a></p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的 HTTP 协议，在逐渐的被 HTTPS 协议所取代，在浏览器、搜索引擎、CA 机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS 加密时代”，HTTPS 将在未来的几年内全面取代 HTTP 成为传输协议的主流。</p>\n<p>读完本文，希望你能明白：</p>\n<ul>\n<li>HTTP 通信存在什么问题</li>\n<li>HTTPS 如何改进 HTTP 存在那些问题</li>\n<li>HTTPS 工作原理是什么</li>\n</ul>\n<h3 id=\"一、什么是HTTPS\"><a href=\"#一、什么是HTTPS\" class=\"headerlink\" title=\"一、什么是HTTPS\"></a>一、什么是HTTPS</h3><p>HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>\n<p>HTTPS 主要作用是：</p>\n<p>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</p>\n<p>（2）对网站服务器进行真实身份认证。</p>\n<p>我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用<code>http://</code>，而是改用<code>https://</code>。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。</p>\n<h3 id=\"二、为什么需要HTTPS\"><a href=\"#二、为什么需要HTTPS\" class=\"headerlink\" title=\"二、为什么需要HTTPS\"></a>二、为什么需要HTTPS</h3><p>在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题，接下来，我们先来了解下 HTTP 协议存在的哪些问题：</p>\n<ul>\n<li><p>通信使用明文（不加密），内容可能被<strong>窃听</strong> </p>\n<p>  信息加密：使用非对称加密（RSA）交换密钥，使用对称加密（AES）传输报文，兼备安全与效率</p>\n</li>\n<li><p>无法证明报文的完整性，所以可能遭<strong>篡改</strong> </p>\n<p>  完整性校验：数字签名</p>\n</li>\n<li><p>不验证通信方的身份，因此有可能遭遇<strong>伪装</strong> </p>\n<p>  身份验证：数字证书</p>\n</li>\n</ul>\n<h3 id=\"三、HTTPS如何解决HTTP上述问题\"><a href=\"#三、HTTPS如何解决HTTP上述问题\" class=\"headerlink\" title=\"三、HTTPS如何解决HTTP上述问题?\"></a>三、HTTPS如何解决HTTP上述问题?</h3><p><strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132445345.png\" alt=\"image-20220422132445345\" style=\"zoom:33%;\" />\n\n\n\n<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、完整性校验、身份验证这些功能。也就是说<strong>HTTP加上加密处理和认证以及完整性保护后即是HTTPS</strong>。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132508534.png\" alt=\"image-20220422132508534\" style=\"zoom:33%;\" />\n\n<p>HTTPS 协议的主要功能基本都依赖于 TLS&#x2F;SSL 协议，TLS&#x2F;SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，<strong>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性</strong>。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132525551.png\" alt=\"image-20220422132525551\" style=\"zoom:33%;\" />\n\n\n\n<h4 id=\"1-解决内容可能被窃听的问题——加密\"><a href=\"#1-解决内容可能被窃听的问题——加密\" class=\"headerlink\" title=\"1.解决内容可能被窃听的问题——加密\"></a>1.解决内容可能被窃听的问题——加密</h4><h4 id=\"方法1-对称加密\"><a href=\"#方法1-对称加密\" class=\"headerlink\" title=\"方法1.对称加密\"></a>方法1.对称加密</h4><p>这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。<strong>没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了</strong>。</p>\n<p>以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>\n<h4 id=\"方法2-非对称加密\"><a href=\"#方法2-非对称加密\" class=\"headerlink\" title=\"方法2.非对称加密\"></a>方法2.非对称加密</h4><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，<strong>私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得</strong>。</p>\n<p>使用公开密钥加密方式，发送密文的一方使用<strong>对方的公开密钥</strong>进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132541737.png\" alt=\"image-20220422132541737\" style=\"zoom:33%;\" />\n\n<p>非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。</p>\n<p>这种方式有以下缺点：</p>\n<ul>\n<li>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；</li>\n<li>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</li>\n<li>使用非对称加密<strong>在数据加密解密过程需要消耗一定时间</strong>，降低了数据传输效率；</li>\n</ul>\n<h4 id=\"方法3-对称加密-非对称加密-HTTPS采用这种方式\"><a href=\"#方法3-对称加密-非对称加密-HTTPS采用这种方式\" class=\"headerlink\" title=\"方法3.对称加密+非对称加密(HTTPS采用这种方式)\"></a>方法3.对称加密+非对称加密(HTTPS采用这种方式)</h4><p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，<strong>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式</strong>。</p>\n<p>具体做法是：<strong>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</strong>。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。</p>\n<h4 id=\"2-解决报文可能遭篡改问题——数字签名\"><a href=\"#2-解决报文可能遭篡改问题——数字签名\" class=\"headerlink\" title=\"2.解决报文可能遭篡改问题——数字签名\"></a>2.解决报文可能遭篡改问题——数字签名</h4><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。</p>\n<p><strong>数字签名有两种功效</strong>：</p>\n<ul>\n<li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li>\n<li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li>\n</ul>\n<p><strong>数字签名如何生成:</strong></p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132605229.png\" alt=\"image-20220422132605229\" style=\"zoom:33%;\" />\n\n<p>将一段文本先用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。</p>\n<p><strong>校验数字签名流程</strong>：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132617982.png\" alt=\"image-20220422132617982\" style=\"zoom:33%;\" />\n\n<p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>\n<p>假设消息传递在 Kobe，James 两人之间发生。James 将消息连同数字签名一起发送给 Kobe，Kobe 接收到消息后，通过校验数字签名，就可以验证接收到的消息就是 James 发送的。当然，这个过程的前提是 Kobe 知道 James 的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Kobe,或者说拿到的公钥如何证明是 James 的。</p>\n<p>此时就需要引入了<strong>证书颁发机构</strong>（Certificate Authority，简称 CA），CA 数量并不多，Kobe 客户端内置了所有受信任 CA 的证书。CA 对 James 的公钥（和其他信息）数字签名后生成证书。</p>\n<h4 id=\"3-解决通信方身份可能被伪装的问题——数字证书\"><a href=\"#3-解决通信方身份可能被伪装的问题——数字证书\" class=\"headerlink\" title=\"3.解决通信方身份可能被伪装的问题——数字证书\"></a>3.解决通信方身份可能被伪装的问题——数字证书</h4><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p>\n<p>我们来介绍一下数字证书认证机构的业务流程：</p>\n<ul>\n<li>服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li>\n<li>CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li>\n<li>如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;</li>\n<li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li>\n<li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li>\n<li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</li>\n</ul>\n<h3 id=\"四、-HTTPS工作流程\"><a href=\"#四、-HTTPS工作流程\" class=\"headerlink\" title=\"四、 HTTPS工作流程\"></a>四、 HTTPS工作流程</h3><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesimage-20220422132710862.png\" alt=\"image-20220422132710862\" style=\"zoom:80%;\" />\n\n<p>1.Client 发起一个 HTTPS（比如<code>https://juejin.cn/user/4283353031252967</code>）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。</p>\n<p>2.Server 把事先配置好的公钥证书（public key certificate）返回给客户端。</p>\n<p>3.Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。</p>\n<p>4.Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。</p>\n<p>5.Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。</p>\n<p>6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。</p>\n<p>7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。</p>\n<p>8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。</p>\n<h3 id=\"五、HTTP-与-HTTPS-的区别\"><a href=\"#五、HTTP-与-HTTPS-的区别\" class=\"headerlink\" title=\"五、HTTP 与 HTTPS 的区别\"></a>五、HTTP 与 HTTPS 的区别</h3><ul>\n<li><p>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p>\n</li>\n<li><p>HTTPS 比 HTTP 更加安全;</p>\n</li>\n<li><p>HTTPS 需要用到 SSL 证书，而 HTTP 不用;</p>\n</li>\n<li><p>HTTPS 标准端口 443，HTTP 标准端口 80;</p>\n</li>\n<li><p>HTTPS 基于传输层，HTTP 基于应用层;</p>\n</li>\n<li><p>HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示;</p>\n</li>\n</ul>\n<h3 id=\"六、为何不所有的网站都使用HTTPS\"><a href=\"#六、为何不所有的网站都使用HTTPS\" class=\"headerlink\" title=\"六、为何不所有的网站都使用HTTPS\"></a>六、为何不所有的网站都使用HTTPS</h3><p>既然 HTTPS 那么安全可靠，那为何不所有的 Web 网站都使用 HTTPS？</p>\n<p>首先，很多人还是会觉得 HTTPS 实施有门槛，这个门槛在于需要权威 CA 颁发的 SSL 证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。</p>\n<p>其次，HTTPS 普遍认为性能消耗要大于 HTTP，因为<strong>与纯文本通信相比，加密通信会消耗更多的CPU及内存资源</strong>。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在 SLB 或 CDN，来解决此问题。举个实际的例子，“双十一”期间，全站 HTTPS 的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与 HTTP 持平甚至还有小幅提升，因此 HTTPS 经过优化之后其实并不慢。</p>\n<p>除此之外，<strong>想要节约购买证书的开销也是原因之一</strong>。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。</p>\n<p>最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS 部署趋势是由社会、企业、政府共同去推动的。</p>\n<h2 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h2><h3 id=\"什么是网络编程\"><a href=\"#什么是网络编程\" class=\"headerlink\" title=\"什么是网络编程\"></a>什么是网络编程</h3><p>网络编程的本质是多台计算机之间的数据交换。现在的网络编程基本上都是基于请求&#x2F;响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻响应连接，则需要一直启动。</p>\n<h3 id=\"网络编程中两个主要的问题\"><a href=\"#网络编程中两个主要的问题\" class=\"headerlink\" title=\"网络编程中两个主要的问题\"></a>网络编程中两个主要的问题</h3><p><strong>1、</strong>一个是如何准确的定位网络上一台或多台主机，</p>\n<p><strong>2、</strong>另一个就是找到主机后如何可靠高效的进行数据传输。</p>\n<ul>\n<li>在 TCP&#x2F;IP 协议中 IP 层网际层主要负责网络主机的定位，数据传输的路由，由 IP 地址可以唯一地确定 Internet 上的一台主机。</li>\n<li>而 TCP 层传输层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心 IP 层是如何处理数据的。</li>\n</ul>\n<h3 id=\"网络协议是什么\"><a href=\"#网络协议是什么\" class=\"headerlink\" title=\"网络协议是什么\"></a>网络协议是什么</h3><p>在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。</p>\n<h3 id=\"为什么要对网络协议分层\"><a href=\"#为什么要对网络协议分层\" class=\"headerlink\" title=\"为什么要对网络协议分层\"></a>为什么要对网络协议分层</h3><p><strong>1、</strong>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</p>\n<p><strong>2、</strong>灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。</p>\n<p><strong>3、</strong>易于实现和维护。</p>\n<p><strong>4、</strong>促进标准化工作。分开后，每层功能可以相对简单地被描述</p>\n<h3 id=\"体系结构\"><a href=\"#体系结构\" class=\"headerlink\" title=\"体系结构\"></a>体系结构</h3><p><strong>TCP&#x2F;IP参考模型</strong></p>\n<p>OSI 七层协议：应用（HTTP）、表示（SSL&#x2F;TLS）、会话（RPC）、传输（TCP）、网络（IP）、链路（ARP）、物理</p>\n<p>TCP&#x2F;IP 四层协议（数据链路层、网络层、传输层、应用层）</p>\n<p><strong>1、</strong>应用层 <strong>为用户提供各种网络服务</strong>。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET 等。（HTTP 协议全称 Hyper Text Transfer Protocol 超文本传输协议，在浏览器与服务器间传送文档）</p>\n<p><strong>2、</strong>传输层 <strong>建立了主机端到端的连接</strong>，传输层的作用是<strong>为上层协议提供端到端的可靠和透明的数据传输服务</strong>，包括处理差错控制和流量控制等问题。（TCP、UDP）</p>\n<p><strong>3、</strong>网络层 <strong>通过IP寻址来建立两个节点之间的连接</strong>，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。（IP）</p>\n<p><strong>4、</strong>数据链路层 <strong>通过一些规则来控制这些数据的传输</strong>，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路。</p>\n<h3 id=\"什么是TCP和UDP\"><a href=\"#什么是TCP和UDP\" class=\"headerlink\" title=\"什么是TCP和UDP\"></a>什么是TCP和UDP</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>面向连接</td>\n<td>面向连接</td>\n<td>无连接</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>可靠传输，使用拥塞控制和流量控制</td>\n<td>可靠传输</td>\n</tr>\n<tr>\n<td>连接个数</td>\n<td>只能一对一通信</td>\n<td>支持一对一、一对多、多对一、多对多通信</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>要求可靠传输的应用（文件传输）</td>\n<td>实时应用（视频会议、网络直播）</td>\n</tr>\n</tbody></table>\n<h3 id=\"浏览器中输入：网址后都发生了什么？请详细阐述。\"><a href=\"#浏览器中输入：网址后都发生了什么？请详细阐述。\" class=\"headerlink\" title=\"浏览器中输入：网址后都发生了什么？请详细阐述。\"></a>浏览器中输入：网址后都发生了什么？请详细阐述。</h3><p><strong>1、</strong>域名解析，域名→IP 地址，解析过程依次经过了浏览器本地缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。</p>\n<p><strong>2、</strong>建立 TCP&#x2F;IP 连接（三次握手具体过程）</p>\n<p><strong>3、</strong>由浏览器发送一个 HTTP 请求</p>\n<p><strong>4、</strong>经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器</p>\n<p><strong>5、</strong>服务器处理该 HTTP 请求，返回一个 HTML 文件</p>\n<p><strong>6、</strong>浏览器解析该 HTML 文件，并且显示在浏览器端</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640.webp\" alt=\"图片\"></p>\n<h3 id=\"TCP-协议如何来保证传输的可靠性\"><a href=\"#TCP-协议如何来保证传输的可靠性\" class=\"headerlink\" title=\"TCP 协议如何来保证传输的可靠性\"></a>TCP 协议如何来保证传输的可靠性</h3><p><strong>对于可靠性，TCP通过以下方式进行保证：</strong></p>\n<blockquote>\n<p>接收方对数据包进行检查，是否<strong>失序</strong>，失序的话要重排序，是否<strong>重复</strong>，重复的话将重复的数据丢弃，是否<strong>出错</strong>，出错的话将该报文段丢弃。否则的话，接收方会给发送方一个发送一个确认。发送方发送之后如果没有收到这个确认在一定时间后会重发这个报文段。</p>\n</blockquote>\n<ul>\n<li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</li>\n<li><strong>对失序数据包重排序</strong>：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</li>\n<li><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据；</li>\n<li><strong>应答机制</strong>：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>\n<li><strong>超时重发</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>\n<li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。<br>  TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议</strong>。</li>\n</ul>\n<h3 id=\"TCP-的拥塞避免机制\"><a href=\"#TCP-的拥塞避免机制\" class=\"headerlink\" title=\"TCP 的拥塞避免机制\"></a>TCP 的拥塞避免机制</h3><p><a href=\"https://www.cnblogs.com/hongdada/p/11206679.html\">https://www.cnblogs.com/hongdada/p/11206679.html</a></p>\n<p>拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随着负荷的增大而下降。</p>\n<p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p>\n<p>拥塞控制的方法：</p>\n<p><strong>1、 慢开始 + 拥塞避免：</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718131944933-703202720.png\" alt=\"img\"></p>\n<p><strong>慢开始</strong>：拥塞窗口从 1、2、4 以指数规律增长；</p>\n<p><strong>拥塞避免</strong>：到达慢开始阈值后，开始拥塞避免“加法增大”</p>\n<p><strong>2、快重传 + 快恢复：</strong><br><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes443934-20190718132020300-1269239957.png\" alt=\"img\"></p>\n<p><strong>快重传</strong>： **快重传要求接收方在收到一个失序的报文段后就立即发出 重复确认 **（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定， <strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>，而不必继续等待设置的重传计时器时间到期。</p>\n<p><strong>快恢复</strong>：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行<strong>“乘法减小”算法，把 ssthresh 门限减半</strong>，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将拥塞窗口设置为慢开始阈值的大小，<strong>然后执行拥塞避免算法让拥塞窗口线性加1</strong>。</p>\n<h3 id=\"什么是Http协议？\"><a href=\"#什么是Http协议？\" class=\"headerlink\" title=\"什么是Http协议？\"></a>什么是Http协议？</h3><ul>\n<li>Http 协议属于应用层，是在浏览器与服务器间传送文档的规范，简称为“超文本传输协议”</li>\n</ul>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210326001352.png\"></p>\n<h3 id=\"说说HTTP常用的状态码及其含义？\"><a href=\"#说说HTTP常用的状态码及其含义？\" class=\"headerlink\" title=\"说说HTTP常用的状态码及其含义？\"></a>说说HTTP常用的状态码及其含义？</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518889206.webp\" alt=\"图片\"></p>\n<p>不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650518894201.webp\" alt=\"图片\"></p>\n<h3 id=\"Http和Https的区别？\"><a href=\"#Http和Https的区别？\" class=\"headerlink\" title=\"Http和Https的区别？\"></a>Http和Https的区别？</h3><p>Http 协议运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份；Https 是身披 SSL(Secure Socket Layer)外壳的 Http，运行于 SSL 上，SSL 运行于 TCP 之上，是添加了加密和认证机制的 HTTP。二者之间存在如下不同：</p>\n<ul>\n<li>端口不同：Http 与 Https 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</li>\n<li>资源消耗：和 HTTP 通信相比，Https 通信会由于加密解密处理消耗更多的 CPU 和内存资源；</li>\n<li>开销：Https 通信需要证书，而证书一般需要向认证机构购买；</li>\n</ul>\n<p>Https 的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>\n<h3 id=\"什么是http的请求体？\"><a href=\"#什么是http的请求体？\" class=\"headerlink\" title=\"什么是http的请求体？\"></a>什么是http的请求体？</h3><p><strong>1、</strong>HTTP 请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器拿数据，先要表明我要什么吧</p>\n<p><strong>2、</strong>HTTP 请求体由：<strong>请求行、请求头、请求体</strong> 组成的</p>\n<blockquote>\n<p>请求行：请求方法（POST）、URL（character&#x2F;use.html） 和 HTTP 协议版本（HTTP&#x2F;1.1）</p>\n<p>请求头：</p>\n<ul>\n<li>User-Agent：发送请求的浏览器类型;</li>\n<li>Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ <em>&#x2F;</em> ” 指示可接受全部类型，用“ type&#x2F;* ”指示可接受 type 类型的所有子类型;</li>\n<li>Accept-Language：客户端可接受的自然语言;</li>\n<li>Accept-Encoding：客户端可接受的编码格式;</li>\n<li>Accept-Charset：可接受的应答的字符集;</li>\n<li>Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;</li>\n<li>Connection：连接方式(close 或 keepalive);</li>\n<li>Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</li>\n</ul>\n</blockquote>\n<p><strong>3、</strong>注意：GET 请求是没有请求体的</p>\n<h3 id=\"HTTP的响应报文有哪些？\"><a href=\"#HTTP的响应报文有哪些？\" class=\"headerlink\" title=\"HTTP的响应报文有哪些？\"></a>HTTP的响应报文有哪些？</h3><p><strong>1、</strong>http 的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文</p>\n<p><strong>2、</strong>响应报文包含三部分 <strong>状态行、响应头、响应体</strong></p>\n<h3 id=\"Http中常见的header字段有哪些？\"><a href=\"#Http中常见的header字段有哪些？\" class=\"headerlink\" title=\"Http中常见的header字段有哪些？\"></a>Http中常见的header字段有哪些？</h3><p>cookie，请求时传递给服务端的 cookie 信息<br>set-cookie，响应报文首部设置要传递给客户端的 cookie 信息<br>allow，支持什么 HTTP 方法<br>last-modified，资源的最后修改时间<br>expires,设置资源缓存的失败日期<br>content-language，实体的资源语言<br>content-encoding，实体的编码格式<br>content-length，实体主体部分的大小单位是字节<br>content-range，返回的实体的哪些范围<br>content-type，哪些类型<br>accept-ranges，处理的范围请求<br>age，告诉客户端服务器在多久前创建了响应<br>vary，代理服务器的缓存信息<br>location，用于指定重定向后的 URI<br>If-Match，值是资源的唯一标识<br>User-Agent，将创建请求的浏览器和用户代理名称等信息传递给服务器<br>Transfer-Encoding，传输报文的主体编码方式<br>connection，管理持久连接 keep-alive , close Cache-Control，控制浏览器的强缓存</p>\n<h3 id=\"HTTPS工作原理\"><a href=\"#HTTPS工作原理\" class=\"headerlink\" title=\"HTTPS工作原理\"></a>HTTPS工作原理</h3><p>（AES：非对称加密；RSA：对称加密）</p>\n<p><strong>1、</strong>首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA 加密）等进行校验；</p>\n<p><strong>2、</strong>客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA 加密）；</p>\n<p><strong>3、</strong>消息体产生之后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名；</p>\n<p><strong>4、</strong>发送给服务端，此时只有服务端（RSA 私钥）能解密。</p>\n<p><strong>5、</strong>解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。</p>\n<h3 id=\"⭐为什么-TCP-链接需要三次握手，两次不可以么？\"><a href=\"#⭐为什么-TCP-链接需要三次握手，两次不可以么？\" class=\"headerlink\" title=\"⭐为什么 TCP 链接需要三次握手，两次不可以么？\"></a>⭐为什么 TCP 链接需要三次握手，两次不可以么？</h3><p>“三次握手” 的目的是为了防止<strong>已失效的链接请求报文突然又传送到了服务端</strong>，因而产生错误。</p>\n<ul>\n<li>正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。</li>\n<li>假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</li>\n</ul>\n<p>假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求（因为那个是已经失效的请求），因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p>\n<h3 id=\"⭐为什么要四次挥手？\"><a href=\"#⭐为什么要四次挥手？\" class=\"headerlink\" title=\"⭐为什么要四次挥手？\"></a>⭐为什么要四次挥手？</h3><p>TCP 是全双工模式，这就意味着，<br>当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；当 B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p>\n<p>所以想要愉快的结束这次对话就需要四次挥手。</p>\n<h3 id=\"⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\"><a href=\"#⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\" class=\"headerlink\" title=\"⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？\"></a>⭐为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h3><p>MSL（Maximum Segment Lifetime）<strong>报文最大寿命</strong>，TCP 允许不同的实现可以设置不同的 MSL 值。</p>\n<p>第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</p>\n<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。<br>————————————————<br>原文链接：<a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>\n<h3 id=\"⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\"><a href=\"#⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\" class=\"headerlink\" title=\"⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a>⭐如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP 还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个<strong>探测报文段</strong>，以后每隔 75 秒发送一次。若<strong>一连发送10个探测报文仍然没反应</strong>，服务器就认为客户端出了故障，接着就<strong>关闭连接</strong>。<br>————————————————<br>原文链接：<a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>\n<h3 id=\"IP地址是怎样分类的，你知道吗？\"><a href=\"#IP地址是怎样分类的，你知道吗？\" class=\"headerlink\" title=\"IP地址是怎样分类的，你知道吗？\"></a>IP地址是怎样分类的，你知道吗？</h3><p>先说一下 IP 的基本特点：</p>\n<ul>\n<li>IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。</li>\n<li>IP 地址由两部分组成，即<strong>网络地址</strong>和<strong>主机地址</strong>。<br>  网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。</li>\n</ul>\n<p>IP 地址根据网络地址进行分类，主要分为 A、B、C 三类及特殊地址 D、E 这五类</p>\n<p><strong>A类：</strong> (1.0.0.0-126.0.0.0)一般用于大型网络。</p>\n<p><strong>B类：</strong> (128.0.0.0-191.255.0.0)一般用于中等规模网络。</p>\n<p><strong>C类：</strong> (192.0.0.0-223.255.255.0)一般用于小型网络。</p>\n<p><strong>D类：</strong> 是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。</p>\n<p><strong>E类：</strong> 是保留地址。地址的网络号取值于 240~255 之间。</p>\n<h3 id=\"客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？\"><a href=\"#客户端不断进行请求链接会怎样？DDos-Distributed-Denial-of-Service-攻击？\" class=\"headerlink\" title=\"客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？\"></a>客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h3><p>服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>\n<p><strong>(1) DDos 攻击：</strong></p>\n<ul>\n<li>客户端向服务端发送请求链接数据包</li>\n<li>服务端向客户端发送确认数据包</li>\n<li>客户端却不向服务端发送确认数据包，服务器<strong>一直等待</strong>来自客户端的确认</li>\n</ul>\n<p><strong>(2) DDos 预防：（没有彻底根治的办法，除非不使用TCP）</strong></p>\n<ul>\n<li>限制同时打开 SYN 半链接的数目</li>\n<li>缩短 SYN 半链接的 Time out 时间</li>\n<li>关闭不必要的服务</li>\n</ul>\n<h3 id=\"GET-与-POST-的区别？\"><a href=\"#GET-与-POST-的区别？\" class=\"headerlink\" title=\"GET 与 POST 的区别？\"></a>GET 与 POST 的区别？</h3><p>GET 与 POST 是我们常用的两种 HTTP Method，二者之间的区别主要包括如下五个方面：</p>\n<p><strong>1、</strong> 从功能上讲，GET 一般用来<strong>从服务器上获取资源</strong>，POST 一般用来<strong>更新服务器上的资源</strong>；</p>\n<p><strong>2、</strong>从请求参数形式上看，GET请求的数据会<strong>附在URL上</strong>，以?分割 URL 和传输数据，参数之间以&amp;相连；而 POST 请求会把提交的数据则放置在 HTTP 请求报文的 <strong>请求体</strong> 中。</p>\n<p><strong>3、</strong>就安全性而言，POST的<strong>安全性</strong>要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全。</p>\n<p><strong>4、</strong>从请求的大小看，GET请求的<strong>长度</strong>受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p>\n<h3 id=\"DNS的寻址过程你知道吗？\"><a href=\"#DNS的寻址过程你知道吗？\" class=\"headerlink\" title=\"DNS的寻址过程你知道吗？\"></a>DNS的寻址过程你知道吗？</h3><p>浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器。</p>\n<h3 id=\"什么是Socket\"><a href=\"#什么是Socket\" class=\"headerlink\" title=\"什么是Socket\"></a>什么是Socket</h3><p><strong>1、</strong>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 是 TCP&#x2F;IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。</p>\n<p><strong>2、</strong>但是，Socket 所支持的协议种类也不光 TCP&#x2F;IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP&#x2F;IP 协议的网络编程。</p>\n<p><strong>3、</strong>socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的</p>\n<p><strong>4、</strong>Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多，</p>\n<h3 id=\"Socket属于网络的那个层面\"><a href=\"#Socket属于网络的那个层面\" class=\"headerlink\" title=\"Socket属于网络的那个层面\"></a>Socket属于网络的那个层面</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes20210325212441.png\"></p>\n<p>Socket 是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>\n<h3 id=\"Socket通讯的过程\"><a href=\"#Socket通讯的过程\" class=\"headerlink\" title=\"Socket通讯的过程\"></a>Socket通讯的过程</h3><p><strong>基于TCP：</strong></p>\n<p>服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>\n<p><strong>基于UDP：</strong></p>\n<p>UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管</p>\n<h3 id=\"Socket和http的区别和应用场景\"><a href=\"#Socket和http的区别和应用场景\" class=\"headerlink\" title=\"Socket和http的区别和应用场景\"></a>Socket和http的区别和应用场景</h3><p><strong>1、</strong>Socket 连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；</p>\n<p><strong>2、</strong>Socket 适用场景：网络游戏，银行持续交互，直播，在线视屏等。</p>\n<p><strong>3、</strong>http 连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接</p>\n<p><strong>4、</strong>http 适用场景：公司 OA 服务，互联网服务，电商，办公，网站等等等等</p>\n<h3 id=\"什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议\"><a href=\"#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议\" class=\"headerlink\" title=\"什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?\"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h3><p>HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。服务器无法判断用户身份。</p>\n<p>HTTP 的这种特性有优点也有缺点：</p>\n<ul>\n<li><strong>优点</strong>：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用</li>\n<li><strong>缺点</strong>：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享</li>\n</ul>\n<p>解决方案：</p>\n<ol>\n<li>使用参数传递机制：<br> 将参数拼接在请求的 URL 后面，实现数据的传递（GET 方式），例如：<code>/param/list?username=wmyskxz</code><br> <strong>问题</strong>：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有 1kb</li>\n<li>使用 Cookie 技术</li>\n<li>使用 Session 技术</li>\n</ol>\n<p>Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie 机制采用的是在客户端保持状态的方案，而 session 机制采用的是在服务器端保持状态的方案。</p>\n<h3 id=\"什么是Cookie\"><a href=\"#什么是Cookie\" class=\"headerlink\" title=\"什么是Cookie\"></a>什么是Cookie</h3><p>Cookie 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个 Cookie，而客户端浏览器会把 Cookie 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 Cookie 一同提交给服务器，服务器检查该 Cookie，以此来辨认用户状态。服务器还可以根据需要修改 Cookie 的内容。 </p>\n<h3 id=\"什么是Session\"><a href=\"#什么是Session\" class=\"headerlink\" title=\"什么是Session\"></a>什么是Session</h3><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 session。</p>\n<p>服务器默认为客户浏览器的 cookie 中设置 sessionid，这个 sessionid 就和 cookie 对应，浏览器在向服务器请求过程中传输的 cookie 包含 sessionid ，服务器根据传输 cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p>\n<h3 id=\"Cookie和Session对于HTTP有什么用？\"><a href=\"#Cookie和Session对于HTTP有什么用？\" class=\"headerlink\" title=\"Cookie和Session对于HTTP有什么用？\"></a>Cookie和Session对于HTTP有什么用？</h3><p> HTTP 协议本身是无法判断用户身份。所以需要 cookie 或者 session</p>\n<h3 id=\"Cookie与Session区别\"><a href=\"#Cookie与Session区别\" class=\"headerlink\" title=\"Cookie与Session区别\"></a>Cookie与Session区别</h3><ul>\n<li><strong>实现机制</strong>：Session 的实现常常依赖于 Cookie 机制，通过 Cookie 机制回传 SessionID；</li>\n<li><strong>大小限制</strong>：Cookie 有大小限制并且浏览器对每个站点也有 cookie 的个数限制，Session 没有大小限制，理论上只与服务器的内存大小有关；</li>\n<li><strong>安全性</strong>：Cookie 存在安全隐患，通过拦截或本地文件找得到 cookie 后可以进行攻击，而 Session 由于保存在服务器端，相对更加安全；</li>\n<li><strong>服务器资源消耗</strong>：Session 是一定时间内保存在服务器端上，如果 session 过多会增加服务器的压力。</li>\n</ul>\n<h3 id=\"什么是Token\"><a href=\"#什么是Token\" class=\"headerlink\" title=\"什么是Token\"></a>什么是Token</h3><p>Token 的引入：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</p>\n<p>Token 的定义：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</p>\n<p>使用 Token 的目的：Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>\n<p>Token 是在服务端产生的。如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token <strong>证明自己的合法地位</strong></p>\n<h3 id=\"session与token区别\"><a href=\"#session与token区别\" class=\"headerlink\" title=\"session与token区别\"></a>session与token区别</h3><ul>\n<li>session 存储在服务器端，token 存储在客户端</li>\n<li>token 提供认证和授权功能，作为身份认证，token 安全性比 session 好；</li>\n<li>⭐session 这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token 适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>\n</ul>\n<h3 id=\"常用的HTTP方法有哪些？\"><a href=\"#常用的HTTP方法有哪些？\" class=\"headerlink\" title=\"常用的HTTP方法有哪些？\"></a>常用的HTTP方法有哪些？</h3><ul>\n<li><strong>GET：</strong>用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器</li>\n<li><strong>POST：</strong>用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式。</li>\n<li><strong>PUT：</strong>传输文件，报文主体中包含文件内容，保存到对应 URI 位置。</li>\n<li><strong>HEAD：</strong>获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</li>\n<li><strong>DELETE：</strong>删除文件，与 PUT 方法相反，删除对应 URI 位置的文件。</li>\n<li><strong>OPTIONS：</strong>查询相应 URI 支持的 HTTP 方法。</li>\n</ul>\n<h3 id=\"网络层的-ARP-协议工作原理？\"><a href=\"#网络层的-ARP-协议工作原理？\" class=\"headerlink\" title=\"网络层的 ARP 协议工作原理？\"></a>网络层的 ARP 协议工作原理？</h3><p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射</p>\n<h3 id=\"IP地址与物理地址\"><a href=\"#IP地址与物理地址\" class=\"headerlink\" title=\"IP地址与物理地址\"></a>IP地址与物理地址</h3><p>物理地址是数据链路层和物理层使用的地址，IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，其中 ARP 协议用于 IP 地址与物理地址的对应。</p>\n<h3 id=\"影响网络传输的因素有哪些？\"><a href=\"#影响网络传输的因素有哪些？\" class=\"headerlink\" title=\"影响网络传输的因素有哪些？\"></a>影响网络传输的因素有哪些？</h3><p>将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。</p>\n<p>1、网络带宽<br>2、传输距离<br>3、TCP 拥塞控制</p>\n<h3 id=\"什是对称加密与非对称加密\"><a href=\"#什是对称加密与非对称加密\" class=\"headerlink\" title=\"什是对称加密与非对称加密\"></a>什是对称加密与非对称加密</h3><p>对称密钥加密是指<strong>加密和解密使用同一个密钥</strong>的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</p>\n<p>而非对称加密是指使用<strong>一对非对称密钥，即公钥和私钥</strong>，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p>\n<h3 id=\"HTTPS采用对称加密-非对称加密\"><a href=\"#HTTPS采用对称加密-非对称加密\" class=\"headerlink\" title=\"HTTPS采用对称加密+非对称加密\"></a>HTTPS采用对称加密+非对称加密</h3><p>使用对称加密，优点是加密解密速度快，缺点是不安全；<br>使用非对称加密，优点是保证安全性，缺点是速度慢；</p>\n<p>Https 结合两种加密方式的优点，<br>在<strong>交换密钥环节</strong>使用非对称加密方式，之后的<strong>建立通信交换报文</strong>阶段则使用对称加密方式。</p>\n<h2 id=\"TCP-x2F-IP-协议族\"><a href=\"#TCP-x2F-IP-协议族\" class=\"headerlink\" title=\"TCP&#x2F;IP 协议族\"></a>TCP&#x2F;IP 协议族</h2><h3 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h3><p>应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>\n<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>\n<h3 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h3><p>传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的<strong>数据传输服务</strong>。应用进程利用该服务传送应用层报文。</p>\n<p>运输层主要使用一下两种协议</p>\n<ol>\n<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>\n<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>UDP</th>\n<th>TCP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否连接</td>\n<td>无连接</td>\n<td>面向连接</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>不可靠传输，不使用流量控制和拥塞控制</td>\n<td>可靠传输，使用流量控制和拥塞控制</td>\n</tr>\n<tr>\n<td>连接对象个数</td>\n<td>支持一对一，一对多，多对一和多对多交互通信</td>\n<td>只能是一对一通信</td>\n</tr>\n<tr>\n<td>传输方式</td>\n<td>面向报文</td>\n<td>面向字节流</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>首部开销小，仅8字节</td>\n<td>首部最小20字节，最大60字节</td>\n</tr>\n<tr>\n<td>场景</td>\n<td>适用于实时应用（IP电话、视频会议、直播等）</td>\n<td>适用于要求可靠传输的应用，例如文件传输</td>\n</tr>\n</tbody></table>\n<p><strong>每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong></p>\n<p>运行在<code>TCP协议</code>上的协议：</p>\n<ul>\n<li><code>HTTP（Hypertext Transfer Protocol，超文本传输协议）</code>，主要用于普通浏览。</li>\n<li><code>HTTPS（HTTP over SSL，安全超文本传输协议）</code>,<code>HTTP</code>协议的安全版本。</li>\n<li><code>FTP（File Transfer Protocol，文件传输协议）</code>，用于文件传输。</li>\n<li><code>POP3（Post Office Protocol, version 3，邮局协议）</code>，收邮件用。</li>\n<li><code>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</code>，用来发送电子邮件。</li>\n<li><code>TELNET（Teletype over the Network，网络电传）</code>，通过一个<code>终端（terminal）</code>登陆到网络。</li>\n<li><code>SSH（Secure Shell，用于替代安全性差的TELNET）</code>，用于加密安全登陆用。</li>\n</ul>\n<p>运行在<code>UDP协议</code>上的协议：</p>\n<ul>\n<li><code>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）</code>，动态配置 IP 地址。</li>\n</ul>\n<p>运行在<code>TCP</code>和<code>UDP</code>协议上：</p>\n<ul>\n<li><code>DNS（Domain Name Service，域名服务）</code>，用于完成地址查找，邮件转发等工作。</li>\n</ul>\n<h3 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h3><p>网络层的任务就是<strong>选择合适的网间路由和交换结点，确保计算机通信的数据及时传送</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。</p>\n<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>\n<h3 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>\n<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>\n<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p>\n<p>一般的 web 应用的通信传输流是这样的：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS81LzkvMTZhOWM5Y2Q1MjNlMDU5OQ.png\" alt=\"img\"></p>\n<p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p>\n<h3 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>\n<h3 id=\"TCP-x2F-IP-协议族-1\"><a href=\"#TCP-x2F-IP-协议族-1\" class=\"headerlink\" title=\"TCP&#x2F;IP 协议族\"></a>TCP&#x2F;IP 协议族</h3><p>在互联网使用的各种协议中最重要和最著名的就是 TCP&#x2F;IP 两个协议。现在人们经常提到的 TCP&#x2F;IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP&#x2F;IP 协议族。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS80LzcvMTY5ZjY5NjZjMjRhZjM0NQ.png\" alt=\"img\"></p>\n<p>TCP（传输控制协议）和 IP（网际协议）是<strong>最先定义的两个核心协议</strong>，所以才统称为 TCP&#x2F;IP 协议族</p>\n<h2 id=\"TCP的三次握手四次挥手\"><a href=\"#TCP的三次握手四次挥手\" class=\"headerlink\" title=\"TCP的三次握手四次挥手\"></a>TCP的三次握手四次挥手</h2><p>TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如 ip 地址、端口号等。</p>\n<p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个 TCP 连接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接</strong>。</p>\n<p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据</strong>。</p>\n<h3 id=\"TCP报文的头部结构\"><a href=\"#TCP报文的头部结构\" class=\"headerlink\" title=\"TCP报文的头部结构\"></a>TCP报文的头部结构</h3><p>有几个字段需要重点介绍下：</p>\n<p>（1）序号：seq 序号，占 32 位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>\n<p>（2）确认序号：ack 序号，占 32 位，只有 ACK 标志位为 1 时，确认序号字段才有效，ack&#x3D;seq+1。</p>\n<p>（3）标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下：</p>\n<ul>\n<li>ACK：确认序号有效。</li>\n<li>FIN：释放一个连接。</li>\n<li>PSH：接收方应该尽快将这个报文交给应用层。</li>\n<li>RST：重置连接。</li>\n<li>SYN：发起一个新连接。</li>\n<li>URG：紧急指针（urgent pointer）有效。</li>\n</ul>\n<p>需要注意的是：</p>\n<ul>\n<li>不要将确认序号 ack 与标志位中的 ACK 搞混了。</li>\n<li>确认方 ack&#x3D;发起方 seq+1，两端配对。</li>\n</ul>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><blockquote>\n<p>三次握手的本质是确认通信双方收发数据的能力</p>\n</blockquote>\n<p>A-&gt;B</p>\n<p>A 发送给 B，B 若收到</p>\n<blockquote>\n<p>说明B知道：A可以发，B可以收</p>\n</blockquote>\n<p>B 返回给 A，A 若收到：说明 A 之前发给 B 的 B 收到了，同时 B 也能给自己回信，自己能收到这个回信。</p>\n<blockquote>\n<p>说明：A知道：A能发能收，B能收能发</p>\n</blockquote>\n<p>但是此时 B 不知道 A 是否可以收，B 是否发送正常</p>\n<p>于是 A 发送给 B，B 若收到：说明 B 的发送回信 A 能收到</p>\n<blockquote>\n<p>说明：B 知道 A 可以收，B 可以发，结合第一步，得到 B 也知道 A 能发能收，B 能收能发</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IxZWE1MDdlOA.png\" alt=\"三次握手\"></p>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><blockquote>\n<p>四次挥手的目的是关闭一个连接</p>\n</blockquote>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesaHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzcvMTZmN2UwM2IyMWEwN2YwYw.png\" alt=\"四次挥手\"></p>\n<p>A 和 B 打电话，通话即将结束后，<br>A 说“我没啥要说的了”，<br>B 回答“我知道了”，<br>但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，<br>A 回答“知道了”，这样通话才算结束。</p>"},{"title":"开了个B站大会员","copyright":true,"mathjax":true,"date":"2022-12-15T13:39:46.000Z","urlname":"bilibili-vip","_content":"\n最近巫师 3 更新了次世代版本（画质优化+中文配音），由于 PS5 放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（[链接](https://www.bilibili.com/video/BV1L14y1N7b3)）。\n\n<!--more-->\n\n看了一会，诶，咋更新了还这么糊，一看原来是只开了 1080P 画质，一冲动上某多多买了三个月的大会员，点开 4K 画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头 PS5 上再三周目吧，并且期待一手巫师 4。\n\n充了大会员，接下来闲的时候再把 B 站上的电影再看看，总不能浪费了不是 hhh。\n\n最近多个平台都在搞年终总结了，比如 Apple Music 和 PlayStation，准备等其他平台都推出年终总结之后搞波分享～\n\n","source":"_posts/开了个B站大会员.md","raw":"---\ntitle: 开了个B站大会员\ncopyright: true\nmathjax: true\ndate: 2022-12-15 21:39:46\ncategories: 日常小记\ntags: \nurlname: bilibili-vip\n---\n\n最近巫师 3 更新了次世代版本（画质优化+中文配音），由于 PS5 放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（[链接](https://www.bilibili.com/video/BV1L14y1N7b3)）。\n\n<!--more-->\n\n看了一会，诶，咋更新了还这么糊，一看原来是只开了 1080P 画质，一冲动上某多多买了三个月的大会员，点开 4K 画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头 PS5 上再三周目吧，并且期待一手巫师 4。\n\n充了大会员，接下来闲的时候再把 B 站上的电影再看看，总不能浪费了不是 hhh。\n\n最近多个平台都在搞年终总结了，比如 Apple Music 和 PlayStation，准备等其他平台都推出年终总结之后搞波分享～\n\n","slug":"开了个B站大会员","published":1,"updated":"2023-01-26T12:35:58.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw3280010t9t80132hzi0","content":"<p>最近巫师 3 更新了次世代版本（画质优化+中文配音），由于 PS5 放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（<a href=\"https://www.bilibili.com/video/BV1L14y1N7b3\">链接</a>）。</p>\n<span id=\"more\"></span>\n\n<p>看了一会，诶，咋更新了还这么糊，一看原来是只开了 1080P 画质，一冲动上某多多买了三个月的大会员，点开 4K 画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头 PS5 上再三周目吧，并且期待一手巫师 4。</p>\n<p>充了大会员，接下来闲的时候再把 B 站上的电影再看看，总不能浪费了不是 hhh。</p>\n<p>最近多个平台都在搞年终总结了，比如 Apple Music 和 PlayStation，准备等其他平台都推出年终总结之后搞波分享～</p>\n","site":{"data":{}},"length":276,"excerpt":"<p>最近巫师 3 更新了次世代版本（画质优化+中文配音），由于 PS5 放在了学校里，笔记本也带不太动，只能看老戴的视频云玩家二周目了（<a href=\"https://www.bilibili.com/video/BV1L14y1N7b3\">链接</a>）。</p>","more":"<p>看了一会，诶，咋更新了还这么糊，一看原来是只开了 1080P 画质，一冲动上某多多买了三个月的大会员，点开 4K 画质选项，好家伙，直接感受到了次世代的魅力。配音配的也很出色，没什么槽点。回头 PS5 上再三周目吧，并且期待一手巫师 4。</p>\n<p>充了大会员，接下来闲的时候再把 B 站上的电影再看看，总不能浪费了不是 hhh。</p>\n<p>最近多个平台都在搞年终总结了，比如 Apple Music 和 PlayStation，准备等其他平台都推出年终总结之后搞波分享～</p>"},{"title":"Java八股文 - Redis","copyright":true,"mathjax":false,"date":"2023-01-25T05:43:59.000Z","toc":true,"urlname":"Redis","_content":"\n> 整理的 Redis 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 什么是NoSQL？\n\nNoSQL = not only sql（不仅仅是 SQL）\n\n关系型数据库：列+行，同一个表下数据的结构是一样的。\n\n非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。\n\nNoSQL 泛指非关系型数据库，随着 web2.0 互联网的诞生，传统的关系型数据库很难对付 web2.0 大数据时代。尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL 在当今大数据环境下发展的十分迅速，Redis 是发展最快的。\n\n传统 RDBMS（关系数据库管理系统）和 NoSQL（非关系型数据库）比较：\n\nRDBMS：\n - 组织化结构\n - 固定 SQL\n - 数据和关系都存在单独的表中（行列）\n - DML（数据操作语言）、DDL（数据定义语言）等\n - 严格的一致性（ACID）：原子性、一致性、隔离性、持久性\n - 基础的事务\n\nNoSQL：\n - 不仅仅是数据\n - 没有固定查询语言\n - 键值对存储（Redis）、列存储（HBase）、文档存储（MongoDB）、图形数据库（不是存图形，放的是关系）（Neo4j）\n - 最终一致性（BASE）：基本可用、软状态/柔性事务、最终一致性\n\n***\n\n## Redis是什么？\n\n### 定义\n\nRedis = Remote Dictionary Server，即远程字典服务。\n\nRedis 是一个用 C 语言开发的、基于内存结构进行**键值对**数据存储的、高性能的、非关系型 NoSQL 数据库\n\n### 优缺点\n\n**纯内存操作，性能非常出色**，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。支持保存多种数据结构，可以用来实现很多有用的功能。\n\nRedis 的主要缺点是**数据库容量受到物理内存的限制，不能用作海量数据的高性能读写**，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n### 为什么要用缓存\n\n**1、 高性能：**\n\n假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。\n\n**2、高并发：**\n\n直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，缓解数据库压力。\n\n### Redis 与 Memcached 相比有哪些优势\n\nRedis 支持更丰富的数据类型（支持更复杂的应用场景）\n\nRedis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。\n\nRedis 使用单线程的多路 IO 复用模型；Memcached 是多线程，非阻塞 IO 复用的网络模型。\n\n***\n\n## Redis五大基本类型\n\n[Redis 命令大全](https://www.Redis.net.cn/order/)\n\n[Redis 应用场景](https://juejin.cn/post/6857667542652190728)\n\n### String（字符串）\n\n> 1. String 类型是 Redis 的最基础的数据结构，也是最经常使用到的类型。而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以 String 类型是 Redis 的基础。\n>\n> 2. String 类型的值最大能存储 512MB，这里的 String 类型可以是简单字符串、  复杂的 xml/json 的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串。\n\n**应用场景**\n\n1、缓存功能：String 字符串是最常用的数据类型，不仅仅是 Redis，各个语言都是最基本类型，因此，利用 Redis 作为缓存，配合其它数据库作为存储层，利用 Redis 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。\n\n2、计数器：许多系统都会使用 Redis 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。\n\n3、共享用户 session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie 保存在客户端，有安全隐患。这时可以利用 Redis 将用户的 session 集中管理，在这种模式只需要保证 Redis 的高可用，每次用户 session 的更新和获取都可以快速完成。大大提高效率。（分布式会话）\n\n### List（列表）\n\n> 1. List 是简单的字符串列表\n> 2. Redis 可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。Redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。\n\n**应用场景**\n\n1、消息队列：Redis 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过 lpush 命令从左边插入数据，多个数据消费者，可以使用 rpop 命令阻塞的“抢”列表尾部的数据。\n\n2、文章列表或者数据分页展示的应用。比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 Redis 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。\n\n### Set（集合）\n\n> 1. Redis 集合 set 类型和 list 列表类型类似，都可以用来存储多个字符串元素的集合。\n> 2. 但是和 list 不同的是 set 集合当中不允许重复的元素。而且 set 集合当中元素是没有顺序的，不存在元素下标。\n> 3. Redis 的 set 类型是使用哈希表构造的，因此复杂度是 O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。\n\n**应用场景**\n\n1、标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。\n\n2、共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。\n\n3、统计网站的独立 IP。利用 set 集合当中元素不唯一性，可以快速实时统计访问网站的独立 IP。\n\n### sorted set（有序集合）\n\n> Redis 有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。\n\n#### 应用场景\n\n1、排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n\n2、用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。\n\n### hash（哈希）\n\nRedis hash 数据结构 是一个键值对（key-value）集合，它是一个 string 类型的 field 和 value 的映射表，Redis 本身就是一个 key-value 型数据库，因此 hash 数据结构相当于在 value 中又套了一层 key-value 型数据。所以 Redis 中 hash 数据结构特别适合存储关系型对象。\n\n> 用户 ID 为查找的key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key/value 结构来存储\n>\n> 1. 将用户 ID 作为 key，姓名属性+姓名数据整体作为 value。缺点是每次修改用户的某个属性，都需要先反序列化 属性+数据，修改好，然后将 属性+数据 序列化之后在修改回去，开销较大。\n>\n> ![ID -> 属性+数据](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356860189.png)\n>\n> 2. 将用户 ID+姓名属性作为 key，姓名数据作为 value。缺点是用户 ID 使用多次，数据冗余\n>\n> ![ID+属性 -> 数据](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356955204.png)\n>\n> \n>\n> 3. 因此通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。\n>\n> ![ID -> 属性 -> 数据](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356950290.png)\n\n#### 应用场景\n\n1、由于 hash 数据类型的 key-value 的特性，用来存储关系型数据库中表记录，是 Redis 中哈希类型最常用的场景。一条记录作为一个 key-value，把每列属性值对应成 field-value 存储在哈希表当中，然后通过 key 值来区分表当中的主键。\n\n2、经常被用来存储用户相关信息。优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能。\n\n***\n\n## 五大基本类型底层数据结构\n\nRedis 整体的存储结构：\n\nRedis 内部整体的存储结构是一个大的 hashmap，内部是数组实现的 hash，key 冲突通过挂链表去实现，每个 dictEntry 为一个 key/value 对象，value 为定义的 redisObject。\n\n结构图如下：\n\n![Redis 整体的存储结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650433179786.png)\n\ndictEntry 是存储 key->value 的地方，其中包含指向具体的 redisObject 的指针。\n\nredisObject 中*ptr 指向具体的数据结构的地址；type 表示该对象的类型，即 String、List、Hash、Set、Zset 中的一个\n\n### String (arrayList)\n\nString 的数据结构为简单动态字符串(Simple Dynamic String，缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。\n\n![String 的数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356547555.png)\n\n如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。\n\n### List (ziplist - quickList)\n\n1、Redis 3.2 之前的底层实现方式：压缩列表 ziplist 或者 双向循环链表 linkedlist\n\n当 list 存储的数据量比较少且同时满足下面两个条件时，list 就使用 ziplist 存储数据：\n\n- list 中保存的每个元素的长度小于 64 字节；\n- 列表中数据个数少于 512 个。\n\n2、Redis 3.2 及之后的底层实现方式：quicklist\n\nquicklist 是一个基于 ziplist 的双向链表，quicklist 的每个节点都是一个 ziplist，结合了双向链表和 ziplist 的优点。\n\n#### **ziplist**\n\nziplist 是压缩列表，它的好处是能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用 ziplist 存储。但当数据量过大时就 ziplist 就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是 O(N)，即每次插入都会重新进行 realloc 重新分配内存空间。\n\nziplist 结构如下：\n\n![ziplist 结构图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419709341.png)\n\n1、zlbytes：用于记录整个压缩列表占用字节数\n\n2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节，用于快速定位到最后一个节点，从而可以在 ziplist 尾部快速的执行 push，pop 操作\n\n3、zllen：记录了压缩列表包含的节点数量。\n\n4、entryX：压缩列表包含的各个节点\n\n5、zlend：用于标记压缩列表的末端，用来快速定位到最后一个元素，然后倒着遍历。（entry 块的 prevlen 字段表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。）\n\n**为什么数据量大时不用 ziplist？**\n\n因为 ziplist 是一段连续的内存，插入的时间复杂化度为 O(n)，而且每当插入新的元素需要 realloc 做内存扩展；而且如果超出 ziplist 内存大小，还会做重新分配的内存空间，并将内容复制到新的地址。如果数量大的话，重新分配内存和拷贝内存会消耗大量时间。所以不适合大型字符串，也不适合存储量多的元素。\n\n#### quickList\n\n快速列表是 ziplist 和 linkedlist 的混合体，是将 linkedlist 按段切分，每一段用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针链接。\n\n**为什么不直接使用 linkedlist？**\n\nlinkedlist 的附加空间相对太高，prev 和 next 指针就要占去 16 个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。\n\nquicklist 结构图如下：\n\n![quicklist 结构图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419719663.png)\n\n**ziplist的长度**\n\nquicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。关于长度可以使用 list-max-ziplist-size 决定。\n\n**压缩深度**\n\n我们上面说到了 quicklist 下是用多个 ziplist 组成的，同时为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩，可以选择压缩深度。quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 list-compress-depth 决定。为了支持快速 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。\n\n### Hash (ziplist - dict)\n\n#### ziplist\n\n当 Hash 中数据项比较少的情况下，Hash 底层才用压缩列表 ziplist 进行存储数据，随着数据的增加，底层的 ziplist 就可能会转成 dict，具体配置如下\n\n> hash-max-ziplist-entries 512\n> hash-max-ziplist-value 64\n\n在如下两个条件之一满足的时候，ziplist 会转成 dict：\n\n- 当 hash 中的数据项的数目超过 512 的时候，也就是 ziplist 数据项超过 1024 的时候；\n- 当 hash 中插入的任意一个 value 的长度超过了 64 的时候。\n\n每当有新的键值对加入到哈希对象时，先压入键，再压入值，如图：\n\n![ziplist实现的hash](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/20190703171927309.png)\n\n当遍历时，从头到尾的遍历，且跳过值节点。\n\n#### dict\n\n字典的哈希表结构和 Java 的 HashMap 结构几乎是一样的，都是通过某个哈希函数从 key 计算得到在哈希表中的位置，采用链表法解决冲突。Redis 这里使用的是单链表，为了查询效率每次把新数据插入到链表头位置（使用头插法是因为新插入的数据被访问的概率大，可以更快访问到）。\n\n我们可以看到每个 dict 中都有两个 hashtable，结构图如下：\n\n![dict实现的hash](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420119549.png)\n\n虽然 dict 结构有两个 hashtable，但是通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容的时候，需要分配新的 hashtable，然后进行渐近式搬迁，这时候两个 hashtable 存储的旧的 hashtable 和新的 hashtable。搬迁结束后，旧 hashtable 删除，新的取而代之。\n\n**渐进式 rehash**\n\n所谓渐进式 rehash 是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个 O(n)的操作。但是因为我们的 Redis 是单线程的，无法承受这样的耗时过程，所以采用了渐进式 rehash 小步搬迁，虽然慢一点，但是可以搬迁完毕。\n\n**扩容条件**\n\n我们的扩容一般会在 Hash 表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在 Redis 在做 bgsave（RDB 持久化操作的过程），为了减少内存页的过多分离（Copy On Write），Redis 不会去扩容。但是如果 hash 表的元素个数已经到达了第一维数组长度的 5 倍的时候，就会强制扩容，不管你是否在持久化。\n\n不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。\n\n**缩容条件**\n\n当我们的 hash 表元素逐渐删除的越来越少的时候。Redis 于是就会对 hash 表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的 10%，并且缩容不考虑是否在做 Redis 持久化。\n\n不用考虑 bgsave 主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。\n\n**rehash 步骤**\n\n![rehash 步骤](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420130964.png)\n\n### Set (intset - hashSet)\n\nRedis 的集合相当于 Java 中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合 Set 类型底层编码包括 inset 和 hashtable。\n\n当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合 intset 来实现 set 这种数据类型：\n\n> 存储的数据都是整数\n> 存储的数据元素个数小于512个\n\n当不能同时满足这两个条件的时候，Redis 就使用 dict 来存储集合中的数据\n\n**intset**\n\nintset 是一个有序集合，查找元素的复杂度为 O(logN)（采用二分法），但插入时不一定为 O(logN)，因为有可能涉及到升级操作。比如当集合里全是 int16_t 型的整数，这时要插入一个 int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成 int32_t 类型，涉及到内存的重新分配，这时插入的复杂度就为 O(N)了。是 intset 不支持降级操作。\n\n**intset 是有序不要和 zset 搞混，zset 是设置一个 score 来进行排序，而 intset 这里只是单纯的对整数进行升序而已**\n\n### Sorted Set (ziplist - zset(dict + skipList))\n\nZset 有序集合和 set 集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数 score，作为排序的依据。\n\n当数据较少时，sorted set 是由 ziplist 来实现的。\n当数据多的时候，sorted set 是由 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据指定分数 score 的范围来获取 value 列表。\n\n**sorted set ziplist 实现**\n\n在这里我们先来讨论一下前一种情况——基于 ziplist 实现的 sorted set。ziplist 就是由很多数据项组成的一大块连续内存。由于 sorted set 的每一项元素都由数据和 score 组成，因此，当使用 zadd 命令插入一个(数据, score)对的时候，底层在相应的 ziplist 上就插入两个数据项：数据在前，score 在后。\n\n![基于 ziplist 实现的 sorted set](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650431975904.png)\n\nziplist 的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set 的各个查询操作，就是在 ziplist 上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。\n\n随着数据的插入，sorted set 底层的这个 ziplist 就可能会转成 zset 的实现。那么到底插入多少才会转呢？\n\n> zset-max-ziplist-entries 128\t# 当sorted set中的元素个数，即(数据， score)对的数目超过128的时候\n> zset-max-ziplist-value 64\t# 当sorted set中插入的任意一个数据的长度超过了64的时候。\n\n**sorted set ziplist实现**\nRedis 的 zset 是一个复合结构，一方面它需要一个 hash 结构来存储 value 和 score 的对应关系，另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获取 value 列表的功能，这就需要另外一个结构「跳跃表」。\n\n```c\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n```\n\n跳表：链表+多级索引（空间换时间）\n\n和其他结构的比较：\n\n对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。\n\n***\n\n## 三大特殊数据类型\n\n### geospatial（地理位置）\n\n1. 查看附近的人\n2. 微信位置共享\n3. 地图上直线距离的展示\n\n### Hyperloglog（基数）\n\n基数：不重复的元素\n\n网页统计 UV （浏览用户数量，同一天同一个 ip 多次访问算一次访问，目的是计数，而不是保存用户）\n\n传统的方式，set 保存用户的 id，可以统计 set 中元素数量作为标准判断。\n\n但如果这种方式保存大量用户 id，会占用大量内存，我们的目的是为了计数，而不是去保存 id。\n\n### Bitmaps（位存储）\n\nRedis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：\n\n1. Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。\n2. Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。\n\n#### 命令\n\n1. setbit\n\n\t`setbit<key><offset><value>` 设置 Bitmaps 中某个偏移量的值（0 或 1）\n\n\t可以将 idx 位置为 1 表示 idx 用户访问过\n\n2. getbit\n\n\t`getbit<key><offset>` 获取 Bitmaps 中某个偏移量的值\n\n\t通过 idx 位是否为 1 判断 idx 用户是否访问过\n\n3. bitcount\n\n\t`bitcount<key>[start end]` 统计字符串从 start 字节到 end 字节比特值为 1 的数量\n\n4. bitop\n\n\t`bitop and(or/not/xor) <destkey> [key…]` bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。\n\n#### **应用场景**\n\n**两种状态的统计**都可以使用 bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。\n\n***\n\n## Redis事务与锁机制\n\n### 事务\n\n事务本质：一组命令的集合\n\n#### **数据库的事务**\n\n数据库事务通过 ACID（原子性、一致性、隔离性、持久性）来保证。\n\n数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条 SQL 语句在被执行的时候，都会生成一条撤销日志(Undo Log)。\n\n#### Redis 事务\n\nRedis 事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。\n\nRedis 中一个事务从开始到执行会经历**开始**事务（Muiti）、命令**组队**和**执行**事务(Exec)三个阶段，事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。\n\n组队的过程中可以通过 discard 来放弃组队。\n\n**事务的错误处理**\n\n组队阶段某个命令报错，执行时整个队列都会被取消。\n\n![组队阶段某个命令报错](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372301056.png)\n\n如果执行阶段某个命令报错，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。（不保证事务的原子性）\n\n![执行阶段某个命令报错](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372359361.png)\n\n**为什么 Redis 不支持回滚来保证原子性**\n\nRedis 命令只会因为错误的语法而失败，然而没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。\n\n### Redis 锁\n\n#### 悲观锁\n\n**悲观锁(Pessimistic Lock)**， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。**传统的关系型数据库里边就用到了很多这种锁机制**，比如**行锁**，**表锁**等，**读锁**，**写锁**等，都是在做操作之前先上锁。\n\n![悲观锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417157625.png)\n\n> 线程 1 拿到账户后把账户锁住，然后操作，这时候线程 2 也想拿账户，发现加了锁拿不到，只能阻塞等到锁释放。\n\n#### 乐观锁\n\n**乐观锁(Optimistic Lock)，** 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在**更新的时候判断**一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**。Redis 就是利用这种机制实现事务的。\n\n![乐观锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417222072.png)\n\n> 给账户数据加一个版本号，假如线程 1、2 都拿到账户，线程 1 使用账户前先进行版本号比较，v1.0 = v1.0，则扣减账户余额，账户版本号变更为 v1.1，线程 2 准备操作数据库，发现自己预期的账户版本号 v1.0 和当前账户版本号 v1.1 不同（CAS），则不能操作。 \n\n***\n\n## Redis持久化\n\nRedis 是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题 Redis 供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。\n\n两种持久化方式：快照（RDB 文件）和追加式文件（AOF 文件），下面分别为大家介绍两种方式的原理。\n\n- RDB 持久化方式会在一个特定的间隔保存那个时间点的数据快照。\n\n- AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。\n\n- 两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。\n\n### RDB(Redis Database)\n\n> 在满足特定的  Redis 操作条件（时间周期、写操作次数）时，将内存中的数据以 **数据快照** 的形式存储到 db 文件中\n\n#### **工作原理**\n\n> [Redis_RDB持久化之写时复制技术的应用](https://www.cnblogs.com/zyf98/p/15934058.html)\n\nRDB 是一次的全量备份，即周期性的把 Redis 当前内存中的全量数据写入到一个快照文件中。Redis 是单线程程序，这个线程要同时负责多个客户端的读写请求，还要负责周期性的把当前内存中的数据写到快照文件中 RDB 中，那么就会带来以下两个问题：\n\n1. 数据写到 RDB 文件是 IO 操作，IO 操作会严重影响 Redis 的性能，甚至在持久化的过程中，读写请求会阻塞\n2. 假如 Redis 正在进行持久化一个大的数据结构，在这个过程中客户端发送一个删除请求，把这个大的数据结构删掉了，这时候持久化的动作还没有完成。\n\n于是 Redis 使用操作系统的多进程 **写时复制(Copy On Write)机制** 来实现快照的持久化，在持久化过程中调用**glibc**(Linux 下的 C 函数库)的函数 **fork()** 产生一个子进程，该子进程和父进程共享内存里面的代码段和数据段，快照持久化完全交给子进程来处理，父进程继续处理客户端的读写请求。\n\n> 子进程将数据写入到一个临时 RDB 文件中。当子进程完成持久化时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。\n\n在子进程持久化的过程中，如果主进程收到的客户端的读写请求，需要修改某块数据，那么这块数据就会被复制一份到内存，生成该数据的副本，主进程在该副本上进行修改操作。所以即使对某个数据进行了修改，Redis 持久化到 RDB 中的数据也是未修改的数据，这也是把 RDB 文件称为\"快照\"文件的原因，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。这里再深入一点，Redis 内存中的全量数据由一个个的\"数据段页面\"组成，每个数据段页面的大小为 4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中，这个复制的过程称为\"页面分离\"，在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的 2 倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分 Redis 数据还是\"冷数据\"。\n\n正因为修改的部分数据会被额外的复制一份，所以会占用额外的内存，当在进行 RDB 持久化操作的过程中，与此同时如果持续往 Redis 中写入的数据量越多，就会导致占用的额外内存消耗越大。\n\n![RDB 持久化](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2093494-20220226233822789-2067752089.png)\n\n**优点**：\n\n1. RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；\n2. RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；\n3. RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；\n4. 与 AOF 格式的文件相比，RDB 文件可以更快的重启。\n\n**缺点**：\n\n1. 因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。\n2. RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。\n\n### AOF(Append Only File)\n\n以日志的形式来记录每个写的操作，将 Redis 执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\n\n#### **AOF配置项**\n\n```\n# 默认不开启aof  而是使用rdb的方式\nappendonly no\n\n# 默认文件名\nappendfilename \"appendonly.aof\"\n\n# 每次修改都会sync 消耗性能\n# appendfsync always\n# 每秒执行一次 sync 可能会丢失这一秒的数据\nappendfsync everysec\n# 不执行 sync ，这时候操作系统自己同步数据，速度最快\n# appendfsync no \n```\n\nAOF 的整个流程大体来看可以分为两步，第一步是命令的实时写入（如果是 appendfsync everysec 配置，会有 1s 损耗），第二步是对 aof 文件的重写。\n\n#### **AOF 重写机制**\n\n随着 Redis 的运行，AOF 的日志会越来越长，如果实例宕机重启，那么重放整个 AOF 将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr 一千次，那么就不需要去记录这 1000 次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。\n\nRedis 提供了 bgrewriteaof 指令用于对 AOF 日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的 AOF 文件，至此完成。\n\n同样的也可以在 Redis.config 中对重写机制的触发进行配置：\n\n通过将 no-appendfsync-on-rewrite 设置为 yes，开启重写机制；auto-aof-rewrite-percentage 100 意为比上次从写后文件大小增长了 100%再次触发重写；\n\nauto-aof-rewrite-min-size 64mb 意为当文件至少要达到 64mb 才会触发制动重写。\n\n**优点**：\n\n1、数据安全，AOF 是对指令文件进行 **增量更新**，更适合实时性持久化。\n\n2、通过 append 模式写文件，即使中途服务器宕机，可以通过 Redis-check-aof 工具解决数据一致性问题。\n\n3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)\n\n**缺点**：\n\n1、AOF 文件比 RDB 文件大，且恢复速度慢。\n\n2、数据集大的时候，比 RDB 启动效率低。\n\n### RDB与AOF对比\n\nRedis 官方建议同时开启两种持久化策略，AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）\n\n| 比较项     | RDB    | AOF          |\n| ---------- | ------ | ------------ |\n| 启动优先级 | 低     | 高           |\n| 体积       | 小     | 大           |\n| 恢复速度   | 快     | 慢           |\n| 数据安全性 | 丢数据 | 根据策略决定 |\n\n***\n\n## 发布与订阅\n\nRedis 发布与订阅是一种消息通信的模式：发送者（pub）发送消息，订阅者（sub）接收消息。\n\nRedis 通过 PUBLISH 和 SUBSCRIBE 等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是订阅/发布到频道、订阅/发布到模式的客户端。\n\n### 频道（channel）\n\n**订阅**\n\n![频道订阅](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436261125.png)\n\n**发布**\n\n![频道发布](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436267143.png)\n\n#### **完整流程**\n\n发布者向频道 channel:1 发布消息 hi\n\n```\n127.0.0.1:6379> publish channel:1 hi(integer) 1\n```\n\n订阅者订阅消息\n\n```\n127.0.0.1:6379> subscribe channel:1\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\" // 消息类型\n2) \"channel:1\" // 频道\n3) \"hi\" // 消息内容\n```\n\n执行 subscribe 后客户端会进入订阅状态，仅可以使 subscribe、unsubscribe、psubscribe 和 punsubscribe 这四个属于\"发布/订阅\"之外的命令\n\n订阅频道后的客户端可能会收到三种消息类型\n\n- subscribe：表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。\n\n- message：表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。\n\n- unsubscribe：表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为 0 时客户端会退出订阅状态，之后就可以执行其他非\"发布/订阅\"模式的命令了。\n\n\n\n#### **数据结构**\n\n基于 channel 的发布订阅模式是通过字典数据类型实现的\n\n> 类似hashmap，键为channel，值为订阅了该channel的client，用链表链接起来\n\n其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。\n\n![频道模式数据结构模型](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420774862.png)\n\n**订阅**\n\n当使用 subscribe 订阅时，在字典中找到频道 key（如没有则创建），并将订阅的 client 关联在链表后面。\n\n当 client 10 执行 `subscribe channel1 channel2 channel3` 时，会将 client 10 分别加到 channel1 channel2 channel3 关联的链表尾部。\n\n![频道订阅](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420784179.png)\n\n**发布**\n\n发布时，根据 key，找到字典汇总 key 的地址，然后将 msg 发送到关联的链表每一台机器。\n\n**退订**\n\n遍历关联的链表，将指定的地址删除即可。\n\n\n\n### 模式（pattern）\n\npattern 使用了通配符的方式来订阅\n\n通配符中 ? 表示 1 个占位符，\\* 表示任意个占位符(包括 0)，?* 表示 1 个以上占位符。\n\n所以当使用 publish 命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个/某些模式和这个频道匹配的话， 那么所有订阅这个/这些频道的客户端也同样会收到信息。\n\n![模式](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420803487.png)\n\n#### **订阅发布完整流程**\n\n发布者发布消息\n\n```\n127.0.0.1:6379> publish b m1\n(integer) 1\n127.0.0.1:6379> publish b1 m1\n(integer) 1\n127.0.0.1:6379> publish b11 m1\n(integer) 1\n```\n\n订阅者订阅消息\n\n```\n127.0.0.1:6379> psubscribe b*\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"b*\"\n3) (integer) 3\n1) \"pmessage\"\n2) \"b*\"\n3) \"b\"\n4) \"m1\"\n1) \"pmessage\"\n2) \"b*\"\n3) \"b1\"\n4) \"m1\"\n1) \"pmessage\"\n2) \"b*\"\n3) \"b11\"\n4) \"m1\"\n```\n\n#### **数据结构**\n\npattern 属性是一个链表，链表中保存着所有和模式相关的信息。\n\n> 类似链表，每个pattern节点，包含pattern以及订阅该pattern的client\n\n数据结构图如下：\n\n![模式数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420905733.png)\n\n**订阅**\n\n当有信的订阅时，会将订阅的客户端和模式信息添加到链表后面。\n\n![模式订阅](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420913717.png)\n\n**发布**\n\n当发布者发布消息时，首先会发送到对应的频道上，在遍历模式列表，根据 key 匹配模式，匹配成功将消息发给对应的订阅者。\n\n**退订**\n\n使用 punsubscribe，可以将订阅者退订，将改客户端移除出链表。\n\n***\n\n## 主从复制\n\n**什么是主从复制**\n\n在多个 Redis 实例建立起主从关系，当 主 Redis 中的数据发生变化，从 Redis 中的数据也会同步变化\n\n- 通过主从配置可以实现 Redis 数据的备份（从 Redis 就是对 主 Redis 的备份），保证数据安全性\n- 主从库之间采用的是读写分离的方式，读操作：主库、从库都可以接收；写操作：首先到主库执行，然后主库将写操作同步给从库\n\n**主从复制的作用**\n\n- 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n\n- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n\n- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。\n\n- 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。\n\n主从库采用的是读写分离的方式：\n\n![主从库读写分离](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420963646.png) \n\n### 原理\n\n分为全量复制与增量复制\n\n全量复制：发生在第一次复制时\n\n增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库\n\n### 全量复制的三个阶段\n\n![全量复制](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNoteskjk7gr48ft.jpeg)\n\n第一阶段是主从库间建立连接、协商同步的过程。\n\n> 主要是为全量复制做准备。从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。\n>\n> 具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。\n\n第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。\n\n> 具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。\n\n第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。\n\n> 具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。\n\n### 断网增量更新\n\n当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。\n\n![断网增量更新](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesg0eezljwqy.jpeg)\n\n## 哨兵机制\n\n> 哨兵的核心功能是主节点的自动故障转移\n>\n> 1. 监控 主库，判断 主库 是否宕机\n> 2. 主库 如果宕机，则从 从库 中 选举成为 主库（因此需要奇数个哨兵）\n> 3. 更改主从配置\n\n下图是一个典型的哨兵集群监控的逻辑图：\n\n![哨兵机制](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420977306.png)\n\n![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n \n\nRedis Sentinel 包含了若个 Sentinel 节点，这样做也带来了两个好处：\n\n1. 对于节点的故障判断是由多个 Sentinel 节点共同完成，这样可以有效地防止误判\n2. 即使个别 Sentinel 节点不可用，整个 Sentinel 集群依然是可用的。\n\n哨兵实现了以下功能\n\n1. 监控：每个 Sentinel 节点会对数据节点（Redis master/slave 节点）和其余 Sentinel 节点进行监控\n2. 通知：Sentinel 节点会将故障转移的结果通知给应用方\n3. 故障转移：实现 slave 晋升为 master，并维护后续正确的主从关系\n4. 配置中心：在 Redis Sentinel 模式中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息\n\n其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置中心和通知功能，则需要在与客户端的交互中才能体现。\n\n### 监控\n\nSentinel 节点需要监控 master、slave 以及其它 Sentinel 节点的状态。这一过程是通过 Redis 的 pub/sub 系统实现的。Redis Sentinel 一共有三个定时监控任务，完成对各个节点发现和监控：\n\n1. 监控主从拓扑信息：每隔 10 秒，每个 Sentinel 节点，会向 master 和 slave 发送 INFO 命令获取最新的拓扑结构\n2. Sentinel 节点信息交换：每隔 2 秒，每个 Sentinel 节点，会向 Redis 数据节点的`sentinel:hello` 频道上，发送自身的信息，以及对主节点的判断信息。这样，Sentinel 节点之间就可以交换信息\n3. 节点状态监控：每隔 1 秒，每个 Sentinel 节点，会向 master、slave、其余 Sentinel 节点发送 PING 命令做心跳检测，来确认这些节点当前是否可达\n\n### 主观/客观下线\n\n#### 主观下线\n\n每个 Sentinel 节点，每隔 1 秒会对数据节点发送 ping 命令做心跳检测，当这些节点超过 down-after-milliseconds 没有进行有效回复时，Sentinel 节点会对该节点做失败判定，这个行为叫做主观下线。\n\n#### 客观下线\n\n客观下线，是指当大多数 Sentinel 节点，都认为 master 节点宕机了，那么这个判定就是客观的，叫做客观下线。\n\n那么这个大多数是指多少呢？这其实就是分布式协调中的 quorum 判定了，大多数就是过半数，比如哨兵数量是 5，那么大多数就是 5/2+1=3 个，哨兵数量是 10 大多数就是 10/2+1=6 个。\n\n注：Sentinel 节点的数量至少为 3 个，否则不满足 quorum 判定条件。\n\n### 哨兵选举\n\n如果发生了客观下线，那么哨兵节点会选举出一个 Leader 来进行实际的故障转移工作。Redis 使用了 Raft 算法来实现哨兵领导者选举，大致思路如下：\n\n1. 每个 Sentinel 节点都有资格成为领导者，当它主观认为某个数据节点宕机后，会向其他 Sentinel 节点发送 sentinel is-master-down-by-addr 命令，要求自己成为领导者；\n2. 收到命令的 Sentinel 节点，如果没有同意过其他 Sentinel 节点的 sentinelis-master-down-by-addr 命令，将同意该请求，否则拒绝（每个 Sentinel 节点只有 1 票）；\n3. 如果该 Sentinel 节点发现自己的票数已经大于等于 MAX(quorum, num(sentinels)/2+1)，那么它将成为领导者；\n4. 如果此过程没有选举出领导者，将进入下一次选举。\n\n### **故障转移**\n\n选举出的 Leader Sentinel 节点将负责故障转移，也就是进行 master/slave 节点的主从切换。故障转移，首先要从 slave 节点中筛选出一个作为新的 master，主要考虑以下 slave 信息：\n\n1. 跟 master 断开连接的时长：如果一个 slave 跟 master 的断开连接时长已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么该 slave 就被认为不适合选举为 master；\n2. slave 的优先级配置：slave priority 参数值越小，优先级就越高；\n3. 复制 offset：当优先级相同时，哪个 slave 复制了越多的数据（offset 越靠后），优先级越高；\n4. run id：如果 offset 和优先级都相同，则哪个 slave 的 run id 越小，优先级越高。\n\n接着，筛选完 slave 后， 会对它执行 slaveof no one 命令，让其成为主节点。\n\n最后，Sentinel 领导者节点会向剩余的 slave 节点发送命令，让它们成为新的 master 节点的从节点，复制规则与 parallel-syncs 参数有关。\n\nSentinel 节点集合会将原来的 master 节点更新为 slave 节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。\n\n注：Leader Sentinel 节点，会从新的 master 节点那里得到一个 configuration epoch，本质是个 version 版本号，每次主从切换的 version 号都必须是唯一的。其他的哨兵都是根据 version 来更新自己的 master 配置。\n\n## 集群配置\n\n> 高可用：保证 Redis 一直处于可用状态，即使出现了故障也有备用方案保证可用性\n>\n> 高并发：一个 Redis 实例已经可以支持多达 11w并发读操作或 8.1w并发写操作；但是如果有更高并发需求的应用来说，可以通过 读写分离、集群配置 来解决高并发问题\n\n- Redis 集群中每个节点是对等的，无中心结构\n- 数据按照 slots 分布式存储在不同的 Redis 节点上，节点中的数据可共享，可以动态调整数据分布\n- 可扩展性强，可以动态增删节点，最多可扩展至 1000+ 节点\n- 集群的每个节点通过 `主从（哨兵模式）`保证其高可用性\n- Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作\n- Redis 集群之间是如何复制的？异步复制\n\n> [Redis_数据分布算法：传统哈希-一致性哈希-哈希slot](https://blog.csdn.net/qq_43846090/article/details/123721066)\n\n### 传统哈希\n\n最简单的数据分布算法，对进来的 key 进行 hash，然后对节点数据进行取模，就知道分布到哪个节点上了；\n缺点就是: 如果一个节点宕机，所有缓存的位置都要发生改变，当服务器数量发生改变时，所有缓存在一定时间内是失效的，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）\n\n### 一致性哈希\n\n实际上就是引入了一个圆环的概念， 让每个数据的 hash 分布到整个圆环，然后顺时针去找离他最近的节点存储\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525022243.png\" alt=\"一致性哈希\" style=\"zoom: 50%;\" />\n\nhash 算法的取模法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，\ndubbo 的复杂均衡有用到该算法；\n\n好处:\n\n使用 hash 算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了；\n而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效。上图中如果节点 A 失效，则 C → A 之间的数据会重新缓存到节点 B 上。\n\nhash 环偏斜：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525154544.png\" alt=\"hash 环偏斜\" style=\"zoom: 50%;\" />\n\n1 号、2 号、3 号、4 号、6 号数据均被缓存在了服务器 A 上；只有 5 号被缓存在了服务器 B 上；服务器 C 上甚至没有缓存任何图片\n如果出现上图中的情况，A、B、C 三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器 A 出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃；\n\n上图中的情况则被称之为 hash 环的偏斜 ；\n我们应该怎样防止 hash 环的偏斜？\n增加虚拟节点：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525203417.png\" alt=\"增加虚拟节点防止 hash 环的偏斜\" style=\"zoom:50%;\" />\n\n为了解决这个数据负载均衡的问题，搞出来虚拟节点，把真实节点搞一堆虚拟节点分布到环，那么整个区间的数据会落到这些虚拟节点上；\n\n虚拟节点越多，hash 环上的节点就越多，缓存被均匀分布的概率就越大。\n\n### 哈希槽\n\nRedis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。\n\n首先哈希槽其实是两个概念，第一个是哈希算法。Redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 Redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。\n\nRedis cluster 包含了 16384 个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。\n\n**为什么哈希槽的大小是固定的16384？**\n\n> `CRC16`算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做`mod`运算的时候，为什么不`mod`65536，而选择`mod`16384？\n\n**不能太大，主要从节点间的通信性能方面考虑：**\n\n每个节点之间是需要进行一个通信的，也就是不断地 pingpong 机制，让每个节点连接对方的信息；发送的消息头中有一个 bitmap，其中每一位代表一个槽，如果该位为 1，表示这个槽是属于当前节点，如果槽位过大，那么这个 bitmap 就会太大，心跳包过于庞大，浪费带宽。\n\n**不能太小，主要从压缩率方面考虑：**\n\n由于 bitmap 在传输过程中会进行压缩，bitmap 的填充率用 slots/N 表示（N 即节点数），对于同样的 slots，如果 N 太小，导致其填充率过高，压缩率就很低。\n\n***\n\n## 缓存穿透、击穿、雪崩\n\n### 缓存穿透\n\n**问题来源**\n\n缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，每次都去 DB 判断然而又不能复制到 Redis 中，这就是漏洞。\n\n例如发起为 id 为“-1”的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。\n\n**解决方案**\n\n1. **接口校验**：接口层增加校验，例如对 id<=0 的直接拦截。\n\n2. **缓存空值**：从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 10 秒（设置太长会导致正常情况也没法使用）。\n\n3. **布隆过滤器**：布隆过滤器用于快速判某个元素是否存在于集合中，由一个很长的二进制向量（位图）和一系列哈希函数两部分组成。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的错误识别率，添加到集合中的元素越多，误报的可能性就越大。\n\n\t位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。\n\n\t> [布隆过滤器](https://javaguide.cn/cs-basics/data-structure/bloom-filter.html)\n\t>\n\t> [缓存穿透-布隆过滤器](https://javaguide.cn/database/Redis/Redis-questions-01.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F)\n\n\t具体而言：\n\n\t把 **所有可能存在的请求的值** 都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。布隆过滤器判断不存在的话，则肯定不存在，布隆过滤器判断存在，则进一步查 Redis，Redis 中存在则返回，Redis 中不存在则查数据库。\n\n\t为什么布隆过滤器会出现误判的情况呢? \n\n\t**当一个元素加入布隆过滤器中的时候，会进行以下操作：**\n\n\t1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n\n\t\t> hashVal1 = hashMethod1(key)， hashVal2= hashMethod2(key)...\n\n\t2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n\t\t> 把位数组中的 hashVal1 和 hashVal2 处置为 1\n\n\t**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行以下操作：**\n\n\t1. 对给定元素再次进行相同的哈希计算；\n\n\t\t> hashVal1 = hashMethod1(key)， hashVal2= hashMethod2(key)...\n\n\t2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n\t\t> 判断位数组中的 hashVal1 和 hashVal2 处是否全部为 1，全部为 1说明当前元素存在于位数组中。\n\n\t然而会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n\n\t> **⭐例如**：val1 经过两次hash得到下标 1， 3，将1、3处置为1，val2经过两次hash得到下标2、4，将2、4处置为1，对于新元素val3经过两次hash得到下标1、2，判断这两个位置都为1，误判以为val3存在，实际上不存在。\n\n\n### 缓存击穿\n\n**问题来源**\n\n缓存击穿是指一个热点的 key，有大并发集中对其进行访问，突然间这个 key 失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。\n\n**解决方案**\n\n> 热点key失效 → 打到数据库上，因此可以从这两方面进行解决\n\n1、设置热点数据永远不过期。\n\n2、接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。\n\n3、加互斥锁：如果缓存失效的情况，只有拿到锁才可以查询数据库，分布式场景下可以使用分布式锁。\n\n### 缓存雪崩\n\n**问题来源**\n\n缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是指很多不同的数据都过期了，都查不到从而查数据库。\n\n**解决方案**\n\n1. **缓存数据的过期时间设置随机**，防止同一时间大量数据过期现象发生。\n2. 设置热点数据永远不过期。\n3. 在即将发生大并发访问之前，进行**缓存预热**将可能大量访问的数据加载到缓存。\n4. 接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。\n5. 为了防止 Redis 宕机导致缓存雪崩的问题，可以**搭建Redis集群**，提高 Redis 的容灾性。\n6. 提高数据库的容灾能力，可以使用**数据库分库分表**，读写分离的策略。\n\n## Redis 淘汰策略\n\n### Redis 内存淘汰策略\n\n> Redis 是基于内存结构进行数据缓存的，当内存资源消耗完毕，当将要有新的数据缓存进来时，为了腾出空间放新的数据，需要将内存中的一些数据释放掉，这种释放数据的策略称为 Redis 的淘汰策略。\n\nLRU：Least Recently Used\n\nLFU：Least Frequently Used\n\nLRU 淘汰的是最久未访问到的数据，而 LFU 是淘汰的是最不经常使用的数据（若两个或多个数据的使用频率相同时，LFU 会再选择最久未访问到的数据淘汰）。\n\n```conf\n# volatile-lru -> 在设置了过期时间的数据中使用 LRU\n# allkeys-lru -> 在所有数据中使用 LRU\n# volatile-lfu -> 在设置了过期时间的数据中使用 LFU\n# allkeys-lfu -> 在所有数据中使用 LFU\n# volatile-random -> 在设置了过期时间的数据中随机淘汰\n# allkeys-random -> 在所有数据中随机淘汰\n# volatile-ttl -> 越早过期的数据 越先被淘汰\n# noeviction -> 不淘汰任何数据，当内存不够时直接抛出异常\n```\n\n### Redis 缓存失效策略\n\n**定时过期策略**\n\n每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，有效地减少了因为过期键带来的内存浪费；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。\n\n**惰性过期策略**\n\n只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。\n\n**定期过期策略**\n\n每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。\n\n**Redis中同时使用了定期过期和惰性过期两种过期策略。**\n\n所谓定期删除，指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。\n\n**假设 Redis 里放了 10w 个 key，都设置了过期时间，**你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。**注意，**这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。\n\n**但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？**所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\n\n**获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。**但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存快耗尽了，咋整？**答案是：走内存淘汰机制。**\n\n***\n\n## Redis分布式并发问题\n\n> 单体项目中，购物车下单可以使用 synchronized 关键字锁住实例对象，只让一个线程下单并扣减库存\n>\n> 而对于集群而言，在每台服务器上锁住实例对象，但是每台之间是无法感知的，仍然可能存在商品超卖问题\n\n### 使用 Redis 实现分布式锁\n\n```java\n@Transactional\n@Override\npublic Map<String, String> addOrder(String cids, Orders orders) {\n    log.info(\"add order begin...\");\n\n    Map<String, String> map = new HashMap<>();\n\n    // 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）\n    String[] arr = cids.split(\"，\");\n    List<Integer> cidsList = new ArrayList<>();\n    for (String s : arr) {\n        cidsList.add(Integer.parseInt(s));\n    }\n    // 获取所有skuId\n    List<ShoppingCartVO> list1 = shoppingCartMapper.selectShopCartByCids(cidsList);\n\n    boolean allLocked = true;\n    List<String> lockedSkuIds = new ArrayList<>();\n    Map<String, String> values = new HashMap<>();\n    for (ShoppingCartVO sc : list1) {\n        String skuId = sc.getSkuId()， value = UUID.randomUUID().toString();\n        Boolean thisLocked = srt.boundValueOps(sc.getSkuId()).setIfAbsent(value, 10, TimeUnit.SECONDS);\n        if (!thisLocked) {   // 返回 false 说明之前有该数据，即有线程在操作这个 商品库存\n            allLocked = false;  // 因此这个sku就没有锁住，不能继续操作\n            break;\n        } else {\n            lockedSkuIds.add(skuId);\n            values.put(skuId, value);\n        }\n    }\n    if (allLocked) {\n        // 2、校验库存\n        List<ShoppingCartVO> list = shoppingCartMapper.selectShopCartByCids(cidsList);\n        boolean f = true;\n        StringBuilder sb = new StringBuilder();\n        for (ShoppingCartVO sc : list) {\n            if (Integer.parseInt(sc.getCartNum()) > sc.getSkuStock()) {\n                f = false;\n            }\n            //获取所有商品的名称，以逗号拼接成字符串\n            sb.append(sc.getProductName()).append(\"，\");\n        }\n        String untitled = sb.toString();\n\n        if (f) {\n            log.info(\"product stock is ok ... \");\n            // 3、表示库存充足----保存订单\n            // a.userId   b.untitled  c.收货人信息：姓名、电话、地址\n            // d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态\n            orders.setUntitled(untitled);\n            orders.setCreateTime(new Date());\n            orders.setStatus(\"1\");\n\n            // 生成订单编号\n            String orderId = UUID.randomUUID().toString().replace(\"-\"， \"\");\n            orders.setOrderId(orderId);\n\n            // 保存订单\n            ordersMapper.insert(orders);\n            // 4、生成商品快照\n            for (ShoppingCartVO sc : list) {\n                int cnum = Integer.parseInt(sc.getCartNum());\n                String itemId = System.currentTimeMillis() + \"\" + (new Random().nextInt(89999) + 10000);\n                OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，\n                                                    sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, new BigDecimal(sc.getSellPrice() * cnum)， new Date()， new Date()， 0);\n                orderItemMapper.insert(orderItem);\n            }\n\n            // 5、扣减库存：根据套餐Id修改套餐库存量\n            for (ShoppingCartVO sc : list) {\n                String skuId = sc.getSkuId();\n                int newStock = sc.getSkuStock() - Integer.parseInt(sc.getCartNum());\n\n                ProductSku productSku = new ProductSku();\n                productSku.setSkuId(skuId);\n                productSku.setStock(newStock);\n                //根据主键来修改属性值\n                productSkuMapper.updateByPrimaryKeySelective(productSku);\n            }\n\n            // 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作\n            for (int cid : cidsList) {\n                shoppingCartMapper.deleteByPrimaryKey(cid);\n            }\n\n            // 释放锁\n            for (String lockedSkuId : lockedSkuIds) {\n                String value = srt.boundValueOps(lockedSkuId).get();\n                if (value != null && value.equals(values.get(lockedSkuId))) {\n                    srt.delete(lockedSkuId);\n                }\n            }\n\n            log.info(\"add order finished... \");\n\n            map.put(\"orderId\"， orderId);\n            map.put(\"productNames\"， untitled);\n            return map;\n        } else {\n            // 表示库存不足\n            return null;\n        }\n    } else {    // 加锁失败\n        // 要将部分锁定的sku释放锁，即从Redis中移除锁住的skuId\n        for (String lockedSkuId : lockedSkuIds) {\n            srt.delete(lockedSkuId);\n        }\n        return null;\n    }\n}\n```\n\n1. 如果订单中部分商品加锁成功，但是由于一些商品加锁失败导致无法提交订单，此时要注意将加锁的商品恢复，即从 Redis 中移除该商品\n\n\t> 在 allLocked == false 中，释放加锁的商品\n\n2. 第一次根据 购物车 Id 查到的购物车记录（包含商品库存）到加锁提交订单之前，可能有别的线程 操作了其中某个商品的库存并操作完了，为了防止当前线程还对之前库存进行修改，应当在加锁后操作前重新查询库存。\n\n3. 当前线程加锁成功之后，在执行添加订单的过程中如果出现了异常导致无法释放锁\n\n\t> 可以在对商品加锁时设置过期时间，则到期自动释放锁\n\n4. 档给锁设置了过期时间之后，如果当前线程 t1 因为特殊原因，在锁过期之前没有完成业务执行，释放掉了锁，此时线程 t2 加锁成功，如果线程 t1 执行结束，将会释放 线程 t2 的锁，导致 线程 t2 在无锁状态\n\n\t> 对于加成功并提交完订单之后，对当前商品的锁释放，要判断 Redis 中的value是否和自己记录的相同，即是否是自己加的锁\n\t>\n\t> ```java\n\t> // 释放锁\n\t> for (String lockedSkuId : lockedSkuIds) {\n\t>    String value = srt.boundValueOps(lockedSkuId).get();\n\t>    if (values.get(lockedSkuId).equals(value)) {\n\t>      \tsrt.delete(lockedSkuId);\n\t>    }\n\t> }\n\t> ```\n\n5. 当前线程 t1 判断是自己加的锁，在准备删除之前，锁过期了并且被其他线程 t2 拿到了成功加锁，这时候线程 t1 会释放掉线程 t2 的锁（并发量很大仍然需要考虑）\n\n\t> 保证 查询锁是否是自己加的和删除自己加的锁 的原子性（使用 lua 脚本，让多个 Redis 操作具有原子性，查询+删除）\n\n6. 使用看门狗线程解决线程 t1 释放相乘 t2 的锁的问题\n\n\t> 线程t1 加锁并设置过期时间，此时启动 看门狗线程（守护线程）监控线程 t1过期时间，过期时间要到了但是线程t1 业务还在执行，则重置过期时间，这样可以保证业务执行完之前不会释放锁\n\n### 分布式锁框架 Resisson\n\n- 添加依赖\n\n\t```xml\n\t<!-- https://mvnrepository.com/artifact/org.redisson/redisson -->\n\t<dependency>\n\t    <groupId>org.redisson</groupId>\n\t    <artifactId>redisson</artifactId>\n\t    <version>3.16.7</version>\n\t</dependency>\n\t```\n\n- 配置 yaml 文件\n\n\t```yaml\n\tredisson:\n\t  addr:\n\t    singleAddr:\n\t      host: Redis://47.110.247.63:6389\n\t      password: FYX123fyx.\n\t      database: 0\n\t```\n\n- 配置 RedissonClient（也可以配置成集群模式、主从模式）\n\n\t```java\n\t@Configuration\n\tpublic class RedissonConfig {\n\t    @Value(\"${redisson.addr.singleAddr.host}\")\n\t    private String host;\n\t\n\t    @Value(\"${redisson.addr.singleAddr.password}\")\n\t    private String password;\n\t\n\t    @Value(\"${redisson.addr.singleAddr.database}\")\n\t    private int database;\n\t\n\t    @Bean\n\t    public RedissonClient redissonClient() {\n\t        Config config = new Config();\n\t        config.useSingleServer().setAddress(host)\n\t                .setPassword(password)\n\t                .setDatabase(database);\n\t        return Redisson.create(config);\n\t    }\n\t}\n\t```\n\n- 操作\n\n\t```java\n\t@Transactional\n\t@Override\n\tpublic Map<String, String> addOrder(String cids, Orders orders) {\n\t    log.info(\"add order begin...\");\n\t\n\t    // 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）\n\t    String[] arr = cids.split(\"，\");\n\t    List<Integer> cidsList = new ArrayList<>();\n\t    for (String s : arr) {\n\t        cidsList.add(Integer.parseInt(s));\n\t    }\n\t    // 获取所有skuId\n\t    List<ShoppingCartVO> list = shoppingCartMapper.selectShopCartByCids(cidsList);\n\t    List<String> lockedSkuIds = new ArrayList<>();\n\t    Map<String, RLock> locks = new HashMap<>(); // {\"1\":lock1, \"2\":lock2}\n\t    boolean allLocked = true;\n\t    for (ShoppingCartVO sc : list) {\n\t        String skuId = sc.getSkuId();\n\t        boolean b = false;\n\t        RLock lock = redissonClient.getLock(skuId);\n\t        try {\n\t            b = lock.tryLock(10, 3, TimeUnit.SECONDS);\n\t        } catch (InterruptedException e) {\n\t            e.printStackTrace();\n\t        }\n\t        if (!b) {\n\t            allLocked = false;\n\t            break;\n\t        } else {\n\t            lockedSkuIds.add(skuId);\n\t            locks.put(skuId, lock);\n\t        }\n\t    }\n\t\n\t    Map<String, String> map = null;\n\t    try {\n\t        if (allLocked) {\n\t            // 2、校验库存\n\t            list = shoppingCartMapper.selectShopCartByCids(cidsList);\n\t            boolean f = true;\n\t            StringBuilder sb = new StringBuilder();\n\t            for (ShoppingCartVO sc : list) {\n\t                if (Integer.parseInt(sc.getCartNum()) > sc.getSkuStock()) {\n\t                    f = false;\n\t                }\n\t                //获取所有商品的名称，以逗号拼接成字符串\n\t                sb.append(sc.getProductName()).append(\"，\");\n\t            }\n\t            String untitled = sb.toString();\n\t\n\t            if (f) {\n\t                log.info(\"product stock is ok ... \");\n\t                // 3、表示库存充足----保存订单\n\t                // a.userId   b.untitled  c.收货人信息：姓名、电话、地址\n\t                // d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态\n\t                orders.setUntitled(untitled);\n\t                orders.setCreateTime(new Date());\n\t                orders.setStatus(\"1\");\n\t\n\t                // 生成订单编号\n\t                String orderId = UUID.randomUUID().toString().replace(\"-\"， \"\");\n\t                orders.setOrderId(orderId);\n\t\n\t                // 保存订单\n\t                ordersMapper.insert(orders);\n\t                // 4、生成商品快照\n\t                for (ShoppingCartVO sc : list) {\n\t                    int cnum = Integer.parseInt(sc.getCartNum());\n\t                    String itemId = System.currentTimeMillis() + \"\" + (new Random().nextInt(89999) + 10000);\n\t                    OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，\n\t                                                        sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, new BigDecimal(sc.getSellPrice() * cnum)， new Date()， new Date()， 0);\n\t                    orderItemMapper.insert(orderItem);\n\t                }\n\t\n\t                // 5、扣减库存：根据套餐Id修改套餐库存量\n\t                for (ShoppingCartVO sc : list) {\n\t                    String skuId = sc.getSkuId();\n\t                    int newStock = sc.getSkuStock() - Integer.parseInt(sc.getCartNum());\n\t\n\t                    ProductSku productSku = new ProductSku();\n\t                    productSku.setSkuId(skuId);\n\t                    productSku.setStock(newStock);\n\t                    //根据主键来修改属性值\n\t                    productSkuMapper.updateByPrimaryKeySelective(productSku);\n\t                }\n\t\n\t                // 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作\n\t                for (int cid : cidsList) {\n\t                    shoppingCartMapper.deleteByPrimaryKey(cid);\n\t                }\n\t\n\t                log.info(\"add order finished... \");\n\t\n\t                map = new HashMap<>();\n\t                map.put(\"orderId\"， orderId);\n\t                map.put(\"productNames\"， untitled);\n\t\n\t            }\n\t\n\t        }\n\t    } catch (Exception e) {\n\t        e.printStackTrace();\n\t    } finally {\n\t        // 释放锁\n\t        for (String lockedSkuId : lockedSkuIds) {\n\t            locks.get(lockedSkuId).unlock();\n\t        }\n\t    }\n\t    return map;\n\t}\n\t```\n\n### 分布式锁特点\n\n1. 互斥性\n\n\t保证在不同节点间不同线程的互斥（只有一个节点当然可以）\n\n2. 可重入性\n\n\t同一个节点上的同一个线程如果获取锁之后可以再次获取到这个锁\n\n3. 锁超时\n\n\t加锁成功之后设置超时时间，以防止线程故障导致不释放锁而引起死锁\n\n4. 高效、高可用\n\n\t支持单节点 Redis、主从 Redis、集群 Redis\n\n5. 支持阻塞和非阻塞\n\n\ttryLock 非阻塞 和 tryLock(long timeOut) 阻塞\n\n### Redisson 的使用\n\n1. 获取锁（公平锁 / 非公平锁）\n\n\t```java\n\t// 公平锁\n\tRLock lock = redissonClient.getFairLock(skuId);\n\t\n\t// 非公平锁\n\tRLock lock = redissonClient.getLock(skuId);\n\t```\n\n2. 加锁（阻塞锁 / 非阻塞锁）\n\n\t```java\n\t// 阻塞锁，设置加锁成功后的超时时间 20s，不加时间默认 30s\n\tlock.lock(20, TimeUnit.SECONDS);\n\t\n\t// 非阻塞锁（设置等待时间 3s，加锁成功后的超时时间 10s，不加则默认 30s）\n\tlock.tryLock(10, 3, TimeUnit.SECONDS);\n\t```\n\n3. 释放锁\n\n\t```java\n\tlock.unlock();\n\t```\n\n4. 实例\n\n\t```java\n\t// 公平非阻塞锁\n\tRLock lock = redissonClient.getLock(skuId);\n\tlock.tryLock(10, 3, TimeUnit.SECONDS);\n\t```\n\n***\n\n## 缓存与数据库双写一致性\n\n总结：\n\n读数据：先读缓存，如果有直接返回，如果没有查数据库查到数据存到缓存中并返回\n\n写数据：先写数据库，再删缓存，这个阶段可能删缓存失败，可以考虑使用一下三种方案：\n\n1. 如果删除缓存失败，需要将数据写入重试表，然后使用 elastic-job 等定时任务进行重试。\n2. 如果删除缓存失败，需要将数据发送 mq 消息到 mq 服务器，在 mq 的 consumer 中处理。\n3. 订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。\n\n> [如何保证数据库和缓存双写一致性？-苏三说技术](https://www.zhihu.com/question/319817091/answer/2432904728)\n\n### 问题引入\n\n通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526232523.png)\n\n1. 用户请求过来之后，先查缓存有没有数据，如果有则直接返回。\n2. 如果缓存没数据，再继续查数据库。\n3. 如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。\n4. 如果数据库也没数据，则直接返回空。\n\n这是缓存非常常见的用法。一眼看上去，好像没有啥问题。\n\n但你忽略了一个非常重要的细节：**如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？**\n\n不更新缓存行不行？\n\n答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？\n\n那么，我们该如何更新缓存呢？\n\n目前有以下 4 种方案：\n\n1. 先写缓存，再写数据库\n2. 先写数据库，再写缓存\n3. 先删缓存，再写数据库\n4. 先写数据库，再删缓存\n\n接下来，我们详细说说这 4 种方案。\n\n### 先写缓存，再写数据库\n\n对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。\n\n那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？\n\n我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526427819.png)\n\n某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526436447.png)\n\n其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。\n\n我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。\n\n但如果某条数据，在数据库中都不存在，你缓存这种“`假数据`”又有啥意义呢？\n\n因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。\n\n### 先写数据库，再写缓存\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526499487.png)\n\n用户的写操作，先写数据库，再写缓存，可以避免之前“假数据”的问题。但它却带来了新的问题。\n\n#### 写缓存失败了\n\n如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526558901.png)\n\n如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。\n\n但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。\n\n也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。\n\n这就会出现：数据库是`新数据`，而缓存是`旧数据`，两边`数据不一致`的情况。\n\n#### 高并发下的问题\n\n假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a 和 b，它们同时请求到业务系统。\n\n其中请求 a 获取的是旧数据，而请求 b 获取的是新数据，如下图所示：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526645914.png)\n\n1. 请求 a 先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。\n2. 这时候请求 b 过来了，先写了数据库。\n3. 接下来，请求 b 顺利写了缓存。\n4. 此时，请求 a 卡顿结束，也写了缓存。\n\n很显然，在这个过程当中，请求 b 在缓存中的`新数据`，被请求 a 的`旧数据`覆盖了。\n\n也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。\n\n#### 浪费系统资源\n\n有些业务场景比较特殊：`写多读少`。\n\n如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。\n\n还不如不用 Redis，反正写数据库都要写，我读数据又比较少，Redis 使用频率低，却还要一直更新 Redis 中数据。\n\n### 先删缓存，再写数据库\n\n不然是先写缓存还是先写数据库都有很多问题，那么考虑不是 `更新缓存` 而是 `删除缓存`。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526855730.png)\n\n在用户的写操作中，先执行删除缓存操作，再去写数据库\n\n#### 高并发下的问题\n\n假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求 c，还有另一个写数据请求 d（一个更新操作），同时请求到业务系统。如下图所示：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650527043982.png)\n\n1. 请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。\n2. 这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。\n3. 请求 c 将数据库中的旧值，更新到缓存中。\n4. 此时，请求 d 卡顿结束，把新值写入数据库。\n\n在这个过程当中，请求 d 的新值并没有被请求 c 写入缓存，同样会导致缓存和数据库的数据不一致的情况。\n\n#### 缓存双删\n\n在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。\n\n有人说还不好办，请求 d 在写完数据库之后，把缓存重新删一次不就行了？\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528097218.png)\n\n这就是我们所说的`缓存双删`，即在写数据库之前删除一次，写完数据库后，再删除一次。\n\n该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的`时间间隔`之后。\n\n我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：\n\n1. 请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。\n2. 这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。\n3. 请求 c 将数据库中的旧值，更新到缓存中。\n4. 此时，请求 d 卡顿结束，把新值写入数据库。\n5. 一段时间之后，比如：500ms，请求 d 将缓存删除。\n\n这样来看确实可以解决缓存不一致问题。\n\n那么，为什么一定要间隔一段时间之后，才能删除缓存呢？\n\n请求 d 卡顿结束，把新值写入数据库后，请求 c 将数据库中的旧值，更新到缓存中。\n\n此时，如果请求 d 删除太快，在请求 c 将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求 c 更新缓存之后，再删除缓存，才能把旧值及时删除了。\n\n所以需要在请求 d 中加一个时间间隔，确保请求 c，或者类似于请求 c 的其他请求，如果在缓存中设置了旧值，最终都能够被请求 d 删除掉。\n\n接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？\n\n### 先写数据库，再删缓存\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528137396.png)\n\n在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：\n\n1. 请求 e 先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。\n2. 请求 f 查询缓存，发现缓存中有数据，直接返回该数据。\n3. 请求 e 删除缓存。\n\n在这个过程中，只有请求 f 读了一次旧数据，后来旧数据被请求 e 及时删除了，看起来问题不大。\n\n但如果是读数据请求先过来呢？\n\n1. 请求 f 查询缓存，发现缓存中有数据，直接返回该数据。\n2. 请求 e 先写数据库。\n3. 请求 e 删除缓存。\n\n这种情况看起来也没问题呀？\n\n答：对的。\n\n但就怕出现下面这种情况，即缓存自己失效了。如下图所示：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528267733.png)\n\n1. 缓存过期时间到了，自动失效。\n2. 请求 f 查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。\n3. 请求 e 先写数据库，接着删除了缓存。\n4. 请求 f 更新旧值到缓存中。\n\n这时，缓存和数据库的数据同样出现不一致的情况了。\n\n但这种情况还是比较少的，需要同时满足以下条件才可以：\n\n1. 缓存刚好自动失效。\n2. 请求 f 从数据库查出旧值，更新缓存的耗时，比请求 e 写数据库，并且删除缓存的还长。\n\n我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。\n\n由此可见，系统同时满足上述两个条件的概率非常小。\n\n> 推荐大家使用先写数据库，再删缓存的方案，虽说不能100%避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。\n\n但在该方案中，如果删除缓存失败了该怎么办呢？\n\n### 删缓存失败怎么办？\n\n其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。\n\n那么，删除缓存失败怎么办呢？\n\n答：需要加`重试机制`。\n\n在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试 3 次。如果其中有任何一次成功，则直接返回成功。如果 3 次都失败了，则写入数据库，准备后续再处理。\n\n当然，如果你在接口中直接`同步重试`，该接口并发量比较高的时候，可能有点影响接口性能。\n\n这时，就需要改成`异步重试`了。\n\n异步重试方式有很多种，比如：\n\n1. 每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统 OOM 问题，不太建议使用。\n2. 将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。\n3. 将重试数据写表，然后使用 elastic-job 等定时任务进行重试。\n4. 将重试的请求写入 mq 等消息中间件中，在 mq 的 consumer 中处理。\n5. 订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。\n\n#### 定时任务\n\n使用`定时任务重试`的具体方案如下：\n\n1. 当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：\n\n\t![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528474531.png)\n\n2. 在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为 0。然后重试 5 次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。\n\n\t![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528480542.png)\n\n3. 在高并发场景中，定时任务推荐使用`elastic-job`。相对于 xxl-job 等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7 秒等。\n\n使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。\n\n但它有一个很大的优点，即数据是落库的，不会丢数据。\n\n#### mq\n\n在高并发的业务场景中，mq（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。\n\nmq 的生产者，生产了消息之后，通过指定的 topic 发送到 mq 服务器。然后 mq 的消费者，订阅该 topic 的消息，读取消息数据之后，做业务逻辑处理。\n\n使用`mq重试`的具体方案如下：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528506474.png)\n\n1. 当用户操作写完数据库，但删除缓存失败了，产生一条 mq 消息，发送给 mq 服务器。\n2. mq 消费者读取 mq 消息，重试 5 次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则写入`死信队列`中。\n3. 推荐 mq 使用`rocketmq`，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。\n\n当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送 mq 消息，到 mq 服务器，然后有 mq 消费者全权负责删除缓存的任务。\n\n因为 mq 的实时性还是比较高的，因此改良后的方案也是一种不错的选择。\n\n#### binlog\n\n前面我们聊过的，无论是定时任务，还是 mq（消息队列），做重试机制，对业务都有一定的侵入性。\n\n在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。\n\n而使用 mq 的方案中，如果删除缓存失败了，需要在业务代码中发送 mq 消息到 mq 服务器。\n\n其实，还有一种更优雅的实现，即`监听binlog`，比如使用：`canal`等中间件。\n\n具体方案如下：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528533430.png)\n\n1. 在业务接口中写数据库之后，就不管了，直接返回成功。\n2. mysql 服务器会自动把变更的数据写入 binlog 中。\n3. binlog 订阅者获取变更的数据，然后删除缓存。\n\n这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在 binlog 订阅者中做缓存删除工作。\n\n但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。\n\n如何解决这个问题呢？\n\n答：这就需要加上前面聊过的`重试机制`了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入 mq，让 mq 自动重试。\n\n在这里推荐使用`mq自动重试机制`。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528538202.png)\n\n在 binlog 订阅者中如果删除缓存失败，则发送一条 mq 消息到 mq 服务器，在 mq 消费者中自动重试 5 次。如果有任意一次成功，则直接返回成功。如果重试 5 次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。\n\n***\n\n## Redis 线程模型\n\n### 单线程的Redis为什么这么快\n\n1. 纯内存操作\n\n2. 单线程操作，避免了频繁的上下文切换\n\n3. 采用了非阻塞 I/O 多路复用机制\n\n### Redis 为什么是单线程的\n\n官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。\n\n既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦）。Redis 利用队列将并发访问变为串行访问\n\n1、绝大部分请求是纯粹的内存操作（非常快速）\n\n2、采用单线程，避免了不必要的上下文切换和竞争条件\n\n3、非阻塞 IO 优点：\n\n- 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)\n- 支持丰富数据类型，支持 string，list，set，sorted set，hash\n- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行\n- 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除如何解决 Redis 的并发竞争 key 问题\n\n**同时有多个子系统去set一个key。这个时候要注意什么呢？**\n\n不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 Redis-server 上。因此，Redis 的事务机制，十分鸡肋。\n\n- 如果对这个 key 操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可\n- 如果对这个 key 操作，要求顺序：分布式锁+时间戳。假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。\n- 利用队列，将 set 方法变成串行访问也可以 Redis 遇到高并发，如果保证读写 key 的一致性\n\n对 Redis 的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题,Redis 内部已经帮你处理好并发的问题了。\n\n### 为什么Redis的操作是原子性的，怎么保证原子性的？\n\n对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。\n\nRedis 的操作之所以是原子性的，是因为 Redis 是单线程的。（Redis 新版本已经引入多线程，这里基于旧版本的 Redis）\n\nRedis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操作的原子性。\n\n多个命令在并发中也是原子性的吗？\n\n不一定， 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用 Redis+Lua 的方式实现.\n\n### 讲解下Redis线程模型\n\n文件事件处理器包括分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。\n\n当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。\n\nI/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。\n\n**工作原理：**\n\nI/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。\n\n尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：\n\n当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。\n\n## 其他参考\n\n[原创 一洺 [阿里开发者](javascript:void(0);) 2022-03-24 08:00](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247507942&idx=1&sn=e00fd16ec56d0e10cc830678ee25c417&chksm=e92ae2e9de5d6bff6d227646c12685a5c45a4c3322e2186954555a14ebcd9510e8ae579a4941&mpshare=1&scene=24&srcid=0324gng7YtX5XX0z9bf7aObR&sharer_sharetime=1648080975816&sharer_shareid=ebfad4e5798246e3d3928c1f4ee9048e#rd)\n\nhttps://blog.csdn.net/qq_31387317/category_7391502.html\n","source":"_posts/Java八股文-Redis.md","raw":"---\ntitle: Java八股文 - Redis\ncopyright: true\nmathjax: false\ncategories:\n  - Java八股文\ndate: 2023-01-25 13:43:59\ntags:\ntoc: true\nurlname: Redis\n---\n\n> 整理的 Redis 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<!--more-->\n\n## 什么是NoSQL？\n\nNoSQL = not only sql（不仅仅是 SQL）\n\n关系型数据库：列+行，同一个表下数据的结构是一样的。\n\n非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。\n\nNoSQL 泛指非关系型数据库，随着 web2.0 互联网的诞生，传统的关系型数据库很难对付 web2.0 大数据时代。尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL 在当今大数据环境下发展的十分迅速，Redis 是发展最快的。\n\n传统 RDBMS（关系数据库管理系统）和 NoSQL（非关系型数据库）比较：\n\nRDBMS：\n - 组织化结构\n - 固定 SQL\n - 数据和关系都存在单独的表中（行列）\n - DML（数据操作语言）、DDL（数据定义语言）等\n - 严格的一致性（ACID）：原子性、一致性、隔离性、持久性\n - 基础的事务\n\nNoSQL：\n - 不仅仅是数据\n - 没有固定查询语言\n - 键值对存储（Redis）、列存储（HBase）、文档存储（MongoDB）、图形数据库（不是存图形，放的是关系）（Neo4j）\n - 最终一致性（BASE）：基本可用、软状态/柔性事务、最终一致性\n\n***\n\n## Redis是什么？\n\n### 定义\n\nRedis = Remote Dictionary Server，即远程字典服务。\n\nRedis 是一个用 C 语言开发的、基于内存结构进行**键值对**数据存储的、高性能的、非关系型 NoSQL 数据库\n\n### 优缺点\n\n**纯内存操作，性能非常出色**，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。支持保存多种数据结构，可以用来实现很多有用的功能。\n\nRedis 的主要缺点是**数据库容量受到物理内存的限制，不能用作海量数据的高性能读写**，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n### 为什么要用缓存\n\n**1、 高性能：**\n\n假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。\n\n**2、高并发：**\n\n直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，缓解数据库压力。\n\n### Redis 与 Memcached 相比有哪些优势\n\nRedis 支持更丰富的数据类型（支持更复杂的应用场景）\n\nRedis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。\n\nRedis 使用单线程的多路 IO 复用模型；Memcached 是多线程，非阻塞 IO 复用的网络模型。\n\n***\n\n## Redis五大基本类型\n\n[Redis 命令大全](https://www.Redis.net.cn/order/)\n\n[Redis 应用场景](https://juejin.cn/post/6857667542652190728)\n\n### String（字符串）\n\n> 1. String 类型是 Redis 的最基础的数据结构，也是最经常使用到的类型。而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以 String 类型是 Redis 的基础。\n>\n> 2. String 类型的值最大能存储 512MB，这里的 String 类型可以是简单字符串、  复杂的 xml/json 的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串。\n\n**应用场景**\n\n1、缓存功能：String 字符串是最常用的数据类型，不仅仅是 Redis，各个语言都是最基本类型，因此，利用 Redis 作为缓存，配合其它数据库作为存储层，利用 Redis 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。\n\n2、计数器：许多系统都会使用 Redis 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。\n\n3、共享用户 session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie 保存在客户端，有安全隐患。这时可以利用 Redis 将用户的 session 集中管理，在这种模式只需要保证 Redis 的高可用，每次用户 session 的更新和获取都可以快速完成。大大提高效率。（分布式会话）\n\n### List（列表）\n\n> 1. List 是简单的字符串列表\n> 2. Redis 可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。Redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。\n\n**应用场景**\n\n1、消息队列：Redis 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过 lpush 命令从左边插入数据，多个数据消费者，可以使用 rpop 命令阻塞的“抢”列表尾部的数据。\n\n2、文章列表或者数据分页展示的应用。比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 Redis 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。\n\n### Set（集合）\n\n> 1. Redis 集合 set 类型和 list 列表类型类似，都可以用来存储多个字符串元素的集合。\n> 2. 但是和 list 不同的是 set 集合当中不允许重复的元素。而且 set 集合当中元素是没有顺序的，不存在元素下标。\n> 3. Redis 的 set 类型是使用哈希表构造的，因此复杂度是 O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。\n\n**应用场景**\n\n1、标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。\n\n2、共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。\n\n3、统计网站的独立 IP。利用 set 集合当中元素不唯一性，可以快速实时统计访问网站的独立 IP。\n\n### sorted set（有序集合）\n\n> Redis 有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。\n\n#### 应用场景\n\n1、排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。\n\n2、用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。\n\n### hash（哈希）\n\nRedis hash 数据结构 是一个键值对（key-value）集合，它是一个 string 类型的 field 和 value 的映射表，Redis 本身就是一个 key-value 型数据库，因此 hash 数据结构相当于在 value 中又套了一层 key-value 型数据。所以 Redis 中 hash 数据结构特别适合存储关系型对象。\n\n> 用户 ID 为查找的key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key/value 结构来存储\n>\n> 1. 将用户 ID 作为 key，姓名属性+姓名数据整体作为 value。缺点是每次修改用户的某个属性，都需要先反序列化 属性+数据，修改好，然后将 属性+数据 序列化之后在修改回去，开销较大。\n>\n> ![ID -> 属性+数据](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356860189.png)\n>\n> 2. 将用户 ID+姓名属性作为 key，姓名数据作为 value。缺点是用户 ID 使用多次，数据冗余\n>\n> ![ID+属性 -> 数据](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356955204.png)\n>\n> \n>\n> 3. 因此通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。\n>\n> ![ID -> 属性 -> 数据](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356950290.png)\n\n#### 应用场景\n\n1、由于 hash 数据类型的 key-value 的特性，用来存储关系型数据库中表记录，是 Redis 中哈希类型最常用的场景。一条记录作为一个 key-value，把每列属性值对应成 field-value 存储在哈希表当中，然后通过 key 值来区分表当中的主键。\n\n2、经常被用来存储用户相关信息。优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能。\n\n***\n\n## 五大基本类型底层数据结构\n\nRedis 整体的存储结构：\n\nRedis 内部整体的存储结构是一个大的 hashmap，内部是数组实现的 hash，key 冲突通过挂链表去实现，每个 dictEntry 为一个 key/value 对象，value 为定义的 redisObject。\n\n结构图如下：\n\n![Redis 整体的存储结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650433179786.png)\n\ndictEntry 是存储 key->value 的地方，其中包含指向具体的 redisObject 的指针。\n\nredisObject 中*ptr 指向具体的数据结构的地址；type 表示该对象的类型，即 String、List、Hash、Set、Zset 中的一个\n\n### String (arrayList)\n\nString 的数据结构为简单动态字符串(Simple Dynamic String，缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。\n\n![String 的数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356547555.png)\n\n如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。\n\n### List (ziplist - quickList)\n\n1、Redis 3.2 之前的底层实现方式：压缩列表 ziplist 或者 双向循环链表 linkedlist\n\n当 list 存储的数据量比较少且同时满足下面两个条件时，list 就使用 ziplist 存储数据：\n\n- list 中保存的每个元素的长度小于 64 字节；\n- 列表中数据个数少于 512 个。\n\n2、Redis 3.2 及之后的底层实现方式：quicklist\n\nquicklist 是一个基于 ziplist 的双向链表，quicklist 的每个节点都是一个 ziplist，结合了双向链表和 ziplist 的优点。\n\n#### **ziplist**\n\nziplist 是压缩列表，它的好处是能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用 ziplist 存储。但当数据量过大时就 ziplist 就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是 O(N)，即每次插入都会重新进行 realloc 重新分配内存空间。\n\nziplist 结构如下：\n\n![ziplist 结构图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419709341.png)\n\n1、zlbytes：用于记录整个压缩列表占用字节数\n\n2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节，用于快速定位到最后一个节点，从而可以在 ziplist 尾部快速的执行 push，pop 操作\n\n3、zllen：记录了压缩列表包含的节点数量。\n\n4、entryX：压缩列表包含的各个节点\n\n5、zlend：用于标记压缩列表的末端，用来快速定位到最后一个元素，然后倒着遍历。（entry 块的 prevlen 字段表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。）\n\n**为什么数据量大时不用 ziplist？**\n\n因为 ziplist 是一段连续的内存，插入的时间复杂化度为 O(n)，而且每当插入新的元素需要 realloc 做内存扩展；而且如果超出 ziplist 内存大小，还会做重新分配的内存空间，并将内容复制到新的地址。如果数量大的话，重新分配内存和拷贝内存会消耗大量时间。所以不适合大型字符串，也不适合存储量多的元素。\n\n#### quickList\n\n快速列表是 ziplist 和 linkedlist 的混合体，是将 linkedlist 按段切分，每一段用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针链接。\n\n**为什么不直接使用 linkedlist？**\n\nlinkedlist 的附加空间相对太高，prev 和 next 指针就要占去 16 个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。\n\nquicklist 结构图如下：\n\n![quicklist 结构图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419719663.png)\n\n**ziplist的长度**\n\nquicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。关于长度可以使用 list-max-ziplist-size 决定。\n\n**压缩深度**\n\n我们上面说到了 quicklist 下是用多个 ziplist 组成的，同时为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩，可以选择压缩深度。quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 list-compress-depth 决定。为了支持快速 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。\n\n### Hash (ziplist - dict)\n\n#### ziplist\n\n当 Hash 中数据项比较少的情况下，Hash 底层才用压缩列表 ziplist 进行存储数据，随着数据的增加，底层的 ziplist 就可能会转成 dict，具体配置如下\n\n> hash-max-ziplist-entries 512\n> hash-max-ziplist-value 64\n\n在如下两个条件之一满足的时候，ziplist 会转成 dict：\n\n- 当 hash 中的数据项的数目超过 512 的时候，也就是 ziplist 数据项超过 1024 的时候；\n- 当 hash 中插入的任意一个 value 的长度超过了 64 的时候。\n\n每当有新的键值对加入到哈希对象时，先压入键，再压入值，如图：\n\n![ziplist实现的hash](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/20190703171927309.png)\n\n当遍历时，从头到尾的遍历，且跳过值节点。\n\n#### dict\n\n字典的哈希表结构和 Java 的 HashMap 结构几乎是一样的，都是通过某个哈希函数从 key 计算得到在哈希表中的位置，采用链表法解决冲突。Redis 这里使用的是单链表，为了查询效率每次把新数据插入到链表头位置（使用头插法是因为新插入的数据被访问的概率大，可以更快访问到）。\n\n我们可以看到每个 dict 中都有两个 hashtable，结构图如下：\n\n![dict实现的hash](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420119549.png)\n\n虽然 dict 结构有两个 hashtable，但是通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容的时候，需要分配新的 hashtable，然后进行渐近式搬迁，这时候两个 hashtable 存储的旧的 hashtable 和新的 hashtable。搬迁结束后，旧 hashtable 删除，新的取而代之。\n\n**渐进式 rehash**\n\n所谓渐进式 rehash 是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个 O(n)的操作。但是因为我们的 Redis 是单线程的，无法承受这样的耗时过程，所以采用了渐进式 rehash 小步搬迁，虽然慢一点，但是可以搬迁完毕。\n\n**扩容条件**\n\n我们的扩容一般会在 Hash 表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在 Redis 在做 bgsave（RDB 持久化操作的过程），为了减少内存页的过多分离（Copy On Write），Redis 不会去扩容。但是如果 hash 表的元素个数已经到达了第一维数组长度的 5 倍的时候，就会强制扩容，不管你是否在持久化。\n\n不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。\n\n**缩容条件**\n\n当我们的 hash 表元素逐渐删除的越来越少的时候。Redis 于是就会对 hash 表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的 10%，并且缩容不考虑是否在做 Redis 持久化。\n\n不用考虑 bgsave 主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。\n\n**rehash 步骤**\n\n![rehash 步骤](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420130964.png)\n\n### Set (intset - hashSet)\n\nRedis 的集合相当于 Java 中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合 Set 类型底层编码包括 inset 和 hashtable。\n\n当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合 intset 来实现 set 这种数据类型：\n\n> 存储的数据都是整数\n> 存储的数据元素个数小于512个\n\n当不能同时满足这两个条件的时候，Redis 就使用 dict 来存储集合中的数据\n\n**intset**\n\nintset 是一个有序集合，查找元素的复杂度为 O(logN)（采用二分法），但插入时不一定为 O(logN)，因为有可能涉及到升级操作。比如当集合里全是 int16_t 型的整数，这时要插入一个 int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成 int32_t 类型，涉及到内存的重新分配，这时插入的复杂度就为 O(N)了。是 intset 不支持降级操作。\n\n**intset 是有序不要和 zset 搞混，zset 是设置一个 score 来进行排序，而 intset 这里只是单纯的对整数进行升序而已**\n\n### Sorted Set (ziplist - zset(dict + skipList))\n\nZset 有序集合和 set 集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数 score，作为排序的依据。\n\n当数据较少时，sorted set 是由 ziplist 来实现的。\n当数据多的时候，sorted set 是由 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据指定分数 score 的范围来获取 value 列表。\n\n**sorted set ziplist 实现**\n\n在这里我们先来讨论一下前一种情况——基于 ziplist 实现的 sorted set。ziplist 就是由很多数据项组成的一大块连续内存。由于 sorted set 的每一项元素都由数据和 score 组成，因此，当使用 zadd 命令插入一个(数据, score)对的时候，底层在相应的 ziplist 上就插入两个数据项：数据在前，score 在后。\n\n![基于 ziplist 实现的 sorted set](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650431975904.png)\n\nziplist 的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set 的各个查询操作，就是在 ziplist 上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。\n\n随着数据的插入，sorted set 底层的这个 ziplist 就可能会转成 zset 的实现。那么到底插入多少才会转呢？\n\n> zset-max-ziplist-entries 128\t# 当sorted set中的元素个数，即(数据， score)对的数目超过128的时候\n> zset-max-ziplist-value 64\t# 当sorted set中插入的任意一个数据的长度超过了64的时候。\n\n**sorted set ziplist实现**\nRedis 的 zset 是一个复合结构，一方面它需要一个 hash 结构来存储 value 和 score 的对应关系，另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获取 value 列表的功能，这就需要另外一个结构「跳跃表」。\n\n```c\ntypedef struct zset {\n    dict *dict;\n    zskiplist *zsl;\n} zset;\n```\n\n跳表：链表+多级索引（空间换时间）\n\n和其他结构的比较：\n\n对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。\n\n***\n\n## 三大特殊数据类型\n\n### geospatial（地理位置）\n\n1. 查看附近的人\n2. 微信位置共享\n3. 地图上直线距离的展示\n\n### Hyperloglog（基数）\n\n基数：不重复的元素\n\n网页统计 UV （浏览用户数量，同一天同一个 ip 多次访问算一次访问，目的是计数，而不是保存用户）\n\n传统的方式，set 保存用户的 id，可以统计 set 中元素数量作为标准判断。\n\n但如果这种方式保存大量用户 id，会占用大量内存，我们的目的是为了计数，而不是去保存 id。\n\n### Bitmaps（位存储）\n\nRedis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：\n\n1. Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。\n2. Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。\n\n#### 命令\n\n1. setbit\n\n\t`setbit<key><offset><value>` 设置 Bitmaps 中某个偏移量的值（0 或 1）\n\n\t可以将 idx 位置为 1 表示 idx 用户访问过\n\n2. getbit\n\n\t`getbit<key><offset>` 获取 Bitmaps 中某个偏移量的值\n\n\t通过 idx 位是否为 1 判断 idx 用户是否访问过\n\n3. bitcount\n\n\t`bitcount<key>[start end]` 统计字符串从 start 字节到 end 字节比特值为 1 的数量\n\n4. bitop\n\n\t`bitop and(or/not/xor) <destkey> [key…]` bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。\n\n#### **应用场景**\n\n**两种状态的统计**都可以使用 bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。\n\n***\n\n## Redis事务与锁机制\n\n### 事务\n\n事务本质：一组命令的集合\n\n#### **数据库的事务**\n\n数据库事务通过 ACID（原子性、一致性、隔离性、持久性）来保证。\n\n数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条 SQL 语句在被执行的时候，都会生成一条撤销日志(Undo Log)。\n\n#### Redis 事务\n\nRedis 事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。\n\nRedis 中一个事务从开始到执行会经历**开始**事务（Muiti）、命令**组队**和**执行**事务(Exec)三个阶段，事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。\n\n组队的过程中可以通过 discard 来放弃组队。\n\n**事务的错误处理**\n\n组队阶段某个命令报错，执行时整个队列都会被取消。\n\n![组队阶段某个命令报错](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372301056.png)\n\n如果执行阶段某个命令报错，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。（不保证事务的原子性）\n\n![执行阶段某个命令报错](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372359361.png)\n\n**为什么 Redis 不支持回滚来保证原子性**\n\nRedis 命令只会因为错误的语法而失败，然而没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。\n\n### Redis 锁\n\n#### 悲观锁\n\n**悲观锁(Pessimistic Lock)**， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。**传统的关系型数据库里边就用到了很多这种锁机制**，比如**行锁**，**表锁**等，**读锁**，**写锁**等，都是在做操作之前先上锁。\n\n![悲观锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417157625.png)\n\n> 线程 1 拿到账户后把账户锁住，然后操作，这时候线程 2 也想拿账户，发现加了锁拿不到，只能阻塞等到锁释放。\n\n#### 乐观锁\n\n**乐观锁(Optimistic Lock)，** 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在**更新的时候判断**一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**。Redis 就是利用这种机制实现事务的。\n\n![乐观锁](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417222072.png)\n\n> 给账户数据加一个版本号，假如线程 1、2 都拿到账户，线程 1 使用账户前先进行版本号比较，v1.0 = v1.0，则扣减账户余额，账户版本号变更为 v1.1，线程 2 准备操作数据库，发现自己预期的账户版本号 v1.0 和当前账户版本号 v1.1 不同（CAS），则不能操作。 \n\n***\n\n## Redis持久化\n\nRedis 是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题 Redis 供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。\n\n两种持久化方式：快照（RDB 文件）和追加式文件（AOF 文件），下面分别为大家介绍两种方式的原理。\n\n- RDB 持久化方式会在一个特定的间隔保存那个时间点的数据快照。\n\n- AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。\n\n- 两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。\n\n### RDB(Redis Database)\n\n> 在满足特定的  Redis 操作条件（时间周期、写操作次数）时，将内存中的数据以 **数据快照** 的形式存储到 db 文件中\n\n#### **工作原理**\n\n> [Redis_RDB持久化之写时复制技术的应用](https://www.cnblogs.com/zyf98/p/15934058.html)\n\nRDB 是一次的全量备份，即周期性的把 Redis 当前内存中的全量数据写入到一个快照文件中。Redis 是单线程程序，这个线程要同时负责多个客户端的读写请求，还要负责周期性的把当前内存中的数据写到快照文件中 RDB 中，那么就会带来以下两个问题：\n\n1. 数据写到 RDB 文件是 IO 操作，IO 操作会严重影响 Redis 的性能，甚至在持久化的过程中，读写请求会阻塞\n2. 假如 Redis 正在进行持久化一个大的数据结构，在这个过程中客户端发送一个删除请求，把这个大的数据结构删掉了，这时候持久化的动作还没有完成。\n\n于是 Redis 使用操作系统的多进程 **写时复制(Copy On Write)机制** 来实现快照的持久化，在持久化过程中调用**glibc**(Linux 下的 C 函数库)的函数 **fork()** 产生一个子进程，该子进程和父进程共享内存里面的代码段和数据段，快照持久化完全交给子进程来处理，父进程继续处理客户端的读写请求。\n\n> 子进程将数据写入到一个临时 RDB 文件中。当子进程完成持久化时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。\n\n在子进程持久化的过程中，如果主进程收到的客户端的读写请求，需要修改某块数据，那么这块数据就会被复制一份到内存，生成该数据的副本，主进程在该副本上进行修改操作。所以即使对某个数据进行了修改，Redis 持久化到 RDB 中的数据也是未修改的数据，这也是把 RDB 文件称为\"快照\"文件的原因，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。这里再深入一点，Redis 内存中的全量数据由一个个的\"数据段页面\"组成，每个数据段页面的大小为 4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中，这个复制的过程称为\"页面分离\"，在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的 2 倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分 Redis 数据还是\"冷数据\"。\n\n正因为修改的部分数据会被额外的复制一份，所以会占用额外的内存，当在进行 RDB 持久化操作的过程中，与此同时如果持续往 Redis 中写入的数据量越多，就会导致占用的额外内存消耗越大。\n\n![RDB 持久化](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2093494-20220226233822789-2067752089.png)\n\n**优点**：\n\n1. RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；\n2. RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；\n3. RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；\n4. 与 AOF 格式的文件相比，RDB 文件可以更快的重启。\n\n**缺点**：\n\n1. 因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。\n2. RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。\n\n### AOF(Append Only File)\n\n以日志的形式来记录每个写的操作，将 Redis 执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\n\n#### **AOF配置项**\n\n```\n# 默认不开启aof  而是使用rdb的方式\nappendonly no\n\n# 默认文件名\nappendfilename \"appendonly.aof\"\n\n# 每次修改都会sync 消耗性能\n# appendfsync always\n# 每秒执行一次 sync 可能会丢失这一秒的数据\nappendfsync everysec\n# 不执行 sync ，这时候操作系统自己同步数据，速度最快\n# appendfsync no \n```\n\nAOF 的整个流程大体来看可以分为两步，第一步是命令的实时写入（如果是 appendfsync everysec 配置，会有 1s 损耗），第二步是对 aof 文件的重写。\n\n#### **AOF 重写机制**\n\n随着 Redis 的运行，AOF 的日志会越来越长，如果实例宕机重启，那么重放整个 AOF 将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr 一千次，那么就不需要去记录这 1000 次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。\n\nRedis 提供了 bgrewriteaof 指令用于对 AOF 日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的 AOF 文件，至此完成。\n\n同样的也可以在 Redis.config 中对重写机制的触发进行配置：\n\n通过将 no-appendfsync-on-rewrite 设置为 yes，开启重写机制；auto-aof-rewrite-percentage 100 意为比上次从写后文件大小增长了 100%再次触发重写；\n\nauto-aof-rewrite-min-size 64mb 意为当文件至少要达到 64mb 才会触发制动重写。\n\n**优点**：\n\n1、数据安全，AOF 是对指令文件进行 **增量更新**，更适合实时性持久化。\n\n2、通过 append 模式写文件，即使中途服务器宕机，可以通过 Redis-check-aof 工具解决数据一致性问题。\n\n3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)\n\n**缺点**：\n\n1、AOF 文件比 RDB 文件大，且恢复速度慢。\n\n2、数据集大的时候，比 RDB 启动效率低。\n\n### RDB与AOF对比\n\nRedis 官方建议同时开启两种持久化策略，AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）\n\n| 比较项     | RDB    | AOF          |\n| ---------- | ------ | ------------ |\n| 启动优先级 | 低     | 高           |\n| 体积       | 小     | 大           |\n| 恢复速度   | 快     | 慢           |\n| 数据安全性 | 丢数据 | 根据策略决定 |\n\n***\n\n## 发布与订阅\n\nRedis 发布与订阅是一种消息通信的模式：发送者（pub）发送消息，订阅者（sub）接收消息。\n\nRedis 通过 PUBLISH 和 SUBSCRIBE 等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是订阅/发布到频道、订阅/发布到模式的客户端。\n\n### 频道（channel）\n\n**订阅**\n\n![频道订阅](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436261125.png)\n\n**发布**\n\n![频道发布](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436267143.png)\n\n#### **完整流程**\n\n发布者向频道 channel:1 发布消息 hi\n\n```\n127.0.0.1:6379> publish channel:1 hi(integer) 1\n```\n\n订阅者订阅消息\n\n```\n127.0.0.1:6379> subscribe channel:1\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\" // 消息类型\n2) \"channel:1\" // 频道\n3) \"hi\" // 消息内容\n```\n\n执行 subscribe 后客户端会进入订阅状态，仅可以使 subscribe、unsubscribe、psubscribe 和 punsubscribe 这四个属于\"发布/订阅\"之外的命令\n\n订阅频道后的客户端可能会收到三种消息类型\n\n- subscribe：表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。\n\n- message：表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。\n\n- unsubscribe：表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为 0 时客户端会退出订阅状态，之后就可以执行其他非\"发布/订阅\"模式的命令了。\n\n\n\n#### **数据结构**\n\n基于 channel 的发布订阅模式是通过字典数据类型实现的\n\n> 类似hashmap，键为channel，值为订阅了该channel的client，用链表链接起来\n\n其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。\n\n![频道模式数据结构模型](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420774862.png)\n\n**订阅**\n\n当使用 subscribe 订阅时，在字典中找到频道 key（如没有则创建），并将订阅的 client 关联在链表后面。\n\n当 client 10 执行 `subscribe channel1 channel2 channel3` 时，会将 client 10 分别加到 channel1 channel2 channel3 关联的链表尾部。\n\n![频道订阅](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420784179.png)\n\n**发布**\n\n发布时，根据 key，找到字典汇总 key 的地址，然后将 msg 发送到关联的链表每一台机器。\n\n**退订**\n\n遍历关联的链表，将指定的地址删除即可。\n\n\n\n### 模式（pattern）\n\npattern 使用了通配符的方式来订阅\n\n通配符中 ? 表示 1 个占位符，\\* 表示任意个占位符(包括 0)，?* 表示 1 个以上占位符。\n\n所以当使用 publish 命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个/某些模式和这个频道匹配的话， 那么所有订阅这个/这些频道的客户端也同样会收到信息。\n\n![模式](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420803487.png)\n\n#### **订阅发布完整流程**\n\n发布者发布消息\n\n```\n127.0.0.1:6379> publish b m1\n(integer) 1\n127.0.0.1:6379> publish b1 m1\n(integer) 1\n127.0.0.1:6379> publish b11 m1\n(integer) 1\n```\n\n订阅者订阅消息\n\n```\n127.0.0.1:6379> psubscribe b*\nReading messages... (press Ctrl-C to quit)\n1) \"psubscribe\"\n2) \"b*\"\n3) (integer) 3\n1) \"pmessage\"\n2) \"b*\"\n3) \"b\"\n4) \"m1\"\n1) \"pmessage\"\n2) \"b*\"\n3) \"b1\"\n4) \"m1\"\n1) \"pmessage\"\n2) \"b*\"\n3) \"b11\"\n4) \"m1\"\n```\n\n#### **数据结构**\n\npattern 属性是一个链表，链表中保存着所有和模式相关的信息。\n\n> 类似链表，每个pattern节点，包含pattern以及订阅该pattern的client\n\n数据结构图如下：\n\n![模式数据结构](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420905733.png)\n\n**订阅**\n\n当有信的订阅时，会将订阅的客户端和模式信息添加到链表后面。\n\n![模式订阅](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420913717.png)\n\n**发布**\n\n当发布者发布消息时，首先会发送到对应的频道上，在遍历模式列表，根据 key 匹配模式，匹配成功将消息发给对应的订阅者。\n\n**退订**\n\n使用 punsubscribe，可以将订阅者退订，将改客户端移除出链表。\n\n***\n\n## 主从复制\n\n**什么是主从复制**\n\n在多个 Redis 实例建立起主从关系，当 主 Redis 中的数据发生变化，从 Redis 中的数据也会同步变化\n\n- 通过主从配置可以实现 Redis 数据的备份（从 Redis 就是对 主 Redis 的备份），保证数据安全性\n- 主从库之间采用的是读写分离的方式，读操作：主库、从库都可以接收；写操作：首先到主库执行，然后主库将写操作同步给从库\n\n**主从复制的作用**\n\n- 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。\n\n- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。\n\n- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。\n\n- 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。\n\n主从库采用的是读写分离的方式：\n\n![主从库读写分离](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420963646.png) \n\n### 原理\n\n分为全量复制与增量复制\n\n全量复制：发生在第一次复制时\n\n增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库\n\n### 全量复制的三个阶段\n\n![全量复制](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNoteskjk7gr48ft.jpeg)\n\n第一阶段是主从库间建立连接、协商同步的过程。\n\n> 主要是为全量复制做准备。从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。\n>\n> 具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。\n\n第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。\n\n> 具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。\n\n第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。\n\n> 具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。\n\n### 断网增量更新\n\n当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。\n\n![断网增量更新](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesg0eezljwqy.jpeg)\n\n## 哨兵机制\n\n> 哨兵的核心功能是主节点的自动故障转移\n>\n> 1. 监控 主库，判断 主库 是否宕机\n> 2. 主库 如果宕机，则从 从库 中 选举成为 主库（因此需要奇数个哨兵）\n> 3. 更改主从配置\n\n下图是一个典型的哨兵集群监控的逻辑图：\n\n![哨兵机制](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420977306.png)\n\n![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n \n\nRedis Sentinel 包含了若个 Sentinel 节点，这样做也带来了两个好处：\n\n1. 对于节点的故障判断是由多个 Sentinel 节点共同完成，这样可以有效地防止误判\n2. 即使个别 Sentinel 节点不可用，整个 Sentinel 集群依然是可用的。\n\n哨兵实现了以下功能\n\n1. 监控：每个 Sentinel 节点会对数据节点（Redis master/slave 节点）和其余 Sentinel 节点进行监控\n2. 通知：Sentinel 节点会将故障转移的结果通知给应用方\n3. 故障转移：实现 slave 晋升为 master，并维护后续正确的主从关系\n4. 配置中心：在 Redis Sentinel 模式中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息\n\n其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置中心和通知功能，则需要在与客户端的交互中才能体现。\n\n### 监控\n\nSentinel 节点需要监控 master、slave 以及其它 Sentinel 节点的状态。这一过程是通过 Redis 的 pub/sub 系统实现的。Redis Sentinel 一共有三个定时监控任务，完成对各个节点发现和监控：\n\n1. 监控主从拓扑信息：每隔 10 秒，每个 Sentinel 节点，会向 master 和 slave 发送 INFO 命令获取最新的拓扑结构\n2. Sentinel 节点信息交换：每隔 2 秒，每个 Sentinel 节点，会向 Redis 数据节点的`sentinel:hello` 频道上，发送自身的信息，以及对主节点的判断信息。这样，Sentinel 节点之间就可以交换信息\n3. 节点状态监控：每隔 1 秒，每个 Sentinel 节点，会向 master、slave、其余 Sentinel 节点发送 PING 命令做心跳检测，来确认这些节点当前是否可达\n\n### 主观/客观下线\n\n#### 主观下线\n\n每个 Sentinel 节点，每隔 1 秒会对数据节点发送 ping 命令做心跳检测，当这些节点超过 down-after-milliseconds 没有进行有效回复时，Sentinel 节点会对该节点做失败判定，这个行为叫做主观下线。\n\n#### 客观下线\n\n客观下线，是指当大多数 Sentinel 节点，都认为 master 节点宕机了，那么这个判定就是客观的，叫做客观下线。\n\n那么这个大多数是指多少呢？这其实就是分布式协调中的 quorum 判定了，大多数就是过半数，比如哨兵数量是 5，那么大多数就是 5/2+1=3 个，哨兵数量是 10 大多数就是 10/2+1=6 个。\n\n注：Sentinel 节点的数量至少为 3 个，否则不满足 quorum 判定条件。\n\n### 哨兵选举\n\n如果发生了客观下线，那么哨兵节点会选举出一个 Leader 来进行实际的故障转移工作。Redis 使用了 Raft 算法来实现哨兵领导者选举，大致思路如下：\n\n1. 每个 Sentinel 节点都有资格成为领导者，当它主观认为某个数据节点宕机后，会向其他 Sentinel 节点发送 sentinel is-master-down-by-addr 命令，要求自己成为领导者；\n2. 收到命令的 Sentinel 节点，如果没有同意过其他 Sentinel 节点的 sentinelis-master-down-by-addr 命令，将同意该请求，否则拒绝（每个 Sentinel 节点只有 1 票）；\n3. 如果该 Sentinel 节点发现自己的票数已经大于等于 MAX(quorum, num(sentinels)/2+1)，那么它将成为领导者；\n4. 如果此过程没有选举出领导者，将进入下一次选举。\n\n### **故障转移**\n\n选举出的 Leader Sentinel 节点将负责故障转移，也就是进行 master/slave 节点的主从切换。故障转移，首先要从 slave 节点中筛选出一个作为新的 master，主要考虑以下 slave 信息：\n\n1. 跟 master 断开连接的时长：如果一个 slave 跟 master 的断开连接时长已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么该 slave 就被认为不适合选举为 master；\n2. slave 的优先级配置：slave priority 参数值越小，优先级就越高；\n3. 复制 offset：当优先级相同时，哪个 slave 复制了越多的数据（offset 越靠后），优先级越高；\n4. run id：如果 offset 和优先级都相同，则哪个 slave 的 run id 越小，优先级越高。\n\n接着，筛选完 slave 后， 会对它执行 slaveof no one 命令，让其成为主节点。\n\n最后，Sentinel 领导者节点会向剩余的 slave 节点发送命令，让它们成为新的 master 节点的从节点，复制规则与 parallel-syncs 参数有关。\n\nSentinel 节点集合会将原来的 master 节点更新为 slave 节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。\n\n注：Leader Sentinel 节点，会从新的 master 节点那里得到一个 configuration epoch，本质是个 version 版本号，每次主从切换的 version 号都必须是唯一的。其他的哨兵都是根据 version 来更新自己的 master 配置。\n\n## 集群配置\n\n> 高可用：保证 Redis 一直处于可用状态，即使出现了故障也有备用方案保证可用性\n>\n> 高并发：一个 Redis 实例已经可以支持多达 11w并发读操作或 8.1w并发写操作；但是如果有更高并发需求的应用来说，可以通过 读写分离、集群配置 来解决高并发问题\n\n- Redis 集群中每个节点是对等的，无中心结构\n- 数据按照 slots 分布式存储在不同的 Redis 节点上，节点中的数据可共享，可以动态调整数据分布\n- 可扩展性强，可以动态增删节点，最多可扩展至 1000+ 节点\n- 集群的每个节点通过 `主从（哨兵模式）`保证其高可用性\n- Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作\n- Redis 集群之间是如何复制的？异步复制\n\n> [Redis_数据分布算法：传统哈希-一致性哈希-哈希slot](https://blog.csdn.net/qq_43846090/article/details/123721066)\n\n### 传统哈希\n\n最简单的数据分布算法，对进来的 key 进行 hash，然后对节点数据进行取模，就知道分布到哪个节点上了；\n缺点就是: 如果一个节点宕机，所有缓存的位置都要发生改变，当服务器数量发生改变时，所有缓存在一定时间内是失效的，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）\n\n### 一致性哈希\n\n实际上就是引入了一个圆环的概念， 让每个数据的 hash 分布到整个圆环，然后顺时针去找离他最近的节点存储\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525022243.png\" alt=\"一致性哈希\" style=\"zoom: 50%;\" />\n\nhash 算法的取模法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，\ndubbo 的复杂均衡有用到该算法；\n\n好处:\n\n使用 hash 算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了；\n而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效。上图中如果节点 A 失效，则 C → A 之间的数据会重新缓存到节点 B 上。\n\nhash 环偏斜：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525154544.png\" alt=\"hash 环偏斜\" style=\"zoom: 50%;\" />\n\n1 号、2 号、3 号、4 号、6 号数据均被缓存在了服务器 A 上；只有 5 号被缓存在了服务器 B 上；服务器 C 上甚至没有缓存任何图片\n如果出现上图中的情况，A、B、C 三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器 A 出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃；\n\n上图中的情况则被称之为 hash 环的偏斜 ；\n我们应该怎样防止 hash 环的偏斜？\n增加虚拟节点：\n\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525203417.png\" alt=\"增加虚拟节点防止 hash 环的偏斜\" style=\"zoom:50%;\" />\n\n为了解决这个数据负载均衡的问题，搞出来虚拟节点，把真实节点搞一堆虚拟节点分布到环，那么整个区间的数据会落到这些虚拟节点上；\n\n虚拟节点越多，hash 环上的节点就越多，缓存被均匀分布的概率就越大。\n\n### 哈希槽\n\nRedis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。\n\n首先哈希槽其实是两个概念，第一个是哈希算法。Redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 Redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。\n\nRedis cluster 包含了 16384 个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。\n\n**为什么哈希槽的大小是固定的16384？**\n\n> `CRC16`算法产生的hash值有16bit，该算法可以产生2^16-=65536个值。换句话说，值是分布在0~65535之间。那作者在做`mod`运算的时候，为什么不`mod`65536，而选择`mod`16384？\n\n**不能太大，主要从节点间的通信性能方面考虑：**\n\n每个节点之间是需要进行一个通信的，也就是不断地 pingpong 机制，让每个节点连接对方的信息；发送的消息头中有一个 bitmap，其中每一位代表一个槽，如果该位为 1，表示这个槽是属于当前节点，如果槽位过大，那么这个 bitmap 就会太大，心跳包过于庞大，浪费带宽。\n\n**不能太小，主要从压缩率方面考虑：**\n\n由于 bitmap 在传输过程中会进行压缩，bitmap 的填充率用 slots/N 表示（N 即节点数），对于同样的 slots，如果 N 太小，导致其填充率过高，压缩率就很低。\n\n***\n\n## 缓存穿透、击穿、雪崩\n\n### 缓存穿透\n\n**问题来源**\n\n缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，每次都去 DB 判断然而又不能复制到 Redis 中，这就是漏洞。\n\n例如发起为 id 为“-1”的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。\n\n**解决方案**\n\n1. **接口校验**：接口层增加校验，例如对 id<=0 的直接拦截。\n\n2. **缓存空值**：从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 10 秒（设置太长会导致正常情况也没法使用）。\n\n3. **布隆过滤器**：布隆过滤器用于快速判某个元素是否存在于集合中，由一个很长的二进制向量（位图）和一系列哈希函数两部分组成。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的错误识别率，添加到集合中的元素越多，误报的可能性就越大。\n\n\t位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。\n\n\t> [布隆过滤器](https://javaguide.cn/cs-basics/data-structure/bloom-filter.html)\n\t>\n\t> [缓存穿透-布隆过滤器](https://javaguide.cn/database/Redis/Redis-questions-01.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F)\n\n\t具体而言：\n\n\t把 **所有可能存在的请求的值** 都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。布隆过滤器判断不存在的话，则肯定不存在，布隆过滤器判断存在，则进一步查 Redis，Redis 中存在则返回，Redis 中不存在则查数据库。\n\n\t为什么布隆过滤器会出现误判的情况呢? \n\n\t**当一个元素加入布隆过滤器中的时候，会进行以下操作：**\n\n\t1. 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。\n\n\t\t> hashVal1 = hashMethod1(key)， hashVal2= hashMethod2(key)...\n\n\t2. 根据得到的哈希值，在位数组中把对应下标的值置为 1。\n\n\t\t> 把位数组中的 hashVal1 和 hashVal2 处置为 1\n\n\t**当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行以下操作：**\n\n\t1. 对给定元素再次进行相同的哈希计算；\n\n\t\t> hashVal1 = hashMethod1(key)， hashVal2= hashMethod2(key)...\n\n\t2. 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。\n\n\t\t> 判断位数组中的 hashVal1 和 hashVal2 处是否全部为 1，全部为 1说明当前元素存在于位数组中。\n\n\t然而会出现这样一种情况：**不同的字符串可能哈希出来的位置相同。** （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n\n\t> **⭐例如**：val1 经过两次hash得到下标 1， 3，将1、3处置为1，val2经过两次hash得到下标2、4，将2、4处置为1，对于新元素val3经过两次hash得到下标1、2，判断这两个位置都为1，误判以为val3存在，实际上不存在。\n\n\n### 缓存击穿\n\n**问题来源**\n\n缓存击穿是指一个热点的 key，有大并发集中对其进行访问，突然间这个 key 失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。\n\n**解决方案**\n\n> 热点key失效 → 打到数据库上，因此可以从这两方面进行解决\n\n1、设置热点数据永远不过期。\n\n2、接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。\n\n3、加互斥锁：如果缓存失效的情况，只有拿到锁才可以查询数据库，分布式场景下可以使用分布式锁。\n\n### 缓存雪崩\n\n**问题来源**\n\n缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是指很多不同的数据都过期了，都查不到从而查数据库。\n\n**解决方案**\n\n1. **缓存数据的过期时间设置随机**，防止同一时间大量数据过期现象发生。\n2. 设置热点数据永远不过期。\n3. 在即将发生大并发访问之前，进行**缓存预热**将可能大量访问的数据加载到缓存。\n4. 接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。\n5. 为了防止 Redis 宕机导致缓存雪崩的问题，可以**搭建Redis集群**，提高 Redis 的容灾性。\n6. 提高数据库的容灾能力，可以使用**数据库分库分表**，读写分离的策略。\n\n## Redis 淘汰策略\n\n### Redis 内存淘汰策略\n\n> Redis 是基于内存结构进行数据缓存的，当内存资源消耗完毕，当将要有新的数据缓存进来时，为了腾出空间放新的数据，需要将内存中的一些数据释放掉，这种释放数据的策略称为 Redis 的淘汰策略。\n\nLRU：Least Recently Used\n\nLFU：Least Frequently Used\n\nLRU 淘汰的是最久未访问到的数据，而 LFU 是淘汰的是最不经常使用的数据（若两个或多个数据的使用频率相同时，LFU 会再选择最久未访问到的数据淘汰）。\n\n```conf\n# volatile-lru -> 在设置了过期时间的数据中使用 LRU\n# allkeys-lru -> 在所有数据中使用 LRU\n# volatile-lfu -> 在设置了过期时间的数据中使用 LFU\n# allkeys-lfu -> 在所有数据中使用 LFU\n# volatile-random -> 在设置了过期时间的数据中随机淘汰\n# allkeys-random -> 在所有数据中随机淘汰\n# volatile-ttl -> 越早过期的数据 越先被淘汰\n# noeviction -> 不淘汰任何数据，当内存不够时直接抛出异常\n```\n\n### Redis 缓存失效策略\n\n**定时过期策略**\n\n每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，有效地减少了因为过期键带来的内存浪费；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。\n\n**惰性过期策略**\n\n只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。\n\n**定期过期策略**\n\n每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。\n\n**Redis中同时使用了定期过期和惰性过期两种过期策略。**\n\n所谓定期删除，指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。\n\n**假设 Redis 里放了 10w 个 key，都设置了过期时间，**你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。**注意，**这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。\n\n**但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？**所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。\n\n**获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。**但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存快耗尽了，咋整？**答案是：走内存淘汰机制。**\n\n***\n\n## Redis分布式并发问题\n\n> 单体项目中，购物车下单可以使用 synchronized 关键字锁住实例对象，只让一个线程下单并扣减库存\n>\n> 而对于集群而言，在每台服务器上锁住实例对象，但是每台之间是无法感知的，仍然可能存在商品超卖问题\n\n### 使用 Redis 实现分布式锁\n\n```java\n@Transactional\n@Override\npublic Map<String, String> addOrder(String cids, Orders orders) {\n    log.info(\"add order begin...\");\n\n    Map<String, String> map = new HashMap<>();\n\n    // 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）\n    String[] arr = cids.split(\"，\");\n    List<Integer> cidsList = new ArrayList<>();\n    for (String s : arr) {\n        cidsList.add(Integer.parseInt(s));\n    }\n    // 获取所有skuId\n    List<ShoppingCartVO> list1 = shoppingCartMapper.selectShopCartByCids(cidsList);\n\n    boolean allLocked = true;\n    List<String> lockedSkuIds = new ArrayList<>();\n    Map<String, String> values = new HashMap<>();\n    for (ShoppingCartVO sc : list1) {\n        String skuId = sc.getSkuId()， value = UUID.randomUUID().toString();\n        Boolean thisLocked = srt.boundValueOps(sc.getSkuId()).setIfAbsent(value, 10, TimeUnit.SECONDS);\n        if (!thisLocked) {   // 返回 false 说明之前有该数据，即有线程在操作这个 商品库存\n            allLocked = false;  // 因此这个sku就没有锁住，不能继续操作\n            break;\n        } else {\n            lockedSkuIds.add(skuId);\n            values.put(skuId, value);\n        }\n    }\n    if (allLocked) {\n        // 2、校验库存\n        List<ShoppingCartVO> list = shoppingCartMapper.selectShopCartByCids(cidsList);\n        boolean f = true;\n        StringBuilder sb = new StringBuilder();\n        for (ShoppingCartVO sc : list) {\n            if (Integer.parseInt(sc.getCartNum()) > sc.getSkuStock()) {\n                f = false;\n            }\n            //获取所有商品的名称，以逗号拼接成字符串\n            sb.append(sc.getProductName()).append(\"，\");\n        }\n        String untitled = sb.toString();\n\n        if (f) {\n            log.info(\"product stock is ok ... \");\n            // 3、表示库存充足----保存订单\n            // a.userId   b.untitled  c.收货人信息：姓名、电话、地址\n            // d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态\n            orders.setUntitled(untitled);\n            orders.setCreateTime(new Date());\n            orders.setStatus(\"1\");\n\n            // 生成订单编号\n            String orderId = UUID.randomUUID().toString().replace(\"-\"， \"\");\n            orders.setOrderId(orderId);\n\n            // 保存订单\n            ordersMapper.insert(orders);\n            // 4、生成商品快照\n            for (ShoppingCartVO sc : list) {\n                int cnum = Integer.parseInt(sc.getCartNum());\n                String itemId = System.currentTimeMillis() + \"\" + (new Random().nextInt(89999) + 10000);\n                OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，\n                                                    sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, new BigDecimal(sc.getSellPrice() * cnum)， new Date()， new Date()， 0);\n                orderItemMapper.insert(orderItem);\n            }\n\n            // 5、扣减库存：根据套餐Id修改套餐库存量\n            for (ShoppingCartVO sc : list) {\n                String skuId = sc.getSkuId();\n                int newStock = sc.getSkuStock() - Integer.parseInt(sc.getCartNum());\n\n                ProductSku productSku = new ProductSku();\n                productSku.setSkuId(skuId);\n                productSku.setStock(newStock);\n                //根据主键来修改属性值\n                productSkuMapper.updateByPrimaryKeySelective(productSku);\n            }\n\n            // 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作\n            for (int cid : cidsList) {\n                shoppingCartMapper.deleteByPrimaryKey(cid);\n            }\n\n            // 释放锁\n            for (String lockedSkuId : lockedSkuIds) {\n                String value = srt.boundValueOps(lockedSkuId).get();\n                if (value != null && value.equals(values.get(lockedSkuId))) {\n                    srt.delete(lockedSkuId);\n                }\n            }\n\n            log.info(\"add order finished... \");\n\n            map.put(\"orderId\"， orderId);\n            map.put(\"productNames\"， untitled);\n            return map;\n        } else {\n            // 表示库存不足\n            return null;\n        }\n    } else {    // 加锁失败\n        // 要将部分锁定的sku释放锁，即从Redis中移除锁住的skuId\n        for (String lockedSkuId : lockedSkuIds) {\n            srt.delete(lockedSkuId);\n        }\n        return null;\n    }\n}\n```\n\n1. 如果订单中部分商品加锁成功，但是由于一些商品加锁失败导致无法提交订单，此时要注意将加锁的商品恢复，即从 Redis 中移除该商品\n\n\t> 在 allLocked == false 中，释放加锁的商品\n\n2. 第一次根据 购物车 Id 查到的购物车记录（包含商品库存）到加锁提交订单之前，可能有别的线程 操作了其中某个商品的库存并操作完了，为了防止当前线程还对之前库存进行修改，应当在加锁后操作前重新查询库存。\n\n3. 当前线程加锁成功之后，在执行添加订单的过程中如果出现了异常导致无法释放锁\n\n\t> 可以在对商品加锁时设置过期时间，则到期自动释放锁\n\n4. 档给锁设置了过期时间之后，如果当前线程 t1 因为特殊原因，在锁过期之前没有完成业务执行，释放掉了锁，此时线程 t2 加锁成功，如果线程 t1 执行结束，将会释放 线程 t2 的锁，导致 线程 t2 在无锁状态\n\n\t> 对于加成功并提交完订单之后，对当前商品的锁释放，要判断 Redis 中的value是否和自己记录的相同，即是否是自己加的锁\n\t>\n\t> ```java\n\t> // 释放锁\n\t> for (String lockedSkuId : lockedSkuIds) {\n\t>    String value = srt.boundValueOps(lockedSkuId).get();\n\t>    if (values.get(lockedSkuId).equals(value)) {\n\t>      \tsrt.delete(lockedSkuId);\n\t>    }\n\t> }\n\t> ```\n\n5. 当前线程 t1 判断是自己加的锁，在准备删除之前，锁过期了并且被其他线程 t2 拿到了成功加锁，这时候线程 t1 会释放掉线程 t2 的锁（并发量很大仍然需要考虑）\n\n\t> 保证 查询锁是否是自己加的和删除自己加的锁 的原子性（使用 lua 脚本，让多个 Redis 操作具有原子性，查询+删除）\n\n6. 使用看门狗线程解决线程 t1 释放相乘 t2 的锁的问题\n\n\t> 线程t1 加锁并设置过期时间，此时启动 看门狗线程（守护线程）监控线程 t1过期时间，过期时间要到了但是线程t1 业务还在执行，则重置过期时间，这样可以保证业务执行完之前不会释放锁\n\n### 分布式锁框架 Resisson\n\n- 添加依赖\n\n\t```xml\n\t<!-- https://mvnrepository.com/artifact/org.redisson/redisson -->\n\t<dependency>\n\t    <groupId>org.redisson</groupId>\n\t    <artifactId>redisson</artifactId>\n\t    <version>3.16.7</version>\n\t</dependency>\n\t```\n\n- 配置 yaml 文件\n\n\t```yaml\n\tredisson:\n\t  addr:\n\t    singleAddr:\n\t      host: Redis://47.110.247.63:6389\n\t      password: FYX123fyx.\n\t      database: 0\n\t```\n\n- 配置 RedissonClient（也可以配置成集群模式、主从模式）\n\n\t```java\n\t@Configuration\n\tpublic class RedissonConfig {\n\t    @Value(\"${redisson.addr.singleAddr.host}\")\n\t    private String host;\n\t\n\t    @Value(\"${redisson.addr.singleAddr.password}\")\n\t    private String password;\n\t\n\t    @Value(\"${redisson.addr.singleAddr.database}\")\n\t    private int database;\n\t\n\t    @Bean\n\t    public RedissonClient redissonClient() {\n\t        Config config = new Config();\n\t        config.useSingleServer().setAddress(host)\n\t                .setPassword(password)\n\t                .setDatabase(database);\n\t        return Redisson.create(config);\n\t    }\n\t}\n\t```\n\n- 操作\n\n\t```java\n\t@Transactional\n\t@Override\n\tpublic Map<String, String> addOrder(String cids, Orders orders) {\n\t    log.info(\"add order begin...\");\n\t\n\t    // 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）\n\t    String[] arr = cids.split(\"，\");\n\t    List<Integer> cidsList = new ArrayList<>();\n\t    for (String s : arr) {\n\t        cidsList.add(Integer.parseInt(s));\n\t    }\n\t    // 获取所有skuId\n\t    List<ShoppingCartVO> list = shoppingCartMapper.selectShopCartByCids(cidsList);\n\t    List<String> lockedSkuIds = new ArrayList<>();\n\t    Map<String, RLock> locks = new HashMap<>(); // {\"1\":lock1, \"2\":lock2}\n\t    boolean allLocked = true;\n\t    for (ShoppingCartVO sc : list) {\n\t        String skuId = sc.getSkuId();\n\t        boolean b = false;\n\t        RLock lock = redissonClient.getLock(skuId);\n\t        try {\n\t            b = lock.tryLock(10, 3, TimeUnit.SECONDS);\n\t        } catch (InterruptedException e) {\n\t            e.printStackTrace();\n\t        }\n\t        if (!b) {\n\t            allLocked = false;\n\t            break;\n\t        } else {\n\t            lockedSkuIds.add(skuId);\n\t            locks.put(skuId, lock);\n\t        }\n\t    }\n\t\n\t    Map<String, String> map = null;\n\t    try {\n\t        if (allLocked) {\n\t            // 2、校验库存\n\t            list = shoppingCartMapper.selectShopCartByCids(cidsList);\n\t            boolean f = true;\n\t            StringBuilder sb = new StringBuilder();\n\t            for (ShoppingCartVO sc : list) {\n\t                if (Integer.parseInt(sc.getCartNum()) > sc.getSkuStock()) {\n\t                    f = false;\n\t                }\n\t                //获取所有商品的名称，以逗号拼接成字符串\n\t                sb.append(sc.getProductName()).append(\"，\");\n\t            }\n\t            String untitled = sb.toString();\n\t\n\t            if (f) {\n\t                log.info(\"product stock is ok ... \");\n\t                // 3、表示库存充足----保存订单\n\t                // a.userId   b.untitled  c.收货人信息：姓名、电话、地址\n\t                // d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态\n\t                orders.setUntitled(untitled);\n\t                orders.setCreateTime(new Date());\n\t                orders.setStatus(\"1\");\n\t\n\t                // 生成订单编号\n\t                String orderId = UUID.randomUUID().toString().replace(\"-\"， \"\");\n\t                orders.setOrderId(orderId);\n\t\n\t                // 保存订单\n\t                ordersMapper.insert(orders);\n\t                // 4、生成商品快照\n\t                for (ShoppingCartVO sc : list) {\n\t                    int cnum = Integer.parseInt(sc.getCartNum());\n\t                    String itemId = System.currentTimeMillis() + \"\" + (new Random().nextInt(89999) + 10000);\n\t                    OrderItem orderItem = new OrderItem(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，\n\t                                                        sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, new BigDecimal(sc.getSellPrice() * cnum)， new Date()， new Date()， 0);\n\t                    orderItemMapper.insert(orderItem);\n\t                }\n\t\n\t                // 5、扣减库存：根据套餐Id修改套餐库存量\n\t                for (ShoppingCartVO sc : list) {\n\t                    String skuId = sc.getSkuId();\n\t                    int newStock = sc.getSkuStock() - Integer.parseInt(sc.getCartNum());\n\t\n\t                    ProductSku productSku = new ProductSku();\n\t                    productSku.setSkuId(skuId);\n\t                    productSku.setStock(newStock);\n\t                    //根据主键来修改属性值\n\t                    productSkuMapper.updateByPrimaryKeySelective(productSku);\n\t                }\n\t\n\t                // 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作\n\t                for (int cid : cidsList) {\n\t                    shoppingCartMapper.deleteByPrimaryKey(cid);\n\t                }\n\t\n\t                log.info(\"add order finished... \");\n\t\n\t                map = new HashMap<>();\n\t                map.put(\"orderId\"， orderId);\n\t                map.put(\"productNames\"， untitled);\n\t\n\t            }\n\t\n\t        }\n\t    } catch (Exception e) {\n\t        e.printStackTrace();\n\t    } finally {\n\t        // 释放锁\n\t        for (String lockedSkuId : lockedSkuIds) {\n\t            locks.get(lockedSkuId).unlock();\n\t        }\n\t    }\n\t    return map;\n\t}\n\t```\n\n### 分布式锁特点\n\n1. 互斥性\n\n\t保证在不同节点间不同线程的互斥（只有一个节点当然可以）\n\n2. 可重入性\n\n\t同一个节点上的同一个线程如果获取锁之后可以再次获取到这个锁\n\n3. 锁超时\n\n\t加锁成功之后设置超时时间，以防止线程故障导致不释放锁而引起死锁\n\n4. 高效、高可用\n\n\t支持单节点 Redis、主从 Redis、集群 Redis\n\n5. 支持阻塞和非阻塞\n\n\ttryLock 非阻塞 和 tryLock(long timeOut) 阻塞\n\n### Redisson 的使用\n\n1. 获取锁（公平锁 / 非公平锁）\n\n\t```java\n\t// 公平锁\n\tRLock lock = redissonClient.getFairLock(skuId);\n\t\n\t// 非公平锁\n\tRLock lock = redissonClient.getLock(skuId);\n\t```\n\n2. 加锁（阻塞锁 / 非阻塞锁）\n\n\t```java\n\t// 阻塞锁，设置加锁成功后的超时时间 20s，不加时间默认 30s\n\tlock.lock(20, TimeUnit.SECONDS);\n\t\n\t// 非阻塞锁（设置等待时间 3s，加锁成功后的超时时间 10s，不加则默认 30s）\n\tlock.tryLock(10, 3, TimeUnit.SECONDS);\n\t```\n\n3. 释放锁\n\n\t```java\n\tlock.unlock();\n\t```\n\n4. 实例\n\n\t```java\n\t// 公平非阻塞锁\n\tRLock lock = redissonClient.getLock(skuId);\n\tlock.tryLock(10, 3, TimeUnit.SECONDS);\n\t```\n\n***\n\n## 缓存与数据库双写一致性\n\n总结：\n\n读数据：先读缓存，如果有直接返回，如果没有查数据库查到数据存到缓存中并返回\n\n写数据：先写数据库，再删缓存，这个阶段可能删缓存失败，可以考虑使用一下三种方案：\n\n1. 如果删除缓存失败，需要将数据写入重试表，然后使用 elastic-job 等定时任务进行重试。\n2. 如果删除缓存失败，需要将数据发送 mq 消息到 mq 服务器，在 mq 的 consumer 中处理。\n3. 订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。\n\n> [如何保证数据库和缓存双写一致性？-苏三说技术](https://www.zhihu.com/question/319817091/answer/2432904728)\n\n### 问题引入\n\n通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526232523.png)\n\n1. 用户请求过来之后，先查缓存有没有数据，如果有则直接返回。\n2. 如果缓存没数据，再继续查数据库。\n3. 如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。\n4. 如果数据库也没数据，则直接返回空。\n\n这是缓存非常常见的用法。一眼看上去，好像没有啥问题。\n\n但你忽略了一个非常重要的细节：**如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？**\n\n不更新缓存行不行？\n\n答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？\n\n那么，我们该如何更新缓存呢？\n\n目前有以下 4 种方案：\n\n1. 先写缓存，再写数据库\n2. 先写数据库，再写缓存\n3. 先删缓存，再写数据库\n4. 先写数据库，再删缓存\n\n接下来，我们详细说说这 4 种方案。\n\n### 先写缓存，再写数据库\n\n对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。\n\n那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？\n\n我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526427819.png)\n\n某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526436447.png)\n\n其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。\n\n我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。\n\n但如果某条数据，在数据库中都不存在，你缓存这种“`假数据`”又有啥意义呢？\n\n因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。\n\n### 先写数据库，再写缓存\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526499487.png)\n\n用户的写操作，先写数据库，再写缓存，可以避免之前“假数据”的问题。但它却带来了新的问题。\n\n#### 写缓存失败了\n\n如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526558901.png)\n\n如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。\n\n但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。\n\n也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。\n\n这就会出现：数据库是`新数据`，而缓存是`旧数据`，两边`数据不一致`的情况。\n\n#### 高并发下的问题\n\n假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a 和 b，它们同时请求到业务系统。\n\n其中请求 a 获取的是旧数据，而请求 b 获取的是新数据，如下图所示：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526645914.png)\n\n1. 请求 a 先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。\n2. 这时候请求 b 过来了，先写了数据库。\n3. 接下来，请求 b 顺利写了缓存。\n4. 此时，请求 a 卡顿结束，也写了缓存。\n\n很显然，在这个过程当中，请求 b 在缓存中的`新数据`，被请求 a 的`旧数据`覆盖了。\n\n也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。\n\n#### 浪费系统资源\n\n有些业务场景比较特殊：`写多读少`。\n\n如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。\n\n还不如不用 Redis，反正写数据库都要写，我读数据又比较少，Redis 使用频率低，却还要一直更新 Redis 中数据。\n\n### 先删缓存，再写数据库\n\n不然是先写缓存还是先写数据库都有很多问题，那么考虑不是 `更新缓存` 而是 `删除缓存`。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526855730.png)\n\n在用户的写操作中，先执行删除缓存操作，再去写数据库\n\n#### 高并发下的问题\n\n假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求 c，还有另一个写数据请求 d（一个更新操作），同时请求到业务系统。如下图所示：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650527043982.png)\n\n1. 请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。\n2. 这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。\n3. 请求 c 将数据库中的旧值，更新到缓存中。\n4. 此时，请求 d 卡顿结束，把新值写入数据库。\n\n在这个过程当中，请求 d 的新值并没有被请求 c 写入缓存，同样会导致缓存和数据库的数据不一致的情况。\n\n#### 缓存双删\n\n在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。\n\n有人说还不好办，请求 d 在写完数据库之后，把缓存重新删一次不就行了？\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528097218.png)\n\n这就是我们所说的`缓存双删`，即在写数据库之前删除一次，写完数据库后，再删除一次。\n\n该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的`时间间隔`之后。\n\n我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：\n\n1. 请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。\n2. 这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。\n3. 请求 c 将数据库中的旧值，更新到缓存中。\n4. 此时，请求 d 卡顿结束，把新值写入数据库。\n5. 一段时间之后，比如：500ms，请求 d 将缓存删除。\n\n这样来看确实可以解决缓存不一致问题。\n\n那么，为什么一定要间隔一段时间之后，才能删除缓存呢？\n\n请求 d 卡顿结束，把新值写入数据库后，请求 c 将数据库中的旧值，更新到缓存中。\n\n此时，如果请求 d 删除太快，在请求 c 将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求 c 更新缓存之后，再删除缓存，才能把旧值及时删除了。\n\n所以需要在请求 d 中加一个时间间隔，确保请求 c，或者类似于请求 c 的其他请求，如果在缓存中设置了旧值，最终都能够被请求 d 删除掉。\n\n接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？\n\n### 先写数据库，再删缓存\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528137396.png)\n\n在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：\n\n1. 请求 e 先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。\n2. 请求 f 查询缓存，发现缓存中有数据，直接返回该数据。\n3. 请求 e 删除缓存。\n\n在这个过程中，只有请求 f 读了一次旧数据，后来旧数据被请求 e 及时删除了，看起来问题不大。\n\n但如果是读数据请求先过来呢？\n\n1. 请求 f 查询缓存，发现缓存中有数据，直接返回该数据。\n2. 请求 e 先写数据库。\n3. 请求 e 删除缓存。\n\n这种情况看起来也没问题呀？\n\n答：对的。\n\n但就怕出现下面这种情况，即缓存自己失效了。如下图所示：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528267733.png)\n\n1. 缓存过期时间到了，自动失效。\n2. 请求 f 查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。\n3. 请求 e 先写数据库，接着删除了缓存。\n4. 请求 f 更新旧值到缓存中。\n\n这时，缓存和数据库的数据同样出现不一致的情况了。\n\n但这种情况还是比较少的，需要同时满足以下条件才可以：\n\n1. 缓存刚好自动失效。\n2. 请求 f 从数据库查出旧值，更新缓存的耗时，比请求 e 写数据库，并且删除缓存的还长。\n\n我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。\n\n由此可见，系统同时满足上述两个条件的概率非常小。\n\n> 推荐大家使用先写数据库，再删缓存的方案，虽说不能100%避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。\n\n但在该方案中，如果删除缓存失败了该怎么办呢？\n\n### 删缓存失败怎么办？\n\n其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。\n\n那么，删除缓存失败怎么办呢？\n\n答：需要加`重试机制`。\n\n在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试 3 次。如果其中有任何一次成功，则直接返回成功。如果 3 次都失败了，则写入数据库，准备后续再处理。\n\n当然，如果你在接口中直接`同步重试`，该接口并发量比较高的时候，可能有点影响接口性能。\n\n这时，就需要改成`异步重试`了。\n\n异步重试方式有很多种，比如：\n\n1. 每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统 OOM 问题，不太建议使用。\n2. 将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。\n3. 将重试数据写表，然后使用 elastic-job 等定时任务进行重试。\n4. 将重试的请求写入 mq 等消息中间件中，在 mq 的 consumer 中处理。\n5. 订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。\n\n#### 定时任务\n\n使用`定时任务重试`的具体方案如下：\n\n1. 当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：\n\n\t![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528474531.png)\n\n2. 在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为 0。然后重试 5 次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。\n\n\t![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528480542.png)\n\n3. 在高并发场景中，定时任务推荐使用`elastic-job`。相对于 xxl-job 等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7 秒等。\n\n使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。\n\n但它有一个很大的优点，即数据是落库的，不会丢数据。\n\n#### mq\n\n在高并发的业务场景中，mq（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。\n\nmq 的生产者，生产了消息之后，通过指定的 topic 发送到 mq 服务器。然后 mq 的消费者，订阅该 topic 的消息，读取消息数据之后，做业务逻辑处理。\n\n使用`mq重试`的具体方案如下：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528506474.png)\n\n1. 当用户操作写完数据库，但删除缓存失败了，产生一条 mq 消息，发送给 mq 服务器。\n2. mq 消费者读取 mq 消息，重试 5 次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则写入`死信队列`中。\n3. 推荐 mq 使用`rocketmq`，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。\n\n当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送 mq 消息，到 mq 服务器，然后有 mq 消费者全权负责删除缓存的任务。\n\n因为 mq 的实时性还是比较高的，因此改良后的方案也是一种不错的选择。\n\n#### binlog\n\n前面我们聊过的，无论是定时任务，还是 mq（消息队列），做重试机制，对业务都有一定的侵入性。\n\n在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。\n\n而使用 mq 的方案中，如果删除缓存失败了，需要在业务代码中发送 mq 消息到 mq 服务器。\n\n其实，还有一种更优雅的实现，即`监听binlog`，比如使用：`canal`等中间件。\n\n具体方案如下：\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528533430.png)\n\n1. 在业务接口中写数据库之后，就不管了，直接返回成功。\n2. mysql 服务器会自动把变更的数据写入 binlog 中。\n3. binlog 订阅者获取变更的数据，然后删除缓存。\n\n这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在 binlog 订阅者中做缓存删除工作。\n\n但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。\n\n如何解决这个问题呢？\n\n答：这就需要加上前面聊过的`重试机制`了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入 mq，让 mq 自动重试。\n\n在这里推荐使用`mq自动重试机制`。\n\n![图片](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528538202.png)\n\n在 binlog 订阅者中如果删除缓存失败，则发送一条 mq 消息到 mq 服务器，在 mq 消费者中自动重试 5 次。如果有任意一次成功，则直接返回成功。如果重试 5 次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。\n\n***\n\n## Redis 线程模型\n\n### 单线程的Redis为什么这么快\n\n1. 纯内存操作\n\n2. 单线程操作，避免了频繁的上下文切换\n\n3. 采用了非阻塞 I/O 多路复用机制\n\n### Redis 为什么是单线程的\n\n官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。\n\n既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦）。Redis 利用队列将并发访问变为串行访问\n\n1、绝大部分请求是纯粹的内存操作（非常快速）\n\n2、采用单线程，避免了不必要的上下文切换和竞争条件\n\n3、非阻塞 IO 优点：\n\n- 速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)\n- 支持丰富数据类型，支持 string，list，set，sorted set，hash\n- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行\n- 丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除如何解决 Redis 的并发竞争 key 问题\n\n**同时有多个子系统去set一个key。这个时候要注意什么呢？**\n\n不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 Redis-server 上。因此，Redis 的事务机制，十分鸡肋。\n\n- 如果对这个 key 操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可\n- 如果对这个 key 操作，要求顺序：分布式锁+时间戳。假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。\n- 利用队列，将 set 方法变成串行访问也可以 Redis 遇到高并发，如果保证读写 key 的一致性\n\n对 Redis 的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题,Redis 内部已经帮你处理好并发的问题了。\n\n### 为什么Redis的操作是原子性的，怎么保证原子性的？\n\n对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。\n\nRedis 的操作之所以是原子性的，是因为 Redis 是单线程的。（Redis 新版本已经引入多线程，这里基于旧版本的 Redis）\n\nRedis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操作的原子性。\n\n多个命令在并发中也是原子性的吗？\n\n不一定， 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用 Redis+Lua 的方式实现.\n\n### 讲解下Redis线程模型\n\n文件事件处理器包括分别是套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。\n\n当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。\n\nI/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。\n\n**工作原理：**\n\nI/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。\n\n尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：\n\n当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。\n\n## 其他参考\n\n[原创 一洺 [阿里开发者](javascript:void(0);) 2022-03-24 08:00](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247507942&idx=1&sn=e00fd16ec56d0e10cc830678ee25c417&chksm=e92ae2e9de5d6bff6d227646c12685a5c45a4c3322e2186954555a14ebcd9510e8ae579a4941&mpshare=1&scene=24&srcid=0324gng7YtX5XX0z9bf7aObR&sharer_sharetime=1648080975816&sharer_shareid=ebfad4e5798246e3d3928c1f4ee9048e#rd)\n\nhttps://blog.csdn.net/qq_31387317/category_7391502.html\n","slug":"Java八股文-Redis","published":1,"updated":"2023-01-29T11:45:09.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw3280013t9t889q7blhp","content":"<blockquote>\n<p>整理的 Redis 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～\t<span id=\"more\"></span></p>\n</blockquote>\n<h2 id=\"什么是NoSQL？\"><a href=\"#什么是NoSQL？\" class=\"headerlink\" title=\"什么是NoSQL？\"></a>什么是NoSQL？</h2><p>NoSQL &#x3D; not only sql（不仅仅是 SQL）</p>\n<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>\n<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>\n<p>NoSQL 泛指非关系型数据库，随着 web2.0 互联网的诞生，传统的关系型数据库很难对付 web2.0 大数据时代。尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL 在当今大数据环境下发展的十分迅速，Redis 是发展最快的。</p>\n<p>传统 RDBMS（关系数据库管理系统）和 NoSQL（非关系型数据库）比较：</p>\n<p>RDBMS：</p>\n<ul>\n<li>组织化结构</li>\n<li>固定 SQL</li>\n<li>数据和关系都存在单独的表中（行列）</li>\n<li>DML（数据操作语言）、DDL（数据定义语言）等</li>\n<li>严格的一致性（ACID）：原子性、一致性、隔离性、持久性</li>\n<li>基础的事务</li>\n</ul>\n<p>NoSQL：</p>\n<ul>\n<li>不仅仅是数据</li>\n<li>没有固定查询语言</li>\n<li>键值对存储（Redis）、列存储（HBase）、文档存储（MongoDB）、图形数据库（不是存图形，放的是关系）（Neo4j）</li>\n<li>最终一致性（BASE）：基本可用、软状态&#x2F;柔性事务、最终一致性</li>\n</ul>\n<hr>\n<h2 id=\"Redis是什么？\"><a href=\"#Redis是什么？\" class=\"headerlink\" title=\"Redis是什么？\"></a>Redis是什么？</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>Redis &#x3D; Remote Dictionary Server，即远程字典服务。</p>\n<p>Redis 是一个用 C 语言开发的、基于内存结构进行<strong>键值对</strong>数据存储的、高性能的、非关系型 NoSQL 数据库</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p><strong>纯内存操作，性能非常出色</strong>，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。支持保存多种数据结构，可以用来实现很多有用的功能。</p>\n<p>Redis 的主要缺点是<strong>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写</strong>，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<h3 id=\"为什么要用缓存\"><a href=\"#为什么要用缓存\" class=\"headerlink\" title=\"为什么要用缓存\"></a>为什么要用缓存</h3><p><strong>1、 高性能：</strong></p>\n<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。</p>\n<p><strong>2、高并发：</strong></p>\n<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，缓解数据库压力。</p>\n<h3 id=\"Redis-与-Memcached-相比有哪些优势\"><a href=\"#Redis-与-Memcached-相比有哪些优势\" class=\"headerlink\" title=\"Redis 与 Memcached 相比有哪些优势\"></a>Redis 与 Memcached 相比有哪些优势</h3><p>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</p>\n<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</p>\n<p>Redis 使用单线程的多路 IO 复用模型；Memcached 是多线程，非阻塞 IO 复用的网络模型。</p>\n<hr>\n<h2 id=\"Redis五大基本类型\"><a href=\"#Redis五大基本类型\" class=\"headerlink\" title=\"Redis五大基本类型\"></a>Redis五大基本类型</h2><p><a href=\"https://www.redis.net.cn/order/\">Redis 命令大全</a></p>\n<p><a href=\"https://juejin.cn/post/6857667542652190728\">Redis 应用场景</a></p>\n<h3 id=\"String（字符串）\"><a href=\"#String（字符串）\" class=\"headerlink\" title=\"String（字符串）\"></a>String（字符串）</h3><blockquote>\n<ol>\n<li><p>String 类型是 Redis 的最基础的数据结构，也是最经常使用到的类型。而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以 String 类型是 Redis 的基础。</p>\n</li>\n<li><p>String 类型的值最大能存储 512MB，这里的 String 类型可以是简单字符串、  复杂的 xml&#x2F;json 的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串。</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>应用场景</strong></p>\n<p>1、缓存功能：String 字符串是最常用的数据类型，不仅仅是 Redis，各个语言都是最基本类型，因此，利用 Redis 作为缓存，配合其它数据库作为存储层，利用 Redis 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p>\n<p>2、计数器：许多系统都会使用 Redis 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p>\n<p>3、共享用户 session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie 保存在客户端，有安全隐患。这时可以利用 Redis 将用户的 session 集中管理，在这种模式只需要保证 Redis 的高可用，每次用户 session 的更新和获取都可以快速完成。大大提高效率。（分布式会话）</p>\n<h3 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h3><blockquote>\n<ol>\n<li>List 是简单的字符串列表</li>\n<li>Redis 可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。Redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。</li>\n</ol>\n</blockquote>\n<p><strong>应用场景</strong></p>\n<p>1、消息队列：Redis 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过 lpush 命令从左边插入数据，多个数据消费者，可以使用 rpop 命令阻塞的“抢”列表尾部的数据。</p>\n<p>2、文章列表或者数据分页展示的应用。比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 Redis 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p>\n<h3 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h3><blockquote>\n<ol>\n<li>Redis 集合 set 类型和 list 列表类型类似，都可以用来存储多个字符串元素的集合。</li>\n<li>但是和 list 不同的是 set 集合当中不允许重复的元素。而且 set 集合当中元素是没有顺序的，不存在元素下标。</li>\n<li>Redis 的 set 类型是使用哈希表构造的，因此复杂度是 O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。</li>\n</ol>\n</blockquote>\n<p><strong>应用场景</strong></p>\n<p>1、标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。</p>\n<p>2、共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。</p>\n<p>3、统计网站的独立 IP。利用 set 集合当中元素不唯一性，可以快速实时统计访问网站的独立 IP。</p>\n<h3 id=\"sorted-set（有序集合）\"><a href=\"#sorted-set（有序集合）\" class=\"headerlink\" title=\"sorted set（有序集合）\"></a>sorted set（有序集合）</h3><blockquote>\n<p>Redis 有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。</p>\n</blockquote>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>1、排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>\n<p>2、用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p>\n<h3 id=\"hash（哈希）\"><a href=\"#hash（哈希）\" class=\"headerlink\" title=\"hash（哈希）\"></a>hash（哈希）</h3><p>Redis hash 数据结构 是一个键值对（key-value）集合，它是一个 string 类型的 field 和 value 的映射表，Redis 本身就是一个 key-value 型数据库，因此 hash 数据结构相当于在 value 中又套了一层 key-value 型数据。所以 Redis 中 hash 数据结构特别适合存储关系型对象。</p>\n<blockquote>\n<p>用户 ID 为查找的key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key&#x2F;value 结构来存储</p>\n<ol>\n<li>将用户 ID 作为 key，姓名属性+姓名数据整体作为 value。缺点是每次修改用户的某个属性，都需要先反序列化 属性+数据，修改好，然后将 属性+数据 序列化之后在修改回去，开销较大。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356860189.png\" alt=\"ID -&gt; 属性+数据\"></p>\n<ol start=\"2\">\n<li>将用户 ID+姓名属性作为 key，姓名数据作为 value。缺点是用户 ID 使用多次，数据冗余</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356955204.png\" alt=\"ID+属性 -&gt; 数据\"></p>\n<ol start=\"3\">\n<li>因此通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356950290.png\" alt=\"ID -&gt; 属性 -&gt; 数据\"></p>\n</blockquote>\n<h4 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>1、由于 hash 数据类型的 key-value 的特性，用来存储关系型数据库中表记录，是 Redis 中哈希类型最常用的场景。一条记录作为一个 key-value，把每列属性值对应成 field-value 存储在哈希表当中，然后通过 key 值来区分表当中的主键。</p>\n<p>2、经常被用来存储用户相关信息。优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能。</p>\n<hr>\n<h2 id=\"五大基本类型底层数据结构\"><a href=\"#五大基本类型底层数据结构\" class=\"headerlink\" title=\"五大基本类型底层数据结构\"></a>五大基本类型底层数据结构</h2><p>Redis 整体的存储结构：</p>\n<p>Redis 内部整体的存储结构是一个大的 hashmap，内部是数组实现的 hash，key 冲突通过挂链表去实现，每个 dictEntry 为一个 key&#x2F;value 对象，value 为定义的 redisObject。</p>\n<p>结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650433179786.png\" alt=\"Redis 整体的存储结构\"></p>\n<p>dictEntry 是存储 key-&gt;value 的地方，其中包含指向具体的 redisObject 的指针。</p>\n<p>redisObject 中*ptr 指向具体的数据结构的地址；type 表示该对象的类型，即 String、List、Hash、Set、Zset 中的一个</p>\n<h3 id=\"String-arrayList\"><a href=\"#String-arrayList\" class=\"headerlink\" title=\"String (arrayList)\"></a>String (arrayList)</h3><p>String 的数据结构为简单动态字符串(Simple Dynamic String，缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356547555.png\" alt=\"String 的数据结构\"></p>\n<p>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>\n<h3 id=\"List-ziplist-quickList\"><a href=\"#List-ziplist-quickList\" class=\"headerlink\" title=\"List (ziplist - quickList)\"></a>List (ziplist - quickList)</h3><p>1、Redis 3.2 之前的底层实现方式：压缩列表 ziplist 或者 双向循环链表 linkedlist</p>\n<p>当 list 存储的数据量比较少且同时满足下面两个条件时，list 就使用 ziplist 存储数据：</p>\n<ul>\n<li>list 中保存的每个元素的长度小于 64 字节；</li>\n<li>列表中数据个数少于 512 个。</li>\n</ul>\n<p>2、Redis 3.2 及之后的底层实现方式：quicklist</p>\n<p>quicklist 是一个基于 ziplist 的双向链表，quicklist 的每个节点都是一个 ziplist，结合了双向链表和 ziplist 的优点。</p>\n<h4 id=\"ziplist\"><a href=\"#ziplist\" class=\"headerlink\" title=\"ziplist\"></a><strong>ziplist</strong></h4><p>ziplist 是压缩列表，它的好处是能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用 ziplist 存储。但当数据量过大时就 ziplist 就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是 O(N)，即每次插入都会重新进行 realloc 重新分配内存空间。</p>\n<p>ziplist 结构如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419709341.png\" alt=\"ziplist 结构图\"></p>\n<p>1、zlbytes：用于记录整个压缩列表占用字节数</p>\n<p>2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节，用于快速定位到最后一个节点，从而可以在 ziplist 尾部快速的执行 push，pop 操作</p>\n<p>3、zllen：记录了压缩列表包含的节点数量。</p>\n<p>4、entryX：压缩列表包含的各个节点</p>\n<p>5、zlend：用于标记压缩列表的末端，用来快速定位到最后一个元素，然后倒着遍历。（entry 块的 prevlen 字段表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。）</p>\n<p><strong>为什么数据量大时不用 ziplist？</strong></p>\n<p>因为 ziplist 是一段连续的内存，插入的时间复杂化度为 O(n)，而且每当插入新的元素需要 realloc 做内存扩展；而且如果超出 ziplist 内存大小，还会做重新分配的内存空间，并将内容复制到新的地址。如果数量大的话，重新分配内存和拷贝内存会消耗大量时间。所以不适合大型字符串，也不适合存储量多的元素。</p>\n<h4 id=\"quickList\"><a href=\"#quickList\" class=\"headerlink\" title=\"quickList\"></a>quickList</h4><p>快速列表是 ziplist 和 linkedlist 的混合体，是将 linkedlist 按段切分，每一段用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针链接。</p>\n<p><strong>为什么不直接使用 linkedlist？</strong></p>\n<p>linkedlist 的附加空间相对太高，prev 和 next 指针就要占去 16 个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p>\n<p>quicklist 结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419719663.png\" alt=\"quicklist 结构图\"></p>\n<p><strong>ziplist的长度</strong></p>\n<p>quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。关于长度可以使用 list-max-ziplist-size 决定。</p>\n<p><strong>压缩深度</strong></p>\n<p>我们上面说到了 quicklist 下是用多个 ziplist 组成的，同时为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩，可以选择压缩深度。quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 list-compress-depth 决定。为了支持快速 push&#x2F;pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p>\n<h3 id=\"Hash-ziplist-dict\"><a href=\"#Hash-ziplist-dict\" class=\"headerlink\" title=\"Hash (ziplist - dict)\"></a>Hash (ziplist - dict)</h3><h4 id=\"ziplist-1\"><a href=\"#ziplist-1\" class=\"headerlink\" title=\"ziplist\"></a>ziplist</h4><p>当 Hash 中数据项比较少的情况下，Hash 底层才用压缩列表 ziplist 进行存储数据，随着数据的增加，底层的 ziplist 就可能会转成 dict，具体配置如下</p>\n<blockquote>\n<p>hash-max-ziplist-entries 512<br>hash-max-ziplist-value 64</p>\n</blockquote>\n<p>在如下两个条件之一满足的时候，ziplist 会转成 dict：</p>\n<ul>\n<li>当 hash 中的数据项的数目超过 512 的时候，也就是 ziplist 数据项超过 1024 的时候；</li>\n<li>当 hash 中插入的任意一个 value 的长度超过了 64 的时候。</li>\n</ul>\n<p>每当有新的键值对加入到哈希对象时，先压入键，再压入值，如图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/20190703171927309.png\" alt=\"ziplist实现的hash\"></p>\n<p>当遍历时，从头到尾的遍历，且跳过值节点。</p>\n<h4 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h4><p>字典的哈希表结构和 Java 的 HashMap 结构几乎是一样的，都是通过某个哈希函数从 key 计算得到在哈希表中的位置，采用链表法解决冲突。Redis 这里使用的是单链表，为了查询效率每次把新数据插入到链表头位置（使用头插法是因为新插入的数据被访问的概率大，可以更快访问到）。</p>\n<p>我们可以看到每个 dict 中都有两个 hashtable，结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420119549.png\" alt=\"dict实现的hash\"></p>\n<p>虽然 dict 结构有两个 hashtable，但是通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容的时候，需要分配新的 hashtable，然后进行渐近式搬迁，这时候两个 hashtable 存储的旧的 hashtable 和新的 hashtable。搬迁结束后，旧 hashtable 删除，新的取而代之。</p>\n<p><strong>渐进式 rehash</strong></p>\n<p>所谓渐进式 rehash 是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个 O(n)的操作。但是因为我们的 Redis 是单线程的，无法承受这样的耗时过程，所以采用了渐进式 rehash 小步搬迁，虽然慢一点，但是可以搬迁完毕。</p>\n<p><strong>扩容条件</strong></p>\n<p>我们的扩容一般会在 Hash 表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在 Redis 在做 bgsave（RDB 持久化操作的过程），为了减少内存页的过多分离（Copy On Write），Redis 不会去扩容。但是如果 hash 表的元素个数已经到达了第一维数组长度的 5 倍的时候，就会强制扩容，不管你是否在持久化。</p>\n<p>不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。</p>\n<p><strong>缩容条件</strong></p>\n<p>当我们的 hash 表元素逐渐删除的越来越少的时候。Redis 于是就会对 hash 表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的 10%，并且缩容不考虑是否在做 Redis 持久化。</p>\n<p>不用考虑 bgsave 主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p>\n<p><strong>rehash 步骤</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420130964.png\" alt=\"rehash 步骤\"></p>\n<h3 id=\"Set-intset-hashSet\"><a href=\"#Set-intset-hashSet\" class=\"headerlink\" title=\"Set (intset - hashSet)\"></a>Set (intset - hashSet)</h3><p>Redis 的集合相当于 Java 中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合 Set 类型底层编码包括 inset 和 hashtable。</p>\n<p>当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合 intset 来实现 set 这种数据类型：</p>\n<blockquote>\n<p>存储的数据都是整数<br>存储的数据元素个数小于512个</p>\n</blockquote>\n<p>当不能同时满足这两个条件的时候，Redis 就使用 dict 来存储集合中的数据</p>\n<p><strong>intset</strong></p>\n<p>intset 是一个有序集合，查找元素的复杂度为 O(logN)（采用二分法），但插入时不一定为 O(logN)，因为有可能涉及到升级操作。比如当集合里全是 int16_t 型的整数，这时要插入一个 int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成 int32_t 类型，涉及到内存的重新分配，这时插入的复杂度就为 O(N)了。是 intset 不支持降级操作。</p>\n<p><strong>intset 是有序不要和 zset 搞混，zset 是设置一个 score 来进行排序，而 intset 这里只是单纯的对整数进行升序而已</strong></p>\n<h3 id=\"Sorted-Set-ziplist-zset-dict-skipList\"><a href=\"#Sorted-Set-ziplist-zset-dict-skipList\" class=\"headerlink\" title=\"Sorted Set (ziplist - zset(dict + skipList))\"></a>Sorted Set (ziplist - zset(dict + skipList))</h3><p>Zset 有序集合和 set 集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数 score，作为排序的依据。</p>\n<p>当数据较少时，sorted set 是由 ziplist 来实现的。<br>当数据多的时候，sorted set 是由 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据指定分数 score 的范围来获取 value 列表。</p>\n<p><strong>sorted set ziplist 实现</strong></p>\n<p>在这里我们先来讨论一下前一种情况——基于 ziplist 实现的 sorted set。ziplist 就是由很多数据项组成的一大块连续内存。由于 sorted set 的每一项元素都由数据和 score 组成，因此，当使用 zadd 命令插入一个(数据, score)对的时候，底层在相应的 ziplist 上就插入两个数据项：数据在前，score 在后。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650431975904.png\" alt=\"基于 ziplist 实现的 sorted set\"></p>\n<p>ziplist 的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set 的各个查询操作，就是在 ziplist 上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p>\n<p>随着数据的插入，sorted set 底层的这个 ziplist 就可能会转成 zset 的实现。那么到底插入多少才会转呢？</p>\n<blockquote>\n<p>zset-max-ziplist-entries 128\t# 当sorted set中的元素个数，即(数据， score)对的数目超过128的时候<br>zset-max-ziplist-value 64\t# 当sorted set中插入的任意一个数据的长度超过了64的时候。</p>\n</blockquote>\n<p><strong>sorted set ziplist实现</strong><br>Redis 的 zset 是一个复合结构，一方面它需要一个 hash 结构来存储 value 和 score 的对应关系，另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获取 value 列表的功能，这就需要另外一个结构「跳跃表」。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n\n<p>跳表：链表+多级索引（空间换时间）</p>\n<p>和其他结构的比较：</p>\n<p>对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>\n<hr>\n<h2 id=\"三大特殊数据类型\"><a href=\"#三大特殊数据类型\" class=\"headerlink\" title=\"三大特殊数据类型\"></a>三大特殊数据类型</h2><h3 id=\"geospatial（地理位置）\"><a href=\"#geospatial（地理位置）\" class=\"headerlink\" title=\"geospatial（地理位置）\"></a>geospatial（地理位置）</h3><ol>\n<li>查看附近的人</li>\n<li>微信位置共享</li>\n<li>地图上直线距离的展示</li>\n</ol>\n<h3 id=\"Hyperloglog（基数）\"><a href=\"#Hyperloglog（基数）\" class=\"headerlink\" title=\"Hyperloglog（基数）\"></a>Hyperloglog（基数）</h3><p>基数：不重复的元素</p>\n<p>网页统计 UV （浏览用户数量，同一天同一个 ip 多次访问算一次访问，目的是计数，而不是保存用户）</p>\n<p>传统的方式，set 保存用户的 id，可以统计 set 中元素数量作为标准判断。</p>\n<p>但如果这种方式保存大量用户 id，会占用大量内存，我们的目的是为了计数，而不是去保存 id。</p>\n<h3 id=\"Bitmaps（位存储）\"><a href=\"#Bitmaps（位存储）\" class=\"headerlink\" title=\"Bitmaps（位存储）\"></a>Bitmaps（位存储）</h3><p>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：</p>\n<ol>\n<li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li>\n<li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</li>\n</ol>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li><p>setbit</p>\n<p> <code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;</code> 设置 Bitmaps 中某个偏移量的值（0 或 1）</p>\n<p> 可以将 idx 位置为 1 表示 idx 用户访问过</p>\n</li>\n<li><p>getbit</p>\n<p> <code>getbit&lt;key&gt;&lt;offset&gt;</code> 获取 Bitmaps 中某个偏移量的值</p>\n<p> 通过 idx 位是否为 1 判断 idx 用户是否访问过</p>\n</li>\n<li><p>bitcount</p>\n<p> <code>bitcount&lt;key&gt;[start end]</code> 统计字符串从 start 字节到 end 字节比特值为 1 的数量</p>\n</li>\n<li><p>bitop</p>\n<p> <code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code> bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。</p>\n</li>\n</ol>\n<h4 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h4><p><strong>两种状态的统计</strong>都可以使用 bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。</p>\n<hr>\n<h2 id=\"Redis事务与锁机制\"><a href=\"#Redis事务与锁机制\" class=\"headerlink\" title=\"Redis事务与锁机制\"></a>Redis事务与锁机制</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>事务本质：一组命令的集合</p>\n<h4 id=\"数据库的事务\"><a href=\"#数据库的事务\" class=\"headerlink\" title=\"数据库的事务\"></a><strong>数据库的事务</strong></h4><p>数据库事务通过 ACID（原子性、一致性、隔离性、持久性）来保证。</p>\n<p>数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条 SQL 语句在被执行的时候，都会生成一条撤销日志(Undo Log)。</p>\n<h4 id=\"Redis-事务\"><a href=\"#Redis-事务\" class=\"headerlink\" title=\"Redis 事务\"></a>Redis 事务</h4><p>Redis 事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>\n<p>Redis 中一个事务从开始到执行会经历<strong>开始</strong>事务（Muiti）、命令<strong>组队</strong>和<strong>执行</strong>事务(Exec)三个阶段，事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>\n<p>组队的过程中可以通过 discard 来放弃组队。</p>\n<p><strong>事务的错误处理</strong></p>\n<p>组队阶段某个命令报错，执行时整个队列都会被取消。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372301056.png\" alt=\"组队阶段某个命令报错\"></p>\n<p>如果执行阶段某个命令报错，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。（不保证事务的原子性）</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372359361.png\" alt=\"执行阶段某个命令报错\"></p>\n<p><strong>为什么 Redis 不支持回滚来保证原子性</strong></p>\n<p>Redis 命令只会因为错误的语法而失败，然而没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>\n<h3 id=\"Redis-锁\"><a href=\"#Redis-锁\" class=\"headerlink\" title=\"Redis 锁\"></a>Redis 锁</h3><h4 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h4><p><strong>悲观锁(Pessimistic Lock)<strong>， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417157625.png\" alt=\"悲观锁\"></p>\n<blockquote>\n<p>线程 1 拿到账户后把账户锁住，然后操作，这时候线程 2 也想拿账户，发现加了锁拿不到，只能阻塞等到锁释放。</p>\n</blockquote>\n<h4 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h4><p><strong>乐观锁(Optimistic Lock)，</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>更新的时候判断</strong>一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis 就是利用这种机制实现事务的。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417222072.png\" alt=\"乐观锁\"></p>\n<blockquote>\n<p>给账户数据加一个版本号，假如线程 1、2 都拿到账户，线程 1 使用账户前先进行版本号比较，v1.0 &#x3D; v1.0，则扣减账户余额，账户版本号变更为 v1.1，线程 2 准备操作数据库，发现自己预期的账户版本号 v1.0 和当前账户版本号 v1.1 不同（CAS），则不能操作。 </p>\n</blockquote>\n<hr>\n<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><p>Redis 是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题 Redis 供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。</p>\n<p>两种持久化方式：快照（RDB 文件）和追加式文件（AOF 文件），下面分别为大家介绍两种方式的原理。</p>\n<ul>\n<li><p>RDB 持久化方式会在一个特定的间隔保存那个时间点的数据快照。</p>\n</li>\n<li><p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。</p>\n</li>\n<li><p>两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p>\n</li>\n</ul>\n<h3 id=\"RDB-Redis-Database\"><a href=\"#RDB-Redis-Database\" class=\"headerlink\" title=\"RDB(Redis Database)\"></a>RDB(Redis Database)</h3><blockquote>\n<p>在满足特定的  Redis 操作条件（时间周期、写操作次数）时，将内存中的数据以 <strong>数据快照</strong> 的形式存储到 db 文件中</p>\n</blockquote>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a><strong>工作原理</strong></h4><blockquote>\n<p><a href=\"https://www.cnblogs.com/zyf98/p/15934058.html\">Redis_RDB持久化之写时复制技术的应用</a></p>\n</blockquote>\n<p>RDB 是一次的全量备份，即周期性的把 Redis 当前内存中的全量数据写入到一个快照文件中。Redis 是单线程程序，这个线程要同时负责多个客户端的读写请求，还要负责周期性的把当前内存中的数据写到快照文件中 RDB 中，那么就会带来以下两个问题：</p>\n<ol>\n<li>数据写到 RDB 文件是 IO 操作，IO 操作会严重影响 Redis 的性能，甚至在持久化的过程中，读写请求会阻塞</li>\n<li>假如 Redis 正在进行持久化一个大的数据结构，在这个过程中客户端发送一个删除请求，把这个大的数据结构删掉了，这时候持久化的动作还没有完成。</li>\n</ol>\n<p>于是 Redis 使用操作系统的多进程 <strong>写时复制(Copy On Write)机制</strong> 来实现快照的持久化，在持久化过程中调用<strong>glibc</strong>(Linux 下的 C 函数库)的函数 <strong>fork()</strong> 产生一个子进程，该子进程和父进程共享内存里面的代码段和数据段，快照持久化完全交给子进程来处理，父进程继续处理客户端的读写请求。</p>\n<blockquote>\n<p>子进程将数据写入到一个临时 RDB 文件中。当子进程完成持久化时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</p>\n</blockquote>\n<p>在子进程持久化的过程中，如果主进程收到的客户端的读写请求，需要修改某块数据，那么这块数据就会被复制一份到内存，生成该数据的副本，主进程在该副本上进行修改操作。所以即使对某个数据进行了修改，Redis 持久化到 RDB 中的数据也是未修改的数据，这也是把 RDB 文件称为”快照”文件的原因，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。这里再深入一点，Redis 内存中的全量数据由一个个的”数据段页面”组成，每个数据段页面的大小为 4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中，这个复制的过程称为”页面分离”，在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的 2 倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分 Redis 数据还是”冷数据”。</p>\n<p>正因为修改的部分数据会被额外的复制一份，所以会占用额外的内存，当在进行 RDB 持久化操作的过程中，与此同时如果持续往 Redis 中写入的数据量越多，就会导致占用的额外内存消耗越大。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2093494-20220226233822789-2067752089.png\" alt=\"RDB 持久化\"></p>\n<p><strong>优点</strong>：</p>\n<ol>\n<li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li>\n<li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li>\n<li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I&#x2F;O 等操作；</li>\n<li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。</li>\n<li>RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li>\n</ol>\n<h3 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h3><p>以日志的形式来记录每个写的操作，将 Redis 执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<h4 id=\"AOF配置项\"><a href=\"#AOF配置项\" class=\"headerlink\" title=\"AOF配置项\"></a><strong>AOF配置项</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 默认不开启aof  而是使用rdb的方式</span><br><span class=\"line\">appendonly no</span><br><span class=\"line\"></span><br><span class=\"line\"># 默认文件名</span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 每次修改都会sync 消耗性能</span><br><span class=\"line\"># appendfsync always</span><br><span class=\"line\"># 每秒执行一次 sync 可能会丢失这一秒的数据</span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"># 不执行 sync ，这时候操作系统自己同步数据，速度最快</span><br><span class=\"line\"># appendfsync no </span><br></pre></td></tr></table></figure>\n\n<p>AOF 的整个流程大体来看可以分为两步，第一步是命令的实时写入（如果是 appendfsync everysec 配置，会有 1s 损耗），第二步是对 aof 文件的重写。</p>\n<h4 id=\"AOF-重写机制\"><a href=\"#AOF-重写机制\" class=\"headerlink\" title=\"AOF 重写机制\"></a><strong>AOF 重写机制</strong></h4><p>随着 Redis 的运行，AOF 的日志会越来越长，如果实例宕机重启，那么重放整个 AOF 将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr 一千次，那么就不需要去记录这 1000 次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。</p>\n<p>Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的 AOF 文件，至此完成。</p>\n<p>同样的也可以在 Redis.config 中对重写机制的触发进行配置：</p>\n<p>通过将 no-appendfsync-on-rewrite 设置为 yes，开启重写机制；auto-aof-rewrite-percentage 100 意为比上次从写后文件大小增长了 100%再次触发重写；</p>\n<p>auto-aof-rewrite-min-size 64mb 意为当文件至少要达到 64mb 才会触发制动重写。</p>\n<p><strong>优点</strong>：</p>\n<p>1、数据安全，AOF 是对指令文件进行 <strong>增量更新</strong>，更适合实时性持久化。</p>\n<p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 Redis-check-aof 工具解决数据一致性问题。</p>\n<p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p>\n<p><strong>缺点</strong>：</p>\n<p>1、AOF 文件比 RDB 文件大，且恢复速度慢。</p>\n<p>2、数据集大的时候，比 RDB 启动效率低。</p>\n<h3 id=\"RDB与AOF对比\"><a href=\"#RDB与AOF对比\" class=\"headerlink\" title=\"RDB与AOF对比\"></a>RDB与AOF对比</h3><p>Redis 官方建议同时开启两种持久化策略，AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p>\n<table>\n<thead>\n<tr>\n<th>比较项</th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>丢数据</td>\n<td>根据策略决定</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"发布与订阅\"><a href=\"#发布与订阅\" class=\"headerlink\" title=\"发布与订阅\"></a>发布与订阅</h2><p>Redis 发布与订阅是一种消息通信的模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p>\n<p>Redis 通过 PUBLISH 和 SUBSCRIBE 等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是订阅&#x2F;发布到频道、订阅&#x2F;发布到模式的客户端。</p>\n<h3 id=\"频道（channel）\"><a href=\"#频道（channel）\" class=\"headerlink\" title=\"频道（channel）\"></a>频道（channel）</h3><p><strong>订阅</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436261125.png\" alt=\"频道订阅\"></p>\n<p><strong>发布</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436267143.png\" alt=\"频道发布\"></p>\n<h4 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a><strong>完整流程</strong></h4><p>发布者向频道 channel:1 发布消息 hi</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; publish channel:1 hi(integer) 1</span><br></pre></td></tr></table></figure>\n\n<p>订阅者订阅消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; subscribe channel:1</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;subscribe&quot; // 消息类型</span><br><span class=\"line\">2) &quot;channel:1&quot; // 频道</span><br><span class=\"line\">3) &quot;hi&quot; // 消息内容</span><br></pre></td></tr></table></figure>\n\n<p>执行 subscribe 后客户端会进入订阅状态，仅可以使 subscribe、unsubscribe、psubscribe 和 punsubscribe 这四个属于”发布&#x2F;订阅”之外的命令</p>\n<p>订阅频道后的客户端可能会收到三种消息类型</p>\n<ul>\n<li><p>subscribe：表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</p>\n</li>\n<li><p>message：表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</p>\n</li>\n<li><p>unsubscribe：表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为 0 时客户端会退出订阅状态，之后就可以执行其他非”发布&#x2F;订阅”模式的命令了。</p>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h4><p>基于 channel 的发布订阅模式是通过字典数据类型实现的</p>\n<blockquote>\n<p>类似hashmap，键为channel，值为订阅了该channel的client，用链表链接起来</p>\n</blockquote>\n<p>其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420774862.png\" alt=\"频道模式数据结构模型\"></p>\n<p><strong>订阅</strong></p>\n<p>当使用 subscribe 订阅时，在字典中找到频道 key（如没有则创建），并将订阅的 client 关联在链表后面。</p>\n<p>当 client 10 执行 <code>subscribe channel1 channel2 channel3</code> 时，会将 client 10 分别加到 channel1 channel2 channel3 关联的链表尾部。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420784179.png\" alt=\"频道订阅\"></p>\n<p><strong>发布</strong></p>\n<p>发布时，根据 key，找到字典汇总 key 的地址，然后将 msg 发送到关联的链表每一台机器。</p>\n<p><strong>退订</strong></p>\n<p>遍历关联的链表，将指定的地址删除即可。</p>\n<h3 id=\"模式（pattern）\"><a href=\"#模式（pattern）\" class=\"headerlink\" title=\"模式（pattern）\"></a>模式（pattern）</h3><p>pattern 使用了通配符的方式来订阅</p>\n<p>通配符中 ? 表示 1 个占位符，* 表示任意个占位符(包括 0)，?* 表示 1 个以上占位符。</p>\n<p>所以当使用 publish 命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个&#x2F;某些模式和这个频道匹配的话， 那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420803487.png\" alt=\"模式\"></p>\n<h4 id=\"订阅发布完整流程\"><a href=\"#订阅发布完整流程\" class=\"headerlink\" title=\"订阅发布完整流程\"></a><strong>订阅发布完整流程</strong></h4><p>发布者发布消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; publish b m1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; publish b1 m1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; publish b11 m1</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n\n<p>订阅者订阅消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; psubscribe b*</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;psubscribe&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) (integer) 3</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) &quot;b&quot;</span><br><span class=\"line\">4) &quot;m1&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) &quot;b1&quot;</span><br><span class=\"line\">4) &quot;m1&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) &quot;b11&quot;</span><br><span class=\"line\">4) &quot;m1&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h4><p>pattern 属性是一个链表，链表中保存着所有和模式相关的信息。</p>\n<blockquote>\n<p>类似链表，每个pattern节点，包含pattern以及订阅该pattern的client</p>\n</blockquote>\n<p>数据结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420905733.png\" alt=\"模式数据结构\"></p>\n<p><strong>订阅</strong></p>\n<p>当有信的订阅时，会将订阅的客户端和模式信息添加到链表后面。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420913717.png\" alt=\"模式订阅\"></p>\n<p><strong>发布</strong></p>\n<p>当发布者发布消息时，首先会发送到对应的频道上，在遍历模式列表，根据 key 匹配模式，匹配成功将消息发给对应的订阅者。</p>\n<p><strong>退订</strong></p>\n<p>使用 punsubscribe，可以将订阅者退订，将改客户端移除出链表。</p>\n<hr>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p><strong>什么是主从复制</strong></p>\n<p>在多个 Redis 实例建立起主从关系，当 主 Redis 中的数据发生变化，从 Redis 中的数据也会同步变化</p>\n<ul>\n<li>通过主从配置可以实现 Redis 数据的备份（从 Redis 就是对 主 Redis 的备份），保证数据安全性</li>\n<li>主从库之间采用的是读写分离的方式，读操作：主库、从库都可以接收；写操作：首先到主库执行，然后主库将写操作同步给从库</li>\n</ul>\n<p><strong>主从复制的作用</strong></p>\n<ul>\n<li><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>\n</li>\n<li><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>\n</li>\n<li><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</p>\n</li>\n<li><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。</p>\n</li>\n</ul>\n<p>主从库采用的是读写分离的方式：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420963646.png\" alt=\"主从库读写分离\"> </p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>分为全量复制与增量复制</p>\n<p>全量复制：发生在第一次复制时</p>\n<p>增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库</p>\n<h3 id=\"全量复制的三个阶段\"><a href=\"#全量复制的三个阶段\" class=\"headerlink\" title=\"全量复制的三个阶段\"></a>全量复制的三个阶段</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNoteskjk7gr48ft.jpeg\" alt=\"全量复制\"></p>\n<p>第一阶段是主从库间建立连接、协商同步的过程。</p>\n<blockquote>\n<p>主要是为全量复制做准备。从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>\n<p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p>\n</blockquote>\n<p>第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>\n<blockquote>\n<p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>\n</blockquote>\n<p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</p>\n<blockquote>\n<p>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>\n</blockquote>\n<h3 id=\"断网增量更新\"><a href=\"#断网增量更新\" class=\"headerlink\" title=\"断网增量更新\"></a>断网增量更新</h3><p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesg0eezljwqy.jpeg\" alt=\"断网增量更新\"></p>\n<h2 id=\"哨兵机制\"><a href=\"#哨兵机制\" class=\"headerlink\" title=\"哨兵机制\"></a>哨兵机制</h2><blockquote>\n<p>哨兵的核心功能是主节点的自动故障转移</p>\n<ol>\n<li>监控 主库，判断 主库 是否宕机</li>\n<li>主库 如果宕机，则从 从库 中 选举成为 主库（因此需要奇数个哨兵）</li>\n<li>更改主从配置</li>\n</ol>\n</blockquote>\n<p>下图是一个典型的哨兵集群监控的逻辑图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420977306.png\" alt=\"哨兵机制\"></p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\"></p>\n<p>Redis Sentinel 包含了若个 Sentinel 节点，这样做也带来了两个好处：</p>\n<ol>\n<li>对于节点的故障判断是由多个 Sentinel 节点共同完成，这样可以有效地防止误判</li>\n<li>即使个别 Sentinel 节点不可用，整个 Sentinel 集群依然是可用的。</li>\n</ol>\n<p>哨兵实现了以下功能</p>\n<ol>\n<li>监控：每个 Sentinel 节点会对数据节点（Redis master&#x2F;slave 节点）和其余 Sentinel 节点进行监控</li>\n<li>通知：Sentinel 节点会将故障转移的结果通知给应用方</li>\n<li>故障转移：实现 slave 晋升为 master，并维护后续正确的主从关系</li>\n<li>配置中心：在 Redis Sentinel 模式中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息</li>\n</ol>\n<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置中心和通知功能，则需要在与客户端的交互中才能体现。</p>\n<h3 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h3><p>Sentinel 节点需要监控 master、slave 以及其它 Sentinel 节点的状态。这一过程是通过 Redis 的 pub&#x2F;sub 系统实现的。Redis Sentinel 一共有三个定时监控任务，完成对各个节点发现和监控：</p>\n<ol>\n<li>监控主从拓扑信息：每隔 10 秒，每个 Sentinel 节点，会向 master 和 slave 发送 INFO 命令获取最新的拓扑结构</li>\n<li>Sentinel 节点信息交换：每隔 2 秒，每个 Sentinel 节点，会向 Redis 数据节点的<code>sentinel:hello</code> 频道上，发送自身的信息，以及对主节点的判断信息。这样，Sentinel 节点之间就可以交换信息</li>\n<li>节点状态监控：每隔 1 秒，每个 Sentinel 节点，会向 master、slave、其余 Sentinel 节点发送 PING 命令做心跳检测，来确认这些节点当前是否可达</li>\n</ol>\n<h3 id=\"主观-x2F-客观下线\"><a href=\"#主观-x2F-客观下线\" class=\"headerlink\" title=\"主观&#x2F;客观下线\"></a>主观&#x2F;客观下线</h3><h4 id=\"主观下线\"><a href=\"#主观下线\" class=\"headerlink\" title=\"主观下线\"></a>主观下线</h4><p>每个 Sentinel 节点，每隔 1 秒会对数据节点发送 ping 命令做心跳检测，当这些节点超过 down-after-milliseconds 没有进行有效回复时，Sentinel 节点会对该节点做失败判定，这个行为叫做主观下线。</p>\n<h4 id=\"客观下线\"><a href=\"#客观下线\" class=\"headerlink\" title=\"客观下线\"></a>客观下线</h4><p>客观下线，是指当大多数 Sentinel 节点，都认为 master 节点宕机了，那么这个判定就是客观的，叫做客观下线。</p>\n<p>那么这个大多数是指多少呢？这其实就是分布式协调中的 quorum 判定了，大多数就是过半数，比如哨兵数量是 5，那么大多数就是 5&#x2F;2+1&#x3D;3 个，哨兵数量是 10 大多数就是 10&#x2F;2+1&#x3D;6 个。</p>\n<p>注：Sentinel 节点的数量至少为 3 个，否则不满足 quorum 判定条件。</p>\n<h3 id=\"哨兵选举\"><a href=\"#哨兵选举\" class=\"headerlink\" title=\"哨兵选举\"></a>哨兵选举</h3><p>如果发生了客观下线，那么哨兵节点会选举出一个 Leader 来进行实际的故障转移工作。Redis 使用了 Raft 算法来实现哨兵领导者选举，大致思路如下：</p>\n<ol>\n<li>每个 Sentinel 节点都有资格成为领导者，当它主观认为某个数据节点宕机后，会向其他 Sentinel 节点发送 sentinel is-master-down-by-addr 命令，要求自己成为领导者；</li>\n<li>收到命令的 Sentinel 节点，如果没有同意过其他 Sentinel 节点的 sentinelis-master-down-by-addr 命令，将同意该请求，否则拒绝（每个 Sentinel 节点只有 1 票）；</li>\n<li>如果该 Sentinel 节点发现自己的票数已经大于等于 MAX(quorum, num(sentinels)&#x2F;2+1)，那么它将成为领导者；</li>\n<li>如果此过程没有选举出领导者，将进入下一次选举。</li>\n</ol>\n<h3 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a><strong>故障转移</strong></h3><p>选举出的 Leader Sentinel 节点将负责故障转移，也就是进行 master&#x2F;slave 节点的主从切换。故障转移，首先要从 slave 节点中筛选出一个作为新的 master，主要考虑以下 slave 信息：</p>\n<ol>\n<li>跟 master 断开连接的时长：如果一个 slave 跟 master 的断开连接时长已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么该 slave 就被认为不适合选举为 master；</li>\n<li>slave 的优先级配置：slave priority 参数值越小，优先级就越高；</li>\n<li>复制 offset：当优先级相同时，哪个 slave 复制了越多的数据（offset 越靠后），优先级越高；</li>\n<li>run id：如果 offset 和优先级都相同，则哪个 slave 的 run id 越小，优先级越高。</li>\n</ol>\n<p>接着，筛选完 slave 后， 会对它执行 slaveof no one 命令，让其成为主节点。</p>\n<p>最后，Sentinel 领导者节点会向剩余的 slave 节点发送命令，让它们成为新的 master 节点的从节点，复制规则与 parallel-syncs 参数有关。</p>\n<p>Sentinel 节点集合会将原来的 master 节点更新为 slave 节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</p>\n<p>注：Leader Sentinel 节点，会从新的 master 节点那里得到一个 configuration epoch，本质是个 version 版本号，每次主从切换的 version 号都必须是唯一的。其他的哨兵都是根据 version 来更新自己的 master 配置。</p>\n<h2 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h2><blockquote>\n<p>高可用：保证 Redis 一直处于可用状态，即使出现了故障也有备用方案保证可用性</p>\n<p>高并发：一个 Redis 实例已经可以支持多达 11w并发读操作或 8.1w并发写操作；但是如果有更高并发需求的应用来说，可以通过 读写分离、集群配置 来解决高并发问题</p>\n</blockquote>\n<ul>\n<li>Redis 集群中每个节点是对等的，无中心结构</li>\n<li>数据按照 slots 分布式存储在不同的 Redis 节点上，节点中的数据可共享，可以动态调整数据分布</li>\n<li>可扩展性强，可以动态增删节点，最多可扩展至 1000+ 节点</li>\n<li>集群的每个节点通过 <code>主从（哨兵模式）</code>保证其高可用性</li>\n<li>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作</li>\n<li>Redis 集群之间是如何复制的？异步复制</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_43846090/article/details/123721066\">Redis_数据分布算法：传统哈希-一致性哈希-哈希slot</a></p>\n</blockquote>\n<h3 id=\"传统哈希\"><a href=\"#传统哈希\" class=\"headerlink\" title=\"传统哈希\"></a>传统哈希</h3><p>最简单的数据分布算法，对进来的 key 进行 hash，然后对节点数据进行取模，就知道分布到哪个节点上了；<br>缺点就是: 如果一个节点宕机，所有缓存的位置都要发生改变，当服务器数量发生改变时，所有缓存在一定时间内是失效的，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）</p>\n<h3 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h3><p>实际上就是引入了一个圆环的概念， 让每个数据的 hash 分布到整个圆环，然后顺时针去找离他最近的节点存储</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525022243.png\" alt=\"一致性哈希\" style=\"zoom: 50%;\" />\n\n<p>hash 算法的取模法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，<br>dubbo 的复杂均衡有用到该算法；</p>\n<p>好处:</p>\n<p>使用 hash 算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了；<br>而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效。上图中如果节点 A 失效，则 C → A 之间的数据会重新缓存到节点 B 上。</p>\n<p>hash 环偏斜：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525154544.png\" alt=\"hash 环偏斜\" style=\"zoom: 50%;\" />\n\n<p>1 号、2 号、3 号、4 号、6 号数据均被缓存在了服务器 A 上；只有 5 号被缓存在了服务器 B 上；服务器 C 上甚至没有缓存任何图片<br>如果出现上图中的情况，A、B、C 三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器 A 出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃；</p>\n<p>上图中的情况则被称之为 hash 环的偏斜 ；<br>我们应该怎样防止 hash 环的偏斜？<br>增加虚拟节点：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525203417.png\" alt=\"增加虚拟节点防止 hash 环的偏斜\" style=\"zoom:50%;\" />\n\n<p>为了解决这个数据负载均衡的问题，搞出来虚拟节点，把真实节点搞一堆虚拟节点分布到环，那么整个区间的数据会落到这些虚拟节点上；</p>\n<p>虚拟节点越多，hash 环上的节点就越多，缓存被均匀分布的概率就越大。</p>\n<h3 id=\"哈希槽\"><a href=\"#哈希槽\" class=\"headerlink\" title=\"哈希槽\"></a>哈希槽</h3><p>Redis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。</p>\n<p>首先哈希槽其实是两个概念，第一个是哈希算法。Redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 Redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p>\n<p>Redis cluster 包含了 16384 个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p>\n<p><strong>为什么哈希槽的大小是固定的16384？</strong></p>\n<blockquote>\n<p><code>CRC16</code>算法产生的hash值有16bit，该算法可以产生2^16-&#x3D;65536个值。换句话说，值是分布在0~65535之间。那作者在做<code>mod</code>运算的时候，为什么不<code>mod</code>65536，而选择<code>mod</code>16384？</p>\n</blockquote>\n<p><strong>不能太大，主要从节点间的通信性能方面考虑：</strong></p>\n<p>每个节点之间是需要进行一个通信的，也就是不断地 pingpong 机制，让每个节点连接对方的信息；发送的消息头中有一个 bitmap，其中每一位代表一个槽，如果该位为 1，表示这个槽是属于当前节点，如果槽位过大，那么这个 bitmap 就会太大，心跳包过于庞大，浪费带宽。</p>\n<p><strong>不能太小，主要从压缩率方面考虑：</strong></p>\n<p>由于 bitmap 在传输过程中会进行压缩，bitmap 的填充率用 slots&#x2F;N 表示（N 即节点数），对于同样的 slots，如果 N 太小，导致其填充率过高，压缩率就很低。</p>\n<hr>\n<h2 id=\"缓存穿透、击穿、雪崩\"><a href=\"#缓存穿透、击穿、雪崩\" class=\"headerlink\" title=\"缓存穿透、击穿、雪崩\"></a>缓存穿透、击穿、雪崩</h2><h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p><strong>问题来源</strong></p>\n<p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，每次都去 DB 判断然而又不能复制到 Redis 中，这就是漏洞。</p>\n<p>例如发起为 id 为“-1”的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li><p><strong>接口校验</strong>：接口层增加校验，例如对 id&lt;&#x3D;0 的直接拦截。</p>\n</li>\n<li><p><strong>缓存空值</strong>：从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 10 秒（设置太长会导致正常情况也没法使用）。</p>\n</li>\n<li><p><strong>布隆过滤器</strong>：布隆过滤器用于快速判某个元素是否存在于集合中，由一个很长的二进制向量（位图）和一系列哈希函数两部分组成。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的错误识别率，添加到集合中的元素越多，误报的可能性就越大。</p>\n<p> 位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit &#x2F; 8 &#x3D; 125000 Byte &#x3D; 125000&#x2F;1024 kb ≈ 122kb 的空间。</p>\n<blockquote>\n<p><a href=\"https://javaguide.cn/cs-basics/data-structure/bloom-filter.html\">布隆过滤器</a></p>\n<p><a href=\"https://javaguide.cn/database/Redis/Redis-questions-01.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\">缓存穿透-布隆过滤器</a></p>\n</blockquote>\n<p> 具体而言：</p>\n<p> 把 <strong>所有可能存在的请求的值</strong> 都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。布隆过滤器判断不存在的话，则肯定不存在，布隆过滤器判断存在，则进一步查 Redis，Redis 中存在则返回，Redis 中不存在则查数据库。</p>\n<p> 为什么布隆过滤器会出现误判的情况呢? </p>\n<p> <strong>当一个元素加入布隆过滤器中的时候，会进行以下操作：</strong></p>\n<ol>\n<li><p>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>\n<blockquote>\n<p>hashVal1 &#x3D; hashMethod1(key)， hashVal2&#x3D; hashMethod2(key)…</p>\n</blockquote>\n</li>\n<li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>\n<blockquote>\n<p>把位数组中的 hashVal1 和 hashVal2 处置为 1</p>\n</blockquote>\n</li>\n</ol>\n<p> <strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行以下操作：</strong></p>\n<ol>\n<li><p>对给定元素再次进行相同的哈希计算；</p>\n<blockquote>\n<p>hashVal1 &#x3D; hashMethod1(key)， hashVal2&#x3D; hashMethod2(key)…</p>\n</blockquote>\n</li>\n<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>\n<blockquote>\n<p>判断位数组中的 hashVal1 和 hashVal2 处是否全部为 1，全部为 1说明当前元素存在于位数组中。</p>\n</blockquote>\n</li>\n</ol>\n<p> 然而会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n<blockquote>\n<p><strong>⭐例如</strong>：val1 经过两次hash得到下标 1， 3，将1、3处置为1，val2经过两次hash得到下标2、4，将2、4处置为1，对于新元素val3经过两次hash得到下标1、2，判断这两个位置都为1，误判以为val3存在，实际上不存在。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p><strong>问题来源</strong></p>\n<p>缓存击穿是指一个热点的 key，有大并发集中对其进行访问，突然间这个 key 失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</p>\n<p><strong>解决方案</strong></p>\n<blockquote>\n<p>热点key失效 → 打到数据库上，因此可以从这两方面进行解决</p>\n</blockquote>\n<p>1、设置热点数据永远不过期。</p>\n<p>2、接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</p>\n<p>3、加互斥锁：如果缓存失效的情况，只有拿到锁才可以查询数据库，分布式场景下可以使用分布式锁。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p><strong>问题来源</strong></p>\n<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是指很多不同的数据都过期了，都查不到从而查数据库。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li><strong>缓存数据的过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</li>\n<li>设置热点数据永远不过期。</li>\n<li>在即将发生大并发访问之前，进行<strong>缓存预热</strong>将可能大量访问的数据加载到缓存。</li>\n<li>接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li>\n<li>为了防止 Redis 宕机导致缓存雪崩的问题，可以<strong>搭建Redis集群</strong>，提高 Redis 的容灾性。</li>\n<li>提高数据库的容灾能力，可以使用<strong>数据库分库分表</strong>，读写分离的策略。</li>\n</ol>\n<h2 id=\"Redis-淘汰策略\"><a href=\"#Redis-淘汰策略\" class=\"headerlink\" title=\"Redis 淘汰策略\"></a>Redis 淘汰策略</h2><h3 id=\"Redis-内存淘汰策略\"><a href=\"#Redis-内存淘汰策略\" class=\"headerlink\" title=\"Redis 内存淘汰策略\"></a>Redis 内存淘汰策略</h3><blockquote>\n<p>Redis 是基于内存结构进行数据缓存的，当内存资源消耗完毕，当将要有新的数据缓存进来时，为了腾出空间放新的数据，需要将内存中的一些数据释放掉，这种释放数据的策略称为 Redis 的淘汰策略。</p>\n</blockquote>\n<p>LRU：Least Recently Used</p>\n<p>LFU：Least Frequently Used</p>\n<p>LRU 淘汰的是最久未访问到的数据，而 LFU 是淘汰的是最不经常使用的数据（若两个或多个数据的使用频率相同时，LFU 会再选择最久未访问到的数据淘汰）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># volatile-lru -&gt; 在设置了过期时间的数据中使用 LRU</span><br><span class=\"line\"># allkeys-lru -&gt; 在所有数据中使用 LRU</span><br><span class=\"line\"># volatile-lfu -&gt; 在设置了过期时间的数据中使用 LFU</span><br><span class=\"line\"># allkeys-lfu -&gt; 在所有数据中使用 LFU</span><br><span class=\"line\"># volatile-random -&gt; 在设置了过期时间的数据中随机淘汰</span><br><span class=\"line\"># allkeys-random -&gt; 在所有数据中随机淘汰</span><br><span class=\"line\"># volatile-ttl -&gt; 越早过期的数据 越先被淘汰</span><br><span class=\"line\"># noeviction -&gt; 不淘汰任何数据，当内存不够时直接抛出异常</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redis-缓存失效策略\"><a href=\"#Redis-缓存失效策略\" class=\"headerlink\" title=\"Redis 缓存失效策略\"></a>Redis 缓存失效策略</h3><p><strong>定时过期策略</strong></p>\n<p>每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，有效地减少了因为过期键带来的内存浪费；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>\n<p><strong>惰性过期策略</strong></p>\n<p>只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p>\n<p><strong>定期过期策略</strong></p>\n<p>每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p>\n<p><strong>Redis中同时使用了定期过期和惰性过期两种过期策略。</strong></p>\n<p>所谓定期删除，指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>\n<p><strong>假设 Redis 里放了 10w 个 key，都设置了过期时间，</strong>你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。<strong>注意，</strong>这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。</p>\n<p><strong>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？</strong>所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p>\n<p><strong>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</strong>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存快耗尽了，咋整？<strong>答案是：走内存淘汰机制。</strong></p>\n<hr>\n<h2 id=\"Redis分布式并发问题\"><a href=\"#Redis分布式并发问题\" class=\"headerlink\" title=\"Redis分布式并发问题\"></a>Redis分布式并发问题</h2><blockquote>\n<p>单体项目中，购物车下单可以使用 synchronized 关键字锁住实例对象，只让一个线程下单并扣减库存</p>\n<p>而对于集群而言，在每台服务器上锁住实例对象，但是每台之间是无法感知的，仍然可能存在商品超卖问题</p>\n</blockquote>\n<h3 id=\"使用-Redis-实现分布式锁\"><a href=\"#使用-Redis-实现分布式锁\" class=\"headerlink\" title=\"使用 Redis 实现分布式锁\"></a>使用 Redis 实现分布式锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title function_\">addOrder</span><span class=\"params\">(String cids, Orders orders)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;add order begin...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）</span></span><br><span class=\"line\">    String[] arr = cids.split(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; cidsList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : arr) &#123;</span><br><span class=\"line\">        cidsList.add(Integer.parseInt(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取所有skuId</span></span><br><span class=\"line\">    List&lt;ShoppingCartVO&gt; list1 = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">allLocked</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    List&lt;String&gt; lockedSkuIds = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    Map&lt;String, String&gt; values = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ShoppingCartVO sc : list1) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId()， value = UUID.randomUUID().toString();</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">thisLocked</span> <span class=\"operator\">=</span> srt.boundValueOps(sc.getSkuId()).setIfAbsent(value, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!thisLocked) &#123;   <span class=\"comment\">// 返回 false 说明之前有该数据，即有线程在操作这个 商品库存</span></span><br><span class=\"line\">            allLocked = <span class=\"literal\">false</span>;  <span class=\"comment\">// 因此这个sku就没有锁住，不能继续操作</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lockedSkuIds.add(skuId);</span><br><span class=\"line\">            values.put(skuId, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allLocked) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2、校验库存</span></span><br><span class=\"line\">        List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Integer.parseInt(sc.getCartNum()) &gt; sc.getSkuStock()) &#123;</span><br><span class=\"line\">                f = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//获取所有商品的名称，以逗号拼接成字符串</span></span><br><span class=\"line\">            sb.append(sc.getProductName()).append(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">untitled</span> <span class=\"operator\">=</span> sb.toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;product stock is ok ... &quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 3、表示库存充足----保存订单</span></span><br><span class=\"line\">            <span class=\"comment\">// a.userId   b.untitled  c.收货人信息：姓名、电话、地址</span></span><br><span class=\"line\">            <span class=\"comment\">// d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态</span></span><br><span class=\"line\">            orders.setUntitled(untitled);</span><br><span class=\"line\">            orders.setCreateTime(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">            orders.setStatus(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 生成订单编号</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> UUID.randomUUID().toString().replace(<span class=\"string\">&quot;-&quot;</span>， <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            orders.setOrderId(orderId);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 保存订单</span></span><br><span class=\"line\">            ordersMapper.insert(orders);</span><br><span class=\"line\">            <span class=\"comment\">// 4、生成商品快照</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">cnum</span> <span class=\"operator\">=</span> Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">itemId</span> <span class=\"operator\">=</span> System.currentTimeMillis() + <span class=\"string\">&quot;&quot;</span> + (<span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>().nextInt(<span class=\"number\">89999</span>) + <span class=\"number\">10000</span>);</span><br><span class=\"line\">                <span class=\"type\">OrderItem</span> <span class=\"variable\">orderItem</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OrderItem</span>(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，</span><br><span class=\"line\">                                                    sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(sc.getSellPrice() * cnum)， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"number\">0</span>);</span><br><span class=\"line\">                orderItemMapper.insert(orderItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 5、扣减库存：根据套餐Id修改套餐库存量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">newStock</span> <span class=\"operator\">=</span> sc.getSkuStock() - Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">ProductSku</span> <span class=\"variable\">productSku</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProductSku</span>();</span><br><span class=\"line\">                productSku.setSkuId(skuId);</span><br><span class=\"line\">                productSku.setStock(newStock);</span><br><span class=\"line\">                <span class=\"comment\">//根据主键来修改属性值</span></span><br><span class=\"line\">                productSkuMapper.updateByPrimaryKeySelective(productSku);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> cid : cidsList) &#123;</span><br><span class=\"line\">                shoppingCartMapper.deleteByPrimaryKey(cid);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> srt.boundValueOps(lockedSkuId).get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span> &amp;&amp; value.equals(values.get(lockedSkuId))) &#123;</span><br><span class=\"line\">                    srt.delete(lockedSkuId);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;add order finished... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            map.put(<span class=\"string\">&quot;orderId&quot;</span>， orderId);</span><br><span class=\"line\">            map.put(<span class=\"string\">&quot;productNames&quot;</span>， untitled);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 表示库存不足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 加锁失败</span></span><br><span class=\"line\">        <span class=\"comment\">// 要将部分锁定的sku释放锁，即从Redis中移除锁住的skuId</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">            srt.delete(lockedSkuId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>如果订单中部分商品加锁成功，但是由于一些商品加锁失败导致无法提交订单，此时要注意将加锁的商品恢复，即从 Redis 中移除该商品</p>\n<blockquote>\n<p>在 allLocked &#x3D;&#x3D; false 中，释放加锁的商品</p>\n</blockquote>\n</li>\n<li><p>第一次根据 购物车 Id 查到的购物车记录（包含商品库存）到加锁提交订单之前，可能有别的线程 操作了其中某个商品的库存并操作完了，为了防止当前线程还对之前库存进行修改，应当在加锁后操作前重新查询库存。</p>\n</li>\n<li><p>当前线程加锁成功之后，在执行添加订单的过程中如果出现了异常导致无法释放锁</p>\n<blockquote>\n<p>可以在对商品加锁时设置过期时间，则到期自动释放锁</p>\n</blockquote>\n</li>\n<li><p>档给锁设置了过期时间之后，如果当前线程 t1 因为特殊原因，在锁过期之前没有完成业务执行，释放掉了锁，此时线程 t2 加锁成功，如果线程 t1 执行结束，将会释放 线程 t2 的锁，导致 线程 t2 在无锁状态</p>\n<blockquote>\n<p>对于加成功并提交完订单之后，对当前商品的锁释放，要判断 Redis 中的value是否和自己记录的相同，即是否是自己加的锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 释放锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> srt.boundValueOps(lockedSkuId).get();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (values.get(lockedSkuId).equals(value)) &#123;</span><br><span class=\"line\">     \tsrt.delete(lockedSkuId);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>当前线程 t1 判断是自己加的锁，在准备删除之前，锁过期了并且被其他线程 t2 拿到了成功加锁，这时候线程 t1 会释放掉线程 t2 的锁（并发量很大仍然需要考虑）</p>\n<blockquote>\n<p>保证 查询锁是否是自己加的和删除自己加的锁 的原子性（使用 lua 脚本，让多个 Redis 操作具有原子性，查询+删除）</p>\n</blockquote>\n</li>\n<li><p>使用看门狗线程解决线程 t1 释放相乘 t2 的锁的问题</p>\n<blockquote>\n<p>线程t1 加锁并设置过期时间，此时启动 看门狗线程（守护线程）监控线程 t1过期时间，过期时间要到了但是线程t1 业务还在执行，则重置过期时间，这样可以保证业务执行完之前不会释放锁</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"分布式锁框架-Resisson\"><a href=\"#分布式锁框架-Resisson\" class=\"headerlink\" title=\"分布式锁框架 Resisson\"></a>分布式锁框架 Resisson</h3><ul>\n<li><p>添加依赖</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.16.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置 yaml 文件</p>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redisson:</span></span><br><span class=\"line\">  <span class=\"attr\">addr:</span></span><br><span class=\"line\">    <span class=\"attr\">singleAddr:</span></span><br><span class=\"line\">      <span class=\"attr\">host:</span> <span class=\"string\">Redis://47.110.247.63:6389</span></span><br><span class=\"line\">      <span class=\"attr\">password:</span> <span class=\"string\">FYX123fyx.</span></span><br><span class=\"line\">      <span class=\"attr\">database:</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置 RedissonClient（也可以配置成集群模式、主从模式）</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;redisson.addr.singleAddr.host&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;redisson.addr.singleAddr.password&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;redisson.addr.singleAddr.database&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> database;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        config.useSingleServer().setAddress(host)</span><br><span class=\"line\">                .setPassword(password)</span><br><span class=\"line\">                .setDatabase(database);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>操作</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title function_\">addOrder</span><span class=\"params\">(String cids, Orders orders)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;add order begin...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）</span></span><br><span class=\"line\">    String[] arr = cids.split(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; cidsList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : arr) &#123;</span><br><span class=\"line\">        cidsList.add(Integer.parseInt(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取所有skuId</span></span><br><span class=\"line\">    List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\">    List&lt;String&gt; lockedSkuIds = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    Map&lt;String, RLock&gt; locks = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// &#123;&quot;1&quot;:lock1, &quot;2&quot;:lock2&#125;</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">allLocked</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId();</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(skuId);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            b = lock.tryLock(<span class=\"number\">10</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!b) &#123;</span><br><span class=\"line\">            allLocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lockedSkuIds.add(skuId);</span><br><span class=\"line\">            locks.put(skuId, lock);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, String&gt; map = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (allLocked) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2、校验库存</span></span><br><span class=\"line\">            list = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.parseInt(sc.getCartNum()) &gt; sc.getSkuStock()) &#123;</span><br><span class=\"line\">                    f = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//获取所有商品的名称，以逗号拼接成字符串</span></span><br><span class=\"line\">                sb.append(sc.getProductName()).append(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">untitled</span> <span class=\"operator\">=</span> sb.toString();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f) &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;product stock is ok ... &quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 3、表示库存充足----保存订单</span></span><br><span class=\"line\">                <span class=\"comment\">// a.userId   b.untitled  c.收货人信息：姓名、电话、地址</span></span><br><span class=\"line\">                <span class=\"comment\">// d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态</span></span><br><span class=\"line\">                orders.setUntitled(untitled);</span><br><span class=\"line\">                orders.setCreateTime(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">                orders.setStatus(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 生成订单编号</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> UUID.randomUUID().toString().replace(<span class=\"string\">&quot;-&quot;</span>， <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                orders.setOrderId(orderId);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 保存订单</span></span><br><span class=\"line\">                ordersMapper.insert(orders);</span><br><span class=\"line\">                <span class=\"comment\">// 4、生成商品快照</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">cnum</span> <span class=\"operator\">=</span> Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">itemId</span> <span class=\"operator\">=</span> System.currentTimeMillis() + <span class=\"string\">&quot;&quot;</span> + (<span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>().nextInt(<span class=\"number\">89999</span>) + <span class=\"number\">10000</span>);</span><br><span class=\"line\">                    <span class=\"type\">OrderItem</span> <span class=\"variable\">orderItem</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OrderItem</span>(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，</span><br><span class=\"line\">                                                        sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(sc.getSellPrice() * cnum)， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"number\">0</span>);</span><br><span class=\"line\">                    orderItemMapper.insert(orderItem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 5、扣减库存：根据套餐Id修改套餐库存量</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">newStock</span> <span class=\"operator\">=</span> sc.getSkuStock() - Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"type\">ProductSku</span> <span class=\"variable\">productSku</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProductSku</span>();</span><br><span class=\"line\">                    productSku.setSkuId(skuId);</span><br><span class=\"line\">                    productSku.setStock(newStock);</span><br><span class=\"line\">                    <span class=\"comment\">//根据主键来修改属性值</span></span><br><span class=\"line\">                    productSkuMapper.updateByPrimaryKeySelective(productSku);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> cid : cidsList) &#123;</span><br><span class=\"line\">                    shoppingCartMapper.deleteByPrimaryKey(cid);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;add order finished... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">                map.put(<span class=\"string\">&quot;orderId&quot;</span>， orderId);</span><br><span class=\"line\">                map.put(<span class=\"string\">&quot;productNames&quot;</span>， untitled);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">            locks.get(lockedSkuId).unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"分布式锁特点\"><a href=\"#分布式锁特点\" class=\"headerlink\" title=\"分布式锁特点\"></a>分布式锁特点</h3><ol>\n<li><p>互斥性</p>\n<p> 保证在不同节点间不同线程的互斥（只有一个节点当然可以）</p>\n</li>\n<li><p>可重入性</p>\n<p> 同一个节点上的同一个线程如果获取锁之后可以再次获取到这个锁</p>\n</li>\n<li><p>锁超时</p>\n<p> 加锁成功之后设置超时时间，以防止线程故障导致不释放锁而引起死锁</p>\n</li>\n<li><p>高效、高可用</p>\n<p> 支持单节点 Redis、主从 Redis、集群 Redis</p>\n</li>\n<li><p>支持阻塞和非阻塞</p>\n<p> tryLock 非阻塞 和 tryLock(long timeOut) 阻塞</p>\n</li>\n</ol>\n<h3 id=\"Redisson-的使用\"><a href=\"#Redisson-的使用\" class=\"headerlink\" title=\"Redisson 的使用\"></a>Redisson 的使用</h3><ol>\n<li><p>获取锁（公平锁 &#x2F; 非公平锁）</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 公平锁</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getFairLock(skuId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非公平锁</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(skuId);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>加锁（阻塞锁 &#x2F; 非阻塞锁）</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阻塞锁，设置加锁成功后的超时时间 20s，不加时间默认 30s</span></span><br><span class=\"line\">lock.lock(<span class=\"number\">20</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非阻塞锁（设置等待时间 3s，加锁成功后的超时时间 10s，不加则默认 30s）</span></span><br><span class=\"line\">lock.tryLock(<span class=\"number\">10</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>释放锁</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.unlock();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实例</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 公平非阻塞锁</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(skuId);</span><br><span class=\"line\">lock.tryLock(<span class=\"number\">10</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"缓存与数据库双写一致性\"><a href=\"#缓存与数据库双写一致性\" class=\"headerlink\" title=\"缓存与数据库双写一致性\"></a>缓存与数据库双写一致性</h2><p>总结：</p>\n<p>读数据：先读缓存，如果有直接返回，如果没有查数据库查到数据存到缓存中并返回</p>\n<p>写数据：先写数据库，再删缓存，这个阶段可能删缓存失败，可以考虑使用一下三种方案：</p>\n<ol>\n<li>如果删除缓存失败，需要将数据写入重试表，然后使用 elastic-job 等定时任务进行重试。</li>\n<li>如果删除缓存失败，需要将数据发送 mq 消息到 mq 服务器，在 mq 的 consumer 中处理。</li>\n<li>订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</li>\n</ol>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/319817091/answer/2432904728\">如何保证数据库和缓存双写一致性？-苏三说技术</a></p>\n</blockquote>\n<h3 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h3><p>通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526232523.png\" alt=\"图片\"></p>\n<ol>\n<li>用户请求过来之后，先查缓存有没有数据，如果有则直接返回。</li>\n<li>如果缓存没数据，再继续查数据库。</li>\n<li>如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。</li>\n<li>如果数据库也没数据，则直接返回空。</li>\n</ol>\n<p>这是缓存非常常见的用法。一眼看上去，好像没有啥问题。</p>\n<p>但你忽略了一个非常重要的细节：<strong>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？</strong></p>\n<p>不更新缓存行不行？</p>\n<p>答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？</p>\n<p>那么，我们该如何更新缓存呢？</p>\n<p>目前有以下 4 种方案：</p>\n<ol>\n<li>先写缓存，再写数据库</li>\n<li>先写数据库，再写缓存</li>\n<li>先删缓存，再写数据库</li>\n<li>先写数据库，再删缓存</li>\n</ol>\n<p>接下来，我们详细说说这 4 种方案。</p>\n<h3 id=\"先写缓存，再写数据库\"><a href=\"#先写缓存，再写数据库\" class=\"headerlink\" title=\"先写缓存，再写数据库\"></a>先写缓存，再写数据库</h3><p>对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。</p>\n<p>那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？</p>\n<p>我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526427819.png\" alt=\"图片\"></p>\n<p>某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526436447.png\" alt=\"图片\"></p>\n<p>其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。</p>\n<p>我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。</p>\n<p>但如果某条数据，在数据库中都不存在，你缓存这种“<code>假数据</code>”又有啥意义呢？</p>\n<p>因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。</p>\n<h3 id=\"先写数据库，再写缓存\"><a href=\"#先写数据库，再写缓存\" class=\"headerlink\" title=\"先写数据库，再写缓存\"></a>先写数据库，再写缓存</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526499487.png\" alt=\"图片\"></p>\n<p>用户的写操作，先写数据库，再写缓存，可以避免之前“假数据”的问题。但它却带来了新的问题。</p>\n<h4 id=\"写缓存失败了\"><a href=\"#写缓存失败了\" class=\"headerlink\" title=\"写缓存失败了\"></a>写缓存失败了</h4><p>如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526558901.png\" alt=\"图片\"></p>\n<p>如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。</p>\n<p>但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。</p>\n<p>也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。</p>\n<p>这就会出现：数据库是<code>新数据</code>，而缓存是<code>旧数据</code>，两边<code>数据不一致</code>的情况。</p>\n<h4 id=\"高并发下的问题\"><a href=\"#高并发下的问题\" class=\"headerlink\" title=\"高并发下的问题\"></a>高并发下的问题</h4><p>假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a 和 b，它们同时请求到业务系统。</p>\n<p>其中请求 a 获取的是旧数据，而请求 b 获取的是新数据，如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526645914.png\" alt=\"图片\"></p>\n<ol>\n<li>请求 a 先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。</li>\n<li>这时候请求 b 过来了，先写了数据库。</li>\n<li>接下来，请求 b 顺利写了缓存。</li>\n<li>此时，请求 a 卡顿结束，也写了缓存。</li>\n</ol>\n<p>很显然，在这个过程当中，请求 b 在缓存中的<code>新数据</code>，被请求 a 的<code>旧数据</code>覆盖了。</p>\n<p>也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。</p>\n<h4 id=\"浪费系统资源\"><a href=\"#浪费系统资源\" class=\"headerlink\" title=\"浪费系统资源\"></a>浪费系统资源</h4><p>有些业务场景比较特殊：<code>写多读少</code>。</p>\n<p>如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。</p>\n<p>还不如不用 Redis，反正写数据库都要写，我读数据又比较少，Redis 使用频率低，却还要一直更新 Redis 中数据。</p>\n<h3 id=\"先删缓存，再写数据库\"><a href=\"#先删缓存，再写数据库\" class=\"headerlink\" title=\"先删缓存，再写数据库\"></a>先删缓存，再写数据库</h3><p>不然是先写缓存还是先写数据库都有很多问题，那么考虑不是 <code>更新缓存</code> 而是 <code>删除缓存</code>。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526855730.png\" alt=\"图片\"></p>\n<p>在用户的写操作中，先执行删除缓存操作，再去写数据库</p>\n<h4 id=\"高并发下的问题-1\"><a href=\"#高并发下的问题-1\" class=\"headerlink\" title=\"高并发下的问题\"></a>高并发下的问题</h4><p>假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求 c，还有另一个写数据请求 d（一个更新操作），同时请求到业务系统。如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650527043982.png\" alt=\"图片\"></p>\n<ol>\n<li>请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</li>\n<li>这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</li>\n<li>请求 c 将数据库中的旧值，更新到缓存中。</li>\n<li>此时，请求 d 卡顿结束，把新值写入数据库。</li>\n</ol>\n<p>在这个过程当中，请求 d 的新值并没有被请求 c 写入缓存，同样会导致缓存和数据库的数据不一致的情况。</p>\n<h4 id=\"缓存双删\"><a href=\"#缓存双删\" class=\"headerlink\" title=\"缓存双删\"></a>缓存双删</h4><p>在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。</p>\n<p>有人说还不好办，请求 d 在写完数据库之后，把缓存重新删一次不就行了？</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528097218.png\" alt=\"图片\"></p>\n<p>这就是我们所说的<code>缓存双删</code>，即在写数据库之前删除一次，写完数据库后，再删除一次。</p>\n<p>该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的<code>时间间隔</code>之后。</p>\n<p>我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：</p>\n<ol>\n<li>请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</li>\n<li>这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</li>\n<li>请求 c 将数据库中的旧值，更新到缓存中。</li>\n<li>此时，请求 d 卡顿结束，把新值写入数据库。</li>\n<li>一段时间之后，比如：500ms，请求 d 将缓存删除。</li>\n</ol>\n<p>这样来看确实可以解决缓存不一致问题。</p>\n<p>那么，为什么一定要间隔一段时间之后，才能删除缓存呢？</p>\n<p>请求 d 卡顿结束，把新值写入数据库后，请求 c 将数据库中的旧值，更新到缓存中。</p>\n<p>此时，如果请求 d 删除太快，在请求 c 将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求 c 更新缓存之后，再删除缓存，才能把旧值及时删除了。</p>\n<p>所以需要在请求 d 中加一个时间间隔，确保请求 c，或者类似于请求 c 的其他请求，如果在缓存中设置了旧值，最终都能够被请求 d 删除掉。</p>\n<p>接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？</p>\n<h3 id=\"先写数据库，再删缓存\"><a href=\"#先写数据库，再删缓存\" class=\"headerlink\" title=\"先写数据库，再删缓存\"></a>先写数据库，再删缓存</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528137396.png\" alt=\"图片\"></p>\n<p>在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：</p>\n<ol>\n<li>请求 e 先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。</li>\n<li>请求 f 查询缓存，发现缓存中有数据，直接返回该数据。</li>\n<li>请求 e 删除缓存。</li>\n</ol>\n<p>在这个过程中，只有请求 f 读了一次旧数据，后来旧数据被请求 e 及时删除了，看起来问题不大。</p>\n<p>但如果是读数据请求先过来呢？</p>\n<ol>\n<li>请求 f 查询缓存，发现缓存中有数据，直接返回该数据。</li>\n<li>请求 e 先写数据库。</li>\n<li>请求 e 删除缓存。</li>\n</ol>\n<p>这种情况看起来也没问题呀？</p>\n<p>答：对的。</p>\n<p>但就怕出现下面这种情况，即缓存自己失效了。如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528267733.png\" alt=\"图片\"></p>\n<ol>\n<li>缓存过期时间到了，自动失效。</li>\n<li>请求 f 查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。</li>\n<li>请求 e 先写数据库，接着删除了缓存。</li>\n<li>请求 f 更新旧值到缓存中。</li>\n</ol>\n<p>这时，缓存和数据库的数据同样出现不一致的情况了。</p>\n<p>但这种情况还是比较少的，需要同时满足以下条件才可以：</p>\n<ol>\n<li>缓存刚好自动失效。</li>\n<li>请求 f 从数据库查出旧值，更新缓存的耗时，比请求 e 写数据库，并且删除缓存的还长。</li>\n</ol>\n<p>我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。</p>\n<p>由此可见，系统同时满足上述两个条件的概率非常小。</p>\n<blockquote>\n<p>推荐大家使用先写数据库，再删缓存的方案，虽说不能100%避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。</p>\n</blockquote>\n<p>但在该方案中，如果删除缓存失败了该怎么办呢？</p>\n<h3 id=\"删缓存失败怎么办？\"><a href=\"#删缓存失败怎么办？\" class=\"headerlink\" title=\"删缓存失败怎么办？\"></a>删缓存失败怎么办？</h3><p>其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。</p>\n<p>那么，删除缓存失败怎么办呢？</p>\n<p>答：需要加<code>重试机制</code>。</p>\n<p>在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试 3 次。如果其中有任何一次成功，则直接返回成功。如果 3 次都失败了，则写入数据库，准备后续再处理。</p>\n<p>当然，如果你在接口中直接<code>同步重试</code>，该接口并发量比较高的时候，可能有点影响接口性能。</p>\n<p>这时，就需要改成<code>异步重试</code>了。</p>\n<p>异步重试方式有很多种，比如：</p>\n<ol>\n<li>每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统 OOM 问题，不太建议使用。</li>\n<li>将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。</li>\n<li>将重试数据写表，然后使用 elastic-job 等定时任务进行重试。</li>\n<li>将重试的请求写入 mq 等消息中间件中，在 mq 的 consumer 中处理。</li>\n<li>订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</li>\n</ol>\n<h4 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h4><p>使用<code>定时任务重试</code>的具体方案如下：</p>\n<ol>\n<li><p>当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528474531.png\" alt=\"图片\"></p>\n</li>\n<li><p>在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为 0。然后重试 5 次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528480542.png\" alt=\"图片\"></p>\n</li>\n<li><p>在高并发场景中，定时任务推荐使用<code>elastic-job</code>。相对于 xxl-job 等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7 秒等。</p>\n</li>\n</ol>\n<p>使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。</p>\n<p>但它有一个很大的优点，即数据是落库的，不会丢数据。</p>\n<h4 id=\"mq\"><a href=\"#mq\" class=\"headerlink\" title=\"mq\"></a>mq</h4><p>在高并发的业务场景中，mq（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。</p>\n<p>mq 的生产者，生产了消息之后，通过指定的 topic 发送到 mq 服务器。然后 mq 的消费者，订阅该 topic 的消息，读取消息数据之后，做业务逻辑处理。</p>\n<p>使用<code>mq重试</code>的具体方案如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528506474.png\" alt=\"图片\"></p>\n<ol>\n<li>当用户操作写完数据库，但删除缓存失败了，产生一条 mq 消息，发送给 mq 服务器。</li>\n<li>mq 消费者读取 mq 消息，重试 5 次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则写入<code>死信队列</code>中。</li>\n<li>推荐 mq 使用<code>rocketmq</code>，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。</li>\n</ol>\n<p>当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送 mq 消息，到 mq 服务器，然后有 mq 消费者全权负责删除缓存的任务。</p>\n<p>因为 mq 的实时性还是比较高的，因此改良后的方案也是一种不错的选择。</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>前面我们聊过的，无论是定时任务，还是 mq（消息队列），做重试机制，对业务都有一定的侵入性。</p>\n<p>在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。</p>\n<p>而使用 mq 的方案中，如果删除缓存失败了，需要在业务代码中发送 mq 消息到 mq 服务器。</p>\n<p>其实，还有一种更优雅的实现，即<code>监听binlog</code>，比如使用：<code>canal</code>等中间件。</p>\n<p>具体方案如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528533430.png\" alt=\"图片\"></p>\n<ol>\n<li>在业务接口中写数据库之后，就不管了，直接返回成功。</li>\n<li>mysql 服务器会自动把变更的数据写入 binlog 中。</li>\n<li>binlog 订阅者获取变更的数据，然后删除缓存。</li>\n</ol>\n<p>这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在 binlog 订阅者中做缓存删除工作。</p>\n<p>但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。</p>\n<p>如何解决这个问题呢？</p>\n<p>答：这就需要加上前面聊过的<code>重试机制</code>了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入 mq，让 mq 自动重试。</p>\n<p>在这里推荐使用<code>mq自动重试机制</code>。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528538202.png\" alt=\"图片\"></p>\n<p>在 binlog 订阅者中如果删除缓存失败，则发送一条 mq 消息到 mq 服务器，在 mq 消费者中自动重试 5 次。如果有任意一次成功，则直接返回成功。如果重试 5 次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。</p>\n<hr>\n<h2 id=\"Redis-线程模型\"><a href=\"#Redis-线程模型\" class=\"headerlink\" title=\"Redis 线程模型\"></a>Redis 线程模型</h2><h3 id=\"单线程的Redis为什么这么快\"><a href=\"#单线程的Redis为什么这么快\" class=\"headerlink\" title=\"单线程的Redis为什么这么快\"></a>单线程的Redis为什么这么快</h3><ol>\n<li><p>纯内存操作</p>\n</li>\n<li><p>单线程操作，避免了频繁的上下文切换</p>\n</li>\n<li><p>采用了非阻塞 I&#x2F;O 多路复用机制</p>\n</li>\n</ol>\n<h3 id=\"Redis-为什么是单线程的\"><a href=\"#Redis-为什么是单线程的\" class=\"headerlink\" title=\"Redis 为什么是单线程的\"></a>Redis 为什么是单线程的</h3><p>官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p>\n<p>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦）。Redis 利用队列将并发访问变为串行访问</p>\n<p>1、绝大部分请求是纯粹的内存操作（非常快速）</p>\n<p>2、采用单线程，避免了不必要的上下文切换和竞争条件</p>\n<p>3、非阻塞 IO 优点：</p>\n<ul>\n<li>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)</li>\n<li>支持丰富数据类型，支持 string，list，set，sorted set，hash</li>\n<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>\n<li>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除如何解决 Redis 的并发竞争 key 问题</li>\n</ul>\n<p><strong>同时有多个子系统去set一个key。这个时候要注意什么呢？</strong></p>\n<p>不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 Redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p>\n<ul>\n<li>如果对这个 key 操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可</li>\n<li>如果对这个 key 操作，要求顺序：分布式锁+时间戳。假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。</li>\n<li>利用队列，将 set 方法变成串行访问也可以 Redis 遇到高并发，如果保证读写 key 的一致性</li>\n</ul>\n<p>对 Redis 的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题,Redis 内部已经帮你处理好并发的问题了。</p>\n<h3 id=\"为什么Redis的操作是原子性的，怎么保证原子性的？\"><a href=\"#为什么Redis的操作是原子性的，怎么保证原子性的？\" class=\"headerlink\" title=\"为什么Redis的操作是原子性的，怎么保证原子性的？\"></a>为什么Redis的操作是原子性的，怎么保证原子性的？</h3><p>对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。</p>\n<p>Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。（Redis 新版本已经引入多线程，这里基于旧版本的 Redis）</p>\n<p>Redis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操作的原子性。</p>\n<p>多个命令在并发中也是原子性的吗？</p>\n<p>不一定， 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用 Redis+Lua 的方式实现.</p>\n<h3 id=\"讲解下Redis线程模型\"><a href=\"#讲解下Redis线程模型\" class=\"headerlink\" title=\"讲解下Redis线程模型\"></a>讲解下Redis线程模型</h3><p>文件事件处理器包括分别是套接字、 I&#x2F;O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I&#x2F;O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>\n<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>\n<p>I&#x2F;O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。</p>\n<p><strong>工作原理：</strong></p>\n<p>I&#x2F;O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。</p>\n<p>尽管多个文件事件可能会并发地出现， 但 I&#x2F;O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：</p>\n<p>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I&#x2F;O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</p>\n<h2 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247507942&idx=1&sn=e00fd16ec56d0e10cc830678ee25c417&chksm=e92ae2e9de5d6bff6d227646c12685a5c45a4c3322e2186954555a14ebcd9510e8ae579a4941&mpshare=1&scene=24&srcid=0324gng7YtX5XX0z9bf7aObR&sharer_sharetime=1648080975816&sharer_shareid=ebfad4e5798246e3d3928c1f4ee9048e#rd\">原创 一洺 <a href=\"javascript:void(0);\">阿里开发者</a> 2022-03-24 08:00</a></p>\n<p><a href=\"https://blog.csdn.net/qq_31387317/category_7391502.html\">https://blog.csdn.net/qq_31387317/category_7391502.html</a></p>\n","site":{"data":{}},"length":39274,"excerpt":"<blockquote>\n<p>整理的 Redis 相关知识点和面试题，部分内容摘自网络，如有侵权请联系我～","more":"</p>\n</blockquote>\n<h2 id=\"什么是NoSQL？\"><a href=\"#什么是NoSQL？\" class=\"headerlink\" title=\"什么是NoSQL？\"></a>什么是NoSQL？</h2><p>NoSQL &#x3D; not only sql（不仅仅是 SQL）</p>\n<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>\n<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>\n<p>NoSQL 泛指非关系型数据库，随着 web2.0 互联网的诞生，传统的关系型数据库很难对付 web2.0 大数据时代。尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL 在当今大数据环境下发展的十分迅速，Redis 是发展最快的。</p>\n<p>传统 RDBMS（关系数据库管理系统）和 NoSQL（非关系型数据库）比较：</p>\n<p>RDBMS：</p>\n<ul>\n<li>组织化结构</li>\n<li>固定 SQL</li>\n<li>数据和关系都存在单独的表中（行列）</li>\n<li>DML（数据操作语言）、DDL（数据定义语言）等</li>\n<li>严格的一致性（ACID）：原子性、一致性、隔离性、持久性</li>\n<li>基础的事务</li>\n</ul>\n<p>NoSQL：</p>\n<ul>\n<li>不仅仅是数据</li>\n<li>没有固定查询语言</li>\n<li>键值对存储（Redis）、列存储（HBase）、文档存储（MongoDB）、图形数据库（不是存图形，放的是关系）（Neo4j）</li>\n<li>最终一致性（BASE）：基本可用、软状态&#x2F;柔性事务、最终一致性</li>\n</ul>\n<hr>\n<h2 id=\"Redis是什么？\"><a href=\"#Redis是什么？\" class=\"headerlink\" title=\"Redis是什么？\"></a>Redis是什么？</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>Redis &#x3D; Remote Dictionary Server，即远程字典服务。</p>\n<p>Redis 是一个用 C 语言开发的、基于内存结构进行<strong>键值对</strong>数据存储的、高性能的、非关系型 NoSQL 数据库</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p><strong>纯内存操作，性能非常出色</strong>，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。支持保存多种数据结构，可以用来实现很多有用的功能。</p>\n<p>Redis 的主要缺点是<strong>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写</strong>，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p>\n<h3 id=\"为什么要用缓存\"><a href=\"#为什么要用缓存\" class=\"headerlink\" title=\"为什么要用缓存\"></a>为什么要用缓存</h3><p><strong>1、 高性能：</strong></p>\n<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可。</p>\n<p><strong>2、高并发：</strong></p>\n<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，缓解数据库压力。</p>\n<h3 id=\"Redis-与-Memcached-相比有哪些优势\"><a href=\"#Redis-与-Memcached-相比有哪些优势\" class=\"headerlink\" title=\"Redis 与 Memcached 相比有哪些优势\"></a>Redis 与 Memcached 相比有哪些优势</h3><p>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</p>\n<p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memecache 把数据全部存在内存之中。</p>\n<p>Redis 使用单线程的多路 IO 复用模型；Memcached 是多线程，非阻塞 IO 复用的网络模型。</p>\n<hr>\n<h2 id=\"Redis五大基本类型\"><a href=\"#Redis五大基本类型\" class=\"headerlink\" title=\"Redis五大基本类型\"></a>Redis五大基本类型</h2><p><a href=\"https://www.redis.net.cn/order/\">Redis 命令大全</a></p>\n<p><a href=\"https://juejin.cn/post/6857667542652190728\">Redis 应用场景</a></p>\n<h3 id=\"String（字符串）\"><a href=\"#String（字符串）\" class=\"headerlink\" title=\"String（字符串）\"></a>String（字符串）</h3><blockquote>\n<ol>\n<li><p>String 类型是 Redis 的最基础的数据结构，也是最经常使用到的类型。而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以 String 类型是 Redis 的基础。</p>\n</li>\n<li><p>String 类型的值最大能存储 512MB，这里的 String 类型可以是简单字符串、  复杂的 xml&#x2F;json 的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串。</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>应用场景</strong></p>\n<p>1、缓存功能：String 字符串是最常用的数据类型，不仅仅是 Redis，各个语言都是最基本类型，因此，利用 Redis 作为缓存，配合其它数据库作为存储层，利用 Redis 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p>\n<p>2、计数器：许多系统都会使用 Redis 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p>\n<p>3、共享用户 session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie 保存在客户端，有安全隐患。这时可以利用 Redis 将用户的 session 集中管理，在这种模式只需要保证 Redis 的高可用，每次用户 session 的更新和获取都可以快速完成。大大提高效率。（分布式会话）</p>\n<h3 id=\"List（列表）\"><a href=\"#List（列表）\" class=\"headerlink\" title=\"List（列表）\"></a>List（列表）</h3><blockquote>\n<ol>\n<li>List 是简单的字符串列表</li>\n<li>Redis 可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。Redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。</li>\n</ol>\n</blockquote>\n<p><strong>应用场景</strong></p>\n<p>1、消息队列：Redis 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过 lpush 命令从左边插入数据，多个数据消费者，可以使用 rpop 命令阻塞的“抢”列表尾部的数据。</p>\n<p>2、文章列表或者数据分页展示的应用。比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 Redis 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p>\n<h3 id=\"Set（集合）\"><a href=\"#Set（集合）\" class=\"headerlink\" title=\"Set（集合）\"></a>Set（集合）</h3><blockquote>\n<ol>\n<li>Redis 集合 set 类型和 list 列表类型类似，都可以用来存储多个字符串元素的集合。</li>\n<li>但是和 list 不同的是 set 集合当中不允许重复的元素。而且 set 集合当中元素是没有顺序的，不存在元素下标。</li>\n<li>Redis 的 set 类型是使用哈希表构造的，因此复杂度是 O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。</li>\n</ol>\n</blockquote>\n<p><strong>应用场景</strong></p>\n<p>1、标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。</p>\n<p>2、共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。</p>\n<p>3、统计网站的独立 IP。利用 set 集合当中元素不唯一性，可以快速实时统计访问网站的独立 IP。</p>\n<h3 id=\"sorted-set（有序集合）\"><a href=\"#sorted-set（有序集合）\" class=\"headerlink\" title=\"sorted set（有序集合）\"></a>sorted set（有序集合）</h3><blockquote>\n<p>Redis 有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。</p>\n</blockquote>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>1、排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>\n<p>2、用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p>\n<h3 id=\"hash（哈希）\"><a href=\"#hash（哈希）\" class=\"headerlink\" title=\"hash（哈希）\"></a>hash（哈希）</h3><p>Redis hash 数据结构 是一个键值对（key-value）集合，它是一个 string 类型的 field 和 value 的映射表，Redis 本身就是一个 key-value 型数据库，因此 hash 数据结构相当于在 value 中又套了一层 key-value 型数据。所以 Redis 中 hash 数据结构特别适合存储关系型对象。</p>\n<blockquote>\n<p>用户 ID 为查找的key，存储的 value 用户对象包含姓名，年龄，生日等信息，如果用普通的 key&#x2F;value 结构来存储</p>\n<ol>\n<li>将用户 ID 作为 key，姓名属性+姓名数据整体作为 value。缺点是每次修改用户的某个属性，都需要先反序列化 属性+数据，修改好，然后将 属性+数据 序列化之后在修改回去，开销较大。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356860189.png\" alt=\"ID -&gt; 属性+数据\"></p>\n<ol start=\"2\">\n<li>将用户 ID+姓名属性作为 key，姓名数据作为 value。缺点是用户 ID 使用多次，数据冗余</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356955204.png\" alt=\"ID+属性 -&gt; 数据\"></p>\n<ol start=\"3\">\n<li>因此通过 key(用户 ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356950290.png\" alt=\"ID -&gt; 属性 -&gt; 数据\"></p>\n</blockquote>\n<h4 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>1、由于 hash 数据类型的 key-value 的特性，用来存储关系型数据库中表记录，是 Redis 中哈希类型最常用的场景。一条记录作为一个 key-value，把每列属性值对应成 field-value 存储在哈希表当中，然后通过 key 值来区分表当中的主键。</p>\n<p>2、经常被用来存储用户相关信息。优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能。</p>\n<hr>\n<h2 id=\"五大基本类型底层数据结构\"><a href=\"#五大基本类型底层数据结构\" class=\"headerlink\" title=\"五大基本类型底层数据结构\"></a>五大基本类型底层数据结构</h2><p>Redis 整体的存储结构：</p>\n<p>Redis 内部整体的存储结构是一个大的 hashmap，内部是数组实现的 hash，key 冲突通过挂链表去实现，每个 dictEntry 为一个 key&#x2F;value 对象，value 为定义的 redisObject。</p>\n<p>结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650433179786.png\" alt=\"Redis 整体的存储结构\"></p>\n<p>dictEntry 是存储 key-&gt;value 的地方，其中包含指向具体的 redisObject 的指针。</p>\n<p>redisObject 中*ptr 指向具体的数据结构的地址；type 表示该对象的类型，即 String、List、Hash、Set、Zset 中的一个</p>\n<h3 id=\"String-arrayList\"><a href=\"#String-arrayList\" class=\"headerlink\" title=\"String (arrayList)\"></a>String (arrayList)</h3><p>String 的数据结构为简单动态字符串(Simple Dynamic String，缩写 SDS)。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650356547555.png\" alt=\"String 的数据结构\"></p>\n<p>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>\n<h3 id=\"List-ziplist-quickList\"><a href=\"#List-ziplist-quickList\" class=\"headerlink\" title=\"List (ziplist - quickList)\"></a>List (ziplist - quickList)</h3><p>1、Redis 3.2 之前的底层实现方式：压缩列表 ziplist 或者 双向循环链表 linkedlist</p>\n<p>当 list 存储的数据量比较少且同时满足下面两个条件时，list 就使用 ziplist 存储数据：</p>\n<ul>\n<li>list 中保存的每个元素的长度小于 64 字节；</li>\n<li>列表中数据个数少于 512 个。</li>\n</ul>\n<p>2、Redis 3.2 及之后的底层实现方式：quicklist</p>\n<p>quicklist 是一个基于 ziplist 的双向链表，quicklist 的每个节点都是一个 ziplist，结合了双向链表和 ziplist 的优点。</p>\n<h4 id=\"ziplist\"><a href=\"#ziplist\" class=\"headerlink\" title=\"ziplist\"></a><strong>ziplist</strong></h4><p>ziplist 是压缩列表，它的好处是能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用 ziplist 存储。但当数据量过大时就 ziplist 就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是 O(N)，即每次插入都会重新进行 realloc 重新分配内存空间。</p>\n<p>ziplist 结构如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419709341.png\" alt=\"ziplist 结构图\"></p>\n<p>1、zlbytes：用于记录整个压缩列表占用字节数</p>\n<p>2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节，用于快速定位到最后一个节点，从而可以在 ziplist 尾部快速的执行 push，pop 操作</p>\n<p>3、zllen：记录了压缩列表包含的节点数量。</p>\n<p>4、entryX：压缩列表包含的各个节点</p>\n<p>5、zlend：用于标记压缩列表的末端，用来快速定位到最后一个元素，然后倒着遍历。（entry 块的 prevlen 字段表示前一个 entry 的字节长度，当压缩列表倒着遍历时，需要通过这个字段来快速定位到下一个元素的位置。）</p>\n<p><strong>为什么数据量大时不用 ziplist？</strong></p>\n<p>因为 ziplist 是一段连续的内存，插入的时间复杂化度为 O(n)，而且每当插入新的元素需要 realloc 做内存扩展；而且如果超出 ziplist 内存大小，还会做重新分配的内存空间，并将内容复制到新的地址。如果数量大的话，重新分配内存和拷贝内存会消耗大量时间。所以不适合大型字符串，也不适合存储量多的元素。</p>\n<h4 id=\"quickList\"><a href=\"#quickList\" class=\"headerlink\" title=\"quickList\"></a>quickList</h4><p>快速列表是 ziplist 和 linkedlist 的混合体，是将 linkedlist 按段切分，每一段用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针链接。</p>\n<p><strong>为什么不直接使用 linkedlist？</strong></p>\n<p>linkedlist 的附加空间相对太高，prev 和 next 指针就要占去 16 个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p>\n<p>quicklist 结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650419719663.png\" alt=\"quicklist 结构图\"></p>\n<p><strong>ziplist的长度</strong></p>\n<p>quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。关于长度可以使用 list-max-ziplist-size 决定。</p>\n<p><strong>压缩深度</strong></p>\n<p>我们上面说到了 quicklist 下是用多个 ziplist 组成的，同时为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩，可以选择压缩深度。quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数 list-compress-depth 决定。为了支持快速 push&#x2F;pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p>\n<h3 id=\"Hash-ziplist-dict\"><a href=\"#Hash-ziplist-dict\" class=\"headerlink\" title=\"Hash (ziplist - dict)\"></a>Hash (ziplist - dict)</h3><h4 id=\"ziplist-1\"><a href=\"#ziplist-1\" class=\"headerlink\" title=\"ziplist\"></a>ziplist</h4><p>当 Hash 中数据项比较少的情况下，Hash 底层才用压缩列表 ziplist 进行存储数据，随着数据的增加，底层的 ziplist 就可能会转成 dict，具体配置如下</p>\n<blockquote>\n<p>hash-max-ziplist-entries 512<br>hash-max-ziplist-value 64</p>\n</blockquote>\n<p>在如下两个条件之一满足的时候，ziplist 会转成 dict：</p>\n<ul>\n<li>当 hash 中的数据项的数目超过 512 的时候，也就是 ziplist 数据项超过 1024 的时候；</li>\n<li>当 hash 中插入的任意一个 value 的长度超过了 64 的时候。</li>\n</ul>\n<p>每当有新的键值对加入到哈希对象时，先压入键，再压入值，如图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/20190703171927309.png\" alt=\"ziplist实现的hash\"></p>\n<p>当遍历时，从头到尾的遍历，且跳过值节点。</p>\n<h4 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h4><p>字典的哈希表结构和 Java 的 HashMap 结构几乎是一样的，都是通过某个哈希函数从 key 计算得到在哈希表中的位置，采用链表法解决冲突。Redis 这里使用的是单链表，为了查询效率每次把新数据插入到链表头位置（使用头插法是因为新插入的数据被访问的概率大，可以更快访问到）。</p>\n<p>我们可以看到每个 dict 中都有两个 hashtable，结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420119549.png\" alt=\"dict实现的hash\"></p>\n<p>虽然 dict 结构有两个 hashtable，但是通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容的时候，需要分配新的 hashtable，然后进行渐近式搬迁，这时候两个 hashtable 存储的旧的 hashtable 和新的 hashtable。搬迁结束后，旧 hashtable 删除，新的取而代之。</p>\n<p><strong>渐进式 rehash</strong></p>\n<p>所谓渐进式 rehash 是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个 O(n)的操作。但是因为我们的 Redis 是单线程的，无法承受这样的耗时过程，所以采用了渐进式 rehash 小步搬迁，虽然慢一点，但是可以搬迁完毕。</p>\n<p><strong>扩容条件</strong></p>\n<p>我们的扩容一般会在 Hash 表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在 Redis 在做 bgsave（RDB 持久化操作的过程），为了减少内存页的过多分离（Copy On Write），Redis 不会去扩容。但是如果 hash 表的元素个数已经到达了第一维数组长度的 5 倍的时候，就会强制扩容，不管你是否在持久化。</p>\n<p>不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。</p>\n<p><strong>缩容条件</strong></p>\n<p>当我们的 hash 表元素逐渐删除的越来越少的时候。Redis 于是就会对 hash 表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的 10%，并且缩容不考虑是否在做 Redis 持久化。</p>\n<p>不用考虑 bgsave 主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p>\n<p><strong>rehash 步骤</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420130964.png\" alt=\"rehash 步骤\"></p>\n<h3 id=\"Set-intset-hashSet\"><a href=\"#Set-intset-hashSet\" class=\"headerlink\" title=\"Set (intset - hashSet)\"></a>Set (intset - hashSet)</h3><p>Redis 的集合相当于 Java 中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合 Set 类型底层编码包括 inset 和 hashtable。</p>\n<p>当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合 intset 来实现 set 这种数据类型：</p>\n<blockquote>\n<p>存储的数据都是整数<br>存储的数据元素个数小于512个</p>\n</blockquote>\n<p>当不能同时满足这两个条件的时候，Redis 就使用 dict 来存储集合中的数据</p>\n<p><strong>intset</strong></p>\n<p>intset 是一个有序集合，查找元素的复杂度为 O(logN)（采用二分法），但插入时不一定为 O(logN)，因为有可能涉及到升级操作。比如当集合里全是 int16_t 型的整数，这时要插入一个 int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成 int32_t 类型，涉及到内存的重新分配，这时插入的复杂度就为 O(N)了。是 intset 不支持降级操作。</p>\n<p><strong>intset 是有序不要和 zset 搞混，zset 是设置一个 score 来进行排序，而 intset 这里只是单纯的对整数进行升序而已</strong></p>\n<h3 id=\"Sorted-Set-ziplist-zset-dict-skipList\"><a href=\"#Sorted-Set-ziplist-zset-dict-skipList\" class=\"headerlink\" title=\"Sorted Set (ziplist - zset(dict + skipList))\"></a>Sorted Set (ziplist - zset(dict + skipList))</h3><p>Zset 有序集合和 set 集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数 score，作为排序的依据。</p>\n<p>当数据较少时，sorted set 是由 ziplist 来实现的。<br>当数据多的时候，sorted set 是由 zset 的数据结构来实现的，这个 zset 包含一个 dict + 一个 skiplist。dict 用来查询数据到分数(score)的对应关系，而 skiplist 用来根据指定分数 score 的范围来获取 value 列表。</p>\n<p><strong>sorted set ziplist 实现</strong></p>\n<p>在这里我们先来讨论一下前一种情况——基于 ziplist 实现的 sorted set。ziplist 就是由很多数据项组成的一大块连续内存。由于 sorted set 的每一项元素都由数据和 score 组成，因此，当使用 zadd 命令插入一个(数据, score)对的时候，底层在相应的 ziplist 上就插入两个数据项：数据在前，score 在后。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650431975904.png\" alt=\"基于 ziplist 实现的 sorted set\"></p>\n<p>ziplist 的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set 的各个查询操作，就是在 ziplist 上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p>\n<p>随着数据的插入，sorted set 底层的这个 ziplist 就可能会转成 zset 的实现。那么到底插入多少才会转呢？</p>\n<blockquote>\n<p>zset-max-ziplist-entries 128\t# 当sorted set中的元素个数，即(数据， score)对的数目超过128的时候<br>zset-max-ziplist-value 64\t# 当sorted set中插入的任意一个数据的长度超过了64的时候。</p>\n</blockquote>\n<p><strong>sorted set ziplist实现</strong><br>Redis 的 zset 是一个复合结构，一方面它需要一个 hash 结构来存储 value 和 score 的对应关系，另一方面需要提供按照 score 来排序的功能，还需要能够指定 score 的范围来获取 value 列表的功能，这就需要另外一个结构「跳跃表」。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zset</span> &#123;</span></span><br><span class=\"line\">    dict *dict;</span><br><span class=\"line\">    zskiplist *zsl;</span><br><span class=\"line\">&#125; zset;</span><br></pre></td></tr></table></figure>\n\n<p>跳表：链表+多级索引（空间换时间）</p>\n<p>和其他结构的比较：</p>\n<p>对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>\n<hr>\n<h2 id=\"三大特殊数据类型\"><a href=\"#三大特殊数据类型\" class=\"headerlink\" title=\"三大特殊数据类型\"></a>三大特殊数据类型</h2><h3 id=\"geospatial（地理位置）\"><a href=\"#geospatial（地理位置）\" class=\"headerlink\" title=\"geospatial（地理位置）\"></a>geospatial（地理位置）</h3><ol>\n<li>查看附近的人</li>\n<li>微信位置共享</li>\n<li>地图上直线距离的展示</li>\n</ol>\n<h3 id=\"Hyperloglog（基数）\"><a href=\"#Hyperloglog（基数）\" class=\"headerlink\" title=\"Hyperloglog（基数）\"></a>Hyperloglog（基数）</h3><p>基数：不重复的元素</p>\n<p>网页统计 UV （浏览用户数量，同一天同一个 ip 多次访问算一次访问，目的是计数，而不是保存用户）</p>\n<p>传统的方式，set 保存用户的 id，可以统计 set 中元素数量作为标准判断。</p>\n<p>但如果这种方式保存大量用户 id，会占用大量内存，我们的目的是为了计数，而不是去保存 id。</p>\n<h3 id=\"Bitmaps（位存储）\"><a href=\"#Bitmaps（位存储）\" class=\"headerlink\" title=\"Bitmaps（位存储）\"></a>Bitmaps（位存储）</h3><p>Redis 提供了 Bitmaps 这个“数据类型”可以实现对位的操作：</p>\n<ol>\n<li>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li>\n<li>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</li>\n</ol>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li><p>setbit</p>\n<p> <code>setbit&lt;key&gt;&lt;offset&gt;&lt;value&gt;</code> 设置 Bitmaps 中某个偏移量的值（0 或 1）</p>\n<p> 可以将 idx 位置为 1 表示 idx 用户访问过</p>\n</li>\n<li><p>getbit</p>\n<p> <code>getbit&lt;key&gt;&lt;offset&gt;</code> 获取 Bitmaps 中某个偏移量的值</p>\n<p> 通过 idx 位是否为 1 判断 idx 用户是否访问过</p>\n</li>\n<li><p>bitcount</p>\n<p> <code>bitcount&lt;key&gt;[start end]</code> 统计字符串从 start 字节到 end 字节比特值为 1 的数量</p>\n</li>\n<li><p>bitop</p>\n<p> <code>bitop and(or/not/xor) &lt;destkey&gt; [key…]</code> bitop 是一个复合操作， 它可以做多个 Bitmaps 的 and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在 destkey 中。</p>\n</li>\n</ol>\n<h4 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a><strong>应用场景</strong></h4><p><strong>两种状态的统计</strong>都可以使用 bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。</p>\n<hr>\n<h2 id=\"Redis事务与锁机制\"><a href=\"#Redis事务与锁机制\" class=\"headerlink\" title=\"Redis事务与锁机制\"></a>Redis事务与锁机制</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>事务本质：一组命令的集合</p>\n<h4 id=\"数据库的事务\"><a href=\"#数据库的事务\" class=\"headerlink\" title=\"数据库的事务\"></a><strong>数据库的事务</strong></h4><p>数据库事务通过 ACID（原子性、一致性、隔离性、持久性）来保证。</p>\n<p>数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条 SQL 语句在被执行的时候，都会生成一条撤销日志(Undo Log)。</p>\n<h4 id=\"Redis-事务\"><a href=\"#Redis-事务\" class=\"headerlink\" title=\"Redis 事务\"></a>Redis 事务</h4><p>Redis 事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>\n<p>Redis 中一个事务从开始到执行会经历<strong>开始</strong>事务（Muiti）、命令<strong>组队</strong>和<strong>执行</strong>事务(Exec)三个阶段，事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>\n<p>组队的过程中可以通过 discard 来放弃组队。</p>\n<p><strong>事务的错误处理</strong></p>\n<p>组队阶段某个命令报错，执行时整个队列都会被取消。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372301056.png\" alt=\"组队阶段某个命令报错\"></p>\n<p>如果执行阶段某个命令报错，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。（不保证事务的原子性）</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650372359361.png\" alt=\"执行阶段某个命令报错\"></p>\n<p><strong>为什么 Redis 不支持回滚来保证原子性</strong></p>\n<p>Redis 命令只会因为错误的语法而失败，然而没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>\n<h3 id=\"Redis-锁\"><a href=\"#Redis-锁\" class=\"headerlink\" title=\"Redis 锁\"></a>Redis 锁</h3><h4 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h4><p><strong>悲观锁(Pessimistic Lock)<strong>， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417157625.png\" alt=\"悲观锁\"></p>\n<blockquote>\n<p>线程 1 拿到账户后把账户锁住，然后操作，这时候线程 2 也想拿账户，发现加了锁拿不到，只能阻塞等到锁释放。</p>\n</blockquote>\n<h4 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h4><p><strong>乐观锁(Optimistic Lock)，</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在<strong>更新的时候判断</strong>一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis 就是利用这种机制实现事务的。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650417222072.png\" alt=\"乐观锁\"></p>\n<blockquote>\n<p>给账户数据加一个版本号，假如线程 1、2 都拿到账户，线程 1 使用账户前先进行版本号比较，v1.0 &#x3D; v1.0，则扣减账户余额，账户版本号变更为 v1.1，线程 2 准备操作数据库，发现自己预期的账户版本号 v1.0 和当前账户版本号 v1.1 不同（CAS），则不能操作。 </p>\n</blockquote>\n<hr>\n<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><p>Redis 是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题 Redis 供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。</p>\n<p>两种持久化方式：快照（RDB 文件）和追加式文件（AOF 文件），下面分别为大家介绍两种方式的原理。</p>\n<ul>\n<li><p>RDB 持久化方式会在一个特定的间隔保存那个时间点的数据快照。</p>\n</li>\n<li><p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。</p>\n</li>\n<li><p>两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p>\n</li>\n</ul>\n<h3 id=\"RDB-Redis-Database\"><a href=\"#RDB-Redis-Database\" class=\"headerlink\" title=\"RDB(Redis Database)\"></a>RDB(Redis Database)</h3><blockquote>\n<p>在满足特定的  Redis 操作条件（时间周期、写操作次数）时，将内存中的数据以 <strong>数据快照</strong> 的形式存储到 db 文件中</p>\n</blockquote>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a><strong>工作原理</strong></h4><blockquote>\n<p><a href=\"https://www.cnblogs.com/zyf98/p/15934058.html\">Redis_RDB持久化之写时复制技术的应用</a></p>\n</blockquote>\n<p>RDB 是一次的全量备份，即周期性的把 Redis 当前内存中的全量数据写入到一个快照文件中。Redis 是单线程程序，这个线程要同时负责多个客户端的读写请求，还要负责周期性的把当前内存中的数据写到快照文件中 RDB 中，那么就会带来以下两个问题：</p>\n<ol>\n<li>数据写到 RDB 文件是 IO 操作，IO 操作会严重影响 Redis 的性能，甚至在持久化的过程中，读写请求会阻塞</li>\n<li>假如 Redis 正在进行持久化一个大的数据结构，在这个过程中客户端发送一个删除请求，把这个大的数据结构删掉了，这时候持久化的动作还没有完成。</li>\n</ol>\n<p>于是 Redis 使用操作系统的多进程 <strong>写时复制(Copy On Write)机制</strong> 来实现快照的持久化，在持久化过程中调用<strong>glibc</strong>(Linux 下的 C 函数库)的函数 <strong>fork()</strong> 产生一个子进程，该子进程和父进程共享内存里面的代码段和数据段，快照持久化完全交给子进程来处理，父进程继续处理客户端的读写请求。</p>\n<blockquote>\n<p>子进程将数据写入到一个临时 RDB 文件中。当子进程完成持久化时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</p>\n</blockquote>\n<p>在子进程持久化的过程中，如果主进程收到的客户端的读写请求，需要修改某块数据，那么这块数据就会被复制一份到内存，生成该数据的副本，主进程在该副本上进行修改操作。所以即使对某个数据进行了修改，Redis 持久化到 RDB 中的数据也是未修改的数据，这也是把 RDB 文件称为”快照”文件的原因，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。这里再深入一点，Redis 内存中的全量数据由一个个的”数据段页面”组成，每个数据段页面的大小为 4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中，这个复制的过程称为”页面分离”，在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的 2 倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分 Redis 数据还是”冷数据”。</p>\n<p>正因为修改的部分数据会被额外的复制一份，所以会占用额外的内存，当在进行 RDB 持久化操作的过程中，与此同时如果持续往 Redis 中写入的数据量越多，就会导致占用的额外内存消耗越大。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes2093494-20220226233822789-2067752089.png\" alt=\"RDB 持久化\"></p>\n<p><strong>优点</strong>：</p>\n<ol>\n<li>RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</li>\n<li>RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</li>\n<li>RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I&#x2F;O 等操作；</li>\n<li>与 AOF 格式的文件相比，RDB 文件可以更快的重启。</li>\n</ol>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。</li>\n<li>RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</li>\n</ol>\n<h3 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h3><p>以日志的形式来记录每个写的操作，将 Redis 执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<h4 id=\"AOF配置项\"><a href=\"#AOF配置项\" class=\"headerlink\" title=\"AOF配置项\"></a><strong>AOF配置项</strong></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 默认不开启aof  而是使用rdb的方式</span><br><span class=\"line\">appendonly no</span><br><span class=\"line\"></span><br><span class=\"line\"># 默认文件名</span><br><span class=\"line\">appendfilename &quot;appendonly.aof&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 每次修改都会sync 消耗性能</span><br><span class=\"line\"># appendfsync always</span><br><span class=\"line\"># 每秒执行一次 sync 可能会丢失这一秒的数据</span><br><span class=\"line\">appendfsync everysec</span><br><span class=\"line\"># 不执行 sync ，这时候操作系统自己同步数据，速度最快</span><br><span class=\"line\"># appendfsync no </span><br></pre></td></tr></table></figure>\n\n<p>AOF 的整个流程大体来看可以分为两步，第一步是命令的实时写入（如果是 appendfsync everysec 配置，会有 1s 损耗），第二步是对 aof 文件的重写。</p>\n<h4 id=\"AOF-重写机制\"><a href=\"#AOF-重写机制\" class=\"headerlink\" title=\"AOF 重写机制\"></a><strong>AOF 重写机制</strong></h4><p>随着 Redis 的运行，AOF 的日志会越来越长，如果实例宕机重启，那么重放整个 AOF 将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr 一千次，那么就不需要去记录这 1000 次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。</p>\n<p>Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的 AOF 文件，至此完成。</p>\n<p>同样的也可以在 Redis.config 中对重写机制的触发进行配置：</p>\n<p>通过将 no-appendfsync-on-rewrite 设置为 yes，开启重写机制；auto-aof-rewrite-percentage 100 意为比上次从写后文件大小增长了 100%再次触发重写；</p>\n<p>auto-aof-rewrite-min-size 64mb 意为当文件至少要达到 64mb 才会触发制动重写。</p>\n<p><strong>优点</strong>：</p>\n<p>1、数据安全，AOF 是对指令文件进行 <strong>增量更新</strong>，更适合实时性持久化。</p>\n<p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 Redis-check-aof 工具解决数据一致性问题。</p>\n<p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p>\n<p><strong>缺点</strong>：</p>\n<p>1、AOF 文件比 RDB 文件大，且恢复速度慢。</p>\n<p>2、数据集大的时候，比 RDB 启动效率低。</p>\n<h3 id=\"RDB与AOF对比\"><a href=\"#RDB与AOF对比\" class=\"headerlink\" title=\"RDB与AOF对比\"></a>RDB与AOF对比</h3><p>Redis 官方建议同时开启两种持久化策略，AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p>\n<table>\n<thead>\n<tr>\n<th>比较项</th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动优先级</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>体积</td>\n<td>小</td>\n<td>大</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>丢数据</td>\n<td>根据策略决定</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"发布与订阅\"><a href=\"#发布与订阅\" class=\"headerlink\" title=\"发布与订阅\"></a>发布与订阅</h2><p>Redis 发布与订阅是一种消息通信的模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p>\n<p>Redis 通过 PUBLISH 和 SUBSCRIBE 等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是订阅&#x2F;发布到频道、订阅&#x2F;发布到模式的客户端。</p>\n<h3 id=\"频道（channel）\"><a href=\"#频道（channel）\" class=\"headerlink\" title=\"频道（channel）\"></a>频道（channel）</h3><p><strong>订阅</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436261125.png\" alt=\"频道订阅\"></p>\n<p><strong>发布</strong></p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650436267143.png\" alt=\"频道发布\"></p>\n<h4 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a><strong>完整流程</strong></h4><p>发布者向频道 channel:1 发布消息 hi</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; publish channel:1 hi(integer) 1</span><br></pre></td></tr></table></figure>\n\n<p>订阅者订阅消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; subscribe channel:1</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;subscribe&quot; // 消息类型</span><br><span class=\"line\">2) &quot;channel:1&quot; // 频道</span><br><span class=\"line\">3) &quot;hi&quot; // 消息内容</span><br></pre></td></tr></table></figure>\n\n<p>执行 subscribe 后客户端会进入订阅状态，仅可以使 subscribe、unsubscribe、psubscribe 和 punsubscribe 这四个属于”发布&#x2F;订阅”之外的命令</p>\n<p>订阅频道后的客户端可能会收到三种消息类型</p>\n<ul>\n<li><p>subscribe：表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</p>\n</li>\n<li><p>message：表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</p>\n</li>\n<li><p>unsubscribe：表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为 0 时客户端会退出订阅状态，之后就可以执行其他非”发布&#x2F;订阅”模式的命令了。</p>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h4><p>基于 channel 的发布订阅模式是通过字典数据类型实现的</p>\n<blockquote>\n<p>类似hashmap，键为channel，值为订阅了该channel的client，用链表链接起来</p>\n</blockquote>\n<p>其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420774862.png\" alt=\"频道模式数据结构模型\"></p>\n<p><strong>订阅</strong></p>\n<p>当使用 subscribe 订阅时，在字典中找到频道 key（如没有则创建），并将订阅的 client 关联在链表后面。</p>\n<p>当 client 10 执行 <code>subscribe channel1 channel2 channel3</code> 时，会将 client 10 分别加到 channel1 channel2 channel3 关联的链表尾部。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420784179.png\" alt=\"频道订阅\"></p>\n<p><strong>发布</strong></p>\n<p>发布时，根据 key，找到字典汇总 key 的地址，然后将 msg 发送到关联的链表每一台机器。</p>\n<p><strong>退订</strong></p>\n<p>遍历关联的链表，将指定的地址删除即可。</p>\n<h3 id=\"模式（pattern）\"><a href=\"#模式（pattern）\" class=\"headerlink\" title=\"模式（pattern）\"></a>模式（pattern）</h3><p>pattern 使用了通配符的方式来订阅</p>\n<p>通配符中 ? 表示 1 个占位符，* 表示任意个占位符(包括 0)，?* 表示 1 个以上占位符。</p>\n<p>所以当使用 publish 命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个&#x2F;某些模式和这个频道匹配的话， 那么所有订阅这个&#x2F;这些频道的客户端也同样会收到信息。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420803487.png\" alt=\"模式\"></p>\n<h4 id=\"订阅发布完整流程\"><a href=\"#订阅发布完整流程\" class=\"headerlink\" title=\"订阅发布完整流程\"></a><strong>订阅发布完整流程</strong></h4><p>发布者发布消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; publish b m1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; publish b1 m1</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; publish b11 m1</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n\n<p>订阅者订阅消息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; psubscribe b*</span><br><span class=\"line\">Reading messages... (press Ctrl-C to quit)</span><br><span class=\"line\">1) &quot;psubscribe&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) (integer) 3</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) &quot;b&quot;</span><br><span class=\"line\">4) &quot;m1&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) &quot;b1&quot;</span><br><span class=\"line\">4) &quot;m1&quot;</span><br><span class=\"line\">1) &quot;pmessage&quot;</span><br><span class=\"line\">2) &quot;b*&quot;</span><br><span class=\"line\">3) &quot;b11&quot;</span><br><span class=\"line\">4) &quot;m1&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据结构-1\"><a href=\"#数据结构-1\" class=\"headerlink\" title=\"数据结构\"></a><strong>数据结构</strong></h4><p>pattern 属性是一个链表，链表中保存着所有和模式相关的信息。</p>\n<blockquote>\n<p>类似链表，每个pattern节点，包含pattern以及订阅该pattern的client</p>\n</blockquote>\n<p>数据结构图如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420905733.png\" alt=\"模式数据结构\"></p>\n<p><strong>订阅</strong></p>\n<p>当有信的订阅时，会将订阅的客户端和模式信息添加到链表后面。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420913717.png\" alt=\"模式订阅\"></p>\n<p><strong>发布</strong></p>\n<p>当发布者发布消息时，首先会发送到对应的频道上，在遍历模式列表，根据 key 匹配模式，匹配成功将消息发给对应的订阅者。</p>\n<p><strong>退订</strong></p>\n<p>使用 punsubscribe，可以将订阅者退订，将改客户端移除出链表。</p>\n<hr>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p><strong>什么是主从复制</strong></p>\n<p>在多个 Redis 实例建立起主从关系，当 主 Redis 中的数据发生变化，从 Redis 中的数据也会同步变化</p>\n<ul>\n<li>通过主从配置可以实现 Redis 数据的备份（从 Redis 就是对 主 Redis 的备份），保证数据安全性</li>\n<li>主从库之间采用的是读写分离的方式，读操作：主库、从库都可以接收；写操作：首先到主库执行，然后主库将写操作同步给从库</li>\n</ul>\n<p><strong>主从复制的作用</strong></p>\n<ul>\n<li><p>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>\n</li>\n<li><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p>\n</li>\n<li><p>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</p>\n</li>\n<li><p>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础。</p>\n</li>\n</ul>\n<p>主从库采用的是读写分离的方式：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420963646.png\" alt=\"主从库读写分离\"> </p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>分为全量复制与增量复制</p>\n<p>全量复制：发生在第一次复制时</p>\n<p>增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库</p>\n<h3 id=\"全量复制的三个阶段\"><a href=\"#全量复制的三个阶段\" class=\"headerlink\" title=\"全量复制的三个阶段\"></a>全量复制的三个阶段</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNoteskjk7gr48ft.jpeg\" alt=\"全量复制\"></p>\n<p>第一阶段是主从库间建立连接、协商同步的过程。</p>\n<blockquote>\n<p>主要是为全量复制做准备。从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>\n<p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p>\n</blockquote>\n<p>第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>\n<blockquote>\n<p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>\n</blockquote>\n<p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</p>\n<blockquote>\n<p>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>\n</blockquote>\n<h3 id=\"断网增量更新\"><a href=\"#断网增量更新\" class=\"headerlink\" title=\"断网增量更新\"></a>断网增量更新</h3><p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotesg0eezljwqy.jpeg\" alt=\"断网增量更新\"></p>\n<h2 id=\"哨兵机制\"><a href=\"#哨兵机制\" class=\"headerlink\" title=\"哨兵机制\"></a>哨兵机制</h2><blockquote>\n<p>哨兵的核心功能是主节点的自动故障转移</p>\n<ol>\n<li>监控 主库，判断 主库 是否宕机</li>\n<li>主库 如果宕机，则从 从库 中 选举成为 主库（因此需要奇数个哨兵）</li>\n<li>更改主从配置</li>\n</ol>\n</blockquote>\n<p>下图是一个典型的哨兵集群监控的逻辑图：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650420977306.png\" alt=\"哨兵机制\"></p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\"></p>\n<p>Redis Sentinel 包含了若个 Sentinel 节点，这样做也带来了两个好处：</p>\n<ol>\n<li>对于节点的故障判断是由多个 Sentinel 节点共同完成，这样可以有效地防止误判</li>\n<li>即使个别 Sentinel 节点不可用，整个 Sentinel 集群依然是可用的。</li>\n</ol>\n<p>哨兵实现了以下功能</p>\n<ol>\n<li>监控：每个 Sentinel 节点会对数据节点（Redis master&#x2F;slave 节点）和其余 Sentinel 节点进行监控</li>\n<li>通知：Sentinel 节点会将故障转移的结果通知给应用方</li>\n<li>故障转移：实现 slave 晋升为 master，并维护后续正确的主从关系</li>\n<li>配置中心：在 Redis Sentinel 模式中，客户端在初始化的时候连接的是 Sentinel 节点集合，从中获取主节点信息</li>\n</ol>\n<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置中心和通知功能，则需要在与客户端的交互中才能体现。</p>\n<h3 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h3><p>Sentinel 节点需要监控 master、slave 以及其它 Sentinel 节点的状态。这一过程是通过 Redis 的 pub&#x2F;sub 系统实现的。Redis Sentinel 一共有三个定时监控任务，完成对各个节点发现和监控：</p>\n<ol>\n<li>监控主从拓扑信息：每隔 10 秒，每个 Sentinel 节点，会向 master 和 slave 发送 INFO 命令获取最新的拓扑结构</li>\n<li>Sentinel 节点信息交换：每隔 2 秒，每个 Sentinel 节点，会向 Redis 数据节点的<code>sentinel:hello</code> 频道上，发送自身的信息，以及对主节点的判断信息。这样，Sentinel 节点之间就可以交换信息</li>\n<li>节点状态监控：每隔 1 秒，每个 Sentinel 节点，会向 master、slave、其余 Sentinel 节点发送 PING 命令做心跳检测，来确认这些节点当前是否可达</li>\n</ol>\n<h3 id=\"主观-x2F-客观下线\"><a href=\"#主观-x2F-客观下线\" class=\"headerlink\" title=\"主观&#x2F;客观下线\"></a>主观&#x2F;客观下线</h3><h4 id=\"主观下线\"><a href=\"#主观下线\" class=\"headerlink\" title=\"主观下线\"></a>主观下线</h4><p>每个 Sentinel 节点，每隔 1 秒会对数据节点发送 ping 命令做心跳检测，当这些节点超过 down-after-milliseconds 没有进行有效回复时，Sentinel 节点会对该节点做失败判定，这个行为叫做主观下线。</p>\n<h4 id=\"客观下线\"><a href=\"#客观下线\" class=\"headerlink\" title=\"客观下线\"></a>客观下线</h4><p>客观下线，是指当大多数 Sentinel 节点，都认为 master 节点宕机了，那么这个判定就是客观的，叫做客观下线。</p>\n<p>那么这个大多数是指多少呢？这其实就是分布式协调中的 quorum 判定了，大多数就是过半数，比如哨兵数量是 5，那么大多数就是 5&#x2F;2+1&#x3D;3 个，哨兵数量是 10 大多数就是 10&#x2F;2+1&#x3D;6 个。</p>\n<p>注：Sentinel 节点的数量至少为 3 个，否则不满足 quorum 判定条件。</p>\n<h3 id=\"哨兵选举\"><a href=\"#哨兵选举\" class=\"headerlink\" title=\"哨兵选举\"></a>哨兵选举</h3><p>如果发生了客观下线，那么哨兵节点会选举出一个 Leader 来进行实际的故障转移工作。Redis 使用了 Raft 算法来实现哨兵领导者选举，大致思路如下：</p>\n<ol>\n<li>每个 Sentinel 节点都有资格成为领导者，当它主观认为某个数据节点宕机后，会向其他 Sentinel 节点发送 sentinel is-master-down-by-addr 命令，要求自己成为领导者；</li>\n<li>收到命令的 Sentinel 节点，如果没有同意过其他 Sentinel 节点的 sentinelis-master-down-by-addr 命令，将同意该请求，否则拒绝（每个 Sentinel 节点只有 1 票）；</li>\n<li>如果该 Sentinel 节点发现自己的票数已经大于等于 MAX(quorum, num(sentinels)&#x2F;2+1)，那么它将成为领导者；</li>\n<li>如果此过程没有选举出领导者，将进入下一次选举。</li>\n</ol>\n<h3 id=\"故障转移\"><a href=\"#故障转移\" class=\"headerlink\" title=\"故障转移\"></a><strong>故障转移</strong></h3><p>选举出的 Leader Sentinel 节点将负责故障转移，也就是进行 master&#x2F;slave 节点的主从切换。故障转移，首先要从 slave 节点中筛选出一个作为新的 master，主要考虑以下 slave 信息：</p>\n<ol>\n<li>跟 master 断开连接的时长：如果一个 slave 跟 master 的断开连接时长已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么该 slave 就被认为不适合选举为 master；</li>\n<li>slave 的优先级配置：slave priority 参数值越小，优先级就越高；</li>\n<li>复制 offset：当优先级相同时，哪个 slave 复制了越多的数据（offset 越靠后），优先级越高；</li>\n<li>run id：如果 offset 和优先级都相同，则哪个 slave 的 run id 越小，优先级越高。</li>\n</ol>\n<p>接着，筛选完 slave 后， 会对它执行 slaveof no one 命令，让其成为主节点。</p>\n<p>最后，Sentinel 领导者节点会向剩余的 slave 节点发送命令，让它们成为新的 master 节点的从节点，复制规则与 parallel-syncs 参数有关。</p>\n<p>Sentinel 节点集合会将原来的 master 节点更新为 slave 节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</p>\n<p>注：Leader Sentinel 节点，会从新的 master 节点那里得到一个 configuration epoch，本质是个 version 版本号，每次主从切换的 version 号都必须是唯一的。其他的哨兵都是根据 version 来更新自己的 master 配置。</p>\n<h2 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h2><blockquote>\n<p>高可用：保证 Redis 一直处于可用状态，即使出现了故障也有备用方案保证可用性</p>\n<p>高并发：一个 Redis 实例已经可以支持多达 11w并发读操作或 8.1w并发写操作；但是如果有更高并发需求的应用来说，可以通过 读写分离、集群配置 来解决高并发问题</p>\n</blockquote>\n<ul>\n<li>Redis 集群中每个节点是对等的，无中心结构</li>\n<li>数据按照 slots 分布式存储在不同的 Redis 节点上，节点中的数据可共享，可以动态调整数据分布</li>\n<li>可扩展性强，可以动态增删节点，最多可扩展至 1000+ 节点</li>\n<li>集群的每个节点通过 <code>主从（哨兵模式）</code>保证其高可用性</li>\n<li>Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作</li>\n<li>Redis 集群之间是如何复制的？异步复制</li>\n</ul>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/qq_43846090/article/details/123721066\">Redis_数据分布算法：传统哈希-一致性哈希-哈希slot</a></p>\n</blockquote>\n<h3 id=\"传统哈希\"><a href=\"#传统哈希\" class=\"headerlink\" title=\"传统哈希\"></a>传统哈希</h3><p>最简单的数据分布算法，对进来的 key 进行 hash，然后对节点数据进行取模，就知道分布到哪个节点上了；<br>缺点就是: 如果一个节点宕机，所有缓存的位置都要发生改变，当服务器数量发生改变时，所有缓存在一定时间内是失效的，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）</p>\n<h3 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h3><p>实际上就是引入了一个圆环的概念， 让每个数据的 hash 分布到整个圆环，然后顺时针去找离他最近的节点存储</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525022243.png\" alt=\"一致性哈希\" style=\"zoom: 50%;\" />\n\n<p>hash 算法的取模法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，<br>dubbo 的复杂均衡有用到该算法；</p>\n<p>好处:</p>\n<p>使用 hash 算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了；<br>而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效。上图中如果节点 A 失效，则 C → A 之间的数据会重新缓存到节点 B 上。</p>\n<p>hash 环偏斜：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525154544.png\" alt=\"hash 环偏斜\" style=\"zoom: 50%;\" />\n\n<p>1 号、2 号、3 号、4 号、6 号数据均被缓存在了服务器 A 上；只有 5 号被缓存在了服务器 B 上；服务器 C 上甚至没有缓存任何图片<br>如果出现上图中的情况，A、B、C 三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器 A 出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃；</p>\n<p>上图中的情况则被称之为 hash 环的偏斜 ；<br>我们应该怎样防止 hash 环的偏斜？<br>增加虚拟节点：</p>\n<img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes1650525203417.png\" alt=\"增加虚拟节点防止 hash 环的偏斜\" style=\"zoom:50%;\" />\n\n<p>为了解决这个数据负载均衡的问题，搞出来虚拟节点，把真实节点搞一堆虚拟节点分布到环，那么整个区间的数据会落到这些虚拟节点上；</p>\n<p>虚拟节点越多，hash 环上的节点就越多，缓存被均匀分布的概率就越大。</p>\n<h3 id=\"哈希槽\"><a href=\"#哈希槽\" class=\"headerlink\" title=\"哈希槽\"></a>哈希槽</h3><p>Redis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。</p>\n<p>首先哈希槽其实是两个概念，第一个是哈希算法。Redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 Redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p>\n<p>Redis cluster 包含了 16384 个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p>\n<p><strong>为什么哈希槽的大小是固定的16384？</strong></p>\n<blockquote>\n<p><code>CRC16</code>算法产生的hash值有16bit，该算法可以产生2^16-&#x3D;65536个值。换句话说，值是分布在0~65535之间。那作者在做<code>mod</code>运算的时候，为什么不<code>mod</code>65536，而选择<code>mod</code>16384？</p>\n</blockquote>\n<p><strong>不能太大，主要从节点间的通信性能方面考虑：</strong></p>\n<p>每个节点之间是需要进行一个通信的，也就是不断地 pingpong 机制，让每个节点连接对方的信息；发送的消息头中有一个 bitmap，其中每一位代表一个槽，如果该位为 1，表示这个槽是属于当前节点，如果槽位过大，那么这个 bitmap 就会太大，心跳包过于庞大，浪费带宽。</p>\n<p><strong>不能太小，主要从压缩率方面考虑：</strong></p>\n<p>由于 bitmap 在传输过程中会进行压缩，bitmap 的填充率用 slots&#x2F;N 表示（N 即节点数），对于同样的 slots，如果 N 太小，导致其填充率过高，压缩率就很低。</p>\n<hr>\n<h2 id=\"缓存穿透、击穿、雪崩\"><a href=\"#缓存穿透、击穿、雪崩\" class=\"headerlink\" title=\"缓存穿透、击穿、雪崩\"></a>缓存穿透、击穿、雪崩</h2><h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p><strong>问题来源</strong></p>\n<p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能 DB 就挂掉了，要是有人利用不存在的 key 频繁攻击我们的应用，每次都去 DB 判断然而又不能复制到 Redis 中，这就是漏洞。</p>\n<p>例如发起为 id 为“-1”的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li><p><strong>接口校验</strong>：接口层增加校验，例如对 id&lt;&#x3D;0 的直接拦截。</p>\n</li>\n<li><p><strong>缓存空值</strong>：从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 10 秒（设置太长会导致正常情况也没法使用）。</p>\n</li>\n<li><p><strong>布隆过滤器</strong>：布隆过滤器用于快速判某个元素是否存在于集合中，由一个很长的二进制向量（位图）和一系列哈希函数两部分组成。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的错误识别率，添加到集合中的元素越多，误报的可能性就越大。</p>\n<p> 位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit &#x2F; 8 &#x3D; 125000 Byte &#x3D; 125000&#x2F;1024 kb ≈ 122kb 的空间。</p>\n<blockquote>\n<p><a href=\"https://javaguide.cn/cs-basics/data-structure/bloom-filter.html\">布隆过滤器</a></p>\n<p><a href=\"https://javaguide.cn/database/Redis/Redis-questions-01.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\">缓存穿透-布隆过滤器</a></p>\n</blockquote>\n<p> 具体而言：</p>\n<p> 把 <strong>所有可能存在的请求的值</strong> 都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。布隆过滤器判断不存在的话，则肯定不存在，布隆过滤器判断存在，则进一步查 Redis，Redis 中存在则返回，Redis 中不存在则查数据库。</p>\n<p> 为什么布隆过滤器会出现误判的情况呢? </p>\n<p> <strong>当一个元素加入布隆过滤器中的时候，会进行以下操作：</strong></p>\n<ol>\n<li><p>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p>\n<blockquote>\n<p>hashVal1 &#x3D; hashMethod1(key)， hashVal2&#x3D; hashMethod2(key)…</p>\n</blockquote>\n</li>\n<li><p>根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>\n<blockquote>\n<p>把位数组中的 hashVal1 和 hashVal2 处置为 1</p>\n</blockquote>\n</li>\n</ol>\n<p> <strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行以下操作：</strong></p>\n<ol>\n<li><p>对给定元素再次进行相同的哈希计算；</p>\n<blockquote>\n<p>hashVal1 &#x3D; hashMethod1(key)， hashVal2&#x3D; hashMethod2(key)…</p>\n</blockquote>\n</li>\n<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>\n<blockquote>\n<p>判断位数组中的 hashVal1 和 hashVal2 处是否全部为 1，全部为 1说明当前元素存在于位数组中。</p>\n</blockquote>\n</li>\n</ol>\n<p> 然而会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>\n<blockquote>\n<p><strong>⭐例如</strong>：val1 经过两次hash得到下标 1， 3，将1、3处置为1，val2经过两次hash得到下标2、4，将2、4处置为1，对于新元素val3经过两次hash得到下标1、2，判断这两个位置都为1，误判以为val3存在，实际上不存在。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p><strong>问题来源</strong></p>\n<p>缓存击穿是指一个热点的 key，有大并发集中对其进行访问，突然间这个 key 失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</p>\n<p><strong>解决方案</strong></p>\n<blockquote>\n<p>热点key失效 → 打到数据库上，因此可以从这两方面进行解决</p>\n</blockquote>\n<p>1、设置热点数据永远不过期。</p>\n<p>2、接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</p>\n<p>3、加互斥锁：如果缓存失效的情况，只有拿到锁才可以查询数据库，分布式场景下可以使用分布式锁。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p><strong>问题来源</strong></p>\n<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至 down 机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是指很多不同的数据都过期了，都查不到从而查数据库。</p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li><strong>缓存数据的过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</li>\n<li>设置热点数据永远不过期。</li>\n<li>在即将发生大并发访问之前，进行<strong>缓存预热</strong>将可能大量访问的数据加载到缓存。</li>\n<li>接口限流、降级与熔断。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</li>\n<li>为了防止 Redis 宕机导致缓存雪崩的问题，可以<strong>搭建Redis集群</strong>，提高 Redis 的容灾性。</li>\n<li>提高数据库的容灾能力，可以使用<strong>数据库分库分表</strong>，读写分离的策略。</li>\n</ol>\n<h2 id=\"Redis-淘汰策略\"><a href=\"#Redis-淘汰策略\" class=\"headerlink\" title=\"Redis 淘汰策略\"></a>Redis 淘汰策略</h2><h3 id=\"Redis-内存淘汰策略\"><a href=\"#Redis-内存淘汰策略\" class=\"headerlink\" title=\"Redis 内存淘汰策略\"></a>Redis 内存淘汰策略</h3><blockquote>\n<p>Redis 是基于内存结构进行数据缓存的，当内存资源消耗完毕，当将要有新的数据缓存进来时，为了腾出空间放新的数据，需要将内存中的一些数据释放掉，这种释放数据的策略称为 Redis 的淘汰策略。</p>\n</blockquote>\n<p>LRU：Least Recently Used</p>\n<p>LFU：Least Frequently Used</p>\n<p>LRU 淘汰的是最久未访问到的数据，而 LFU 是淘汰的是最不经常使用的数据（若两个或多个数据的使用频率相同时，LFU 会再选择最久未访问到的数据淘汰）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># volatile-lru -&gt; 在设置了过期时间的数据中使用 LRU</span><br><span class=\"line\"># allkeys-lru -&gt; 在所有数据中使用 LRU</span><br><span class=\"line\"># volatile-lfu -&gt; 在设置了过期时间的数据中使用 LFU</span><br><span class=\"line\"># allkeys-lfu -&gt; 在所有数据中使用 LFU</span><br><span class=\"line\"># volatile-random -&gt; 在设置了过期时间的数据中随机淘汰</span><br><span class=\"line\"># allkeys-random -&gt; 在所有数据中随机淘汰</span><br><span class=\"line\"># volatile-ttl -&gt; 越早过期的数据 越先被淘汰</span><br><span class=\"line\"># noeviction -&gt; 不淘汰任何数据，当内存不够时直接抛出异常</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redis-缓存失效策略\"><a href=\"#Redis-缓存失效策略\" class=\"headerlink\" title=\"Redis 缓存失效策略\"></a>Redis 缓存失效策略</h3><p><strong>定时过期策略</strong></p>\n<p>每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好，有效地减少了因为过期键带来的内存浪费；但是会占用大量的 CPU 资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p>\n<p><strong>惰性过期策略</strong></p>\n<p>只有当访问一个 key 时，才会判断该 key 是否已过期，过期则清除。该策略可以最大化地节省 CPU 资源，却对内存非常不友好。极端情况可能出现大量的过期 key 没有再次被访问，从而不会被清除，占用大量内存。</p>\n<p><strong>定期过期策略</strong></p>\n<p>每隔一定的时间，会扫描一定数量的数据库的 expires 字典中一定数量的 key，并清除其中已过期的 key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得 CPU 和内存资源达到最优的平衡效果。</p>\n<p><strong>Redis中同时使用了定期过期和惰性过期两种过期策略。</strong></p>\n<p>所谓定期删除，指的是 Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p>\n<p><strong>假设 Redis 里放了 10w 个 key，都设置了过期时间，</strong>你每隔几百毫秒，就检查 10w 个 key，那 Redis 基本上就死了，cpu 负载会很高的，消耗在你的检查过期 key 上了。<strong>注意，</strong>这里可不是每隔 100ms 就遍历所有的设置过期时间的 key，那样就是一场性能上的灾难。实际上 Redis 是每隔 100ms 随机抽取一些 key 来检查和删除的。</p>\n<p><strong>但是问题是，定期删除可能会导致很多过期 key 到了时间并没有被删除掉，那咋整呢？</strong>所以就是惰性删除了。这就是说，在你获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p>\n<p><strong>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</strong>但是实际上这还是有问题的，如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存快耗尽了，咋整？<strong>答案是：走内存淘汰机制。</strong></p>\n<hr>\n<h2 id=\"Redis分布式并发问题\"><a href=\"#Redis分布式并发问题\" class=\"headerlink\" title=\"Redis分布式并发问题\"></a>Redis分布式并发问题</h2><blockquote>\n<p>单体项目中，购物车下单可以使用 synchronized 关键字锁住实例对象，只让一个线程下单并扣减库存</p>\n<p>而对于集群而言，在每台服务器上锁住实例对象，但是每台之间是无法感知的，仍然可能存在商品超卖问题</p>\n</blockquote>\n<h3 id=\"使用-Redis-实现分布式锁\"><a href=\"#使用-Redis-实现分布式锁\" class=\"headerlink\" title=\"使用 Redis 实现分布式锁\"></a>使用 Redis 实现分布式锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title function_\">addOrder</span><span class=\"params\">(String cids, Orders orders)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;add order begin...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）</span></span><br><span class=\"line\">    String[] arr = cids.split(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; cidsList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : arr) &#123;</span><br><span class=\"line\">        cidsList.add(Integer.parseInt(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取所有skuId</span></span><br><span class=\"line\">    List&lt;ShoppingCartVO&gt; list1 = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">allLocked</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    List&lt;String&gt; lockedSkuIds = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    Map&lt;String, String&gt; values = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ShoppingCartVO sc : list1) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId()， value = UUID.randomUUID().toString();</span><br><span class=\"line\">        <span class=\"type\">Boolean</span> <span class=\"variable\">thisLocked</span> <span class=\"operator\">=</span> srt.boundValueOps(sc.getSkuId()).setIfAbsent(value, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!thisLocked) &#123;   <span class=\"comment\">// 返回 false 说明之前有该数据，即有线程在操作这个 商品库存</span></span><br><span class=\"line\">            allLocked = <span class=\"literal\">false</span>;  <span class=\"comment\">// 因此这个sku就没有锁住，不能继续操作</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lockedSkuIds.add(skuId);</span><br><span class=\"line\">            values.put(skuId, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allLocked) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2、校验库存</span></span><br><span class=\"line\">        List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Integer.parseInt(sc.getCartNum()) &gt; sc.getSkuStock()) &#123;</span><br><span class=\"line\">                f = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//获取所有商品的名称，以逗号拼接成字符串</span></span><br><span class=\"line\">            sb.append(sc.getProductName()).append(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">untitled</span> <span class=\"operator\">=</span> sb.toString();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;product stock is ok ... &quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 3、表示库存充足----保存订单</span></span><br><span class=\"line\">            <span class=\"comment\">// a.userId   b.untitled  c.收货人信息：姓名、电话、地址</span></span><br><span class=\"line\">            <span class=\"comment\">// d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态</span></span><br><span class=\"line\">            orders.setUntitled(untitled);</span><br><span class=\"line\">            orders.setCreateTime(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">            orders.setStatus(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 生成订单编号</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> UUID.randomUUID().toString().replace(<span class=\"string\">&quot;-&quot;</span>， <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            orders.setOrderId(orderId);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 保存订单</span></span><br><span class=\"line\">            ordersMapper.insert(orders);</span><br><span class=\"line\">            <span class=\"comment\">// 4、生成商品快照</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">cnum</span> <span class=\"operator\">=</span> Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">itemId</span> <span class=\"operator\">=</span> System.currentTimeMillis() + <span class=\"string\">&quot;&quot;</span> + (<span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>().nextInt(<span class=\"number\">89999</span>) + <span class=\"number\">10000</span>);</span><br><span class=\"line\">                <span class=\"type\">OrderItem</span> <span class=\"variable\">orderItem</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OrderItem</span>(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，</span><br><span class=\"line\">                                                    sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(sc.getSellPrice() * cnum)， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"number\">0</span>);</span><br><span class=\"line\">                orderItemMapper.insert(orderItem);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 5、扣减库存：根据套餐Id修改套餐库存量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">newStock</span> <span class=\"operator\">=</span> sc.getSkuStock() - Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">ProductSku</span> <span class=\"variable\">productSku</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProductSku</span>();</span><br><span class=\"line\">                productSku.setSkuId(skuId);</span><br><span class=\"line\">                productSku.setStock(newStock);</span><br><span class=\"line\">                <span class=\"comment\">//根据主键来修改属性值</span></span><br><span class=\"line\">                productSkuMapper.updateByPrimaryKeySelective(productSku);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> cid : cidsList) &#123;</span><br><span class=\"line\">                shoppingCartMapper.deleteByPrimaryKey(cid);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> srt.boundValueOps(lockedSkuId).get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value != <span class=\"literal\">null</span> &amp;&amp; value.equals(values.get(lockedSkuId))) &#123;</span><br><span class=\"line\">                    srt.delete(lockedSkuId);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;add order finished... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            map.put(<span class=\"string\">&quot;orderId&quot;</span>， orderId);</span><br><span class=\"line\">            map.put(<span class=\"string\">&quot;productNames&quot;</span>， untitled);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 表示库存不足</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 加锁失败</span></span><br><span class=\"line\">        <span class=\"comment\">// 要将部分锁定的sku释放锁，即从Redis中移除锁住的skuId</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">            srt.delete(lockedSkuId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>如果订单中部分商品加锁成功，但是由于一些商品加锁失败导致无法提交订单，此时要注意将加锁的商品恢复，即从 Redis 中移除该商品</p>\n<blockquote>\n<p>在 allLocked &#x3D;&#x3D; false 中，释放加锁的商品</p>\n</blockquote>\n</li>\n<li><p>第一次根据 购物车 Id 查到的购物车记录（包含商品库存）到加锁提交订单之前，可能有别的线程 操作了其中某个商品的库存并操作完了，为了防止当前线程还对之前库存进行修改，应当在加锁后操作前重新查询库存。</p>\n</li>\n<li><p>当前线程加锁成功之后，在执行添加订单的过程中如果出现了异常导致无法释放锁</p>\n<blockquote>\n<p>可以在对商品加锁时设置过期时间，则到期自动释放锁</p>\n</blockquote>\n</li>\n<li><p>档给锁设置了过期时间之后，如果当前线程 t1 因为特殊原因，在锁过期之前没有完成业务执行，释放掉了锁，此时线程 t2 加锁成功，如果线程 t1 执行结束，将会释放 线程 t2 的锁，导致 线程 t2 在无锁状态</p>\n<blockquote>\n<p>对于加成功并提交完订单之后，对当前商品的锁释放，要判断 Redis 中的value是否和自己记录的相同，即是否是自己加的锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 释放锁</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> srt.boundValueOps(lockedSkuId).get();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (values.get(lockedSkuId).equals(value)) &#123;</span><br><span class=\"line\">     \tsrt.delete(lockedSkuId);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>当前线程 t1 判断是自己加的锁，在准备删除之前，锁过期了并且被其他线程 t2 拿到了成功加锁，这时候线程 t1 会释放掉线程 t2 的锁（并发量很大仍然需要考虑）</p>\n<blockquote>\n<p>保证 查询锁是否是自己加的和删除自己加的锁 的原子性（使用 lua 脚本，让多个 Redis 操作具有原子性，查询+删除）</p>\n</blockquote>\n</li>\n<li><p>使用看门狗线程解决线程 t1 释放相乘 t2 的锁的问题</p>\n<blockquote>\n<p>线程t1 加锁并设置过期时间，此时启动 看门狗线程（守护线程）监控线程 t1过期时间，过期时间要到了但是线程t1 业务还在执行，则重置过期时间，这样可以保证业务执行完之前不会释放锁</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"分布式锁框架-Resisson\"><a href=\"#分布式锁框架-Resisson\" class=\"headerlink\" title=\"分布式锁框架 Resisson\"></a>分布式锁框架 Resisson</h3><ul>\n<li><p>添加依赖</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.redisson<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>redisson<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.16.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置 yaml 文件</p>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">redisson:</span></span><br><span class=\"line\">  <span class=\"attr\">addr:</span></span><br><span class=\"line\">    <span class=\"attr\">singleAddr:</span></span><br><span class=\"line\">      <span class=\"attr\">host:</span> <span class=\"string\">Redis://47.110.247.63:6389</span></span><br><span class=\"line\">      <span class=\"attr\">password:</span> <span class=\"string\">FYX123fyx.</span></span><br><span class=\"line\">      <span class=\"attr\">database:</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置 RedissonClient（也可以配置成集群模式、主从模式）</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedissonConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;redisson.addr.singleAddr.host&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;redisson.addr.singleAddr.password&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;redisson.addr.singleAddr.database&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> database;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedissonClient <span class=\"title function_\">redissonClient</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Config</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Config</span>();</span><br><span class=\"line\">        config.useSingleServer().setAddress(host)</span><br><span class=\"line\">                .setPassword(password)</span><br><span class=\"line\">                .setDatabase(database);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Redisson.create(config);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>操作</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title function_\">addOrder</span><span class=\"params\">(String cids, Orders orders)</span> &#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">&quot;add order begin...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1、根据cids查询当前订单中关联的购物车记录详情（包括库存）</span></span><br><span class=\"line\">    String[] arr = cids.split(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; cidsList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : arr) &#123;</span><br><span class=\"line\">        cidsList.add(Integer.parseInt(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取所有skuId</span></span><br><span class=\"line\">    List&lt;ShoppingCartVO&gt; list = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\">    List&lt;String&gt; lockedSkuIds = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    Map&lt;String, RLock&gt; locks = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(); <span class=\"comment\">// &#123;&quot;1&quot;:lock1, &quot;2&quot;:lock2&#125;</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">allLocked</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId();</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(skuId);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            b = lock.tryLock(<span class=\"number\">10</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!b) &#123;</span><br><span class=\"line\">            allLocked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lockedSkuIds.add(skuId);</span><br><span class=\"line\">            locks.put(skuId, lock);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, String&gt; map = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (allLocked) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2、校验库存</span></span><br><span class=\"line\">            list = shoppingCartMapper.selectShopCartByCids(cidsList);</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Integer.parseInt(sc.getCartNum()) &gt; sc.getSkuStock()) &#123;</span><br><span class=\"line\">                    f = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//获取所有商品的名称，以逗号拼接成字符串</span></span><br><span class=\"line\">                sb.append(sc.getProductName()).append(<span class=\"string\">&quot;，&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">untitled</span> <span class=\"operator\">=</span> sb.toString();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (f) &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;product stock is ok ... &quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 3、表示库存充足----保存订单</span></span><br><span class=\"line\">                <span class=\"comment\">// a.userId   b.untitled  c.收货人信息：姓名、电话、地址</span></span><br><span class=\"line\">                <span class=\"comment\">// d.总价格   e.支付方式   f.订单的创建时间  g.订单初始状态</span></span><br><span class=\"line\">                orders.setUntitled(untitled);</span><br><span class=\"line\">                orders.setCreateTime(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">                orders.setStatus(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 生成订单编号</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">orderId</span> <span class=\"operator\">=</span> UUID.randomUUID().toString().replace(<span class=\"string\">&quot;-&quot;</span>， <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">                orders.setOrderId(orderId);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 保存订单</span></span><br><span class=\"line\">                ordersMapper.insert(orders);</span><br><span class=\"line\">                <span class=\"comment\">// 4、生成商品快照</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">cnum</span> <span class=\"operator\">=</span> Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">itemId</span> <span class=\"operator\">=</span> System.currentTimeMillis() + <span class=\"string\">&quot;&quot;</span> + (<span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>().nextInt(<span class=\"number\">89999</span>) + <span class=\"number\">10000</span>);</span><br><span class=\"line\">                    <span class=\"type\">OrderItem</span> <span class=\"variable\">orderItem</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OrderItem</span>(itemId, orderId, sc.getProductId()， sc.getProductName()， sc.getProductImg()， sc.getSkuId()，</span><br><span class=\"line\">                                                        sc.getSkuName()， BigDecimal.valueOf(sc.getSellPrice())， cnum, <span class=\"keyword\">new</span> <span class=\"title class_\">BigDecimal</span>(sc.getSellPrice() * cnum)， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()， <span class=\"number\">0</span>);</span><br><span class=\"line\">                    orderItemMapper.insert(orderItem);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 5、扣减库存：根据套餐Id修改套餐库存量</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ShoppingCartVO sc : list) &#123;</span><br><span class=\"line\">                    <span class=\"type\">String</span> <span class=\"variable\">skuId</span> <span class=\"operator\">=</span> sc.getSkuId();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">newStock</span> <span class=\"operator\">=</span> sc.getSkuStock() - Integer.parseInt(sc.getCartNum());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"type\">ProductSku</span> <span class=\"variable\">productSku</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ProductSku</span>();</span><br><span class=\"line\">                    productSku.setSkuId(skuId);</span><br><span class=\"line\">                    productSku.setStock(newStock);</span><br><span class=\"line\">                    <span class=\"comment\">//根据主键来修改属性值</span></span><br><span class=\"line\">                    productSkuMapper.updateByPrimaryKeySelective(productSku);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 6、删除购物车：当购物车中的记录购买成功之后，购物车中对应做删除操作</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> cid : cidsList) &#123;</span><br><span class=\"line\">                    shoppingCartMapper.deleteByPrimaryKey(cid);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;add order finished... &quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">                map.put(<span class=\"string\">&quot;orderId&quot;</span>， orderId);</span><br><span class=\"line\">                map.put(<span class=\"string\">&quot;productNames&quot;</span>， untitled);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String lockedSkuId : lockedSkuIds) &#123;</span><br><span class=\"line\">            locks.get(lockedSkuId).unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"分布式锁特点\"><a href=\"#分布式锁特点\" class=\"headerlink\" title=\"分布式锁特点\"></a>分布式锁特点</h3><ol>\n<li><p>互斥性</p>\n<p> 保证在不同节点间不同线程的互斥（只有一个节点当然可以）</p>\n</li>\n<li><p>可重入性</p>\n<p> 同一个节点上的同一个线程如果获取锁之后可以再次获取到这个锁</p>\n</li>\n<li><p>锁超时</p>\n<p> 加锁成功之后设置超时时间，以防止线程故障导致不释放锁而引起死锁</p>\n</li>\n<li><p>高效、高可用</p>\n<p> 支持单节点 Redis、主从 Redis、集群 Redis</p>\n</li>\n<li><p>支持阻塞和非阻塞</p>\n<p> tryLock 非阻塞 和 tryLock(long timeOut) 阻塞</p>\n</li>\n</ol>\n<h3 id=\"Redisson-的使用\"><a href=\"#Redisson-的使用\" class=\"headerlink\" title=\"Redisson 的使用\"></a>Redisson 的使用</h3><ol>\n<li><p>获取锁（公平锁 &#x2F; 非公平锁）</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 公平锁</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getFairLock(skuId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非公平锁</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(skuId);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>加锁（阻塞锁 &#x2F; 非阻塞锁）</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阻塞锁，设置加锁成功后的超时时间 20s，不加时间默认 30s</span></span><br><span class=\"line\">lock.lock(<span class=\"number\">20</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非阻塞锁（设置等待时间 3s，加锁成功后的超时时间 10s，不加则默认 30s）</span></span><br><span class=\"line\">lock.tryLock(<span class=\"number\">10</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>释放锁</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.unlock();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实例</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 公平非阻塞锁</span></span><br><span class=\"line\"><span class=\"type\">RLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> redissonClient.getLock(skuId);</span><br><span class=\"line\">lock.tryLock(<span class=\"number\">10</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h2 id=\"缓存与数据库双写一致性\"><a href=\"#缓存与数据库双写一致性\" class=\"headerlink\" title=\"缓存与数据库双写一致性\"></a>缓存与数据库双写一致性</h2><p>总结：</p>\n<p>读数据：先读缓存，如果有直接返回，如果没有查数据库查到数据存到缓存中并返回</p>\n<p>写数据：先写数据库，再删缓存，这个阶段可能删缓存失败，可以考虑使用一下三种方案：</p>\n<ol>\n<li>如果删除缓存失败，需要将数据写入重试表，然后使用 elastic-job 等定时任务进行重试。</li>\n<li>如果删除缓存失败，需要将数据发送 mq 消息到 mq 服务器，在 mq 的 consumer 中处理。</li>\n<li>订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</li>\n</ol>\n<blockquote>\n<p><a href=\"https://www.zhihu.com/question/319817091/answer/2432904728\">如何保证数据库和缓存双写一致性？-苏三说技术</a></p>\n</blockquote>\n<h3 id=\"问题引入\"><a href=\"#问题引入\" class=\"headerlink\" title=\"问题引入\"></a>问题引入</h3><p>通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526232523.png\" alt=\"图片\"></p>\n<ol>\n<li>用户请求过来之后，先查缓存有没有数据，如果有则直接返回。</li>\n<li>如果缓存没数据，再继续查数据库。</li>\n<li>如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。</li>\n<li>如果数据库也没数据，则直接返回空。</li>\n</ol>\n<p>这是缓存非常常见的用法。一眼看上去，好像没有啥问题。</p>\n<p>但你忽略了一个非常重要的细节：<strong>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？</strong></p>\n<p>不更新缓存行不行？</p>\n<p>答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？</p>\n<p>那么，我们该如何更新缓存呢？</p>\n<p>目前有以下 4 种方案：</p>\n<ol>\n<li>先写缓存，再写数据库</li>\n<li>先写数据库，再写缓存</li>\n<li>先删缓存，再写数据库</li>\n<li>先写数据库，再删缓存</li>\n</ol>\n<p>接下来，我们详细说说这 4 种方案。</p>\n<h3 id=\"先写缓存，再写数据库\"><a href=\"#先写缓存，再写数据库\" class=\"headerlink\" title=\"先写缓存，再写数据库\"></a>先写缓存，再写数据库</h3><p>对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。</p>\n<p>那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？</p>\n<p>我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526427819.png\" alt=\"图片\"></p>\n<p>某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526436447.png\" alt=\"图片\"></p>\n<p>其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。</p>\n<p>我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。</p>\n<p>但如果某条数据，在数据库中都不存在，你缓存这种“<code>假数据</code>”又有啥意义呢？</p>\n<p>因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。</p>\n<h3 id=\"先写数据库，再写缓存\"><a href=\"#先写数据库，再写缓存\" class=\"headerlink\" title=\"先写数据库，再写缓存\"></a>先写数据库，再写缓存</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526499487.png\" alt=\"图片\"></p>\n<p>用户的写操作，先写数据库，再写缓存，可以避免之前“假数据”的问题。但它却带来了新的问题。</p>\n<h4 id=\"写缓存失败了\"><a href=\"#写缓存失败了\" class=\"headerlink\" title=\"写缓存失败了\"></a>写缓存失败了</h4><p>如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526558901.png\" alt=\"图片\"></p>\n<p>如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。</p>\n<p>但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。</p>\n<p>也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。</p>\n<p>这就会出现：数据库是<code>新数据</code>，而缓存是<code>旧数据</code>，两边<code>数据不一致</code>的情况。</p>\n<h4 id=\"高并发下的问题\"><a href=\"#高并发下的问题\" class=\"headerlink\" title=\"高并发下的问题\"></a>高并发下的问题</h4><p>假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：a 和 b，它们同时请求到业务系统。</p>\n<p>其中请求 a 获取的是旧数据，而请求 b 获取的是新数据，如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526645914.png\" alt=\"图片\"></p>\n<ol>\n<li>请求 a 先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。</li>\n<li>这时候请求 b 过来了，先写了数据库。</li>\n<li>接下来，请求 b 顺利写了缓存。</li>\n<li>此时，请求 a 卡顿结束，也写了缓存。</li>\n</ol>\n<p>很显然，在这个过程当中，请求 b 在缓存中的<code>新数据</code>，被请求 a 的<code>旧数据</code>覆盖了。</p>\n<p>也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。</p>\n<h4 id=\"浪费系统资源\"><a href=\"#浪费系统资源\" class=\"headerlink\" title=\"浪费系统资源\"></a>浪费系统资源</h4><p>有些业务场景比较特殊：<code>写多读少</code>。</p>\n<p>如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。</p>\n<p>还不如不用 Redis，反正写数据库都要写，我读数据又比较少，Redis 使用频率低，却还要一直更新 Redis 中数据。</p>\n<h3 id=\"先删缓存，再写数据库\"><a href=\"#先删缓存，再写数据库\" class=\"headerlink\" title=\"先删缓存，再写数据库\"></a>先删缓存，再写数据库</h3><p>不然是先写缓存还是先写数据库都有很多问题，那么考虑不是 <code>更新缓存</code> 而是 <code>删除缓存</code>。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650526855730.png\" alt=\"图片\"></p>\n<p>在用户的写操作中，先执行删除缓存操作，再去写数据库</p>\n<h4 id=\"高并发下的问题-1\"><a href=\"#高并发下的问题-1\" class=\"headerlink\" title=\"高并发下的问题\"></a>高并发下的问题</h4><p>假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求 c，还有另一个写数据请求 d（一个更新操作），同时请求到业务系统。如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650527043982.png\" alt=\"图片\"></p>\n<ol>\n<li>请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</li>\n<li>这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</li>\n<li>请求 c 将数据库中的旧值，更新到缓存中。</li>\n<li>此时，请求 d 卡顿结束，把新值写入数据库。</li>\n</ol>\n<p>在这个过程当中，请求 d 的新值并没有被请求 c 写入缓存，同样会导致缓存和数据库的数据不一致的情况。</p>\n<h4 id=\"缓存双删\"><a href=\"#缓存双删\" class=\"headerlink\" title=\"缓存双删\"></a>缓存双删</h4><p>在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。</p>\n<p>有人说还不好办，请求 d 在写完数据库之后，把缓存重新删一次不就行了？</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528097218.png\" alt=\"图片\"></p>\n<p>这就是我们所说的<code>缓存双删</code>，即在写数据库之前删除一次，写完数据库后，再删除一次。</p>\n<p>该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的<code>时间间隔</code>之后。</p>\n<p>我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：</p>\n<ol>\n<li>请求 d 先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</li>\n<li>这时请求 c 过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</li>\n<li>请求 c 将数据库中的旧值，更新到缓存中。</li>\n<li>此时，请求 d 卡顿结束，把新值写入数据库。</li>\n<li>一段时间之后，比如：500ms，请求 d 将缓存删除。</li>\n</ol>\n<p>这样来看确实可以解决缓存不一致问题。</p>\n<p>那么，为什么一定要间隔一段时间之后，才能删除缓存呢？</p>\n<p>请求 d 卡顿结束，把新值写入数据库后，请求 c 将数据库中的旧值，更新到缓存中。</p>\n<p>此时，如果请求 d 删除太快，在请求 c 将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求 c 更新缓存之后，再删除缓存，才能把旧值及时删除了。</p>\n<p>所以需要在请求 d 中加一个时间间隔，确保请求 c，或者类似于请求 c 的其他请求，如果在缓存中设置了旧值，最终都能够被请求 d 删除掉。</p>\n<p>接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？</p>\n<h3 id=\"先写数据库，再删缓存\"><a href=\"#先写数据库，再删缓存\" class=\"headerlink\" title=\"先写数据库，再删缓存\"></a>先写数据库，再删缓存</h3><p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528137396.png\" alt=\"图片\"></p>\n<p>在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：</p>\n<ol>\n<li>请求 e 先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。</li>\n<li>请求 f 查询缓存，发现缓存中有数据，直接返回该数据。</li>\n<li>请求 e 删除缓存。</li>\n</ol>\n<p>在这个过程中，只有请求 f 读了一次旧数据，后来旧数据被请求 e 及时删除了，看起来问题不大。</p>\n<p>但如果是读数据请求先过来呢？</p>\n<ol>\n<li>请求 f 查询缓存，发现缓存中有数据，直接返回该数据。</li>\n<li>请求 e 先写数据库。</li>\n<li>请求 e 删除缓存。</li>\n</ol>\n<p>这种情况看起来也没问题呀？</p>\n<p>答：对的。</p>\n<p>但就怕出现下面这种情况，即缓存自己失效了。如下图所示：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528267733.png\" alt=\"图片\"></p>\n<ol>\n<li>缓存过期时间到了，自动失效。</li>\n<li>请求 f 查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。</li>\n<li>请求 e 先写数据库，接着删除了缓存。</li>\n<li>请求 f 更新旧值到缓存中。</li>\n</ol>\n<p>这时，缓存和数据库的数据同样出现不一致的情况了。</p>\n<p>但这种情况还是比较少的，需要同时满足以下条件才可以：</p>\n<ol>\n<li>缓存刚好自动失效。</li>\n<li>请求 f 从数据库查出旧值，更新缓存的耗时，比请求 e 写数据库，并且删除缓存的还长。</li>\n</ol>\n<p>我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。</p>\n<p>由此可见，系统同时满足上述两个条件的概率非常小。</p>\n<blockquote>\n<p>推荐大家使用先写数据库，再删缓存的方案，虽说不能100%避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。</p>\n</blockquote>\n<p>但在该方案中，如果删除缓存失败了该怎么办呢？</p>\n<h3 id=\"删缓存失败怎么办？\"><a href=\"#删缓存失败怎么办？\" class=\"headerlink\" title=\"删缓存失败怎么办？\"></a>删缓存失败怎么办？</h3><p>其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。</p>\n<p>那么，删除缓存失败怎么办呢？</p>\n<p>答：需要加<code>重试机制</code>。</p>\n<p>在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试 3 次。如果其中有任何一次成功，则直接返回成功。如果 3 次都失败了，则写入数据库，准备后续再处理。</p>\n<p>当然，如果你在接口中直接<code>同步重试</code>，该接口并发量比较高的时候，可能有点影响接口性能。</p>\n<p>这时，就需要改成<code>异步重试</code>了。</p>\n<p>异步重试方式有很多种，比如：</p>\n<ol>\n<li>每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统 OOM 问题，不太建议使用。</li>\n<li>将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。</li>\n<li>将重试数据写表，然后使用 elastic-job 等定时任务进行重试。</li>\n<li>将重试的请求写入 mq 等消息中间件中，在 mq 的 consumer 中处理。</li>\n<li>订阅 mysql 的 binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</li>\n</ol>\n<h4 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a>定时任务</h4><p>使用<code>定时任务重试</code>的具体方案如下：</p>\n<ol>\n<li><p>当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528474531.png\" alt=\"图片\"></p>\n</li>\n<li><p>在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为 0。然后重试 5 次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。</p>\n<p> <img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528480542.png\" alt=\"图片\"></p>\n</li>\n<li><p>在高并发场景中，定时任务推荐使用<code>elastic-job</code>。相对于 xxl-job 等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7 秒等。</p>\n</li>\n</ol>\n<p>使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。</p>\n<p>但它有一个很大的优点，即数据是落库的，不会丢数据。</p>\n<h4 id=\"mq\"><a href=\"#mq\" class=\"headerlink\" title=\"mq\"></a>mq</h4><p>在高并发的业务场景中，mq（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。</p>\n<p>mq 的生产者，生产了消息之后，通过指定的 topic 发送到 mq 服务器。然后 mq 的消费者，订阅该 topic 的消息，读取消息数据之后，做业务逻辑处理。</p>\n<p>使用<code>mq重试</code>的具体方案如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528506474.png\" alt=\"图片\"></p>\n<ol>\n<li>当用户操作写完数据库，但删除缓存失败了，产生一条 mq 消息，发送给 mq 服务器。</li>\n<li>mq 消费者读取 mq 消息，重试 5 次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了 5 次，还是失败，则写入<code>死信队列</code>中。</li>\n<li>推荐 mq 使用<code>rocketmq</code>，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。</li>\n</ol>\n<p>当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送 mq 消息，到 mq 服务器，然后有 mq 消费者全权负责删除缓存的任务。</p>\n<p>因为 mq 的实时性还是比较高的，因此改良后的方案也是一种不错的选择。</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>前面我们聊过的，无论是定时任务，还是 mq（消息队列），做重试机制，对业务都有一定的侵入性。</p>\n<p>在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。</p>\n<p>而使用 mq 的方案中，如果删除缓存失败了，需要在业务代码中发送 mq 消息到 mq 服务器。</p>\n<p>其实，还有一种更优雅的实现，即<code>监听binlog</code>，比如使用：<code>canal</code>等中间件。</p>\n<p>具体方案如下：</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528533430.png\" alt=\"图片\"></p>\n<ol>\n<li>在业务接口中写数据库之后，就不管了，直接返回成功。</li>\n<li>mysql 服务器会自动把变更的数据写入 binlog 中。</li>\n<li>binlog 订阅者获取变更的数据，然后删除缓存。</li>\n</ol>\n<p>这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在 binlog 订阅者中做缓存删除工作。</p>\n<p>但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。</p>\n<p>如何解决这个问题呢？</p>\n<p>答：这就需要加上前面聊过的<code>重试机制</code>了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入 mq，让 mq 自动重试。</p>\n<p>在这里推荐使用<code>mq自动重试机制</code>。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/TyporaNotes640-1650528538202.png\" alt=\"图片\"></p>\n<p>在 binlog 订阅者中如果删除缓存失败，则发送一条 mq 消息到 mq 服务器，在 mq 消费者中自动重试 5 次。如果有任意一次成功，则直接返回成功。如果重试 5 次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。</p>\n<hr>\n<h2 id=\"Redis-线程模型\"><a href=\"#Redis-线程模型\" class=\"headerlink\" title=\"Redis 线程模型\"></a>Redis 线程模型</h2><h3 id=\"单线程的Redis为什么这么快\"><a href=\"#单线程的Redis为什么这么快\" class=\"headerlink\" title=\"单线程的Redis为什么这么快\"></a>单线程的Redis为什么这么快</h3><ol>\n<li><p>纯内存操作</p>\n</li>\n<li><p>单线程操作，避免了频繁的上下文切换</p>\n</li>\n<li><p>采用了非阻塞 I&#x2F;O 多路复用机制</p>\n</li>\n</ol>\n<h3 id=\"Redis-为什么是单线程的\"><a href=\"#Redis-为什么是单线程的\" class=\"headerlink\" title=\"Redis 为什么是单线程的\"></a>Redis 为什么是单线程的</h3><p>官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p>\n<p>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦）。Redis 利用队列将并发访问变为串行访问</p>\n<p>1、绝大部分请求是纯粹的内存操作（非常快速）</p>\n<p>2、采用单线程，避免了不必要的上下文切换和竞争条件</p>\n<p>3、非阻塞 IO 优点：</p>\n<ul>\n<li>速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)</li>\n<li>支持丰富数据类型，支持 string，list，set，sorted set，hash</li>\n<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>\n<li>丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除如何解决 Redis 的并发竞争 key 问题</li>\n</ul>\n<p><strong>同时有多个子系统去set一个key。这个时候要注意什么呢？</strong></p>\n<p>不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 key 操作的时候，这多个 key 不一定都存储在同一个 Redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p>\n<ul>\n<li>如果对这个 key 操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可</li>\n<li>如果对这个 key 操作，要求顺序：分布式锁+时间戳。假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了。以此类推。</li>\n<li>利用队列，将 set 方法变成串行访问也可以 Redis 遇到高并发，如果保证读写 key 的一致性</li>\n</ul>\n<p>对 Redis 的操作都是具有原子性的，是线程安全的操作，你不用考虑并发问题,Redis 内部已经帮你处理好并发的问题了。</p>\n<h3 id=\"为什么Redis的操作是原子性的，怎么保证原子性的？\"><a href=\"#为什么Redis的操作是原子性的，怎么保证原子性的？\" class=\"headerlink\" title=\"为什么Redis的操作是原子性的，怎么保证原子性的？\"></a>为什么Redis的操作是原子性的，怎么保证原子性的？</h3><p>对于 Redis 而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。</p>\n<p>Redis 的操作之所以是原子性的，是因为 Redis 是单线程的。（Redis 新版本已经引入多线程，这里基于旧版本的 Redis）</p>\n<p>Redis 本身提供的所有 API 都是原子操作，Redis 中的事务其实是要保证批量操作的原子性。</p>\n<p>多个命令在并发中也是原子性的吗？</p>\n<p>不一定， 将 get 和 set 改成单命令操作，incr 。使用 Redis 的事务，或者使用 Redis+Lua 的方式实现.</p>\n<h3 id=\"讲解下Redis线程模型\"><a href=\"#讲解下Redis线程模型\" class=\"headerlink\" title=\"讲解下Redis线程模型\"></a>讲解下Redis线程模型</h3><p>文件事件处理器包括分别是套接字、 I&#x2F;O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器。使用 I&#x2F;O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>\n<p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p>\n<p>I&#x2F;O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。</p>\n<p><strong>工作原理：</strong></p>\n<p>I&#x2F;O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。</p>\n<p>尽管多个文件事件可能会并发地出现， 但 I&#x2F;O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列， 以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：</p>\n<p>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I&#x2F;O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</p>\n<h2 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247507942&idx=1&sn=e00fd16ec56d0e10cc830678ee25c417&chksm=e92ae2e9de5d6bff6d227646c12685a5c45a4c3322e2186954555a14ebcd9510e8ae579a4941&mpshare=1&scene=24&srcid=0324gng7YtX5XX0z9bf7aObR&sharer_sharetime=1648080975816&sharer_shareid=ebfad4e5798246e3d3928c1f4ee9048e#rd\">原创 一洺 <a href=\"javascript:void(0);\">阿里开发者</a> 2022-03-24 08:00</a></p>\n<p><a href=\"https://blog.csdn.net/qq_31387317/category_7391502.html\">https://blog.csdn.net/qq_31387317/category_7391502.html</a></p>"},{"title":"手把手带你搭建个人博客","copyright":true,"mathjax":true,"date":"2022-12-12T13:08:31.000Z","toc":true,"urlname":"build-blog","_content":"\n## 系统环境&工具\n\n系统环境：MacOS\n\n工具：博客框架为 hexo，博客文件托管于 GitHub，博客网站用 Netlify 生成，国内访问采用 CloudFlare 进行 CDN 加速\n\n<!--more-->\n\n## hexo博客框架安装\n\n### 预先环境\n\n1、安装 node（使用 homebrew）\n\n```bash\nbrew install node\n```\n\n2、查看版本信息，正常看到版本信息即为成功\n\n```bash\nnode -v\nnpm -v\n```\n\n3、切换 npm 的源将源设置为淘宝源（速度快）\n\n```bash\nnpm config get registry\t# 查看源\nnpm config set registry https://registry.npm.taobao.org # 修改为淘宝源\n```\n\n### 安装\n\n1、安装 hexo\n\n```bash\nnpm install hexo-cli -g # 全局安装hexo命令行工具\n```\n\n2、初始化博客项目\n\n```bash\nhexo init \"博客目录名称\"\n# hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解\n```\n\n3、切换至博客目录安装依赖\n\n```bash\ncd blog\nnpm install\n```\n\n4、运行\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n打开链接，本地出现博客界面，即本地搭建成功！\n\n### 添加建站脚本\n\n为了后续`netlify`建站方便，在`package.json`里面添加一个命令：\n\n```json\nJSON\n{\n    // ......\n    \"scripts\": {\n        \"build\": \"hexo generate\",\n        \"clean\": \"hexo clean\",\n        \"deploy\": \"hexo deploy\",\n        \"server\": \"hexo server\",\n        \"netlify\": \"npm run clean && npm run build\" // 新加行\n    },\n    // ......\n}\n```\n\n## GitHub托管项目文件\n\n创建本地仓库，推送到远端服务器\n\n```bash\ncd blog\ngit init\ngit add .\ngit commit -m \"my blog first commit\"\ngit remote add origin \"远端github仓库地址\"\ngit branch -M main\ngit push -u origin main\n```\n\n## Netlify建站\n\n由于 GitHub 自带的 gitpage 访问速度较慢，我们使用 Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub 上的静态网站部署上线。\n\n### 步骤\n\n1、注册并登陆 Netlify\n\n2、add new site - import an existing project\n\n3、连接到 GitHub，选择我们托管在 GitHub 上的博客项目\n\n4、在设置中注意修改一处，Basic build settings - Build command 修改为 `npm run netlify`\n\n5、构建完成可以看到一个 xxx.netlify.app 的 url，即为我们博客的 url，修改该 url 中的 xxx 为 yaxing97，即设置我的个人博客域名为`yaxing97.netlify.app`\n\n### 配置域名\n\n1、购买域名（国内国外都可）\n\n2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮\n\n3、设置域名解析，类型为`CNAME`，主机记录为`@`，记录值为`yaxing97.netlify.app`，其中`yaxing97`是之前建站步骤中设置的个性二级域名\n\n4、在 netlify 中配置域名，domain management - domains - add custom domain，一路通过即可\n\n## CloudFlare加速\n\nNetlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。\n\n### 步骤\n\n1、注册 Cloudflare 并登陆\n\n2、输入您的站点（yaxing97.com），点击添加站点\n\n3、选择免费套餐\n\n4、添加 DNS，Type 为`CNAME`，Name 为`yaxing97.com`，Content 为`yaxing97.netlify.app`\n\n5、使用 cloudflare 提供的 dns 解析服务器（Cloudflare Nameservers）对 `yaxing97.com` 进行 dns 解析\n\n6、到阿里云控制台中，DNS 管理 - DNS 修改，修改 DNS 服务器\n\n## 配置https\n\n回到 netlify 中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成\n\n![配置HTTPS](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png)\n\n\n\n## 文章编写\n\n```bash\nhexo new \"文章标题\"\n# 编写好之后\nhexo clean\nhexo g\ngit add *\ngit commit -m \"commit信息\"\ngit push\n```\n\n过片刻，访问我们的`https://yaxing97.com`，可以看到新添加的文章。\n\n## 参考&更多\n\nhttps://blog.cuijiacai.com/blog-building/\n\nhttps://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\n","source":"_posts/手把手带你搭建个人博客.md","raw":"---\ntitle: 手把手带你搭建个人博客\ncopyright: true\nmathjax: true\ndate: 2022-12-12 21:08:31\ncategories: 技术总结\ntags: \ntoc: true\nurlname: build-blog\n---\n\n## 系统环境&工具\n\n系统环境：MacOS\n\n工具：博客框架为 hexo，博客文件托管于 GitHub，博客网站用 Netlify 生成，国内访问采用 CloudFlare 进行 CDN 加速\n\n<!--more-->\n\n## hexo博客框架安装\n\n### 预先环境\n\n1、安装 node（使用 homebrew）\n\n```bash\nbrew install node\n```\n\n2、查看版本信息，正常看到版本信息即为成功\n\n```bash\nnode -v\nnpm -v\n```\n\n3、切换 npm 的源将源设置为淘宝源（速度快）\n\n```bash\nnpm config get registry\t# 查看源\nnpm config set registry https://registry.npm.taobao.org # 修改为淘宝源\n```\n\n### 安装\n\n1、安装 hexo\n\n```bash\nnpm install hexo-cli -g # 全局安装hexo命令行工具\n```\n\n2、初始化博客项目\n\n```bash\nhexo init \"博客目录名称\"\n# hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解\n```\n\n3、切换至博客目录安装依赖\n\n```bash\ncd blog\nnpm install\n```\n\n4、运行\n\n```bash\nhexo clean\nhexo g\nhexo s\n```\n\n打开链接，本地出现博客界面，即本地搭建成功！\n\n### 添加建站脚本\n\n为了后续`netlify`建站方便，在`package.json`里面添加一个命令：\n\n```json\nJSON\n{\n    // ......\n    \"scripts\": {\n        \"build\": \"hexo generate\",\n        \"clean\": \"hexo clean\",\n        \"deploy\": \"hexo deploy\",\n        \"server\": \"hexo server\",\n        \"netlify\": \"npm run clean && npm run build\" // 新加行\n    },\n    // ......\n}\n```\n\n## GitHub托管项目文件\n\n创建本地仓库，推送到远端服务器\n\n```bash\ncd blog\ngit init\ngit add .\ngit commit -m \"my blog first commit\"\ngit remote add origin \"远端github仓库地址\"\ngit branch -M main\ngit push -u origin main\n```\n\n## Netlify建站\n\n由于 GitHub 自带的 gitpage 访问速度较慢，我们使用 Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub 上的静态网站部署上线。\n\n### 步骤\n\n1、注册并登陆 Netlify\n\n2、add new site - import an existing project\n\n3、连接到 GitHub，选择我们托管在 GitHub 上的博客项目\n\n4、在设置中注意修改一处，Basic build settings - Build command 修改为 `npm run netlify`\n\n5、构建完成可以看到一个 xxx.netlify.app 的 url，即为我们博客的 url，修改该 url 中的 xxx 为 yaxing97，即设置我的个人博客域名为`yaxing97.netlify.app`\n\n### 配置域名\n\n1、购买域名（国内国外都可）\n\n2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮\n\n3、设置域名解析，类型为`CNAME`，主机记录为`@`，记录值为`yaxing97.netlify.app`，其中`yaxing97`是之前建站步骤中设置的个性二级域名\n\n4、在 netlify 中配置域名，domain management - domains - add custom domain，一路通过即可\n\n## CloudFlare加速\n\nNetlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。\n\n### 步骤\n\n1、注册 Cloudflare 并登陆\n\n2、输入您的站点（yaxing97.com），点击添加站点\n\n3、选择免费套餐\n\n4、添加 DNS，Type 为`CNAME`，Name 为`yaxing97.com`，Content 为`yaxing97.netlify.app`\n\n5、使用 cloudflare 提供的 dns 解析服务器（Cloudflare Nameservers）对 `yaxing97.com` 进行 dns 解析\n\n6、到阿里云控制台中，DNS 管理 - DNS 修改，修改 DNS 服务器\n\n## 配置https\n\n回到 netlify 中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成\n\n![配置HTTPS](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png)\n\n\n\n## 文章编写\n\n```bash\nhexo new \"文章标题\"\n# 编写好之后\nhexo clean\nhexo g\ngit add *\ngit commit -m \"commit信息\"\ngit push\n```\n\n过片刻，访问我们的`https://yaxing97.com`，可以看到新添加的文章。\n\n## 参考&更多\n\nhttps://blog.cuijiacai.com/blog-building/\n\nhttps://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\n","slug":"手把手带你搭建个人博客","published":1,"updated":"2023-01-26T12:35:58.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw3290015t9t845071rec","content":"<h2 id=\"系统环境-amp-工具\"><a href=\"#系统环境-amp-工具\" class=\"headerlink\" title=\"系统环境&工具\"></a>系统环境&amp;工具</h2><p>系统环境：MacOS</p>\n<p>工具：博客框架为 hexo，博客文件托管于 GitHub，博客网站用 Netlify 生成，国内访问采用 CloudFlare 进行 CDN 加速</p>\n<span id=\"more\"></span>\n\n<h2 id=\"hexo博客框架安装\"><a href=\"#hexo博客框架安装\" class=\"headerlink\" title=\"hexo博客框架安装\"></a>hexo博客框架安装</h2><h3 id=\"预先环境\"><a href=\"#预先环境\" class=\"headerlink\" title=\"预先环境\"></a>预先环境</h3><p>1、安装 node（使用 homebrew）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n\n<p>2、查看版本信息，正常看到版本信息即为成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n<p>3、切换 npm 的源将源设置为淘宝源（速度快）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry\t<span class=\"comment\"># 查看源</span></span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org <span class=\"comment\"># 修改为淘宝源</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>1、安装 hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g <span class=\"comment\"># 全局安装hexo命令行工具</span></span><br></pre></td></tr></table></figure>\n\n<p>2、初始化博客项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init <span class=\"string\">\"博客目录名称\"</span></span><br><span class=\"line\"><span class=\"comment\"># hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解</span></span><br></pre></td></tr></table></figure>\n\n<p>3、切换至博客目录安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>4、运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>打开链接，本地出现博客界面，即本地搭建成功！</p>\n<h3 id=\"添加建站脚本\"><a href=\"#添加建站脚本\" class=\"headerlink\" title=\"添加建站脚本\"></a>添加建站脚本</h3><p>为了后续<code>netlify</code>建站方便，在<code>package.json</code>里面添加一个命令：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON</span><br><span class=\"line\"><span class=\"punctuation\">{</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"attr\">\"scripts\"</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">{</span></span><br><span class=\"line\">        <span class=\"attr\">\"build\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo generate\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"clean\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo clean\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"deploy\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo deploy\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"server\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo server\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"netlify\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"npm run clean &amp;&amp; npm run build\"</span> <span class=\"comment\">// 新加行</span></span><br><span class=\"line\">    <span class=\"punctuation\">}</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"punctuation\">}</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GitHub托管项目文件\"><a href=\"#GitHub托管项目文件\" class=\"headerlink\" title=\"GitHub托管项目文件\"></a>GitHub托管项目文件</h2><p>创建本地仓库，推送到远端服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"my blog first commit\"</span></span><br><span class=\"line\">git remote add origin <span class=\"string\">\"远端github仓库地址\"</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Netlify建站\"><a href=\"#Netlify建站\" class=\"headerlink\" title=\"Netlify建站\"></a>Netlify建站</h2><p>由于 GitHub 自带的 gitpage 访问速度较慢，我们使用 Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub 上的静态网站部署上线。</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册并登陆 Netlify</p>\n<p>2、add new site - import an existing project</p>\n<p>3、连接到 GitHub，选择我们托管在 GitHub 上的博客项目</p>\n<p>4、在设置中注意修改一处，Basic build settings - Build command 修改为 <code>npm run netlify</code></p>\n<p>5、构建完成可以看到一个 xxx.netlify.app 的 url，即为我们博客的 url，修改该 url 中的 xxx 为 yaxing97，即设置我的个人博客域名为<code>yaxing97.netlify.app</code></p>\n<h3 id=\"配置域名\"><a href=\"#配置域名\" class=\"headerlink\" title=\"配置域名\"></a>配置域名</h3><p>1、购买域名（国内国外都可）</p>\n<p>2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮</p>\n<p>3、设置域名解析，类型为<code>CNAME</code>，主机记录为<code>@</code>，记录值为<code>yaxing97.netlify.app</code>，其中<code>yaxing97</code>是之前建站步骤中设置的个性二级域名</p>\n<p>4、在 netlify 中配置域名，domain management - domains - add custom domain，一路通过即可</p>\n<h2 id=\"CloudFlare加速\"><a href=\"#CloudFlare加速\" class=\"headerlink\" title=\"CloudFlare加速\"></a>CloudFlare加速</h2><p>Netlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。</p>\n<h3 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册 Cloudflare 并登陆</p>\n<p>2、输入您的站点（yaxing97.com），点击添加站点</p>\n<p>3、选择免费套餐</p>\n<p>4、添加 DNS，Type 为<code>CNAME</code>，Name 为<code>yaxing97.com</code>，Content 为<code>yaxing97.netlify.app</code></p>\n<p>5、使用 cloudflare 提供的 dns 解析服务器（Cloudflare Nameservers）对 <code>yaxing97.com</code> 进行 dns 解析</p>\n<p>6、到阿里云控制台中，DNS 管理 - DNS 修改，修改 DNS 服务器</p>\n<h2 id=\"配置https\"><a href=\"#配置https\" class=\"headerlink\" title=\"配置https\"></a>配置https</h2><p>回到 netlify 中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png\" alt=\"配置HTTPS\"></p>\n<h2 id=\"文章编写\"><a href=\"#文章编写\" class=\"headerlink\" title=\"文章编写\"></a>文章编写</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"文章标题\"</span></span><br><span class=\"line\"><span class=\"comment\"># 编写好之后</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">git add *</span><br><span class=\"line\">git commit -m <span class=\"string\">\"commit信息\"</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>过片刻，访问我们的<code>https://yaxing97.com</code>，可以看到新添加的文章。</p>\n<h2 id=\"参考-amp-更多\"><a href=\"#参考-amp-更多\" class=\"headerlink\" title=\"参考&更多\"></a>参考&amp;更多</h2><p><a href=\"https://blog.cuijiacai.com/blog-building/\">https://blog.cuijiacai.com/blog-building/</a></p>\n<p><a href=\"https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\">https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da</a></p>\n","site":{"data":{}},"length":2194,"excerpt":"<h2 id=\"系统环境-amp-工具\"><a href=\"#系统环境-amp-工具\" class=\"headerlink\" title=\"系统环境&工具\"></a>系统环境&amp;工具</h2><p>系统环境：MacOS</p>\n<p>工具：博客框架为 hexo，博客文件托管于 GitHub，博客网站用 Netlify 生成，国内访问采用 CloudFlare 进行 CDN 加速</p>","more":"<h2 id=\"hexo博客框架安装\"><a href=\"#hexo博客框架安装\" class=\"headerlink\" title=\"hexo博客框架安装\"></a>hexo博客框架安装</h2><h3 id=\"预先环境\"><a href=\"#预先环境\" class=\"headerlink\" title=\"预先环境\"></a>预先环境</h3><p>1、安装 node（使用 homebrew）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n\n<p>2、查看版本信息，正常看到版本信息即为成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">npm -v</span><br></pre></td></tr></table></figure>\n\n<p>3、切换 npm 的源将源设置为淘宝源（速度快）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry\t<span class=\"comment\"># 查看源</span></span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org <span class=\"comment\"># 修改为淘宝源</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>1、安装 hexo</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g <span class=\"comment\"># 全局安装hexo命令行工具</span></span><br></pre></td></tr></table></figure>\n\n<p>2、初始化博客项目</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init <span class=\"string\">\"博客目录名称\"</span></span><br><span class=\"line\"><span class=\"comment\"># hexo init \"blog\" 即我的博客目录名称为blog，后续都用该目录来讲解</span></span><br></pre></td></tr></table></figure>\n\n<p>3、切换至博客目录安装依赖</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>4、运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>打开链接，本地出现博客界面，即本地搭建成功！</p>\n<h3 id=\"添加建站脚本\"><a href=\"#添加建站脚本\" class=\"headerlink\" title=\"添加建站脚本\"></a>添加建站脚本</h3><p>为了后续<code>netlify</code>建站方便，在<code>package.json</code>里面添加一个命令：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSON</span><br><span class=\"line\"><span class=\"punctuation\">{</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">    <span class=\"attr\">\"scripts\"</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">{</span></span><br><span class=\"line\">        <span class=\"attr\">\"build\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo generate\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"clean\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo clean\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"deploy\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo deploy\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"server\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"hexo server\"</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">\"netlify\"</span><span class=\"punctuation\">:</span> <span class=\"string\">\"npm run clean &amp;&amp; npm run build\"</span> <span class=\"comment\">// 新加行</span></span><br><span class=\"line\">    <span class=\"punctuation\">}</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\"><span class=\"punctuation\">}</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"GitHub托管项目文件\"><a href=\"#GitHub托管项目文件\" class=\"headerlink\" title=\"GitHub托管项目文件\"></a>GitHub托管项目文件</h2><p>创建本地仓库，推送到远端服务器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> blog</span><br><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"my blog first commit\"</span></span><br><span class=\"line\">git remote add origin <span class=\"string\">\"远端github仓库地址\"</span></span><br><span class=\"line\">git branch -M main</span><br><span class=\"line\">git push -u origin main</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Netlify建站\"><a href=\"#Netlify建站\" class=\"headerlink\" title=\"Netlify建站\"></a>Netlify建站</h2><p>由于 GitHub 自带的 gitpage 访问速度较慢，我们使用 Netlify（一个国外的免费的提供静态网站部署服务的平台）将托管 GitHub 上的静态网站部署上线。</p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册并登陆 Netlify</p>\n<p>2、add new site - import an existing project</p>\n<p>3、连接到 GitHub，选择我们托管在 GitHub 上的博客项目</p>\n<p>4、在设置中注意修改一处，Basic build settings - Build command 修改为 <code>npm run netlify</code></p>\n<p>5、构建完成可以看到一个 xxx.netlify.app 的 url，即为我们博客的 url，修改该 url 中的 xxx 为 yaxing97，即设置我的个人博客域名为<code>yaxing97.netlify.app</code></p>\n<h3 id=\"配置域名\"><a href=\"#配置域名\" class=\"headerlink\" title=\"配置域名\"></a>配置域名</h3><p>1、购买域名（国内国外都可）</p>\n<p>2、购买完成后在域名列表找到自己的域名，点击操作中的解析按钮</p>\n<p>3、设置域名解析，类型为<code>CNAME</code>，主机记录为<code>@</code>，记录值为<code>yaxing97.netlify.app</code>，其中<code>yaxing97</code>是之前建站步骤中设置的个性二级域名</p>\n<p>4、在 netlify 中配置域名，domain management - domains - add custom domain，一路通过即可</p>\n<h2 id=\"CloudFlare加速\"><a href=\"#CloudFlare加速\" class=\"headerlink\" title=\"CloudFlare加速\"></a>CloudFlare加速</h2><p>Netlify 虽然已经提供了 CDN 加速，但在使用过程中发现国内访问还是比较慢，Cloudflare 相对于国内的七牛云、阿里云等云服务商的 CDN 速度会慢一些，但是它有免费版本，而且最重要的是域名不用备案。</p>\n<h3 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>1、注册 Cloudflare 并登陆</p>\n<p>2、输入您的站点（yaxing97.com），点击添加站点</p>\n<p>3、选择免费套餐</p>\n<p>4、添加 DNS，Type 为<code>CNAME</code>，Name 为<code>yaxing97.com</code>，Content 为<code>yaxing97.netlify.app</code></p>\n<p>5、使用 cloudflare 提供的 dns 解析服务器（Cloudflare Nameservers）对 <code>yaxing97.com</code> 进行 dns 解析</p>\n<p>6、到阿里云控制台中，DNS 管理 - DNS 修改，修改 DNS 服务器</p>\n<h2 id=\"配置https\"><a href=\"#配置https\" class=\"headerlink\" title=\"配置https\"></a>配置https</h2><p>回到 netlify 中，Domain management - HTTPS，点击 verify DNS configuration，结果如下即为配置完成</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/image-20221212214817015.png\" alt=\"配置HTTPS\"></p>\n<h2 id=\"文章编写\"><a href=\"#文章编写\" class=\"headerlink\" title=\"文章编写\"></a>文章编写</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"文章标题\"</span></span><br><span class=\"line\"><span class=\"comment\"># 编写好之后</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">git add *</span><br><span class=\"line\">git commit -m <span class=\"string\">\"commit信息\"</span></span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>过片刻，访问我们的<code>https://yaxing97.com</code>，可以看到新添加的文章。</p>\n<h2 id=\"参考-amp-更多\"><a href=\"#参考-amp-更多\" class=\"headerlink\" title=\"参考&更多\"></a>参考&amp;更多</h2><p><a href=\"https://blog.cuijiacai.com/blog-building/\">https://blog.cuijiacai.com/blog-building/</a></p>\n<p><a href=\"https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da\">https://www.mdnice.com/writing/382af676baff4ed4ad5511074fb736da</a></p>"},{"title":"新买的小书桌","copyright":true,"mathjax":true,"date":"2022-12-14T08:21:02.000Z","urlname":"new-desk","_content":"\n之前买了个 LG 的 27 寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有 50cm），显示器靠墙前面只能勉强放下我的 mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。\n\n<!--more-->\n\n如果要使用 27 寸及以上尺寸显示器的话，建议购买宽度至少 70cm 的，我购买的尺寸为 $120 \\times 80 \\times 74 cm$，店铺是“新尚美家居”。\n\n注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。\n\n以下是实拍图 hh。\n\n![新书桌实拍图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG)\n","source":"_posts/新买的小书桌.md","raw":"---\ntitle: 新买的小书桌\ncopyright: true\nmathjax: true\ndate: 2022-12-14 16:21:02\ncategories: 日常小记\ntags: \nurlname: new-desk\n---\n\n之前买了个 LG 的 27 寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有 50cm），显示器靠墙前面只能勉强放下我的 mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。\n\n<!--more-->\n\n如果要使用 27 寸及以上尺寸显示器的话，建议购买宽度至少 70cm 的，我购买的尺寸为 $120 \\times 80 \\times 74 cm$，店铺是“新尚美家居”。\n\n注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。\n\n以下是实拍图 hh。\n\n![新书桌实拍图](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG)\n","slug":"新买的小书桌","published":1,"updated":"2023-01-26T12:35:58.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw32a0018t9t80g27c17z","content":"<p>之前买了个 LG 的 27 寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有 50cm），显示器靠墙前面只能勉强放下我的 mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。</p>\n<span id=\"more\"></span>\n\n<p>如果要使用 27 寸及以上尺寸显示器的话，建议购买宽度至少 70cm 的，我购买的尺寸为 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16.416ex\" height=\"1.581ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -677 7255.9 699\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\" transform=\"translate(500,0)\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(1000,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1722.2,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2722.4,0)\"><path data-c=\"38\" d=\"M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3944.7,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(4944.9,0)\"><path data-c=\"37\" d=\"M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z\"></path><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5944.9,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(6377.9,0)\"><path data-c=\"1D45A\" d=\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>，店铺是“新尚美家居”。</p>\n<p>注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。</p>\n<p>以下是实拍图 hh。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG\" alt=\"新书桌实拍图\"></p>\n","site":{"data":{}},"length":240,"excerpt":"<p>之前买了个 LG 的 27 寸显示器，放在书房的桌子上，一方面不能升高（上面有架板挡住），另一方面是桌子宽度不够（只有 50cm），显示器靠墙前面只能勉强放下我的 mac，导致屏幕离我很近，观感极差。于是在淘宝上淘了个书桌，还算不错。</p>","more":"<p>如果要使用 27 寸及以上尺寸显示器的话，建议购买宽度至少 70cm 的，我购买的尺寸为 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16.416ex\" height=\"1.581ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -677 7255.9 699\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\" transform=\"translate(500,0)\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(1000,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1722.2,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2722.4,0)\"><path data-c=\"38\" d=\"M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z\"></path><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3944.7,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(4944.9,0)\"><path data-c=\"37\" d=\"M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z\"></path><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\" transform=\"translate(500,0)\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5944.9,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(6377.9,0)\"><path data-c=\"1D45A\" d=\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>，店铺是“新尚美家居”。</p>\n<p>注意到手需要自己拧螺丝固定桌腿和桌板（用电动螺丝刀）以及桌腿和桌腿之间的连接（手拧即可）。</p>\n<p>以下是实拍图 hh。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/IMG_1396.JPG\" alt=\"新书桌实拍图\"></p>"},{"title":"新年快乐！","copyright":true,"mathjax":false,"date":"2023-01-22T01:55:21.000Z","toc":null,"urlname":"2023-happy-spring-festival","_content":"\n今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉\n","source":"_posts/新年快乐！.md","raw":"---\ntitle: 新年快乐！\ncopyright: true\nmathjax: false\ncategories:\n  - 日常小记\ndate: 2023-01-22 09:55:21\ntags: \ntoc: \nurlname: 2023-happy-spring-festival\n---\n\n今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉\n","slug":"新年快乐！","published":1,"updated":"2023-01-26T12:07:10.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw32a001at9t88remake6","content":"<p>今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉</p>\n","site":{"data":{}},"length":47,"excerpt":"","more":"<p>今年是大年初一，过新年。祝愿我和各位读者们新年快乐，事事如意，日进斗金，财运亨通，兔年大吉🎉</p>\n"},{"title":"最近关于校招、互联网的一些信息","copyright":true,"mathjax":true,"date":"2023-01-13T04:56:40.000Z","urlname":"202301-it-info","_content":"\n最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。\n\n<!--more-->\n\n1、字节飞书 EA，base 杭州的很多 22 届校招生没过试用期。\n\n2、抖音上一商家 C++基础课程卖 2999 一份，销量 1700+。\n\n3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。\n\n4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。\n\n5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。\n\n6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。\n\n7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业 saas 能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业 saas 的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是 5-7 万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业 saas 付费呢？\n\n8、上海银行开发岗今年降薪，22 年及以前很香的上银，今年风评逐渐变差。\n\n9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。\n\n10、职场 pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。\n\n11、某银行：一个内部几十个人用的单体系统，还要搞 devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。\n\n12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。\n\n13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。\n\n14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - [宇宙区长孙连城的回答](https://www.zhihu.com/question/576438196/answer/2830715899)\n\n15、字节杭州有部门全撤转 base 了，虽然人不多。\n\n16、邮储研发中心总包能到 30+w，很香，但是貌似要 996，个人感觉还是比较香。\n\n17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？\n\n18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。\n\n19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。\n\n20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？\n","source":"_posts/最近关于校招、互联网的一些信息.md","raw":"---\ntitle: 最近关于校招、互联网的一些信息\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2023-01-13 12:56:40\nurlname: 202301-it-info\n---\n\n最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。\n\n<!--more-->\n\n1、字节飞书 EA，base 杭州的很多 22 届校招生没过试用期。\n\n2、抖音上一商家 C++基础课程卖 2999 一份，销量 1700+。\n\n3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。\n\n4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。\n\n5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。\n\n6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。\n\n7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业 saas 能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业 saas 的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是 5-7 万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业 saas 付费呢？\n\n8、上海银行开发岗今年降薪，22 年及以前很香的上银，今年风评逐渐变差。\n\n9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。\n\n10、职场 pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。\n\n11、某银行：一个内部几十个人用的单体系统，还要搞 devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。\n\n12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。\n\n13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。\n\n14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - [宇宙区长孙连城的回答](https://www.zhihu.com/question/576438196/answer/2830715899)\n\n15、字节杭州有部门全撤转 base 了，虽然人不多。\n\n16、邮储研发中心总包能到 30+w，很香，但是貌似要 996，个人感觉还是比较香。\n\n17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？\n\n18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。\n\n19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。\n\n20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？\n","slug":"最近关于校招、互联网的一些信息","published":1,"updated":"2023-01-26T12:35:58.983Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw32b001ct9t88yodawq8","content":"<p>最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。</p>\n<span id=\"more\"></span>\n\n<p>1、字节飞书 EA，base 杭州的很多 22 届校招生没过试用期。</p>\n<p>2、抖音上一商家 C++基础课程卖 2999 一份，销量 1700+。</p>\n<p>3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。</p>\n<p>4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。</p>\n<p>5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。</p>\n<p>6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。</p>\n<p>7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业 saas 能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业 saas 的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是 5-7 万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业 saas 付费呢？</p>\n<p>8、上海银行开发岗今年降薪，22 年及以前很香的上银，今年风评逐渐变差。</p>\n<p>9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。</p>\n<p>10、职场 pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。</p>\n<p>11、某银行：一个内部几十个人用的单体系统，还要搞 devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。</p>\n<p>12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。</p>\n<p>13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。</p>\n<p>14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - <a href=\"https://www.zhihu.com/question/576438196/answer/2830715899\">宇宙区长孙连城的回答</a></p>\n<p>15、字节杭州有部门全撤转 base 了，虽然人不多。</p>\n<p>16、邮储研发中心总包能到 30+w，很香，但是貌似要 996，个人感觉还是比较香。</p>\n<p>17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？</p>\n<p>18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。</p>\n<p>19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。</p>\n<p>20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？</p>\n","site":{"data":{}},"length":1596,"excerpt":"<p>最近刷脉脉、知乎等记录下一些网友发布的一些信息，仅作记录，不对其真实性等作深究，侵删。</p>","more":"<p>1、字节飞书 EA，base 杭州的很多 22 届校招生没过试用期。</p>\n<p>2、抖音上一商家 C++基础课程卖 2999 一份，销量 1700+。</p>\n<p>3、银行类开发岗，从体量、发展、制度等方面考虑，建议去国有大型银行，以及头部的股份制银行。</p>\n<p>4、若是去大城市当程序员，以后可能会想象在老家当老师多舒服呀；若是回家当老师，或许一辈子都会后悔为什么年轻的时候不去大城市闯一闯，这就是人生。希望若干年后，都能和自己和解，这辈子过的还不错。</p>\n<p>5、以前进大专技校中小学等当老师门槛很低，现在越来越高，越来越卷。</p>\n<p>6、不热爱编程，没自信成为行业精英，不喜欢加班，不推荐成为程序员。</p>\n<p>7、这是一位字节战略离职的老哥/老姐对飞书的看法：个人不看好。欧美的企业 saas 能做起来有两个前提：一是欧美有很成熟的职业经理人体系，职业经理人来做采购决策，而中国大部分公司是不追求效率的国企或者抠门创始人搞一言堂的私企；二是企业 saas 的本质是提升员工工作效率，从而实现减少员工数量，降低人力成本，美国人平均工资是 5-7 万美元，省一个人就是大量的成本，中国人力成本这么低，为什么会愿意向飞书这样的企业 saas 付费呢？</p>\n<p>8、上海银行开发岗今年降薪，22 年及以前很香的上银，今年风评逐渐变差。</p>\n<p>9、脉脉投票显示四大行研发中心当一辈子程序员的职业生涯开局比去大厂应届试用期被裁下家不确定更好。</p>\n<p>10、职场 pua：这个需求交给你做是为了培养你，你要开发三天，我交给老员工只要一天；你能力不行，不像别的员工，你离开这个平台寸步难行，要珍惜学习的机会。</p>\n<p>11、某银行：一个内部几十个人用的单体系统，还要搞 devops。千余人，大部分还是僵尸用户的系统逼着你做熔断限流。</p>\n<p>12、农行的一些研发中心风评较差，变更问题、免费加班、削减福利、变相降薪、晋升困难、出市审批、各种考核，要仔细甄别。</p>\n<p>13、互联网企业的卷已经是共识了，在经济环境不好的大势下，仍然有源源不断的年轻小伙伴假如到卷动大潮。这个卷能不能避免？我以前认为不能，因为业务发展速度太快，变化太大，很难避免加班加点的卷。事实上跳出来看看，至少有一半以上的卷都是因为管理者无知，没有思路，不给团队指导和方向导致的“扯淡卷”。也许年轻鲜活的生命不卷白不卷，所谓少年得志的管理者自己也是这么被卷至今。企业成长的代价，最后一半被投资人买单，一半被员工买单，如果花了代价能买来成长，也算值得，可悲的是，多半买不来成长，买来的是失败后的教训。</p>\n<p>14、国家已经拉响了低生育警报，你对提高年轻人生育有什么建议？ - <a href=\"https://www.zhihu.com/question/576438196/answer/2830715899\">宇宙区长孙连城的回答</a></p>\n<p>15、字节杭州有部门全撤转 base 了，虽然人不多。</p>\n<p>16、邮储研发中心总包能到 30+w，很香，但是貌似要 996，个人感觉还是比较香。</p>\n<p>17、字节教育剩下的人不用背指标，不用承担集团的高预期，只需探索新方向和打磨新产品，而且集团每个月固定拨钱养业务，何尝不是一种幸福呢？</p>\n<p>18、前几年当老师门槛很低，如果以当初的条件，现在去应聘，根本进不去。</p>\n<p>19、“围城”这个词一定能在今年秋招占据一席之地。大城小城，国企央企私企外企体制，银行券商互联网制造业军工研究所。究竟是选个能安家的小城还是尽情享受大城市的年轻与自由？是选择一步到位还是将悬念留个未来？是挤出时间来工作还是选择工作外的生活？是坚定走自己的专业还是另辟蹊径？是选择一眼看到头的安心还是未知伴随的风险与机遇？最后，希望各位都能有满意的选择。我们已是当代青年，我们的选择便是新一代青年的选择。与诸位共勉。</p>\n<p>20、从北大来读书的，最近看工作，越来越觉得，在北京挣三十和挣五十没有太大区别，做互联网和做其他行业也没有太大区别，可见的未来的工作只是作为糊口的工具，很难有什么热爱可言。越来越想回家乡找个体制内的稳定工作了，把更多的时间用在生活上面。是我太躺了吗？还是我格局不够？</p>"},{"title":"江苏省考考完啦","copyright":true,"mathjax":true,"date":"2022-12-18T03:49:32.000Z","urlname":"2022-jiangsu-gwy","_content":"\n坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。\n\n<!--more-->\n\n8 月底从字节回学校，本来是准备用 80%的时间准备 gwy 考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于 offer 选择等问题让人心烦，备考甚至中断过一段时间。\n\n来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。\n\n昨天早上行测，135 题，厚礼蟹，感觉以我目前的水平 120 分钟做完 125 题是个极限了，还有浙江省考竟然 115 题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag 已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。\n\n总体而言，对于我这个岗位而言，报录比 80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。\n\n下个月还有国考，这几天再带着看看行测吧。\n","source":"_posts/江苏省考考完啦.md","raw":"---\ntitle: 江苏省考考完啦\ncopyright: true\nmathjax: true\ncategories: 日常小记\ntags: \ndate: 2022-12-18 11:49:32\nurlname: 2022-jiangsu-gwy\n---\n\n坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。\n\n<!--more-->\n\n8 月底从字节回学校，本来是准备用 80%的时间准备 gwy 考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于 offer 选择等问题让人心烦，备考甚至中断过一段时间。\n\n来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。\n\n昨天早上行测，135 题，厚礼蟹，感觉以我目前的水平 120 分钟做完 125 题是个极限了，还有浙江省考竟然 115 题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag 已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。\n\n总体而言，对于我这个岗位而言，报录比 80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。\n\n下个月还有国考，这几天再带着看看行测吧。\n","slug":"江苏省考考完啦","published":1,"updated":"2023-01-26T12:35:58.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw32b001ft9t80w2fb6d7","content":"<p>坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。</p>\n<span id=\"more\"></span>\n\n<p>8 月底从字节回学校，本来是准备用 80%的时间准备 gwy 考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于 offer 选择等问题让人心烦，备考甚至中断过一段时间。</p>\n<p>来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。</p>\n<p>昨天早上行测，135 题，厚礼蟹，感觉以我目前的水平 120 分钟做完 125 题是个极限了，还有浙江省考竟然 115 题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag 已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。</p>\n<p>总体而言，对于我这个岗位而言，报录比 80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。</p>\n<p>下个月还有国考，这几天再带着看看行测吧。</p>\n","site":{"data":{}},"length":635,"excerpt":"<p>坐标常州钟楼区肯德基青山店，看了下下一班回家的班车要到下午一点了，遂坐在肯德基里，沐浴暖冬的阳光，简单回顾一下我备考这次江苏省考的一些事情吧。</p>","more":"<p>8 月底从字节回学校，本来是准备用 80%的时间准备 gwy 考试，剩下时间参加秋招的。然而，事与愿违，由于考公的意愿不是很强烈，再加上一波又一波的笔试面试，严重挤占了复习时间。更关键的是，在后期秋招快结束的时候，由于 offer 选择等问题让人心烦，备考甚至中断过一段时间。</p>\n<p>来常州也是不太顺利，最近疫情管控放开，礼拜五中午来常之前特意做了单管核酸检测，问了下说是晚上六七点就能出结果，并且听朋友说如果第二天早上八点不出结果，就是阳了。等啊等，到晚上七八点了反复查看核酸结果，无。十一点睡前再看了一次，还是无，睡吧，能咋办呢。第二天一早，醒来第一件事就是看核酸结果，结果出来了，阴性，大舒一口气，不然不是浪费了报名费跟酒店费嘛（笑死）。</p>\n<p>昨天早上行测，135 题，厚礼蟹，感觉以我目前的水平 120 分钟做完 125 题是个极限了，还有浙江省考竟然 115 题，晕。下午申论，写了三小时小学生写作，不得不说我的字写的太挫了，以后有空可以练练（flag 已立），不过以后有小孩这个一定要放到高优项。今天上午刚考完专业科目，跟前两天粉笔上做的去年和前年的专业课感觉差不多，都是该会的会，不会的猜，毕竟裸考。</p>\n<p>总体而言，对于我这个岗位而言，报录比 80:2，如果从七月份好好准备，心无旁骛，我觉得应该是可以进面试的（蜜汁自信）。</p>\n<p>下个月还有国考，这几天再带着看看行测吧。</p>"},{"title":"算法 - 排序算法","copyright":true,"mathjax":true,"date":"2023-01-25T05:44:55.000Z","toc":true,"urlname":"algorithm-sort","_content":"\n八大排序算法的代码实现和时空复杂度比较。<!--more-->\n\n| 排序法 | 平均时间   | 最差情形      | 稳定度 | 额外空间   | 备注                              |\n| ------ | ---------- | ------------- | ------ | ---------- | --------------------------------- |\n| ⭐插入  | $O(n^2)$   | $O(n^2)$      | 稳定   | $O(1)$     | 大部分已排序时较好                |\n| ⭐冒泡  | $O(n^2)$   | $O(n^2)$      | 稳定   | $O(1)$     | $n$小时较好                       |\n| ⭐选择  | $O(n^2)$   | $O(n^2)$      | 不稳定 | $O(1)$     | $n$小时较好                       |\n| ⭐快排  | $O(nlogn)$ | $O(n^2)$      | 不稳定 | $O(nlogn)$ | $n$大时较好                       |\n| ⭐堆    | $O(nlogn)$ | $O(nlogn)$    | 不稳定 | $O(1)$     | $n$大时较好                       |\n| ⭐归并  | $O(nlogn)$ | $O(nlogn)$    | 稳定   | $O(1)$     | $n$大时较好                       |\n| 基数   | $O(logRB)$ | $O(logRB)$    | 稳定   | $O(1)$     | $B$是真数(0-9)，$R$是基数(个十百) |\n| 希尔   | $O(nlogn)$ | $O(ns) 1<s<2$ | 不稳定 | $O(1)$     | $s$是所选分组                     |\n\n### 插入\n\n将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n![插入排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/insertionSort.gif)\n\n```java\n/**\n  * 从第二个元素开始，插入到前面已经有序的序列中，即找到序列中第一个小于等于当前元素的，将这以后的元素都\n  * 向后移一位，然后将当前元素插入到这个位置中\n  *\n  * @param arr\n*/\npublic void insertionSort(int[] arr) {\n    /*\n       0 1 2 ...i-1 i i+1 ... n-1\n       对于下标 i,[0, i-1]此时已经有序，将i插入到[0, i-1]中\n       具体操作是找到i应该插入的下标idx，将[idx, i-1]的元素后移，\n       将i元素放到idx+1(最后一个比新元素更大的位置是下标idx，但是循环中idx最后一次还是会往左减一\n       因此要放到idx+1处\n     */\n    int n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int cur_val = arr[i];\n        int idx = i - 1;\n        while (idx >= 0 && arr[idx] > cur_val) {\n            arr[idx + 1] = arr[idx];\n            idx--;\n        }\n        arr[idx + 1] = cur_val;\n    }\n}\n```\n\n### 冒泡\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n\n针对所有的元素重复以上的步骤，除了最后一个。\n\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n![冒泡排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/bubbleSort.gif)\n\n```java\n/**\n  * 一共n个元素，每轮将一个元素冒泡到最后的位置\n  * 对于第i轮，需要冒泡一个元素到第n-1-i的位置，因此需要从[0,1],[1,2], ..., [n-1-i-1,n-1-i]每次将较大的元素往后放\n  * 为了优化已经有序的情况，可以设置flag记录是否已经有序\n  * 如果当轮存在交换则将flag置为false表示未有序，如果flag为true说明前面的元素已经有序了\n  *\n  * @param arr\n*/\n    public void bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {       // 每轮将一个最大的元素沉到最后\n            boolean flag = true;            // 当前轮是否有序\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    flag = false;           // 未有序\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;   \n                }\n            }\n            if (flag) break;                // 有序\n        }\n    }\n```\n\n### 选择\n\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n\n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n重复第二步，直到所有元素均排序完毕。\n\n![选择排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/selectionSort.gif)\n\n```java\n/**\n  * 对于每个位置我们插入其应当有的元素，即对于第0位置的元素，我们找到最小的然后和这个位置的元素进行交换\n  *\n  * @param arr\n*/\npublic void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int min_index = i;\n        for (int j = i; j < n; j++) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        int temp = arr[i];\n        arr[i] = arr[min_index];\n        arr[min_index] = temp;\n    }\n}\n```\n\n### 快排\n\n1. 从数列中挑出一个元素，称为 \"基准\"（pivot）;\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n![快速排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/quickSort-20221125182030127.gif)\n\n递归版本：\n\n```java\npublic void quickSort(int[] arr) {\n    quickSortRange(arr, 0, arr.length - 1);\n}\n\npublic void quickSortRange(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = partition(arr, left, right);\n        quickSortRange(arr, left, mid - 1);\n        quickSortRange(arr, mid + 1, right);\n    }\n\n}\n\nprivate int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    while (left < right) {\n        while (left < right && arr[right] >= pivot) {\n            right--;\n        }\n        arr[left] = arr[right];\n        while (left < right && arr[left] <= pivot) {\n            left++;\n        }\n        arr[right] = arr[left];\n    }\n    arr[left] = pivot;\n    return left;\n}\n```\n\n非递归版本：\n\n```java\nclass Solution {\n    public void quickSort(int[] nums) {\n        stackQuickSort(nums, 0, nums.length - 1);\n    }\n\n    public void stackQuickSort(int[] nums, int left, int right) {\n        Deque<Integer> stack = new LinkedList<>();\n        if (left < right) {\n            stack.push(right);\n            stack.push(left);\n        }\n        while (!stack.isEmpty()) {\n            int l = stack.pop();\n            int r = stack.pop();\n            int mid = partition(nums, l, r);\n            // 得到mid后划分为 [l, mid - 1] mid [mid + 1, r]\n            if (l < mid - 1) {\n                stack.push(mid - 1);\n                stack.push(l);\n            }\n            if (r > mid + 1) {\n                stack.push(r);\n                stack.push(mid + 1);\n            }\n        }\n    }\n\n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[left];\n        while (left < right) {\n            while (left < right && nums[right] >= pivot) {\n                right--;\n            }\n            nums[left] = nums[right];\n            while (left < right && nums[left] <= pivot) {\n                left++;\n            }\n            nums[right] = nums[left];\n        }\n        nums[left] = pivot;\n        return left;\n    }\n}\n```\n\n### 堆\n\n```java\npublic void heapSort(int[] arr) {\n    int len = arr.length;\n\n    buildMaxHeap(arr, len);\n\n    for (int i = len - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0, len);\n    }\n}\n\nprivate void buildMaxHeap(int[] arr, int len) {\n    for (int i = len / 2 - 1; i >= 0; i--) {\n        heapify(arr, i, len);\n    }\n}\n\nprivate void heapify(int[] arr, int i, int len) {\n    while (true) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int largest = i;\n\n        if (left < len && arr[left] > arr[largest]) {\n            largest = left;\n        }\n\n        if (right < len && arr[right] > arr[largest]) {\n            largest = right;\n        }\n\n        if (largest == i) break;\n        swap(arr, i, largest);\n        i = largest;\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n\n### 归并\n\n```java\n/**\n\t* 归并排序\n  * @param arr\n  * @return\n*/\npublic int[] mergeSort(int[] arr) {\n    if (arr == null || arr.length <= 1) return arr;\n    int n = arr.length;\n    int mid = n / 2;\n    int[] left = Arrays.copyOfRange(arr, 0, mid);\n    int[] right = Arrays.copyOfRange(arr, mid, n);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nprivate int[] merge(int[] a, int[] b) {\n    int[] res = new int[a.length + b.length];\n    int i = 0, j = 0, ind = 0;\n    while (i < a.length && j < b.length) {\n        res[ind++] = (a[i] < b[j]) ? a[i++] : b[j++];\n    }\n    while (i < a.length) {\n        res[ind++] = a[i++];\n    }\n    while (j < b.length) {\n        res[ind++] = b[j++];\n    }\n    return res;\n}\n```\n\n### 希尔\n\n```java\n/**\n\t* 希尔排序，减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\t* @param arr\n*/\npublic void shellSort(int[] arr) {\n    int n = arr.length;\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // {i, i+gap, i+2gap, ...}\n        for (int i = 0; i < n; i++) {\n            int cur_val = arr[i];\n            int idx = i - gap;\n            while (idx >= 0 && arr[idx] > cur_val) {\n                arr[idx + gap] = arr[idx];\n                idx -= gap;\n            }\n            arr[idx + gap] = cur_val;\n        }\n    }\n}\n```\n\n \n","source":"_posts/算法-排序算法.md","raw":"---\ntitle: 算法 - 排序算法\ncopyright: true\nmathjax: true\ncategories:\n  - 算法\ndate: 2023-01-25 13:44:55\ntags:\ntoc: true\nurlname: algorithm-sort\n---\n\n八大排序算法的代码实现和时空复杂度比较。<!--more-->\n\n| 排序法 | 平均时间   | 最差情形      | 稳定度 | 额外空间   | 备注                              |\n| ------ | ---------- | ------------- | ------ | ---------- | --------------------------------- |\n| ⭐插入  | $O(n^2)$   | $O(n^2)$      | 稳定   | $O(1)$     | 大部分已排序时较好                |\n| ⭐冒泡  | $O(n^2)$   | $O(n^2)$      | 稳定   | $O(1)$     | $n$小时较好                       |\n| ⭐选择  | $O(n^2)$   | $O(n^2)$      | 不稳定 | $O(1)$     | $n$小时较好                       |\n| ⭐快排  | $O(nlogn)$ | $O(n^2)$      | 不稳定 | $O(nlogn)$ | $n$大时较好                       |\n| ⭐堆    | $O(nlogn)$ | $O(nlogn)$    | 不稳定 | $O(1)$     | $n$大时较好                       |\n| ⭐归并  | $O(nlogn)$ | $O(nlogn)$    | 稳定   | $O(1)$     | $n$大时较好                       |\n| 基数   | $O(logRB)$ | $O(logRB)$    | 稳定   | $O(1)$     | $B$是真数(0-9)，$R$是基数(个十百) |\n| 希尔   | $O(nlogn)$ | $O(ns) 1<s<2$ | 不稳定 | $O(1)$     | $s$是所选分组                     |\n\n### 插入\n\n将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n![插入排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/insertionSort.gif)\n\n```java\n/**\n  * 从第二个元素开始，插入到前面已经有序的序列中，即找到序列中第一个小于等于当前元素的，将这以后的元素都\n  * 向后移一位，然后将当前元素插入到这个位置中\n  *\n  * @param arr\n*/\npublic void insertionSort(int[] arr) {\n    /*\n       0 1 2 ...i-1 i i+1 ... n-1\n       对于下标 i,[0, i-1]此时已经有序，将i插入到[0, i-1]中\n       具体操作是找到i应该插入的下标idx，将[idx, i-1]的元素后移，\n       将i元素放到idx+1(最后一个比新元素更大的位置是下标idx，但是循环中idx最后一次还是会往左减一\n       因此要放到idx+1处\n     */\n    int n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int cur_val = arr[i];\n        int idx = i - 1;\n        while (idx >= 0 && arr[idx] > cur_val) {\n            arr[idx + 1] = arr[idx];\n            idx--;\n        }\n        arr[idx + 1] = cur_val;\n    }\n}\n```\n\n### 冒泡\n\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n\n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n\n针对所有的元素重复以上的步骤，除了最后一个。\n\n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n![冒泡排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/bubbleSort.gif)\n\n```java\n/**\n  * 一共n个元素，每轮将一个元素冒泡到最后的位置\n  * 对于第i轮，需要冒泡一个元素到第n-1-i的位置，因此需要从[0,1],[1,2], ..., [n-1-i-1,n-1-i]每次将较大的元素往后放\n  * 为了优化已经有序的情况，可以设置flag记录是否已经有序\n  * 如果当轮存在交换则将flag置为false表示未有序，如果flag为true说明前面的元素已经有序了\n  *\n  * @param arr\n*/\n    public void bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {       // 每轮将一个最大的元素沉到最后\n            boolean flag = true;            // 当前轮是否有序\n            for (int j = 0; j < n - 1 - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    flag = false;           // 未有序\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;   \n                }\n            }\n            if (flag) break;                // 有序\n        }\n    }\n```\n\n### 选择\n\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。\n\n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n\n重复第二步，直到所有元素均排序完毕。\n\n![选择排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/selectionSort.gif)\n\n```java\n/**\n  * 对于每个位置我们插入其应当有的元素，即对于第0位置的元素，我们找到最小的然后和这个位置的元素进行交换\n  *\n  * @param arr\n*/\npublic void selectionSort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int min_index = i;\n        for (int j = i; j < n; j++) {\n            if (arr[j] < arr[min_index]) {\n                min_index = j;\n            }\n        }\n        int temp = arr[i];\n        arr[i] = arr[min_index];\n        arr[min_index] = temp;\n    }\n}\n```\n\n### 快排\n\n1. 从数列中挑出一个元素，称为 \"基准\"（pivot）;\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n\n![快速排序](https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/quickSort-20221125182030127.gif)\n\n递归版本：\n\n```java\npublic void quickSort(int[] arr) {\n    quickSortRange(arr, 0, arr.length - 1);\n}\n\npublic void quickSortRange(int[] arr, int left, int right) {\n    if (left < right) {\n        int mid = partition(arr, left, right);\n        quickSortRange(arr, left, mid - 1);\n        quickSortRange(arr, mid + 1, right);\n    }\n\n}\n\nprivate int partition(int[] arr, int left, int right) {\n    int pivot = arr[left];\n    while (left < right) {\n        while (left < right && arr[right] >= pivot) {\n            right--;\n        }\n        arr[left] = arr[right];\n        while (left < right && arr[left] <= pivot) {\n            left++;\n        }\n        arr[right] = arr[left];\n    }\n    arr[left] = pivot;\n    return left;\n}\n```\n\n非递归版本：\n\n```java\nclass Solution {\n    public void quickSort(int[] nums) {\n        stackQuickSort(nums, 0, nums.length - 1);\n    }\n\n    public void stackQuickSort(int[] nums, int left, int right) {\n        Deque<Integer> stack = new LinkedList<>();\n        if (left < right) {\n            stack.push(right);\n            stack.push(left);\n        }\n        while (!stack.isEmpty()) {\n            int l = stack.pop();\n            int r = stack.pop();\n            int mid = partition(nums, l, r);\n            // 得到mid后划分为 [l, mid - 1] mid [mid + 1, r]\n            if (l < mid - 1) {\n                stack.push(mid - 1);\n                stack.push(l);\n            }\n            if (r > mid + 1) {\n                stack.push(r);\n                stack.push(mid + 1);\n            }\n        }\n    }\n\n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[left];\n        while (left < right) {\n            while (left < right && nums[right] >= pivot) {\n                right--;\n            }\n            nums[left] = nums[right];\n            while (left < right && nums[left] <= pivot) {\n                left++;\n            }\n            nums[right] = nums[left];\n        }\n        nums[left] = pivot;\n        return left;\n    }\n}\n```\n\n### 堆\n\n```java\npublic void heapSort(int[] arr) {\n    int len = arr.length;\n\n    buildMaxHeap(arr, len);\n\n    for (int i = len - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0, len);\n    }\n}\n\nprivate void buildMaxHeap(int[] arr, int len) {\n    for (int i = len / 2 - 1; i >= 0; i--) {\n        heapify(arr, i, len);\n    }\n}\n\nprivate void heapify(int[] arr, int i, int len) {\n    while (true) {\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n        int largest = i;\n\n        if (left < len && arr[left] > arr[largest]) {\n            largest = left;\n        }\n\n        if (right < len && arr[right] > arr[largest]) {\n            largest = right;\n        }\n\n        if (largest == i) break;\n        swap(arr, i, largest);\n        i = largest;\n    }\n}\n\nprivate void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n```\n\n### 归并\n\n```java\n/**\n\t* 归并排序\n  * @param arr\n  * @return\n*/\npublic int[] mergeSort(int[] arr) {\n    if (arr == null || arr.length <= 1) return arr;\n    int n = arr.length;\n    int mid = n / 2;\n    int[] left = Arrays.copyOfRange(arr, 0, mid);\n    int[] right = Arrays.copyOfRange(arr, mid, n);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nprivate int[] merge(int[] a, int[] b) {\n    int[] res = new int[a.length + b.length];\n    int i = 0, j = 0, ind = 0;\n    while (i < a.length && j < b.length) {\n        res[ind++] = (a[i] < b[j]) ? a[i++] : b[j++];\n    }\n    while (i < a.length) {\n        res[ind++] = a[i++];\n    }\n    while (j < b.length) {\n        res[ind++] = b[j++];\n    }\n    return res;\n}\n```\n\n### 希尔\n\n```java\n/**\n\t* 希尔排序，减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n\t* @param arr\n*/\npublic void shellSort(int[] arr) {\n    int n = arr.length;\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        // {i, i+gap, i+2gap, ...}\n        for (int i = 0; i < n; i++) {\n            int cur_val = arr[i];\n            int idx = i - gap;\n            while (idx >= 0 && arr[idx] > cur_val) {\n                arr[idx + gap] = arr[idx];\n                idx -= gap;\n            }\n            arr[idx + gap] = cur_val;\n        }\n    }\n}\n```\n\n \n","slug":"算法-排序算法","published":1,"updated":"2023-01-31T03:48:26.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldzfw32c001ht9t831k882v6","content":"<p>八大排序算法的代码实现和时空复杂度比较。<span id=\"more\"></span></p>\n<table>\n<thead>\n<tr>\n<th>排序法</th>\n<th>平均时间</th>\n<th>最差情形</th>\n<th>稳定度</th>\n<th>额外空间</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>⭐插入</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>大部分已排序时较好</td>\n</tr>\n<tr>\n<td>⭐冒泡</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>小时较好</td>\n</tr>\n<tr>\n<td>⭐选择</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>小时较好</td>\n</tr>\n<tr>\n<td>⭐快排</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>大时较好</td>\n</tr>\n<tr>\n<td>⭐堆</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>大时较好</td>\n</tr>\n<tr>\n<td>⭐归并</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>大时较好</td>\n</tr>\n<tr>\n<td>基数</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.771ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4319 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1450,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1935,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2412,0)\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3171,0)\"><path data-c=\"1D435\" d=\"M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3930,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.771ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4319 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1450,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1935,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2412,0)\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3171,0)\"><path data-c=\"1D435\" d=\"M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3930,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.717ex\" height=\"1.545ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -683 759 683\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D435\" d=\"M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z\"></path></g></g></g></svg></mjx-container>是真数(0-9)，<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.048ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.717ex\" height=\"1.593ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -683 759 704\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"></path></g></g></g></svg></mjx-container>是基数(个十百)</td>\n</tr>\n<tr>\n<td>希尔</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"15.263ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6746.1 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2221,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2610,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3387.8,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4443.6,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(5190.3,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(6246.1,0)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.023ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.061ex\" height=\"1.023ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 469 452\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g></g></g></svg></mjx-container>是所选分组</td>\n</tr>\n</tbody></table>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>\n<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/insertionSort.gif\" alt=\"插入排序\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 从第二个元素开始，插入到前面已经有序的序列中，即找到序列中第一个小于等于当前元素的，将这以后的元素都</span></span><br><span class=\"line\"><span class=\"comment\">  * 向后移一位，然后将当前元素插入到这个位置中</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertionSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       0 1 2 ...i-1 i i+1 ... n-1</span></span><br><span class=\"line\"><span class=\"comment\">       对于下标 i,[0, i-1]此时已经有序，将i插入到[0, i-1]中</span></span><br><span class=\"line\"><span class=\"comment\">       具体操作是找到i应该插入的下标idx，将[idx, i-1]的元素后移，</span></span><br><span class=\"line\"><span class=\"comment\">       将i元素放到idx+1(最后一个比新元素更大的位置是下标idx，但是循环中idx最后一次还是会往左减一</span></span><br><span class=\"line\"><span class=\"comment\">       因此要放到idx+1处</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cur_val</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (idx &gt;= <span class=\"number\">0</span> &amp;&amp; arr[idx] &gt; cur_val) {</span><br><span class=\"line\">            arr[idx + <span class=\"number\">1</span>] = arr[idx];</span><br><span class=\"line\">            idx--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[idx + <span class=\"number\">1</span>] = cur_val;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>\n<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>\n<p>针对所有的元素重复以上的步骤，除了最后一个。</p>\n<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/bubbleSort.gif\" alt=\"冒泡排序\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 一共n个元素，每轮将一个元素冒泡到最后的位置</span></span><br><span class=\"line\"><span class=\"comment\">  * 对于第i轮，需要冒泡一个元素到第n-1-i的位置，因此需要从[0,1],[1,2], ..., [n-1-i-1,n-1-i]每次将较大的元素往后放</span></span><br><span class=\"line\"><span class=\"comment\">  * 为了优化已经有序的情况，可以设置flag记录是否已经有序</span></span><br><span class=\"line\"><span class=\"comment\">  * 如果当轮存在交换则将flag置为false表示未有序，如果flag为true说明前面的元素已经有序了</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {       <span class=\"comment\">// 每轮将一个最大的元素沉到最后</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;            <span class=\"comment\">// 当前轮是否有序</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n - <span class=\"number\">1</span> - i; j++) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) {</span><br><span class=\"line\">                    flag = <span class=\"literal\">false</span>;           <span class=\"comment\">// 未有序</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[j];</span><br><span class=\"line\">                    arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                    arr[j + <span class=\"number\">1</span>] = temp;   </span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">break</span>;                <span class=\"comment\">// 有序</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>\n<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>\n<p>重复第二步，直到所有元素均排序完毕。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/selectionSort.gif\" alt=\"选择排序\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 对于每个位置我们插入其应当有的元素，即对于第0位置的元素，我们找到最小的然后和这个位置的元素进行交换</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">selectionSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">min_index</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt; n; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[min_index]) {</span><br><span class=\"line\">                min_index = j;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        arr[i] = arr[min_index];</span><br><span class=\"line\">        arr[min_index] = temp;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h3><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/quickSort-20221125182030127.gif\" alt=\"快速排序\"></p>\n<p>递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    quickSortRange(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSortRange</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> partition(arr, left, right);</span><br><span class=\"line\">        quickSortRange(arr, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        quickSortRange(arr, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pivot</span> <span class=\"operator\">=</span> arr[left];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) {</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[left] = arr[right];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) {</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[right] = arr[left];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    arr[left] = pivot;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>非递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> {</span><br><span class=\"line\">        stackQuickSort(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stackQuickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) {</span><br><span class=\"line\">            stack.push(right);</span><br><span class=\"line\">            stack.push(left);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> partition(nums, l, r);</span><br><span class=\"line\">            <span class=\"comment\">// 得到mid后划分为 [l, mid - 1] mid [mid + 1, r]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l &lt; mid - <span class=\"number\">1</span>) {</span><br><span class=\"line\">                stack.push(mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">                stack.push(l);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r &gt; mid + <span class=\"number\">1</span>) {</span><br><span class=\"line\">                stack.push(r);</span><br><span class=\"line\">                stack.push(mid + <span class=\"number\">1</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pivot</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) {</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            nums[left] = nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) {</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            nums[right] = nums[left];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        nums[left] = pivot;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    buildMaxHeap(arr, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        swap(arr, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">        heapify(arr, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildMaxHeap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> len)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        heapify(arr, i, len);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapify</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> len)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">largest</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {</span><br><span class=\"line\">            largest = left;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {</span><br><span class=\"line\">            largest = right;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest == i) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        swap(arr, i, largest);</span><br><span class=\"line\">        i = largest;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"归并\"><a href=\"#归并\" class=\"headerlink\" title=\"归并\"></a>归并</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t* 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] mergeSort(<span class=\"type\">int</span>[] arr) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> n / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] left = Arrays.copyOfRange(arr, <span class=\"number\">0</span>, mid);</span><br><span class=\"line\">    <span class=\"type\">int</span>[] right = Arrays.copyOfRange(arr, mid, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] a, <span class=\"type\">int</span>[] b) {</span><br><span class=\"line\">    <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[a.length + b.length];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, ind = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) {</span><br><span class=\"line\">        res[ind++] = (a[i] &lt; b[j]) ? a[i++] : b[j++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; a.length) {</span><br><span class=\"line\">        res[ind++] = a[i++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; b.length) {</span><br><span class=\"line\">        res[ind++] = b[j++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔\"><a href=\"#希尔\" class=\"headerlink\" title=\"希尔\"></a>希尔</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t* 希尔排序，减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</span></span><br><span class=\"line\"><span class=\"comment\">\t* <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">gap</span> <span class=\"operator\">=</span> n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// {i, i+gap, i+2gap, ...}</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">cur_val</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (idx &gt;= <span class=\"number\">0</span> &amp;&amp; arr[idx] &gt; cur_val) {</span><br><span class=\"line\">                arr[idx + gap] = arr[idx];</span><br><span class=\"line\">                idx -= gap;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            arr[idx + gap] = cur_val;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":5576,"excerpt":"<p>八大排序算法的代码实现和时空复杂度比较。","more":"</p>\n<table>\n<thead>\n<tr>\n<th>排序法</th>\n<th>平均时间</th>\n<th>最差情形</th>\n<th>稳定度</th>\n<th>额外空间</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>⭐插入</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>大部分已排序时较好</td>\n</tr>\n<tr>\n<td>⭐冒泡</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>小时较好</td>\n</tr>\n<tr>\n<td>⭐选择</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>小时较好</td>\n</tr>\n<tr>\n<td>⭐快排</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.832ex\" height=\"2.452ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 2577.6 1083.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1152,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(633,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2188.6,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>大时较好</td>\n</tr>\n<tr>\n<td>⭐堆</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>大时较好</td>\n</tr>\n<tr>\n<td>⭐归并</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container>大时较好</td>\n</tr>\n<tr>\n<td>基数</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.771ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4319 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1450,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1935,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2412,0)\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3171,0)\"><path data-c=\"1D435\" d=\"M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3930,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.771ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4319 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1450,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1935,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2412,0)\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3171,0)\"><path data-c=\"1D435\" d=\"M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3930,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td>稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.717ex\" height=\"1.545ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -683 759 683\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D435\" d=\"M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z\"></path></g></g></g></svg></mjx-container>是真数(0-9)，<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.048ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.717ex\" height=\"1.593ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -683 759 704\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D445\" d=\"M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z\"></path></g></g></g></svg></mjx-container>是基数(个十百)</td>\n</tr>\n<tr>\n<td>希尔</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.052ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4001 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2050,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2535,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3012,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3612,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"15.263ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6746.1 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1152,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1752,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2221,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2610,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3387.8,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4443.6,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(5190.3,0)\"><path data-c=\"3C\" d=\"M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(6246.1,0)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g></g></svg></mjx-container></td>\n<td>不稳定</td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.566ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.618ex\" height=\"2.262ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2041 1000\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D442\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(763,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1152,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1652,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></svg></mjx-container></td>\n<td><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.023ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.061ex\" height=\"1.023ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 469 452\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g></g></g></svg></mjx-container>是所选分组</td>\n</tr>\n</tbody></table>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>\n<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/insertionSort.gif\" alt=\"插入排序\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 从第二个元素开始，插入到前面已经有序的序列中，即找到序列中第一个小于等于当前元素的，将这以后的元素都</span></span><br><span class=\"line\"><span class=\"comment\">  * 向后移一位，然后将当前元素插入到这个位置中</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertionSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       0 1 2 ...i-1 i i+1 ... n-1</span></span><br><span class=\"line\"><span class=\"comment\">       对于下标 i,[0, i-1]此时已经有序，将i插入到[0, i-1]中</span></span><br><span class=\"line\"><span class=\"comment\">       具体操作是找到i应该插入的下标idx，将[idx, i-1]的元素后移，</span></span><br><span class=\"line\"><span class=\"comment\">       将i元素放到idx+1(最后一个比新元素更大的位置是下标idx，但是循环中idx最后一次还是会往左减一</span></span><br><span class=\"line\"><span class=\"comment\">       因此要放到idx+1处</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cur_val</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (idx &gt;= <span class=\"number\">0</span> &amp;&amp; arr[idx] &gt; cur_val) {</span><br><span class=\"line\">            arr[idx + <span class=\"number\">1</span>] = arr[idx];</span><br><span class=\"line\">            idx--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[idx + <span class=\"number\">1</span>] = cur_val;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡\"><a href=\"#冒泡\" class=\"headerlink\" title=\"冒泡\"></a>冒泡</h3><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>\n<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>\n<p>针对所有的元素重复以上的步骤，除了最后一个。</p>\n<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/bubbleSort.gif\" alt=\"冒泡排序\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 一共n个元素，每轮将一个元素冒泡到最后的位置</span></span><br><span class=\"line\"><span class=\"comment\">  * 对于第i轮，需要冒泡一个元素到第n-1-i的位置，因此需要从[0,1],[1,2], ..., [n-1-i-1,n-1-i]每次将较大的元素往后放</span></span><br><span class=\"line\"><span class=\"comment\">  * 为了优化已经有序的情况，可以设置flag记录是否已经有序</span></span><br><span class=\"line\"><span class=\"comment\">  * 如果当轮存在交换则将flag置为false表示未有序，如果flag为true说明前面的元素已经有序了</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bubbleSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {       <span class=\"comment\">// 每轮将一个最大的元素沉到最后</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;            <span class=\"comment\">// 当前轮是否有序</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n - <span class=\"number\">1</span> - i; j++) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) {</span><br><span class=\"line\">                    flag = <span class=\"literal\">false</span>;           <span class=\"comment\">// 未有序</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[j];</span><br><span class=\"line\">                    arr[j] = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                    arr[j + <span class=\"number\">1</span>] = temp;   </span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">break</span>;                <span class=\"comment\">// 有序</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h3><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>\n<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>\n<p>重复第二步，直到所有元素均排序完毕。</p>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/selectionSort.gif\" alt=\"选择排序\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 对于每个位置我们插入其应当有的元素，即对于第0位置的元素，我们找到最小的然后和这个位置的元素进行交换</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">selectionSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">min_index</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt; n; j++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[min_index]) {</span><br><span class=\"line\">                min_index = j;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">        arr[i] = arr[min_index];</span><br><span class=\"line\">        arr[min_index] = temp;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h3><ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>\n</ol>\n<p><img src=\"https://yaxingfang-typora.oss-cn-hangzhou.aliyuncs.com/quickSort-20221125182030127.gif\" alt=\"快速排序\"></p>\n<p>递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    quickSortRange(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSortRange</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &lt; right) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> partition(arr, left, right);</span><br><span class=\"line\">        quickSortRange(arr, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        quickSortRange(arr, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">pivot</span> <span class=\"operator\">=</span> arr[left];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= pivot) {</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[left] = arr[right];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot) {</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        arr[right] = arr[left];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    arr[left] = pivot;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>非递归版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> {</span><br><span class=\"line\">        stackQuickSort(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">stackQuickSort</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; right) {</span><br><span class=\"line\">            stack.push(right);</span><br><span class=\"line\">            stack.push(left);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> partition(nums, l, r);</span><br><span class=\"line\">            <span class=\"comment\">// 得到mid后划分为 [l, mid - 1] mid [mid + 1, r]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l &lt; mid - <span class=\"number\">1</span>) {</span><br><span class=\"line\">                stack.push(mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">                stack.push(l);</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r &gt; mid + <span class=\"number\">1</span>) {</span><br><span class=\"line\">                stack.push(r);</span><br><span class=\"line\">                stack.push(mid + <span class=\"number\">1</span>);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pivot</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) {</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) {</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            nums[left] = nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) {</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            nums[right] = nums[left];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        nums[left] = pivot;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    buildMaxHeap(arr, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        swap(arr, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">        len--;</span><br><span class=\"line\">        heapify(arr, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">buildMaxHeap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> len)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> len / <span class=\"number\">2</span> - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) {</span><br><span class=\"line\">        heapify(arr, i, len);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">heapify</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> len)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">2</span> * i + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">largest</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {</span><br><span class=\"line\">            largest = left;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {</span><br><span class=\"line\">            largest = right;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (largest == i) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        swap(arr, i, largest);</span><br><span class=\"line\">        i = largest;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">    arr[i] = arr[j];</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"归并\"><a href=\"#归并\" class=\"headerlink\" title=\"归并\"></a>归并</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t* 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>[] mergeSort(<span class=\"type\">int</span>[] arr) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> n / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] left = Arrays.copyOfRange(arr, <span class=\"number\">0</span>, mid);</span><br><span class=\"line\">    <span class=\"type\">int</span>[] right = Arrays.copyOfRange(arr, mid, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span>[] merge(<span class=\"type\">int</span>[] a, <span class=\"type\">int</span>[] b) {</span><br><span class=\"line\">    <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[a.length + b.length];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, ind = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) {</span><br><span class=\"line\">        res[ind++] = (a[i] &lt; b[j]) ? a[i++] : b[j++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; a.length) {</span><br><span class=\"line\">        res[ind++] = a[i++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &lt; b.length) {</span><br><span class=\"line\">        res[ind++] = b[j++];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔\"><a href=\"#希尔\" class=\"headerlink\" title=\"希尔\"></a>希尔</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t* 希尔排序，减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</span></span><br><span class=\"line\"><span class=\"comment\">\t* <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">shellSort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">gap</span> <span class=\"operator\">=</span> n / <span class=\"number\">2</span>; gap &gt; <span class=\"number\">0</span>; gap /= <span class=\"number\">2</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// {i, i+gap, i+2gap, ...}</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">cur_val</span> <span class=\"operator\">=</span> arr[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> i - gap;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (idx &gt;= <span class=\"number\">0</span> &amp;&amp; arr[idx] &gt; cur_val) {</span><br><span class=\"line\">                arr[idx + gap] = arr[idx];</span><br><span class=\"line\">                idx -= gap;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            arr[idx + gap] = cur_val;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cldzfw31p0001t9t8bfgybk9z","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw31z000ct9t8gv51g7b4"},{"post_id":"cldzfw322000ht9t8001aa5cu","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw324000mt9t8gfx3feri"},{"post_id":"cldzfw31w0007t9t8f86m5nb0","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw325000pt9t87w23061s"},{"post_id":"cldzfw322000it9t83h3z0w23","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw325000rt9t8cjha9z3d"},{"post_id":"cldzfw323000kt9t80bu0aizt","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw326000ut9t81pnv4pez"},{"post_id":"cldzfw31w0008t9t883lmba4k","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw327000wt9t8g3w23a0b"},{"post_id":"cldzfw31y000at9t8hzfmcqld","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw327000zt9t8cpp7husa"},{"post_id":"cldzfw326000tt9t8h9aa10ku","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw3280011t9t8crnxb5vj"},{"post_id":"cldzfw31s0003t9t865h262z4","category_id":"cldzfw31x0009t9t8h8hbd442","_id":"cldzfw3290014t9t8hg8w9szm"},{"post_id":"cldzfw31s0003t9t865h262z4","category_id":"cldzfw326000st9t82jv6cdlu","_id":"cldzfw3290016t9t8bfoybush"},{"post_id":"cldzfw326000vt9t81ihgaxuw","category_id":"cldzfw31x0009t9t8h8hbd442","_id":"cldzfw32a0019t9t8euks6vlw"},{"post_id":"cldzfw326000vt9t81ihgaxuw","category_id":"cldzfw326000st9t82jv6cdlu","_id":"cldzfw32a001bt9t89f350jux"},{"post_id":"cldzfw327000yt9t857gt6vr3","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw32b001dt9t8azp23r8w"},{"post_id":"cldzfw31y000bt9t8d77e6f6g","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw32c001gt9t8av046wb5"},{"post_id":"cldzfw3280010t9t80132hzi0","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw32c001it9t8ciwag29n"},{"post_id":"cldzfw3280013t9t889q7blhp","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw32c001kt9t829ui9iut"},{"post_id":"cldzfw320000et9t827tqb6pj","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw32d001lt9t8fx9lcaz0"},{"post_id":"cldzfw32a0018t9t80g27c17z","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw32d001nt9t82eu683k3"},{"post_id":"cldzfw32a001at9t88remake6","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw32d001ot9t8gjdre6un"},{"post_id":"cldzfw31v0006t9t88c4za2p0","category_id":"cldzfw31x0009t9t8h8hbd442","_id":"cldzfw32d001qt9t8fopk8y3b"},{"post_id":"cldzfw31v0006t9t88c4za2p0","category_id":"cldzfw32a0017t9t80iblfx7j","_id":"cldzfw32d001rt9t8ecec5phc"},{"post_id":"cldzfw32b001ct9t88yodawq8","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw32d001tt9t88xhx2wiv"},{"post_id":"cldzfw32b001ft9t80w2fb6d7","category_id":"cldzfw31t0004t9t86fxx7k2s","_id":"cldzfw32d001ut9t80ynrc1r8"},{"post_id":"cldzfw321000ft9t82hv43rgr","category_id":"cldzfw321000gt9t82r04hnto","_id":"cldzfw32e001wt9t8afzl6z5u"},{"post_id":"cldzfw324000lt9t81a19ajys","category_id":"cldzfw32c001jt9t85v626a5j","_id":"cldzfw32e001xt9t800d86rp5"},{"post_id":"cldzfw324000ot9t8gyptfx3q","category_id":"cldzfw32d001mt9t886rm9wo5","_id":"cldzfw32e001yt9t8hhlha5w8"},{"post_id":"cldzfw325000qt9t8fhuraug6","category_id":"cldzfw32d001pt9t88wpifyz5","_id":"cldzfw32e001zt9t85mz3boyt"},{"post_id":"cldzfw3290015t9t845071rec","category_id":"cldzfw32d001mt9t886rm9wo5","_id":"cldzfw32e0020t9t8hq4egilu"},{"post_id":"cldzfw32c001ht9t831k882v6","category_id":"cldzfw32d001vt9t8h6hj1xu8","_id":"cldzfw32e0021t9t85fuzblnd"}],"PostTag":[],"Tag":[]}}